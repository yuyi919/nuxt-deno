import {createRequire} from "node:module";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __require = createRequire(import.meta.url);

// ../../node_modules/mobx/dist/mobx.cjs.development.js
var require_mobx_cjs_development = __commonJS((exports) => {
  var die = function(error) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    {
      var e = typeof error === "string" ? error : errors[error];
      if (typeof e === "function")
        e = e.apply(null, args);
      throw new Error("[MobX] " + e);
    }
  };
  var getGlobal = function() {
    if (typeof globalThis !== "undefined") {
      return globalThis;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof globalThis !== "undefined") {
      return globalThis;
    }
    if (typeof self !== "undefined") {
      return self;
    }
    return mockGlobal;
  };
  var assertProxies = function() {
    if (!hasProxy) {
      die("`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`");
    }
  };
  var warnAboutProxyRequirement = function(msg) {
    if (globalState.verifyProxies) {
      die("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + msg);
    }
  };
  var getNextId = function() {
    return ++globalState.mobxGuid;
  };
  var once = function(func) {
    var invoked = false;
    return function() {
      if (invoked) {
        return;
      }
      invoked = true;
      return func.apply(this, arguments);
    };
  };
  var isFunction = function(fn) {
    return typeof fn === "function";
  };
  var isStringish = function(value) {
    var t = typeof value;
    switch (t) {
      case "string":
      case "symbol":
      case "number":
        return true;
    }
    return false;
  };
  var isObject = function(value) {
    return value !== null && typeof value === "object";
  };
  var isPlainObject = function(value) {
    if (!isObject(value)) {
      return false;
    }
    var proto = Object.getPrototypeOf(value);
    if (proto == null) {
      return true;
    }
    var protoConstructor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof protoConstructor === "function" && protoConstructor.toString() === plainObjectString;
  };
  var isGenerator = function(obj) {
    var constructor = obj == null ? undefined : obj.constructor;
    if (!constructor) {
      return false;
    }
    if (constructor.name === "GeneratorFunction" || constructor.displayName === "GeneratorFunction") {
      return true;
    }
    return false;
  };
  var addHiddenProp = function(object, propName, value) {
    defineProperty(object, propName, {
      enumerable: false,
      writable: true,
      configurable: true,
      value
    });
  };
  var addHiddenFinalProp = function(object, propName, value) {
    defineProperty(object, propName, {
      enumerable: false,
      writable: false,
      configurable: true,
      value
    });
  };
  var createInstanceofPredicate = function(name, theClass) {
    var propName = "isMobX" + name;
    theClass.prototype[propName] = true;
    return function(x) {
      return isObject(x) && x[propName] === true;
    };
  };
  var isES6Map = function(thing) {
    return thing instanceof Map;
  };
  var isES6Set = function(thing) {
    return thing instanceof Set;
  };
  var getPlainObjectKeys = function(object) {
    var keys2 = Object.keys(object);
    if (!hasGetOwnPropertySymbols) {
      return keys2;
    }
    var symbols = Object.getOwnPropertySymbols(object);
    if (!symbols.length) {
      return keys2;
    }
    return [].concat(keys2, symbols.filter(function(s) {
      return objectPrototype.propertyIsEnumerable.call(object, s);
    }));
  };
  var stringifyKey = function(key) {
    if (typeof key === "string") {
      return key;
    }
    if (typeof key === "symbol") {
      return key.toString();
    }
    return new String(key).toString();
  };
  var toPrimitive = function(value) {
    return value === null ? null : typeof value === "object" ? "" + value : value;
  };
  var hasProp = function(target, prop) {
    return objectPrototype.hasOwnProperty.call(target, prop);
  };
  var _defineProperties = function(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  };
  var _createClass = function(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  };
  var _extends = function() {
    _extends = Object.assign || function(target) {
      for (var i = 1;i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  };
  var _inheritsLoose = function(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  };
  var _setPrototypeOf = function(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  };
  var _assertThisInitialized = function(self2) {
    if (self2 === undefined) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  };
  var _unsupportedIterableToArray = function(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  };
  var _arrayLikeToArray = function(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len);i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  };
  var _createForOfIteratorHelperLoose = function(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it)
      return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      return function() {
        if (i >= o.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  };
  var createDecoratorAnnotation = function(annotation) {
    function decorator(target, property) {
      storeAnnotation(target, property, annotation);
    }
    return Object.assign(decorator, annotation);
  };
  var storeAnnotation = function(prototype, key, annotation) {
    if (!hasProp(prototype, storedAnnotationsSymbol)) {
      addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
    }
    if (isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {
      var fieldName = prototype.constructor.name + ".prototype." + key.toString();
      die("'" + fieldName + "' is decorated with 'override', " + "but no such decorated member was found on prototype.");
    }
    assertNotDecorated(prototype, annotation, key);
    if (!isOverride(annotation)) {
      prototype[storedAnnotationsSymbol][key] = annotation;
    }
  };
  var assertNotDecorated = function(prototype, annotation, key) {
    if (!isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {
      var fieldName = prototype.constructor.name + ".prototype." + key.toString();
      var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;
      var requestedAnnotationType = annotation.annotationType_;
      die("Cannot apply '@" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already decorated with '@" + currentAnnotationType + "'.") + "\nRe-decorating fields is not allowed." + "\nUse '@override' decorator for methods overridden by subclass.");
    }
  };
  var collectStoredAnnotations = function(target) {
    if (!hasProp(target, storedAnnotationsSymbol)) {
      if (!target[storedAnnotationsSymbol]) {
        die("No annotations were passed to makeObservable, but no decorated members have been found either");
      }
      addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
    }
    return target[storedAnnotationsSymbol];
  };
  var createAtom = function(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
    if (onBecomeObservedHandler === undefined) {
      onBecomeObservedHandler = noop;
    }
    if (onBecomeUnobservedHandler === undefined) {
      onBecomeUnobservedHandler = noop;
    }
    var atom = new Atom(name);
    if (onBecomeObservedHandler !== noop) {
      onBecomeObserved(atom, onBecomeObservedHandler);
    }
    if (onBecomeUnobservedHandler !== noop) {
      onBecomeUnobserved(atom, onBecomeUnobservedHandler);
    }
    return atom;
  };
  var identityComparer = function(a, b) {
    return a === b;
  };
  var structuralComparer = function(a, b) {
    return deepEqual(a, b);
  };
  var shallowComparer = function(a, b) {
    return deepEqual(a, b, 1);
  };
  var defaultComparer = function(a, b) {
    if (Object.is) {
      return Object.is(a, b);
    }
    return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;
  };
  var deepEnhancer = function(v, _, name) {
    if (isObservable(v)) {
      return v;
    }
    if (Array.isArray(v)) {
      return observable.array(v, {
        name
      });
    }
    if (isPlainObject(v)) {
      return observable.object(v, undefined, {
        name
      });
    }
    if (isES6Map(v)) {
      return observable.map(v, {
        name
      });
    }
    if (isES6Set(v)) {
      return observable.set(v, {
        name
      });
    }
    if (typeof v === "function" && !isAction(v) && !isFlow(v)) {
      if (isGenerator(v)) {
        return flow(v);
      } else {
        return autoAction(name, v);
      }
    }
    return v;
  };
  var shallowEnhancer = function(v, _, name) {
    if (v === undefined || v === null) {
      return v;
    }
    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) {
      return v;
    }
    if (Array.isArray(v)) {
      return observable.array(v, {
        name,
        deep: false
      });
    }
    if (isPlainObject(v)) {
      return observable.object(v, undefined, {
        name,
        deep: false
      });
    }
    if (isES6Map(v)) {
      return observable.map(v, {
        name,
        deep: false
      });
    }
    if (isES6Set(v)) {
      return observable.set(v, {
        name,
        deep: false
      });
    }
    {
      die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
    }
  };
  var referenceEnhancer = function(newValue) {
    return newValue;
  };
  var refStructEnhancer = function(v, oldValue) {
    if (isObservable(v)) {
      die("observable.struct should not be used with observable values");
    }
    if (deepEqual(v, oldValue)) {
      return oldValue;
    }
    return v;
  };
  var isOverride = function(annotation) {
    return annotation.annotationType_ === OVERRIDE;
  };
  var make_ = function(adm, key) {
    if (adm.isPlainObject_) {
      die("Cannot apply '" + this.annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + this.annotationType_ + "' cannot be used on plain objects."));
    }
    if (!hasProp(adm.appliedAnnotations_, key)) {
      die("'" + adm.name_ + "." + key.toString() + "' is annotated with '" + this.annotationType_ + "', " + "but no such annotated member was found on prototype.");
    }
    return 0;
  };
  var extend_ = function(adm, key, descriptor, proxyTrap) {
    die("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
  };
  var createActionAnnotation = function(name, options) {
    return {
      annotationType_: name,
      options_: options,
      make_: make_$1,
      extend_: extend_$1
    };
  };
  var make_$1 = function(adm, key, descriptor, source) {
    var _this$options_;
    if ((_this$options_ = this.options_) != null && _this$options_.bound) {
      return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
    }
    if (source === adm.target_) {
      return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
    }
    if (isAction(descriptor.value)) {
      return 1;
    }
    var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
    defineProperty(source, key, actionDescriptor);
    return 2;
  };
  var extend_$1 = function(adm, key, descriptor, proxyTrap) {
    var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
    return adm.defineProperty_(key, actionDescriptor, proxyTrap);
  };
  var assertActionDescriptor = function(adm, _ref, key, _ref2) {
    var annotationType_ = _ref.annotationType_;
    var value = _ref2.value;
    if (!isFunction(value)) {
      die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a function value."));
    }
  };
  var createActionDescriptor = function(adm, annotation, key, descriptor, safeDescriptors) {
    var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
    if (safeDescriptors === undefined) {
      safeDescriptors = globalState.safeDescriptors;
    }
    assertActionDescriptor(adm, annotation, key, descriptor);
    var value = descriptor.value;
    if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {
      var _adm$proxy_;
      value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    }
    return {
      value: createAction((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? undefined : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? undefined : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false, (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : undefined),
      configurable: safeDescriptors ? adm.isPlainObject_ : true,
      enumerable: false,
      writable: safeDescriptors ? false : true
    };
  };
  var createFlowAnnotation = function(name, options) {
    return {
      annotationType_: name,
      options_: options,
      make_: make_$2,
      extend_: extend_$2
    };
  };
  var make_$2 = function(adm, key, descriptor, source) {
    var _this$options_;
    if (source === adm.target_) {
      return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
    }
    if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {
      if (this.extend_(adm, key, descriptor, false) === null) {
        return 0;
      }
    }
    if (isFlow(descriptor.value)) {
      return 1;
    }
    var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
    defineProperty(source, key, flowDescriptor);
    return 2;
  };
  var extend_$2 = function(adm, key, descriptor, proxyTrap) {
    var _this$options_2;
    var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? undefined : _this$options_2.bound);
    return adm.defineProperty_(key, flowDescriptor, proxyTrap);
  };
  var assertFlowDescriptor = function(adm, _ref, key, _ref2) {
    var annotationType_ = _ref.annotationType_;
    var value = _ref2.value;
    if (!isFunction(value)) {
      die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a generator function value."));
    }
  };
  var createFlowDescriptor = function(adm, annotation, key, descriptor, bound, safeDescriptors) {
    if (safeDescriptors === undefined) {
      safeDescriptors = globalState.safeDescriptors;
    }
    assertFlowDescriptor(adm, annotation, key, descriptor);
    var value = descriptor.value;
    if (!isFlow(value)) {
      value = flow(value);
    }
    if (bound) {
      var _adm$proxy_;
      value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
      value.isMobXFlow = true;
    }
    return {
      value,
      configurable: safeDescriptors ? adm.isPlainObject_ : true,
      enumerable: false,
      writable: safeDescriptors ? false : true
    };
  };
  var createComputedAnnotation = function(name, options) {
    return {
      annotationType_: name,
      options_: options,
      make_: make_$3,
      extend_: extend_$3
    };
  };
  var make_$3 = function(adm, key, descriptor) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  };
  var extend_$3 = function(adm, key, descriptor, proxyTrap) {
    assertComputedDescriptor(adm, this, key, descriptor);
    return adm.defineComputedProperty_(key, _extends({}, this.options_, {
      get: descriptor.get,
      set: descriptor.set
    }), proxyTrap);
  };
  var assertComputedDescriptor = function(adm, _ref, key, _ref2) {
    var annotationType_ = _ref.annotationType_;
    var get2 = _ref2.get;
    if (!get2) {
      die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on getter(+setter) properties."));
    }
  };
  var createObservableAnnotation = function(name, options) {
    return {
      annotationType_: name,
      options_: options,
      make_: make_$4,
      extend_: extend_$4
    };
  };
  var make_$4 = function(adm, key, descriptor) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  };
  var extend_$4 = function(adm, key, descriptor, proxyTrap) {
    var _this$options_$enhanc, _this$options_;
    assertObservableDescriptor(adm, this, key, descriptor);
    return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? undefined : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
  };
  var assertObservableDescriptor = function(adm, _ref, key, descriptor) {
    var annotationType_ = _ref.annotationType_;
    if (!("value" in descriptor)) {
      die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' cannot be used on getter/setter properties"));
    }
  };
  var createAutoAnnotation = function(options) {
    return {
      annotationType_: AUTO,
      options_: options,
      make_: make_$5,
      extend_: extend_$5
    };
  };
  var make_$5 = function(adm, key, descriptor, source) {
    var _this$options_3, _this$options_4;
    if (descriptor.get) {
      return computed.make_(adm, key, descriptor, source);
    }
    if (descriptor.set) {
      var set2 = createAction(key.toString(), descriptor.set);
      if (source === adm.target_) {
        return adm.defineProperty_(key, {
          configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
          set: set2
        }) === null ? 0 : 2;
      }
      defineProperty(source, key, {
        configurable: true,
        set: set2
      });
      return 2;
    }
    if (source !== adm.target_ && typeof descriptor.value === "function") {
      var _this$options_2;
      if (isGenerator(descriptor.value)) {
        var _this$options_;
        var flowAnnotation2 = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;
        return flowAnnotation2.make_(adm, key, descriptor, source);
      }
      var actionAnnotation2 = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;
      return actionAnnotation2.make_(adm, key, descriptor, source);
    }
    var observableAnnotation2 = ((_this$options_3 = this.options_) == null ? undefined : _this$options_3.deep) === false ? observable.ref : observable;
    if (typeof descriptor.value === "function" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {
      var _adm$proxy_;
      descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    }
    return observableAnnotation2.make_(adm, key, descriptor, source);
  };
  var extend_$5 = function(adm, key, descriptor, proxyTrap) {
    var _this$options_5, _this$options_6;
    if (descriptor.get) {
      return computed.extend_(adm, key, descriptor, proxyTrap);
    }
    if (descriptor.set) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: createAction(key.toString(), descriptor.set)
      }, proxyTrap);
    }
    if (typeof descriptor.value === "function" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {
      var _adm$proxy_2;
      descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
    }
    var observableAnnotation2 = ((_this$options_6 = this.options_) == null ? undefined : _this$options_6.deep) === false ? observable.ref : observable;
    return observableAnnotation2.extend_(adm, key, descriptor, proxyTrap);
  };
  var asCreateObservableOptions = function(thing) {
    return thing || defaultCreateObservableOptions;
  };
  var getEnhancerFromOptions = function(options) {
    return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
  };
  var getAnnotationFromOptions = function(options) {
    var _options$defaultDecor;
    return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : undefined;
  };
  var getEnhancerFromAnnotation = function(annotation) {
    var _annotation$options_$, _annotation$options_;
    return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? undefined : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
  };
  var createObservable = function(v, arg2, arg3) {
    if (isStringish(arg2)) {
      storeAnnotation(v, arg2, observableAnnotation);
      return;
    }
    if (isObservable(v)) {
      return v;
    }
    if (isPlainObject(v)) {
      return observable.object(v, arg2, arg3);
    }
    if (Array.isArray(v)) {
      return observable.array(v, arg2);
    }
    if (isES6Map(v)) {
      return observable.map(v, arg2);
    }
    if (isES6Set(v)) {
      return observable.set(v, arg2);
    }
    if (typeof v === "object" && v !== null) {
      return v;
    }
    return observable.box(v, arg2);
  };
  var createAction = function(actionName, fn, autoAction2, ref) {
    if (autoAction2 === undefined) {
      autoAction2 = false;
    }
    {
      if (!isFunction(fn)) {
        die("`action` can only be invoked on functions");
      }
      if (typeof actionName !== "string" || !actionName) {
        die("actions should have valid names, got: '" + actionName + "'");
      }
    }
    function res() {
      return executeAction(actionName, autoAction2, fn, ref || this, arguments);
    }
    res.isMobxAction = true;
    if (isFunctionNameConfigurable) {
      tmpNameDescriptor.value = actionName;
      Object.defineProperty(res, "name", tmpNameDescriptor);
    }
    return res;
  };
  var executeAction = function(actionName, canRunAsDerivation, fn, scope, args) {
    var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);
    try {
      return fn.apply(scope, args);
    } catch (err) {
      runInfo.error_ = err;
      throw err;
    } finally {
      _endAction(runInfo);
    }
  };
  var _startAction = function(actionName, canRunAsDerivation, scope, args) {
    var notifySpy_ = isSpyEnabled() && !!actionName;
    var startTime_ = 0;
    if (notifySpy_) {
      startTime_ = Date.now();
      var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;
      spyReportStart({
        type: ACTION,
        name: actionName,
        object: scope,
        arguments: flattenedArgs
      });
    }
    var prevDerivation_ = globalState.trackingDerivation;
    var runAsAction = !canRunAsDerivation || !prevDerivation_;
    startBatch();
    var prevAllowStateChanges_ = globalState.allowStateChanges;
    if (runAsAction) {
      untrackedStart();
      prevAllowStateChanges_ = allowStateChangesStart(true);
    }
    var prevAllowStateReads_ = allowStateReadsStart(true);
    var runInfo = {
      runAsAction_: runAsAction,
      prevDerivation_,
      prevAllowStateChanges_,
      prevAllowStateReads_,
      notifySpy_,
      startTime_,
      actionId_: nextActionId++,
      parentActionId_: currentActionId
    };
    currentActionId = runInfo.actionId_;
    return runInfo;
  };
  var _endAction = function(runInfo) {
    if (currentActionId !== runInfo.actionId_) {
      die(30);
    }
    currentActionId = runInfo.parentActionId_;
    if (runInfo.error_ !== undefined) {
      globalState.suppressReactionErrors = true;
    }
    allowStateChangesEnd(runInfo.prevAllowStateChanges_);
    allowStateReadsEnd(runInfo.prevAllowStateReads_);
    endBatch();
    if (runInfo.runAsAction_) {
      untrackedEnd(runInfo.prevDerivation_);
    }
    if (runInfo.notifySpy_) {
      spyReportEnd({
        time: Date.now() - runInfo.startTime_
      });
    }
    globalState.suppressReactionErrors = false;
  };
  var allowStateChanges = function(allowStateChanges2, func) {
    var prev = allowStateChangesStart(allowStateChanges2);
    try {
      return func();
    } finally {
      allowStateChangesEnd(prev);
    }
  };
  var allowStateChangesStart = function(allowStateChanges2) {
    var prev = globalState.allowStateChanges;
    globalState.allowStateChanges = allowStateChanges2;
    return prev;
  };
  var allowStateChangesEnd = function(prev) {
    globalState.allowStateChanges = prev;
  };
  var isCaughtException = function(e) {
    return e instanceof CaughtException;
  };
  var shouldCompute = function(derivation) {
    switch (derivation.dependenciesState_) {
      case IDerivationState_.UP_TO_DATE_:
        return false;
      case IDerivationState_.NOT_TRACKING_:
      case IDerivationState_.STALE_:
        return true;
      case IDerivationState_.POSSIBLY_STALE_: {
        var prevAllowStateReads = allowStateReadsStart(true);
        var prevUntracked = untrackedStart();
        var obs = derivation.observing_, l = obs.length;
        for (var i = 0;i < l; i++) {
          var obj = obs[i];
          if (isComputedValue(obj)) {
            if (globalState.disableErrorBoundaries) {
              obj.get();
            } else {
              try {
                obj.get();
              } catch (e) {
                untrackedEnd(prevUntracked);
                allowStateReadsEnd(prevAllowStateReads);
                return true;
              }
            }
            if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
        }
        changeDependenciesStateTo0(derivation);
        untrackedEnd(prevUntracked);
        allowStateReadsEnd(prevAllowStateReads);
        return false;
      }
    }
  };
  var isComputingDerivation = function() {
    return globalState.trackingDerivation !== null;
  };
  var checkIfStateModificationsAreAllowed = function(atom) {
    var hasObservers2 = atom.observers_.size > 0;
    if (!globalState.allowStateChanges && (hasObservers2 || globalState.enforceActions === "always")) {
      console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
    }
  };
  var checkIfStateReadsAreAllowed = function(observable2) {
    if (!globalState.allowStateReads && globalState.observableRequiresReaction) {
      console.warn("[mobx] Observable '" + observable2.name_ + "' being read outside a reactive context.");
    }
  };
  var trackDerivedFunction = function(derivation, f, context2) {
    var prevAllowStateReads = allowStateReadsStart(true);
    changeDependenciesStateTo0(derivation);
    derivation.newObserving_ = new Array(derivation.observing_.length + 100);
    derivation.unboundDepsCount_ = 0;
    derivation.runId_ = ++globalState.runId;
    var prevTracking = globalState.trackingDerivation;
    globalState.trackingDerivation = derivation;
    globalState.inBatch++;
    var result;
    if (globalState.disableErrorBoundaries === true) {
      result = f.call(context2);
    } else {
      try {
        result = f.call(context2);
      } catch (e) {
        result = new CaughtException(e);
      }
    }
    globalState.inBatch--;
    globalState.trackingDerivation = prevTracking;
    bindDependencies(derivation);
    warnAboutDerivationWithoutDependencies(derivation);
    allowStateReadsEnd(prevAllowStateReads);
    return result;
  };
  var warnAboutDerivationWithoutDependencies = function(derivation) {
    if (derivation.observing_.length !== 0) {
      return;
    }
    if (typeof derivation.requiresObservable_ === "boolean" ? derivation.requiresObservable_ : globalState.reactionRequiresObservable) {
      console.warn("[mobx] Derivation '" + derivation.name_ + "' is created/updated without reading any observable value.");
    }
  };
  var bindDependencies = function(derivation) {
    var prevObserving = derivation.observing_;
    var observing = derivation.observing_ = derivation.newObserving_;
    var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
    var i0 = 0, l = derivation.unboundDepsCount_;
    for (var i = 0;i < l; i++) {
      var dep = observing[i];
      if (dep.diffValue_ === 0) {
        dep.diffValue_ = 1;
        if (i0 !== i) {
          observing[i0] = dep;
        }
        i0++;
      }
      if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
        lowestNewObservingDerivationState = dep.dependenciesState_;
      }
    }
    observing.length = i0;
    derivation.newObserving_ = null;
    l = prevObserving.length;
    while (l--) {
      var _dep = prevObserving[l];
      if (_dep.diffValue_ === 0) {
        removeObserver(_dep, derivation);
      }
      _dep.diffValue_ = 0;
    }
    while (i0--) {
      var _dep2 = observing[i0];
      if (_dep2.diffValue_ === 1) {
        _dep2.diffValue_ = 0;
        addObserver(_dep2, derivation);
      }
    }
    if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
      derivation.dependenciesState_ = lowestNewObservingDerivationState;
      derivation.onBecomeStale_();
    }
  };
  var clearObserving = function(derivation) {
    var obs = derivation.observing_;
    derivation.observing_ = [];
    var i = obs.length;
    while (i--) {
      removeObserver(obs[i], derivation);
    }
    derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
  };
  var untracked = function(action2) {
    var prev = untrackedStart();
    try {
      return action2();
    } finally {
      untrackedEnd(prev);
    }
  };
  var untrackedStart = function() {
    var prev = globalState.trackingDerivation;
    globalState.trackingDerivation = null;
    return prev;
  };
  var untrackedEnd = function(prev) {
    globalState.trackingDerivation = prev;
  };
  var allowStateReadsStart = function(allowStateReads) {
    var prev = globalState.allowStateReads;
    globalState.allowStateReads = allowStateReads;
    return prev;
  };
  var allowStateReadsEnd = function(prev) {
    globalState.allowStateReads = prev;
  };
  var changeDependenciesStateTo0 = function(derivation) {
    if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      return;
    }
    derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
    var obs = derivation.observing_;
    var i = obs.length;
    while (i--) {
      obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    }
  };
  var isolateGlobalState = function() {
    if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) {
      die(36);
    }
    isolateCalled = true;
    if (canMergeGlobalState) {
      var global2 = getGlobal();
      if (--global2.__mobxInstanceCount === 0) {
        global2.__mobxGlobals = undefined;
      }
      globalState = new MobXGlobals;
    }
  };
  var getGlobalState = function() {
    return globalState;
  };
  var resetGlobalState = function() {
    var defaultGlobals = new MobXGlobals;
    for (var key in defaultGlobals) {
      if (persistentKeys.indexOf(key) === -1) {
        globalState[key] = defaultGlobals[key];
      }
    }
    globalState.allowStateChanges = !globalState.enforceActions;
  };
  var hasObservers = function(observable2) {
    return observable2.observers_ && observable2.observers_.size > 0;
  };
  var getObservers = function(observable2) {
    return observable2.observers_;
  };
  var addObserver = function(observable2, node) {
    observable2.observers_.add(node);
    if (observable2.lowestObserverState_ > node.dependenciesState_) {
      observable2.lowestObserverState_ = node.dependenciesState_;
    }
  };
  var removeObserver = function(observable2, node) {
    observable2.observers_["delete"](node);
    if (observable2.observers_.size === 0) {
      queueForUnobservation(observable2);
    }
  };
  var queueForUnobservation = function(observable2) {
    if (observable2.isPendingUnobservation_ === false) {
      observable2.isPendingUnobservation_ = true;
      globalState.pendingUnobservations.push(observable2);
    }
  };
  var startBatch = function() {
    globalState.inBatch++;
  };
  var endBatch = function() {
    if (--globalState.inBatch === 0) {
      runReactions();
      var list = globalState.pendingUnobservations;
      for (var i = 0;i < list.length; i++) {
        var observable2 = list[i];
        observable2.isPendingUnobservation_ = false;
        if (observable2.observers_.size === 0) {
          if (observable2.isBeingObserved_) {
            observable2.isBeingObserved_ = false;
            observable2.onBUO();
          }
          if (observable2 instanceof ComputedValue) {
            observable2.suspend_();
          }
        }
      }
      globalState.pendingUnobservations = [];
    }
  };
  var reportObserved = function(observable2) {
    checkIfStateReadsAreAllowed(observable2);
    var derivation = globalState.trackingDerivation;
    if (derivation !== null) {
      if (derivation.runId_ !== observable2.lastAccessedBy_) {
        observable2.lastAccessedBy_ = derivation.runId_;
        derivation.newObserving_[derivation.unboundDepsCount_++] = observable2;
        if (!observable2.isBeingObserved_ && globalState.trackingContext) {
          observable2.isBeingObserved_ = true;
          observable2.onBO();
        }
      }
      return true;
    } else if (observable2.observers_.size === 0 && globalState.inBatch > 0) {
      queueForUnobservation(observable2);
    }
    return false;
  };
  var propagateChanged = function(observable2) {
    if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
      return;
    }
    observable2.lowestObserverState_ = IDerivationState_.STALE_;
    observable2.observers_.forEach(function(d) {
      if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
        if (d.isTracing_ !== TraceMode.NONE) {
          logTraceInfo(d, observable2);
        }
        d.onBecomeStale_();
      }
      d.dependenciesState_ = IDerivationState_.STALE_;
    });
  };
  var propagateChangeConfirmed = function(observable2) {
    if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
      return;
    }
    observable2.lowestObserverState_ = IDerivationState_.STALE_;
    observable2.observers_.forEach(function(d) {
      if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
        d.dependenciesState_ = IDerivationState_.STALE_;
        if (d.isTracing_ !== TraceMode.NONE) {
          logTraceInfo(d, observable2);
        }
      } else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
        observable2.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
      }
    });
  };
  var propagateMaybeChanged = function(observable2) {
    if (observable2.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {
      return;
    }
    observable2.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
    observable2.observers_.forEach(function(d) {
      if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
        d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
        d.onBecomeStale_();
      }
    });
  };
  var logTraceInfo = function(derivation, observable2) {
    console.log("[mobx.trace] '" + derivation.name_ + "' is invalidated due to a change in: '" + observable2.name_ + "'");
    if (derivation.isTracing_ === TraceMode.BREAK) {
      var lines = [];
      printDepTree(getDependencyTree(derivation), lines, 1);
      new Function("debugger;\n/*\nTracing '" + derivation.name_ + "'\n\nYou are entering this break point because derivation '" + derivation.name_ + "' is being traced and '" + observable2.name_ + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
    }
  };
  var printDepTree = function(tree, lines, depth) {
    if (lines.length >= 1000) {
      lines.push("(and many more)");
      return;
    }
    lines.push("" + "\t".repeat(depth - 1) + tree.name);
    if (tree.dependencies) {
      tree.dependencies.forEach(function(child) {
        return printDepTree(child, lines, depth + 1);
      });
    }
  };
  var onReactionError = function(handler) {
    globalState.globalReactionErrorHandlers.push(handler);
    return function() {
      var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
      if (idx >= 0) {
        globalState.globalReactionErrorHandlers.splice(idx, 1);
      }
    };
  };
  var runReactions = function() {
    if (globalState.inBatch > 0 || globalState.isRunningReactions) {
      return;
    }
    reactionScheduler(runReactionsHelper);
  };
  var runReactionsHelper = function() {
    globalState.isRunningReactions = true;
    var allReactions = globalState.pendingReactions;
    var iterations = 0;
    while (allReactions.length > 0) {
      if (++iterations === MAX_REACTION_ITERATIONS) {
        console.error("Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]));
        allReactions.splice(0);
      }
      var remainingReactions = allReactions.splice(0);
      for (var i = 0, l = remainingReactions.length;i < l; i++) {
        remainingReactions[i].runReaction_();
      }
    }
    globalState.isRunningReactions = false;
  };
  var setReactionScheduler = function(fn) {
    var baseScheduler = reactionScheduler;
    reactionScheduler = function reactionScheduler(f) {
      return fn(function() {
        return baseScheduler(f);
      });
    };
  };
  var isSpyEnabled = function() {
    return !!globalState.spyListeners.length;
  };
  var spyReport = function(event) {
    if (!globalState.spyListeners.length) {
      return;
    }
    var listeners = globalState.spyListeners;
    for (var i = 0, l = listeners.length;i < l; i++) {
      listeners[i](event);
    }
  };
  var spyReportStart = function(event) {
    var change = _extends({}, event, {
      spyReportStart: true
    });
    spyReport(change);
  };
  var spyReportEnd = function(change) {
    if (change) {
      spyReport(_extends({}, change, {
        type: "report-end",
        spyReportEnd: true
      }));
    } else {
      spyReport(END_EVENT);
    }
  };
  var spy = function(listener) {
    {
      globalState.spyListeners.push(listener);
      return once(function() {
        globalState.spyListeners = globalState.spyListeners.filter(function(l) {
          return l !== listener;
        });
      });
    }
  };
  var createActionFactory = function(autoAction2) {
    var res = function action(arg1, arg2) {
      if (isFunction(arg1)) {
        return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction2);
      }
      if (isFunction(arg2)) {
        return createAction(arg1, arg2, autoAction2);
      }
      if (isStringish(arg2)) {
        return storeAnnotation(arg1, arg2, autoAction2 ? autoActionAnnotation : actionAnnotation);
      }
      if (isStringish(arg1)) {
        return createDecoratorAnnotation(createActionAnnotation(autoAction2 ? AUTOACTION : ACTION, {
          name: arg1,
          autoAction: autoAction2
        }));
      }
      {
        die("Invalid arguments for `action`");
      }
    };
    return res;
  };
  var runInAction = function(fn) {
    return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, undefined);
  };
  var isAction = function(thing) {
    return isFunction(thing) && thing.isMobxAction === true;
  };
  var autorun = function(view, opts) {
    var _opts$name, _opts;
    if (opts === undefined) {
      opts = EMPTY_OBJECT;
    }
    {
      if (!isFunction(view)) {
        die("Autorun expects a function as first argument");
      }
      if (isAction(view)) {
        die("Autorun does not accept actions since actions are untrackable");
      }
    }
    var name = (_opts$name = (_opts = opts) == null ? undefined : _opts.name) != null ? _opts$name : view.name || "Autorun@" + getNextId();
    var runSync = !opts.scheduler && !opts.delay;
    var reaction2;
    if (runSync) {
      reaction2 = new Reaction(name, function() {
        this.track(reactionRunner);
      }, opts.onError, opts.requiresObservable);
    } else {
      var scheduler = createSchedulerFromOptions(opts);
      var isScheduled = false;
      reaction2 = new Reaction(name, function() {
        if (!isScheduled) {
          isScheduled = true;
          scheduler(function() {
            isScheduled = false;
            if (!reaction2.isDisposed_) {
              reaction2.track(reactionRunner);
            }
          });
        }
      }, opts.onError, opts.requiresObservable);
    }
    function reactionRunner() {
      view(reaction2);
    }
    reaction2.schedule_();
    return reaction2.getDisposer_();
  };
  var createSchedulerFromOptions = function(opts) {
    return opts.scheduler ? opts.scheduler : opts.delay ? function(f) {
      return setTimeout(f, opts.delay);
    } : run;
  };
  var reaction = function(expression, effect, opts) {
    var _opts$name2;
    if (opts === undefined) {
      opts = EMPTY_OBJECT;
    }
    {
      if (!isFunction(expression) || !isFunction(effect)) {
        die("First and second argument to reaction should be functions");
      }
      if (!isPlainObject(opts)) {
        die("Third argument of reactions should be an object");
      }
    }
    var name = (_opts$name2 = opts.name) != null ? _opts$name2 : "Reaction@" + getNextId();
    var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
    var runSync = !opts.scheduler && !opts.delay;
    var scheduler = createSchedulerFromOptions(opts);
    var firstTime = true;
    var isScheduled = false;
    var value;
    var oldValue;
    var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
    var r = new Reaction(name, function() {
      if (firstTime || runSync) {
        reactionRunner();
      } else if (!isScheduled) {
        isScheduled = true;
        scheduler(reactionRunner);
      }
    }, opts.onError, opts.requiresObservable);
    function reactionRunner() {
      isScheduled = false;
      if (r.isDisposed_) {
        return;
      }
      var changed = false;
      r.track(function() {
        var nextValue = allowStateChanges(false, function() {
          return expression(r);
        });
        changed = firstTime || !equals(value, nextValue);
        oldValue = value;
        value = nextValue;
      });
      if (firstTime && opts.fireImmediately) {
        effectAction(value, oldValue, r);
      } else if (!firstTime && changed) {
        effectAction(value, oldValue, r);
      }
      firstTime = false;
    }
    r.schedule_();
    return r.getDisposer_();
  };
  var wrapErrorHandler = function(errorHandler, baseFn) {
    return function() {
      try {
        return baseFn.apply(this, arguments);
      } catch (e) {
        errorHandler.call(this, e);
      }
    };
  };
  var onBecomeObserved = function(thing, arg2, arg3) {
    return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
  };
  var onBecomeUnobserved = function(thing, arg2, arg3) {
    return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
  };
  var interceptHook = function(hook, thing, arg2, arg3) {
    var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
    var cb = isFunction(arg3) ? arg3 : arg2;
    var listenersKey = hook + "L";
    if (atom[listenersKey]) {
      atom[listenersKey].add(cb);
    } else {
      atom[listenersKey] = new Set([cb]);
    }
    return function() {
      var hookListeners = atom[listenersKey];
      if (hookListeners) {
        hookListeners["delete"](cb);
        if (hookListeners.size === 0) {
          delete atom[listenersKey];
        }
      }
    };
  };
  var configure = function(options) {
    if (options.isolateGlobalState === true) {
      isolateGlobalState();
    }
    var { useProxies, enforceActions } = options;
    if (useProxies !== undefined) {
      globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
    }
    if (useProxies === "ifavailable") {
      globalState.verifyProxies = true;
    }
    if (enforceActions !== undefined) {
      var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
      globalState.enforceActions = ea;
      globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;
    }
    ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function(key) {
      if (key in options) {
        globalState[key] = !!options[key];
      }
    });
    globalState.allowStateReads = !globalState.observableRequiresReaction;
    if (globalState.disableErrorBoundaries === true) {
      console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.");
    }
    if (options.reactionScheduler) {
      setReactionScheduler(options.reactionScheduler);
    }
  };
  var extendObservable = function(target, properties, annotations, options) {
    {
      if (arguments.length > 4) {
        die("'extendObservable' expected 2-4 arguments");
      }
      if (typeof target !== "object") {
        die("'extendObservable' expects an object as first argument");
      }
      if (isObservableMap(target)) {
        die("'extendObservable' should not be used on maps, use map.merge instead");
      }
      if (!isPlainObject(properties)) {
        die("'extendObservable' only accepts plain objects as second argument");
      }
      if (isObservable(properties) || isObservable(annotations)) {
        die("Extending an object with another observable (object) is not supported");
      }
    }
    var descriptors = getOwnPropertyDescriptors(properties);
    var adm = asObservableObject(target, options)[$mobx];
    startBatch();
    try {
      ownKeys(descriptors).forEach(function(key) {
        adm.extend_(key, descriptors[key], !annotations ? true : (key in annotations) ? annotations[key] : true);
      });
    } finally {
      endBatch();
    }
    return target;
  };
  var getDependencyTree = function(thing, property) {
    return nodeToDependencyTree(getAtom(thing, property));
  };
  var nodeToDependencyTree = function(node) {
    var result = {
      name: node.name_
    };
    if (node.observing_ && node.observing_.length > 0) {
      result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
    }
    return result;
  };
  var getObserverTree = function(thing, property) {
    return nodeToObserverTree(getAtom(thing, property));
  };
  var nodeToObserverTree = function(node) {
    var result = {
      name: node.name_
    };
    if (hasObservers(node)) {
      result.observers = Array.from(getObservers(node)).map(nodeToObserverTree);
    }
    return result;
  };
  var unique = function(list) {
    return Array.from(new Set(list));
  };
  var FlowCancellationError = function() {
    this.message = "FLOW_CANCELLED";
  };
  var isFlowCancellationError = function(error) {
    return error instanceof FlowCancellationError;
  };
  var cancelPromise = function(promise) {
    if (isFunction(promise.cancel)) {
      promise.cancel();
    }
  };
  var flowResult = function(result) {
    return result;
  };
  var isFlow = function(fn) {
    return (fn == null ? undefined : fn.isMobXFlow) === true;
  };
  var interceptReads = function(thing, propOrHandler, handler) {
    var target;
    if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {
      target = getAdministration(thing);
    } else if (isObservableObject(thing)) {
      if (!isStringish(propOrHandler)) {
        return die("InterceptReads can only be used with a specific property, not with an object in general");
      }
      target = getAdministration(thing, propOrHandler);
    } else {
      return die("Expected observable map, object or array as first array");
    }
    if (target.dehancer !== undefined) {
      return die("An intercept reader was already established");
    }
    target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler;
    return function() {
      target.dehancer = undefined;
    };
  };
  var intercept = function(thing, propOrHandler, handler) {
    if (isFunction(handler)) {
      return interceptProperty(thing, propOrHandler, handler);
    } else {
      return interceptInterceptable(thing, propOrHandler);
    }
  };
  var interceptInterceptable = function(thing, handler) {
    return getAdministration(thing).intercept_(handler);
  };
  var interceptProperty = function(thing, property, handler) {
    return getAdministration(thing, property).intercept_(handler);
  };
  var _isComputed = function(value, property) {
    if (property === undefined) {
      return isComputedValue(value);
    }
    if (isObservableObject(value) === false) {
      return false;
    }
    if (!value[$mobx].values_.has(property)) {
      return false;
    }
    var atom = getAtom(value, property);
    return isComputedValue(atom);
  };
  var isComputed = function(value) {
    if (arguments.length > 1) {
      return die("isComputed expects only 1 argument. Use isComputedProp to inspect the observability of a property");
    }
    return _isComputed(value);
  };
  var isComputedProp = function(value, propName) {
    if (!isStringish(propName)) {
      return die("isComputed expected a property name as second argument");
    }
    return _isComputed(value, propName);
  };
  var _isObservable = function(value, property) {
    if (!value) {
      return false;
    }
    if (property !== undefined) {
      if (isObservableMap(value) || isObservableArray(value)) {
        return die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");
      }
      if (isObservableObject(value)) {
        return value[$mobx].values_.has(property);
      }
      return false;
    }
    return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
  };
  var isObservable = function(value) {
    if (arguments.length !== 1) {
      die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
    }
    return _isObservable(value);
  };
  var isObservableProp = function(value, propName) {
    if (!isStringish(propName)) {
      return die("expected a property name as second argument");
    }
    return _isObservable(value, propName);
  };
  var keys = function(obj) {
    if (isObservableObject(obj)) {
      return obj[$mobx].keys_();
    }
    if (isObservableMap(obj) || isObservableSet(obj)) {
      return Array.from(obj.keys());
    }
    if (isObservableArray(obj)) {
      return obj.map(function(_, index) {
        return index;
      });
    }
    die(5);
  };
  var values = function(obj) {
    if (isObservableObject(obj)) {
      return keys(obj).map(function(key) {
        return obj[key];
      });
    }
    if (isObservableMap(obj)) {
      return keys(obj).map(function(key) {
        return obj.get(key);
      });
    }
    if (isObservableSet(obj)) {
      return Array.from(obj.values());
    }
    if (isObservableArray(obj)) {
      return obj.slice();
    }
    die(6);
  };
  var entries = function(obj) {
    if (isObservableObject(obj)) {
      return keys(obj).map(function(key) {
        return [key, obj[key]];
      });
    }
    if (isObservableMap(obj)) {
      return keys(obj).map(function(key) {
        return [key, obj.get(key)];
      });
    }
    if (isObservableSet(obj)) {
      return Array.from(obj.entries());
    }
    if (isObservableArray(obj)) {
      return obj.map(function(key, index) {
        return [index, key];
      });
    }
    die(7);
  };
  var set = function(obj, key, value) {
    if (arguments.length === 2 && !isObservableSet(obj)) {
      startBatch();
      var _values = key;
      try {
        for (var _key in _values) {
          set(obj, _key, _values[_key]);
        }
      } finally {
        endBatch();
      }
      return;
    }
    if (isObservableObject(obj)) {
      obj[$mobx].set_(key, value);
    } else if (isObservableMap(obj)) {
      obj.set(key, value);
    } else if (isObservableSet(obj)) {
      obj.add(key);
    } else if (isObservableArray(obj)) {
      if (typeof key !== "number") {
        key = parseInt(key, 10);
      }
      if (key < 0) {
        die("Invalid index: '" + key + "'");
      }
      startBatch();
      if (key >= obj.length) {
        obj.length = key + 1;
      }
      obj[key] = value;
      endBatch();
    } else {
      die(8);
    }
  };
  var remove = function(obj, key) {
    if (isObservableObject(obj)) {
      obj[$mobx].delete_(key);
    } else if (isObservableMap(obj)) {
      obj["delete"](key);
    } else if (isObservableSet(obj)) {
      obj["delete"](key);
    } else if (isObservableArray(obj)) {
      if (typeof key !== "number") {
        key = parseInt(key, 10);
      }
      obj.splice(key, 1);
    } else {
      die(9);
    }
  };
  var has = function(obj, key) {
    if (isObservableObject(obj)) {
      return obj[$mobx].has_(key);
    } else if (isObservableMap(obj)) {
      return obj.has(key);
    } else if (isObservableSet(obj)) {
      return obj.has(key);
    } else if (isObservableArray(obj)) {
      return key >= 0 && key < obj.length;
    }
    die(10);
  };
  var get = function(obj, key) {
    if (!has(obj, key)) {
      return;
    }
    if (isObservableObject(obj)) {
      return obj[$mobx].get_(key);
    } else if (isObservableMap(obj)) {
      return obj.get(key);
    } else if (isObservableArray(obj)) {
      return obj[key];
    }
    die(11);
  };
  var apiDefineProperty = function(obj, key, descriptor) {
    if (isObservableObject(obj)) {
      return obj[$mobx].defineProperty_(key, descriptor);
    }
    die(39);
  };
  var apiOwnKeys = function(obj) {
    if (isObservableObject(obj)) {
      return obj[$mobx].ownKeys_();
    }
    die(38);
  };
  var observe = function(thing, propOrCb, cbOrFire, fireImmediately) {
    if (isFunction(cbOrFire)) {
      return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
    } else {
      return observeObservable(thing, propOrCb, cbOrFire);
    }
  };
  var observeObservable = function(thing, listener, fireImmediately) {
    return getAdministration(thing).observe_(listener, fireImmediately);
  };
  var observeObservableProperty = function(thing, property, listener, fireImmediately) {
    return getAdministration(thing, property).observe_(listener, fireImmediately);
  };
  var cache = function(map, key, value) {
    map.set(key, value);
    return value;
  };
  var toJSHelper = function(source, __alreadySeen) {
    if (source == null || typeof source !== "object" || source instanceof Date || !isObservable(source)) {
      return source;
    }
    if (isObservableValue(source) || isComputedValue(source)) {
      return toJSHelper(source.get(), __alreadySeen);
    }
    if (__alreadySeen.has(source)) {
      return __alreadySeen.get(source);
    }
    if (isObservableArray(source)) {
      var res = cache(__alreadySeen, source, new Array(source.length));
      source.forEach(function(value, idx) {
        res[idx] = toJSHelper(value, __alreadySeen);
      });
      return res;
    }
    if (isObservableSet(source)) {
      var _res = cache(__alreadySeen, source, new Set);
      source.forEach(function(value) {
        _res.add(toJSHelper(value, __alreadySeen));
      });
      return _res;
    }
    if (isObservableMap(source)) {
      var _res2 = cache(__alreadySeen, source, new Map);
      source.forEach(function(value, key) {
        _res2.set(key, toJSHelper(value, __alreadySeen));
      });
      return _res2;
    } else {
      var _res3 = cache(__alreadySeen, source, {});
      apiOwnKeys(source).forEach(function(key) {
        if (objectPrototype.propertyIsEnumerable.call(source, key)) {
          _res3[key] = toJSHelper(source[key], __alreadySeen);
        }
      });
      return _res3;
    }
  };
  var toJS = function(source, options) {
    if (options) {
      die("toJS no longer supports options");
    }
    return toJSHelper(source, new Map);
  };
  var trace = function() {
    var enterBreakPoint = false;
    for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[args.length - 1] === "boolean") {
      enterBreakPoint = args.pop();
    }
    var derivation = getAtomFromArgs(args);
    if (!derivation) {
      return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
    }
    if (derivation.isTracing_ === TraceMode.NONE) {
      console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
    }
    derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
  };
  var getAtomFromArgs = function(args) {
    switch (args.length) {
      case 0:
        return globalState.trackingDerivation;
      case 1:
        return getAtom(args[0]);
      case 2:
        return getAtom(args[0], args[1]);
    }
  };
  var transaction = function(action2, thisArg) {
    if (thisArg === undefined) {
      thisArg = undefined;
    }
    startBatch();
    try {
      return action2.apply(thisArg);
    } finally {
      endBatch();
    }
  };
  var when = function(predicate, arg1, arg2) {
    if (arguments.length === 1 || arg1 && typeof arg1 === "object") {
      return whenPromise(predicate, arg1);
    }
    return _when(predicate, arg1, arg2 || {});
  };
  var _when = function(predicate, effect, opts) {
    var timeoutHandle;
    if (typeof opts.timeout === "number") {
      var error = new Error("WHEN_TIMEOUT");
      timeoutHandle = setTimeout(function() {
        if (!disposer[$mobx].isDisposed_) {
          disposer();
          if (opts.onError) {
            opts.onError(error);
          } else {
            throw error;
          }
        }
      }, opts.timeout);
    }
    opts.name = opts.name || "When@" + getNextId();
    var effectAction = createAction(opts.name + "-effect", effect);
    var disposer = autorun(function(r) {
      var cond = allowStateChanges(false, predicate);
      if (cond) {
        r.dispose();
        if (timeoutHandle) {
          clearTimeout(timeoutHandle);
        }
        effectAction();
      }
    }, opts);
    return disposer;
  };
  var whenPromise = function(predicate, opts) {
    if (opts && opts.onError) {
      return die("the options 'onError' and 'promise' cannot be combined");
    }
    var cancel;
    var res = new Promise(function(resolve2, reject2) {
      var disposer = _when(predicate, resolve2, _extends({}, opts, {
        onError: reject2
      }));
      cancel = function cancel() {
        disposer();
        reject2(new Error("WHEN_CANCELLED"));
      };
    });
    res.cancel = cancel;
    return res;
  };
  var getAdm = function(target) {
    return target[$mobx];
  };
  var asDynamicObservableObject = function(target, options) {
    var _target$$mobx, _target$$mobx$proxy_;
    assertProxies();
    target = asObservableObject(target, options);
    return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
  };
  var hasInterceptors = function(interceptable) {
    return interceptable.interceptors_ !== undefined && interceptable.interceptors_.length > 0;
  };
  var registerInterceptor = function(interceptable, handler) {
    var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
    interceptors.push(handler);
    return once(function() {
      var idx = interceptors.indexOf(handler);
      if (idx !== -1) {
        interceptors.splice(idx, 1);
      }
    });
  };
  var interceptChange = function(interceptable, change) {
    var prevU = untrackedStart();
    try {
      var interceptors = [].concat(interceptable.interceptors_ || []);
      for (var i = 0, l = interceptors.length;i < l; i++) {
        change = interceptors[i](change);
        if (change && !change.type) {
          die(14);
        }
        if (!change) {
          break;
        }
      }
      return change;
    } finally {
      untrackedEnd(prevU);
    }
  };
  var hasListeners = function(listenable) {
    return listenable.changeListeners_ !== undefined && listenable.changeListeners_.length > 0;
  };
  var registerListener = function(listenable, handler) {
    var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
    listeners.push(handler);
    return once(function() {
      var idx = listeners.indexOf(handler);
      if (idx !== -1) {
        listeners.splice(idx, 1);
      }
    });
  };
  var notifyListeners = function(listenable, change) {
    var prevU = untrackedStart();
    var listeners = listenable.changeListeners_;
    if (!listeners) {
      return;
    }
    listeners = listeners.slice();
    for (var i = 0, l = listeners.length;i < l; i++) {
      listeners[i](change);
    }
    untrackedEnd(prevU);
  };
  var makeObservable = function(target, annotations, options) {
    var adm = asObservableObject(target, options)[$mobx];
    startBatch();
    try {
      var _annotations;
      if (annotations && target[storedAnnotationsSymbol]) {
        die("makeObservable second arg must be nullish when using decorators. Mixing @decorator syntax with annotations is not supported.");
      }
      (_annotations = annotations) != null || (annotations = collectStoredAnnotations(target));
      ownKeys(annotations).forEach(function(key) {
        return adm.make_(key, annotations[key]);
      });
    } finally {
      endBatch();
    }
    return target;
  };
  var makeAutoObservable = function(target, overrides, options) {
    {
      if (!isPlainObject(target) && !isPlainObject(Object.getPrototypeOf(target))) {
        die("'makeAutoObservable' can only be used for classes that don't have a superclass");
      }
      if (isObservableObject(target)) {
        die("makeAutoObservable can only be used on objects not already made observable");
      }
    }
    if (isPlainObject(target)) {
      return extendObservable(target, target, overrides, options);
    }
    var adm = asObservableObject(target, options)[$mobx];
    if (!target[keysSymbol]) {
      var proto = Object.getPrototypeOf(target);
      var keys2 = new Set([].concat(ownKeys(target), ownKeys(proto)));
      keys2["delete"]("constructor");
      keys2["delete"]($mobx);
      addHiddenProp(proto, keysSymbol, keys2);
    }
    startBatch();
    try {
      target[keysSymbol].forEach(function(key) {
        return adm.make_(key, !overrides ? true : (key in overrides) ? overrides[key] : true);
      });
    } finally {
      endBatch();
    }
    return target;
  };
  var createObservableArray = function(initialValues, enhancer, name, owned) {
    if (name === undefined) {
      name = "ObservableArray@" + getNextId();
    }
    if (owned === undefined) {
      owned = false;
    }
    assertProxies();
    var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
    addHiddenFinalProp(adm.values_, $mobx, adm);
    var proxy = new Proxy(adm.values_, arrayTraps);
    adm.proxy_ = proxy;
    if (initialValues && initialValues.length) {
      var prev = allowStateChangesStart(true);
      adm.spliceWithArray_(0, 0, initialValues);
      allowStateChangesEnd(prev);
    }
    return proxy;
  };
  var addArrayExtension = function(funcName, funcFactory) {
    if (typeof Array.prototype[funcName] === "function") {
      arrayExtensions[funcName] = funcFactory(funcName);
    }
  };
  var simpleFunc = function(funcName) {
    return function() {
      var adm = this[$mobx];
      adm.atom_.reportObserved();
      var dehancedValues = adm.dehanceValues_(adm.values_);
      return dehancedValues[funcName].apply(dehancedValues, arguments);
    };
  };
  var mapLikeFunc = function(funcName) {
    return function(callback, thisArg) {
      var _this2 = this;
      var adm = this[$mobx];
      adm.atom_.reportObserved();
      var dehancedValues = adm.dehanceValues_(adm.values_);
      return dehancedValues[funcName](function(element, index) {
        return callback.call(thisArg, element, index, _this2);
      });
    };
  };
  var reduceLikeFunc = function(funcName) {
    return function() {
      var _this3 = this;
      var adm = this[$mobx];
      adm.atom_.reportObserved();
      var dehancedValues = adm.dehanceValues_(adm.values_);
      var callback = arguments[0];
      arguments[0] = function(accumulator, currentValue, index) {
        return callback(accumulator, currentValue, index, _this3);
      };
      return dehancedValues[funcName].apply(dehancedValues, arguments);
    };
  };
  var isObservableArray = function(thing) {
    return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
  };
  var convertToMap = function(dataStructure) {
    if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
      return dataStructure;
    } else if (Array.isArray(dataStructure)) {
      return new Map(dataStructure);
    } else if (isPlainObject(dataStructure)) {
      var map = new Map;
      for (var key in dataStructure) {
        map.set(key, dataStructure[key]);
      }
      return map;
    } else {
      return die(21, dataStructure);
    }
  };
  var asObservableObject = function(target, options) {
    var _options$name;
    if (options && isObservableObject(target)) {
      die("Options can't be provided for already observable objects.");
    }
    if (hasProp(target, $mobx)) {
      if (!(getAdministration(target) instanceof ObservableObjectAdministration)) {
        die("Cannot convert '" + getDebugName(target) + "' into observable object:" + "\nThe target is already observable of different type." + "\nExtending builtins is not supported.");
      }
      return target;
    }
    if (!Object.isExtensible(target)) {
      die("Cannot make the designated object observable; it is not extensible");
    }
    var name = (_options$name = options == null ? undefined : options.name) != null ? _options$name : (isPlainObject(target) ? "ObservableObject" : target.constructor.name) + "@" + getNextId();
    var adm = new ObservableObjectAdministration(target, new Map, String(name), getAnnotationFromOptions(options));
    addHiddenProp(target, $mobx, adm);
    return target;
  };
  var getCachedObservablePropDescriptor = function(key) {
    return descriptorCache[key] || (descriptorCache[key] = {
      get: function get() {
        return this[$mobx].getObservablePropValue_(key);
      },
      set: function set(value) {
        return this[$mobx].setObservablePropValue_(key, value);
      }
    });
  };
  var isObservableObject = function(thing) {
    if (isObject(thing)) {
      return isObservableObjectAdministration(thing[$mobx]);
    }
    return false;
  };
  var recordAnnotationApplied = function(adm, annotation, key) {
    var _adm$target_$storedAn;
    {
      adm.appliedAnnotations_[key] = annotation;
    }
    (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null || delete _adm$target_$storedAn[key];
  };
  var assertAnnotable = function(adm, annotation, key) {
    if (!isAnnotation(annotation)) {
      die("Cannot annotate '" + adm.name_ + "." + key.toString() + "': Invalid annotation.");
    }
    if (!isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {
      var fieldName = adm.name_ + "." + key.toString();
      var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;
      var requestedAnnotationType = annotation.annotationType_;
      die("Cannot apply '" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already annotated with '" + currentAnnotationType + "'.") + "\nRe-annotating fields is not allowed." + "\nUse 'override' annotation for methods overridden by subclass.");
    }
  };
  var inherit = function(ctor, proto) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(ctor.prototype, proto);
    } else if (ctor.prototype.__proto__ !== undefined) {
      ctor.prototype.__proto__ = proto;
    } else {
      ctor.prototype = proto;
    }
  };
  var createArrayEntryDescriptor = function(index) {
    return {
      enumerable: false,
      configurable: true,
      get: function get() {
        return this[$mobx].get_(index);
      },
      set: function set(value) {
        this[$mobx].set_(index, value);
      }
    };
  };
  var createArrayBufferItem = function(index) {
    defineProperty(LegacyObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
  };
  var reserveArrayBuffer = function(max) {
    if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
      for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE;index < max + 100; index++) {
        createArrayBufferItem(index);
      }
      OBSERVABLE_ARRAY_BUFFER_SIZE = max;
    }
  };
  var createLegacyArray = function(initialValues, enhancer, name) {
    return new LegacyObservableArray(initialValues, enhancer, name);
  };
  var getAtom = function(thing, property) {
    if (typeof thing === "object" && thing !== null) {
      if (isObservableArray(thing)) {
        if (property !== undefined) {
          die(23);
        }
        return thing[$mobx].atom_;
      }
      if (isObservableSet(thing)) {
        return thing[$mobx];
      }
      if (isObservableMap(thing)) {
        if (property === undefined) {
          return thing.keysAtom_;
        }
        var observable2 = thing.data_.get(property) || thing.hasMap_.get(property);
        if (!observable2) {
          die(25, property, getDebugName(thing));
        }
        return observable2;
      }
      if (isObservableObject(thing)) {
        if (!property) {
          return die(26);
        }
        var _observable = thing[$mobx].values_.get(property);
        if (!_observable) {
          die(27, property, getDebugName(thing));
        }
        return _observable;
      }
      if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
        return thing;
      }
    } else if (isFunction(thing)) {
      if (isReaction(thing[$mobx])) {
        return thing[$mobx];
      }
    }
    die(28);
  };
  var getAdministration = function(thing, property) {
    if (!thing) {
      die(29);
    }
    if (property !== undefined) {
      return getAdministration(getAtom(thing, property));
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
    if (isObservableMap(thing) || isObservableSet(thing)) {
      return thing;
    }
    if (thing[$mobx]) {
      return thing[$mobx];
    }
    die(24, thing);
  };
  var getDebugName = function(thing, property) {
    var named;
    if (property !== undefined) {
      named = getAtom(thing, property);
    } else if (isAction(thing)) {
      return thing.name;
    } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
      named = getAdministration(thing);
    } else {
      named = getAtom(thing);
    }
    return named.name_;
  };
  var deepEqual = function(a, b, depth) {
    if (depth === undefined) {
      depth = -1;
    }
    return eq(a, b, depth);
  };
  var eq = function(a, b, depth, aStack, bStack) {
    if (a === b) {
      return a !== 0 || 1 / a === 1 / b;
    }
    if (a == null || b == null) {
      return false;
    }
    if (a !== a) {
      return b !== b;
    }
    var type = typeof a;
    if (type !== "function" && type !== "object" && typeof b != "object") {
      return false;
    }
    var className = toString.call(a);
    if (className !== toString.call(b)) {
      return false;
    }
    switch (className) {
      case "[object RegExp]":
      case "[object String]":
        return "" + a === "" + b;
      case "[object Number]":
        if (+a !== +a) {
          return +b !== +b;
        }
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case "[object Date]":
      case "[object Boolean]":
        return +a === +b;
      case "[object Symbol]":
        return typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);
      case "[object Map]":
      case "[object Set]":
        if (depth >= 0) {
          depth++;
        }
        break;
    }
    a = unwrap(a);
    b = unwrap(b);
    var areArrays = className === "[object Array]";
    if (!areArrays) {
      if (typeof a != "object" || typeof b != "object") {
        return false;
      }
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) {
        return false;
      }
    }
    if (depth === 0) {
      return false;
    } else if (depth < 0) {
      depth = -1;
    }
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      if (aStack[length] === a) {
        return bStack[length] === b;
      }
    }
    aStack.push(a);
    bStack.push(b);
    if (areArrays) {
      length = a.length;
      if (length !== b.length) {
        return false;
      }
      while (length--) {
        if (!eq(a[length], b[length], depth - 1, aStack, bStack)) {
          return false;
        }
      }
    } else {
      var keys2 = Object.keys(a);
      var key;
      length = keys2.length;
      if (Object.keys(b).length !== length) {
        return false;
      }
      while (length--) {
        key = keys2[length];
        if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) {
          return false;
        }
      }
    }
    aStack.pop();
    bStack.pop();
    return true;
  };
  var unwrap = function(a) {
    if (isObservableArray(a)) {
      return a.slice();
    }
    if (isES6Map(a) || isObservableMap(a)) {
      return Array.from(a.entries());
    }
    if (isES6Set(a) || isObservableSet(a)) {
      return Array.from(a.entries());
    }
    return a;
  };
  var makeIterable = function(iterator) {
    iterator[Symbol.iterator] = getSelf;
    return iterator;
  };
  var getSelf = function() {
    return this;
  };
  var isAnnotation = function(thing) {
    return thing instanceof Object && typeof thing.annotationType_ === "string" && isFunction(thing.make_) && isFunction(thing.extend_);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var niceErrors = {
    0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
    1: function _(annotationType, key) {
      return "Cannot apply '" + annotationType + "' to '" + key.toString() + "': Field not found.";
    },
    5: "'keys()' can only be used on observable objects, arrays, sets and maps",
    6: "'values()' can only be used on observable objects, arrays, sets and maps",
    7: "'entries()' can only be used on observable objects, arrays and maps",
    8: "'set()' can only be used on observable objects, arrays and maps",
    9: "'remove()' can only be used on observable objects, arrays and maps",
    10: "'has()' can only be used on observable objects, arrays and maps",
    11: "'get()' can only be used on observable objects, arrays and maps",
    12: "Invalid annotation",
    13: "Dynamic observable objects cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
    14: "Intercept handlers should return nothing or a change object",
    15: "Observable arrays cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
    16: "Modification exception: the internal structure of an observable array was changed.",
    17: function _(index, length) {
      return "[mobx.array] Index out of bounds, " + index + " is larger than " + length;
    },
    18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
    19: function _(other) {
      return "Cannot initialize from classes that inherit from Map: " + other.constructor.name;
    },
    20: function _(other) {
      return "Cannot initialize map from " + other;
    },
    21: function _(dataStructure) {
      return "Cannot convert to map from '" + dataStructure + "'";
    },
    22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
    23: "It is not possible to get index atoms from arrays",
    24: function _(thing) {
      return "Cannot obtain administration from " + thing;
    },
    25: function _(property, name) {
      return "the entry '" + property + "' does not exist in the observable map '" + name + "'";
    },
    26: "please specify a property",
    27: function _(property, name) {
      return "no observable property '" + property.toString() + "' found on the observable object '" + name + "'";
    },
    28: function _(thing) {
      return "Cannot obtain atom from " + thing;
    },
    29: "Expecting some object",
    30: "invalid action stack. did you forget to finish an action?",
    31: "missing option for computed: get",
    32: function _(name, derivation) {
      return "Cycle detected in computation " + name + ": " + derivation;
    },
    33: function _(name) {
      return "The setter of computed value '" + name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
    },
    34: function _(name) {
      return "[ComputedValue '" + name + "'] It is not possible to assign a new value to a computed value.";
    },
    35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
    36: "isolateGlobalState should be called before MobX is running any reactions",
    37: function _(method) {
      return "[mobx] `observableArray." + method + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + method + "()` instead";
    },
    38: "'ownKeys()' can only be used on observable objects",
    39: "'defineProperty()' can only be used on observable objects"
  };
  var errors = niceErrors;
  var mockGlobal = {};
  var assign = Object.assign;
  var getDescriptor = Object.getOwnPropertyDescriptor;
  var defineProperty = Object.defineProperty;
  var objectPrototype = Object.prototype;
  var EMPTY_ARRAY = [];
  Object.freeze(EMPTY_ARRAY);
  var EMPTY_OBJECT = {};
  Object.freeze(EMPTY_OBJECT);
  var hasProxy = typeof Proxy !== "undefined";
  var plainObjectString = Object.toString();
  var noop = function noop() {
  };
  var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
  var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {
    return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
  } : Object.getOwnPropertyNames;
  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {
    var res = {};
    ownKeys(target).forEach(function(key) {
      res[key] = getDescriptor(target, key);
    });
    return res;
  };
  var storedAnnotationsSymbol = Symbol("mobx-stored-annotations");
  var $mobx = Symbol("mobx administration");
  var Atom = function() {
    function Atom2(name_) {
      if (name_ === undefined) {
        name_ = "Atom@" + getNextId();
      }
      this.name_ = undefined;
      this.isPendingUnobservation_ = false;
      this.isBeingObserved_ = false;
      this.observers_ = new Set;
      this.diffValue_ = 0;
      this.lastAccessedBy_ = 0;
      this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
      this.onBOL = undefined;
      this.onBUOL = undefined;
      this.name_ = name_;
    }
    var _proto = Atom2.prototype;
    _proto.onBO = function onBO() {
      if (this.onBOL) {
        this.onBOL.forEach(function(listener) {
          return listener();
        });
      }
    };
    _proto.onBUO = function onBUO() {
      if (this.onBUOL) {
        this.onBUOL.forEach(function(listener) {
          return listener();
        });
      }
    };
    _proto.reportObserved = function reportObserved$1() {
      return reportObserved(this);
    };
    _proto.reportChanged = function reportChanged() {
      startBatch();
      propagateChanged(this);
      endBatch();
    };
    _proto.toString = function toString() {
      return this.name_;
    };
    return Atom2;
  }();
  var isAtom = createInstanceofPredicate("Atom", Atom);
  var comparer = {
    identity: identityComparer,
    structural: structuralComparer,
    default: defaultComparer,
    shallow: shallowComparer
  };
  var OVERRIDE = "override";
  var override = createDecoratorAnnotation({
    annotationType_: OVERRIDE,
    make_,
    extend_
  });
  var AUTO = "true";
  var autoAnnotation = createAutoAnnotation();
  var OBSERVABLE = "observable";
  var OBSERVABLE_REF = "observable.ref";
  var OBSERVABLE_SHALLOW = "observable.shallow";
  var OBSERVABLE_STRUCT = "observable.struct";
  var defaultCreateObservableOptions = {
    deep: true,
    name: undefined,
    defaultDecorator: undefined,
    proxy: true
  };
  Object.freeze(defaultCreateObservableOptions);
  var observableAnnotation = createObservableAnnotation(OBSERVABLE);
  var observableRefAnnotation = createObservableAnnotation(OBSERVABLE_REF, {
    enhancer: referenceEnhancer
  });
  var observableShallowAnnotation = createObservableAnnotation(OBSERVABLE_SHALLOW, {
    enhancer: shallowEnhancer
  });
  var observableStructAnnotation = createObservableAnnotation(OBSERVABLE_STRUCT, {
    enhancer: refStructEnhancer
  });
  var observableDecoratorAnnotation = createDecoratorAnnotation(observableAnnotation);
  Object.assign(createObservable, observableDecoratorAnnotation);
  var observableFactories = {
    box: function box(value, options) {
      var o = asCreateObservableOptions(options);
      return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
    },
    array: function array(initialValues, options) {
      var o = asCreateObservableOptions(options);
      return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
    },
    map: function map(initialValues, options) {
      var o = asCreateObservableOptions(options);
      return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
    },
    set: function set(initialValues, options) {
      var o = asCreateObservableOptions(options);
      return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
    },
    object: function object(props, decorators, options) {
      return extendObservable(globalState.useProxies === false || (options == null ? undefined : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
    },
    ref: createDecoratorAnnotation(observableRefAnnotation),
    shallow: createDecoratorAnnotation(observableShallowAnnotation),
    deep: observableDecoratorAnnotation,
    struct: createDecoratorAnnotation(observableStructAnnotation)
  };
  var observable = assign(createObservable, observableFactories);
  var COMPUTED = "computed";
  var COMPUTED_STRUCT = "computed.struct";
  var computedAnnotation = createComputedAnnotation(COMPUTED);
  var computedStructAnnotation = createComputedAnnotation(COMPUTED_STRUCT, {
    equals: comparer.structural
  });
  var computed = function computed(arg1, arg2) {
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, computedAnnotation);
    }
    if (isPlainObject(arg1)) {
      return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
    }
    {
      if (!isFunction(arg1)) {
        die("First argument to `computed` should be an expression.");
      }
      if (isFunction(arg2)) {
        die("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
      }
    }
    var opts = isPlainObject(arg2) ? arg2 : {};
    opts.get = arg1;
    opts.name || (opts.name = arg1.name || "");
    return new ComputedValue(opts);
  };
  Object.assign(computed, computedAnnotation);
  computed.struct = createDecoratorAnnotation(computedStructAnnotation);
  var _getDescriptor$config;
  var _getDescriptor;
  var currentActionId = 0;
  var nextActionId = 1;
  var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = getDescriptor(function() {
  }, "name")) == null ? undefined : _getDescriptor.configurable) != null ? _getDescriptor$config : false;
  var tmpNameDescriptor = {
    value: "action",
    configurable: true,
    writable: false,
    enumerable: false
  };
  var _Symbol$toPrimitive;
  var CREATE = "create";
  _Symbol$toPrimitive = Symbol.toPrimitive;
  var ObservableValue = function(_Atom) {
    _inheritsLoose(ObservableValue2, _Atom);
    function ObservableValue2(value, enhancer, name_, notifySpy, equals) {
      var _this;
      if (name_ === undefined) {
        name_ = "ObservableValue@" + getNextId();
      }
      if (notifySpy === undefined) {
        notifySpy = true;
      }
      if (equals === undefined) {
        equals = comparer["default"];
      }
      _this = _Atom.call(this, name_) || this;
      _this.enhancer = undefined;
      _this.name_ = undefined;
      _this.equals = undefined;
      _this.hasUnreportedChange_ = false;
      _this.interceptors_ = undefined;
      _this.changeListeners_ = undefined;
      _this.value_ = undefined;
      _this.dehancer = undefined;
      _this.enhancer = enhancer;
      _this.name_ = name_;
      _this.equals = equals;
      _this.value_ = enhancer(value, undefined, name_);
      if (notifySpy && isSpyEnabled()) {
        spyReport({
          type: CREATE,
          object: _assertThisInitialized(_this),
          observableKind: "value",
          debugObjectName: _this.name_,
          newValue: "" + _this.value_
        });
      }
      return _this;
    }
    var _proto = ObservableValue2.prototype;
    _proto.dehanceValue = function dehanceValue(value) {
      if (this.dehancer !== undefined) {
        return this.dehancer(value);
      }
      return value;
    };
    _proto.set = function set(newValue) {
      var oldValue = this.value_;
      newValue = this.prepareNewValue_(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notifySpy = isSpyEnabled();
        if (notifySpy) {
          spyReportStart({
            type: UPDATE,
            object: this,
            observableKind: "value",
            debugObjectName: this.name_,
            newValue,
            oldValue
          });
        }
        this.setNewValue_(newValue);
        if (notifySpy) {
          spyReportEnd();
        }
      }
    };
    _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
      checkIfStateModificationsAreAllowed(this);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this,
          type: UPDATE,
          newValue
        });
        if (!change) {
          return globalState.UNCHANGED;
        }
        newValue = change.newValue;
      }
      newValue = this.enhancer(newValue, this.value_, this.name_);
      return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
    };
    _proto.setNewValue_ = function setNewValue_(newValue) {
      var oldValue = this.value_;
      this.value_ = newValue;
      this.reportChanged();
      if (hasListeners(this)) {
        notifyListeners(this, {
          type: UPDATE,
          object: this,
          newValue,
          oldValue
        });
      }
    };
    _proto.get = function get() {
      this.reportObserved();
      return this.dehanceValue(this.value_);
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      if (fireImmediately) {
        listener({
          observableKind: "value",
          debugObjectName: this.name_,
          object: this,
          type: UPDATE,
          newValue: this.value_,
          oldValue: undefined
        });
      }
      return registerListener(this, listener);
    };
    _proto.raw = function raw() {
      return this.value_;
    };
    _proto.toJSON = function toJSON() {
      return this.get();
    };
    _proto.toString = function toString() {
      return this.name_ + "[" + this.value_ + "]";
    };
    _proto.valueOf = function valueOf() {
      return toPrimitive(this.get());
    };
    _proto[_Symbol$toPrimitive] = function() {
      return this.valueOf();
    };
    return ObservableValue2;
  }(Atom);
  var isObservableValue = createInstanceofPredicate("ObservableValue", ObservableValue);
  var _Symbol$toPrimitive$1;
  _Symbol$toPrimitive$1 = Symbol.toPrimitive;
  var ComputedValue = function() {
    function ComputedValue2(options) {
      this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
      this.observing_ = [];
      this.newObserving_ = null;
      this.isBeingObserved_ = false;
      this.isPendingUnobservation_ = false;
      this.observers_ = new Set;
      this.diffValue_ = 0;
      this.runId_ = 0;
      this.lastAccessedBy_ = 0;
      this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
      this.unboundDepsCount_ = 0;
      this.value_ = new CaughtException(null);
      this.name_ = undefined;
      this.triggeredBy_ = undefined;
      this.isComputing_ = false;
      this.isRunningSetter_ = false;
      this.derivation = undefined;
      this.setter_ = undefined;
      this.isTracing_ = TraceMode.NONE;
      this.scope_ = undefined;
      this.equals_ = undefined;
      this.requiresReaction_ = undefined;
      this.keepAlive_ = undefined;
      this.onBOL = undefined;
      this.onBUOL = undefined;
      if (!options.get) {
        die(31);
      }
      this.derivation = options.get;
      this.name_ = options.name || "ComputedValue@" + getNextId();
      if (options.set) {
        this.setter_ = createAction(this.name_ + "-setter", options.set);
      }
      this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
      this.scope_ = options.context;
      this.requiresReaction_ = options.requiresReaction;
      this.keepAlive_ = !!options.keepAlive;
    }
    var _proto = ComputedValue2.prototype;
    _proto.onBecomeStale_ = function onBecomeStale_() {
      propagateMaybeChanged(this);
    };
    _proto.onBO = function onBO() {
      if (this.onBOL) {
        this.onBOL.forEach(function(listener) {
          return listener();
        });
      }
    };
    _proto.onBUO = function onBUO() {
      if (this.onBUOL) {
        this.onBUOL.forEach(function(listener) {
          return listener();
        });
      }
    };
    _proto.get = function get() {
      if (this.isComputing_) {
        die(32, this.name_, this.derivation);
      }
      if (globalState.inBatch === 0 && this.observers_.size === 0 && !this.keepAlive_) {
        if (shouldCompute(this)) {
          this.warnAboutUntrackedRead_();
          startBatch();
          this.value_ = this.computeValue_(false);
          endBatch();
        }
      } else {
        reportObserved(this);
        if (shouldCompute(this)) {
          var prevTrackingContext = globalState.trackingContext;
          if (this.keepAlive_ && !prevTrackingContext) {
            globalState.trackingContext = this;
          }
          if (this.trackAndCompute()) {
            propagateChangeConfirmed(this);
          }
          globalState.trackingContext = prevTrackingContext;
        }
      }
      var result = this.value_;
      if (isCaughtException(result)) {
        throw result.cause;
      }
      return result;
    };
    _proto.set = function set(value) {
      if (this.setter_) {
        if (this.isRunningSetter_) {
          die(33, this.name_);
        }
        this.isRunningSetter_ = true;
        try {
          this.setter_.call(this.scope_, value);
        } finally {
          this.isRunningSetter_ = false;
        }
      } else {
        die(34, this.name_);
      }
    };
    _proto.trackAndCompute = function trackAndCompute() {
      var oldValue = this.value_;
      var wasSuspended = this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;
      var newValue = this.computeValue_(true);
      var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
      if (changed) {
        this.value_ = newValue;
        if (isSpyEnabled()) {
          spyReport({
            observableKind: "computed",
            debugObjectName: this.name_,
            object: this.scope_,
            type: "update",
            oldValue,
            newValue
          });
        }
      }
      return changed;
    };
    _proto.computeValue_ = function computeValue_(track) {
      this.isComputing_ = true;
      var prev = allowStateChangesStart(false);
      var res;
      if (track) {
        res = trackDerivedFunction(this, this.derivation, this.scope_);
      } else {
        if (globalState.disableErrorBoundaries === true) {
          res = this.derivation.call(this.scope_);
        } else {
          try {
            res = this.derivation.call(this.scope_);
          } catch (e) {
            res = new CaughtException(e);
          }
        }
      }
      allowStateChangesEnd(prev);
      this.isComputing_ = false;
      return res;
    };
    _proto.suspend_ = function suspend_() {
      if (!this.keepAlive_) {
        clearObserving(this);
        this.value_ = undefined;
        if (this.isTracing_ !== TraceMode.NONE) {
          console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access.");
        }
      }
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      var _this = this;
      var firstTime = true;
      var prevValue = undefined;
      return autorun(function() {
        var newValue = _this.get();
        if (!firstTime || fireImmediately) {
          var prevU = untrackedStart();
          listener({
            observableKind: "computed",
            debugObjectName: _this.name_,
            type: UPDATE,
            object: _this,
            newValue,
            oldValue: prevValue
          });
          untrackedEnd(prevU);
        }
        firstTime = false;
        prevValue = newValue;
      });
    };
    _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
      if (this.isTracing_ !== TraceMode.NONE) {
        console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
      }
      if (typeof this.requiresReaction_ === "boolean" ? this.requiresReaction_ : globalState.computedRequiresReaction) {
        console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
      }
    };
    _proto.toString = function toString() {
      return this.name_ + "[" + this.derivation.toString() + "]";
    };
    _proto.valueOf = function valueOf() {
      return toPrimitive(this.get());
    };
    _proto[_Symbol$toPrimitive$1] = function() {
      return this.valueOf();
    };
    return ComputedValue2;
  }();
  var isComputedValue = createInstanceofPredicate("ComputedValue", ComputedValue);
  var IDerivationState_;
  (function(IDerivationState_2) {
    IDerivationState_2[IDerivationState_2["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
    IDerivationState_2[IDerivationState_2["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
    IDerivationState_2[IDerivationState_2["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
    IDerivationState_2[IDerivationState_2["STALE_"] = 2] = "STALE_";
  })(IDerivationState_ || (IDerivationState_ = {}));
  var TraceMode;
  (function(TraceMode2) {
    TraceMode2[TraceMode2["NONE"] = 0] = "NONE";
    TraceMode2[TraceMode2["LOG"] = 1] = "LOG";
    TraceMode2[TraceMode2["BREAK"] = 2] = "BREAK";
  })(TraceMode || (TraceMode = {}));
  var CaughtException = function CaughtException(cause) {
    this.cause = undefined;
    this.cause = cause;
  };
  var persistentKeys = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"];
  var MobXGlobals = function MobXGlobals() {
    this.version = 6;
    this.UNCHANGED = {};
    this.trackingDerivation = null;
    this.trackingContext = null;
    this.runId = 0;
    this.mobxGuid = 0;
    this.inBatch = 0;
    this.pendingUnobservations = [];
    this.pendingReactions = [];
    this.isRunningReactions = false;
    this.allowStateChanges = false;
    this.allowStateReads = true;
    this.enforceActions = true;
    this.spyListeners = [];
    this.globalReactionErrorHandlers = [];
    this.computedRequiresReaction = false;
    this.reactionRequiresObservable = false;
    this.observableRequiresReaction = false;
    this.disableErrorBoundaries = false;
    this.suppressReactionErrors = false;
    this.useProxies = true;
    this.verifyProxies = false;
    this.safeDescriptors = true;
  };
  var canMergeGlobalState = true;
  var isolateCalled = false;
  var globalState = function() {
    var global2 = getGlobal();
    if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals) {
      canMergeGlobalState = false;
    }
    if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version) {
      canMergeGlobalState = false;
    }
    if (!canMergeGlobalState) {
      setTimeout(function() {
        if (!isolateCalled) {
          die(35);
        }
      }, 1);
      return new MobXGlobals;
    } else if (global2.__mobxGlobals) {
      global2.__mobxInstanceCount += 1;
      if (!global2.__mobxGlobals.UNCHANGED) {
        global2.__mobxGlobals.UNCHANGED = {};
      }
      return global2.__mobxGlobals;
    } else {
      global2.__mobxInstanceCount = 1;
      return global2.__mobxGlobals = new MobXGlobals;
    }
  }();
  var Reaction = function() {
    function Reaction2(name_, onInvalidate_, errorHandler_, requiresObservable_) {
      if (name_ === undefined) {
        name_ = "Reaction@" + getNextId();
      }
      this.name_ = undefined;
      this.onInvalidate_ = undefined;
      this.errorHandler_ = undefined;
      this.requiresObservable_ = undefined;
      this.observing_ = [];
      this.newObserving_ = [];
      this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
      this.diffValue_ = 0;
      this.runId_ = 0;
      this.unboundDepsCount_ = 0;
      this.isDisposed_ = false;
      this.isScheduled_ = false;
      this.isTrackPending_ = false;
      this.isRunning_ = false;
      this.isTracing_ = TraceMode.NONE;
      this.name_ = name_;
      this.onInvalidate_ = onInvalidate_;
      this.errorHandler_ = errorHandler_;
      this.requiresObservable_ = requiresObservable_;
    }
    var _proto = Reaction2.prototype;
    _proto.onBecomeStale_ = function onBecomeStale_() {
      this.schedule_();
    };
    _proto.schedule_ = function schedule_() {
      if (!this.isScheduled_) {
        this.isScheduled_ = true;
        globalState.pendingReactions.push(this);
        runReactions();
      }
    };
    _proto.isScheduled = function isScheduled() {
      return this.isScheduled_;
    };
    _proto.runReaction_ = function runReaction_() {
      if (!this.isDisposed_) {
        startBatch();
        this.isScheduled_ = false;
        var prev = globalState.trackingContext;
        globalState.trackingContext = this;
        if (shouldCompute(this)) {
          this.isTrackPending_ = true;
          try {
            this.onInvalidate_();
            if (this.isTrackPending_ && isSpyEnabled()) {
              spyReport({
                name: this.name_,
                type: "scheduled-reaction"
              });
            }
          } catch (e) {
            this.reportExceptionInDerivation_(e);
          }
        }
        globalState.trackingContext = prev;
        endBatch();
      }
    };
    _proto.track = function track(fn) {
      if (this.isDisposed_) {
        return;
      }
      startBatch();
      var notify = isSpyEnabled();
      var startTime;
      if (notify) {
        startTime = Date.now();
        spyReportStart({
          name: this.name_,
          type: "reaction"
        });
      }
      this.isRunning_ = true;
      var prevReaction = globalState.trackingContext;
      globalState.trackingContext = this;
      var result = trackDerivedFunction(this, fn, undefined);
      globalState.trackingContext = prevReaction;
      this.isRunning_ = false;
      this.isTrackPending_ = false;
      if (this.isDisposed_) {
        clearObserving(this);
      }
      if (isCaughtException(result)) {
        this.reportExceptionInDerivation_(result.cause);
      }
      if (notify) {
        spyReportEnd({
          time: Date.now() - startTime
        });
      }
      endBatch();
    };
    _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
      var _this = this;
      if (this.errorHandler_) {
        this.errorHandler_(error, this);
        return;
      }
      if (globalState.disableErrorBoundaries) {
        throw error;
      }
      var message = "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'";
      if (!globalState.suppressReactionErrors) {
        console.error(message, error);
      } else {
        console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)");
      }
      if (isSpyEnabled()) {
        spyReport({
          type: "error",
          name: this.name_,
          message,
          error: "" + error
        });
      }
      globalState.globalReactionErrorHandlers.forEach(function(f) {
        return f(error, _this);
      });
    };
    _proto.dispose = function dispose() {
      if (!this.isDisposed_) {
        this.isDisposed_ = true;
        if (!this.isRunning_) {
          startBatch();
          clearObserving(this);
          endBatch();
        }
      }
    };
    _proto.getDisposer_ = function getDisposer_() {
      var r = this.dispose.bind(this);
      r[$mobx] = this;
      return r;
    };
    _proto.toString = function toString() {
      return "Reaction[" + this.name_ + "]";
    };
    _proto.trace = function trace$1(enterBreakPoint) {
      if (enterBreakPoint === undefined) {
        enterBreakPoint = false;
      }
      trace(this, enterBreakPoint);
    };
    return Reaction2;
  }();
  var MAX_REACTION_ITERATIONS = 100;
  var reactionScheduler = function reactionScheduler(f) {
    return f();
  };
  var isReaction = createInstanceofPredicate("Reaction", Reaction);
  var END_EVENT = {
    type: "report-end",
    spyReportEnd: true
  };
  var ACTION = "action";
  var ACTION_BOUND = "action.bound";
  var AUTOACTION = "autoAction";
  var AUTOACTION_BOUND = "autoAction.bound";
  var DEFAULT_ACTION_NAME = "<unnamed action>";
  var actionAnnotation = createActionAnnotation(ACTION);
  var actionBoundAnnotation = createActionAnnotation(ACTION_BOUND, {
    bound: true
  });
  var autoActionAnnotation = createActionAnnotation(AUTOACTION, {
    autoAction: true
  });
  var autoActionBoundAnnotation = createActionAnnotation(AUTOACTION_BOUND, {
    autoAction: true,
    bound: true
  });
  var action = createActionFactory(false);
  Object.assign(action, actionAnnotation);
  var autoAction = createActionFactory(true);
  Object.assign(autoAction, autoActionAnnotation);
  action.bound = createDecoratorAnnotation(actionBoundAnnotation);
  autoAction.bound = createDecoratorAnnotation(autoActionBoundAnnotation);
  var run = function run(f) {
    return f();
  };
  var ON_BECOME_OBSERVED = "onBO";
  var ON_BECOME_UNOBSERVED = "onBUO";
  var NEVER = "never";
  var ALWAYS = "always";
  var OBSERVED = "observed";
  var generatorId = 0;
  FlowCancellationError.prototype = Object.create(Error.prototype);
  var flowAnnotation = createFlowAnnotation("flow");
  var flowBoundAnnotation = createFlowAnnotation("flow.bound", {
    bound: true
  });
  var flow = Object.assign(function flow(arg1, arg2) {
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, flowAnnotation);
    }
    if (arguments.length !== 1) {
      die("Flow expects single argument with generator function");
    }
    var generator = arg1;
    var name = generator.name || "<unnamed flow>";
    var res = function res() {
      var ctx = this;
      var args = arguments;
      var runId = ++generatorId;
      var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
      var rejector;
      var pendingPromise = undefined;
      var promise = new Promise(function(resolve2, reject2) {
        var stepId = 0;
        rejector = reject2;
        function onFulfilled(res2) {
          pendingPromise = undefined;
          var ret;
          try {
            ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res2);
          } catch (e) {
            return reject2(e);
          }
          next(ret);
        }
        function onRejected(err) {
          pendingPromise = undefined;
          var ret;
          try {
            ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
          } catch (e) {
            return reject2(e);
          }
          next(ret);
        }
        function next(ret) {
          if (isFunction(ret == null ? undefined : ret.then)) {
            ret.then(next, reject2);
            return;
          }
          if (ret.done) {
            return resolve2(ret.value);
          }
          pendingPromise = Promise.resolve(ret.value);
          return pendingPromise.then(onFulfilled, onRejected);
        }
        onFulfilled(undefined);
      });
      promise.cancel = action(name + " - runid: " + runId + " - cancel", function() {
        try {
          if (pendingPromise) {
            cancelPromise(pendingPromise);
          }
          var _res = gen["return"](undefined);
          var yieldedPromise = Promise.resolve(_res.value);
          yieldedPromise.then(noop, noop);
          cancelPromise(yieldedPromise);
          rejector(new FlowCancellationError);
        } catch (e) {
          rejector(e);
        }
      });
      return promise;
    };
    res.isMobXFlow = true;
    return res;
  }, flowAnnotation);
  flow.bound = createDecoratorAnnotation(flowBoundAnnotation);
  var objectProxyTraps = {
    has: function has(target, name) {
      if (globalState.trackingDerivation) {
        warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.");
      }
      return getAdm(target).has_(name);
    },
    get: function get(target, name) {
      return getAdm(target).get_(name);
    },
    set: function set(target, name, value) {
      var _getAdm$set_;
      if (!isStringish(name)) {
        return false;
      }
      if (!getAdm(target).values_.has(name)) {
        warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead.");
      }
      return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
    },
    deleteProperty: function deleteProperty(target, name) {
      var _getAdm$delete_;
      {
        warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead.");
      }
      if (!isStringish(name)) {
        return false;
      }
      return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
    },
    defineProperty: function defineProperty(target, name, descriptor) {
      var _getAdm$definePropert;
      {
        warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead.");
      }
      return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
    },
    ownKeys: function ownKeys(target) {
      if (globalState.trackingDerivation) {
        warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.");
      }
      return getAdm(target).ownKeys_();
    },
    preventExtensions: function preventExtensions(target) {
      die(13);
    }
  };
  var keysSymbol = Symbol("mobx-keys");
  var SPLICE = "splice";
  var UPDATE = "update";
  var MAX_SPLICE_SIZE = 1e4;
  var arrayTraps = {
    get: function get(target, name) {
      var adm = target[$mobx];
      if (name === $mobx) {
        return adm;
      }
      if (name === "length") {
        return adm.getArrayLength_();
      }
      if (typeof name === "string" && !isNaN(name)) {
        return adm.get_(parseInt(name));
      }
      if (hasProp(arrayExtensions, name)) {
        return arrayExtensions[name];
      }
      return target[name];
    },
    set: function set(target, name, value) {
      var adm = target[$mobx];
      if (name === "length") {
        adm.setArrayLength_(value);
      }
      if (typeof name === "symbol" || isNaN(name)) {
        target[name] = value;
      } else {
        adm.set_(parseInt(name), value);
      }
      return true;
    },
    preventExtensions: function preventExtensions() {
      die(15);
    }
  };
  var ObservableArrayAdministration = function() {
    function ObservableArrayAdministration2(name, enhancer, owned_, legacyMode_) {
      if (name === undefined) {
        name = "ObservableArray@" + getNextId();
      }
      this.owned_ = undefined;
      this.legacyMode_ = undefined;
      this.atom_ = undefined;
      this.values_ = [];
      this.interceptors_ = undefined;
      this.changeListeners_ = undefined;
      this.enhancer_ = undefined;
      this.dehancer = undefined;
      this.proxy_ = undefined;
      this.lastKnownLength_ = 0;
      this.owned_ = owned_;
      this.legacyMode_ = legacyMode_;
      this.atom_ = new Atom(name);
      this.enhancer_ = function(newV, oldV) {
        return enhancer(newV, oldV, name + "[..]");
      };
    }
    var _proto = ObservableArrayAdministration2.prototype;
    _proto.dehanceValue_ = function dehanceValue_(value) {
      if (this.dehancer !== undefined) {
        return this.dehancer(value);
      }
      return value;
    };
    _proto.dehanceValues_ = function dehanceValues_(values2) {
      if (this.dehancer !== undefined && values2.length > 0) {
        return values2.map(this.dehancer);
      }
      return values2;
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      if (fireImmediately === undefined) {
        fireImmediately = false;
      }
      if (fireImmediately) {
        listener({
          observableKind: "array",
          object: this.proxy_,
          debugObjectName: this.atom_.name_,
          type: "splice",
          index: 0,
          added: this.values_.slice(),
          addedCount: this.values_.length,
          removed: [],
          removedCount: 0
        });
      }
      return registerListener(this, listener);
    };
    _proto.getArrayLength_ = function getArrayLength_() {
      this.atom_.reportObserved();
      return this.values_.length;
    };
    _proto.setArrayLength_ = function setArrayLength_(newLength) {
      if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0) {
        die("Out of range: " + newLength);
      }
      var currentLength = this.values_.length;
      if (newLength === currentLength) {
        return;
      } else if (newLength > currentLength) {
        var newItems = new Array(newLength - currentLength);
        for (var i = 0;i < newLength - currentLength; i++) {
          newItems[i] = undefined;
        }
        this.spliceWithArray_(currentLength, 0, newItems);
      } else {
        this.spliceWithArray_(newLength, currentLength - newLength);
      }
    };
    _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
      if (oldLength !== this.lastKnownLength_) {
        die(16);
      }
      this.lastKnownLength_ += delta;
      if (this.legacyMode_ && delta > 0) {
        reserveArrayBuffer(oldLength + delta + 1);
      }
    };
    _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {
      var _this = this;
      checkIfStateModificationsAreAllowed(this.atom_);
      var length = this.values_.length;
      if (index === undefined) {
        index = 0;
      } else if (index > length) {
        index = length;
      } else if (index < 0) {
        index = Math.max(0, length + index);
      }
      if (arguments.length === 1) {
        deleteCount = length - index;
      } else if (deleteCount === undefined || deleteCount === null) {
        deleteCount = 0;
      } else {
        deleteCount = Math.max(0, Math.min(deleteCount, length - index));
      }
      if (newItems === undefined) {
        newItems = EMPTY_ARRAY;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_,
          type: SPLICE,
          index,
          removedCount: deleteCount,
          added: newItems
        });
        if (!change) {
          return EMPTY_ARRAY;
        }
        deleteCount = change.removedCount;
        newItems = change.added;
      }
      newItems = newItems.length === 0 ? newItems : newItems.map(function(v) {
        return _this.enhancer_(v, undefined);
      });
      if (this.legacyMode_ || true) {
        var lengthDelta = newItems.length - deleteCount;
        this.updateArrayLength_(length, lengthDelta);
      }
      var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);
      if (deleteCount !== 0 || newItems.length !== 0) {
        this.notifyArraySplice_(index, newItems, res);
      }
      return this.dehanceValues_(res);
    };
    _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {
      if (newItems.length < MAX_SPLICE_SIZE) {
        var _this$values_;
        return (_this$values_ = this.values_).splice.apply(_this$values_, [index, deleteCount].concat(newItems));
      } else {
        var res = this.values_.slice(index, index + deleteCount);
        var oldItems = this.values_.slice(index + deleteCount);
        this.values_.length += newItems.length - deleteCount;
        for (var i = 0;i < newItems.length; i++) {
          this.values_[index + i] = newItems[i];
        }
        for (var _i = 0;_i < oldItems.length; _i++) {
          this.values_[index + newItems.length + _i] = oldItems[_i];
        }
        return res;
      }
    };
    _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {
      var notifySpy = !this.owned_ && isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "array",
        object: this.proxy_,
        type: UPDATE,
        debugObjectName: this.atom_.name_,
        index,
        newValue,
        oldValue
      } : null;
      if (notifySpy) {
        spyReportStart(change);
      }
      this.atom_.reportChanged();
      if (notify) {
        notifyListeners(this, change);
      }
      if (notifySpy) {
        spyReportEnd();
      }
    };
    _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {
      var notifySpy = !this.owned_ && isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: SPLICE,
        index,
        removed,
        added,
        removedCount: removed.length,
        addedCount: added.length
      } : null;
      if (notifySpy) {
        spyReportStart(change);
      }
      this.atom_.reportChanged();
      if (notify) {
        notifyListeners(this, change);
      }
      if (notifySpy) {
        spyReportEnd();
      }
    };
    _proto.get_ = function get_(index) {
      if (index < this.values_.length) {
        this.atom_.reportObserved();
        return this.dehanceValue_(this.values_[index]);
      }
      console.warn("[mobx] Out of bounds read: " + index);
    };
    _proto.set_ = function set_(index, newValue) {
      var values2 = this.values_;
      if (index < values2.length) {
        checkIfStateModificationsAreAllowed(this.atom_);
        var oldValue = values2[index];
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            type: UPDATE,
            object: this.proxy_,
            index,
            newValue
          });
          if (!change) {
            return;
          }
          newValue = change.newValue;
        }
        newValue = this.enhancer_(newValue, oldValue);
        var changed = newValue !== oldValue;
        if (changed) {
          values2[index] = newValue;
          this.notifyArrayChildUpdate_(index, newValue, oldValue);
        }
      } else if (index === values2.length) {
        this.spliceWithArray_(index, 0, [newValue]);
      } else {
        die(17, index, values2.length);
      }
    };
    return ObservableArrayAdministration2;
  }();
  var arrayExtensions = {
    clear: function clear() {
      return this.splice(0);
    },
    replace: function replace(newItems) {
      var adm = this[$mobx];
      return adm.spliceWithArray_(0, adm.values_.length, newItems);
    },
    toJSON: function toJSON() {
      return this.slice();
    },
    splice: function splice(index, deleteCount) {
      for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2;_key < _len; _key++) {
        newItems[_key - 2] = arguments[_key];
      }
      var adm = this[$mobx];
      switch (arguments.length) {
        case 0:
          return [];
        case 1:
          return adm.spliceWithArray_(index);
        case 2:
          return adm.spliceWithArray_(index, deleteCount);
      }
      return adm.spliceWithArray_(index, deleteCount, newItems);
    },
    spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {
      return this[$mobx].spliceWithArray_(index, deleteCount, newItems);
    },
    push: function push() {
      var adm = this[$mobx];
      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0;_key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }
      adm.spliceWithArray_(adm.values_.length, 0, items);
      return adm.values_.length;
    },
    pop: function pop() {
      return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
    },
    shift: function shift() {
      return this.splice(0, 1)[0];
    },
    unshift: function unshift() {
      var adm = this[$mobx];
      for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0;_key3 < _len3; _key3++) {
        items[_key3] = arguments[_key3];
      }
      adm.spliceWithArray_(0, 0, items);
      return adm.values_.length;
    },
    reverse: function reverse() {
      if (globalState.trackingDerivation) {
        die(37, "reverse");
      }
      this.replace(this.slice().reverse());
      return this;
    },
    sort: function sort() {
      if (globalState.trackingDerivation) {
        die(37, "sort");
      }
      var copy = this.slice();
      copy.sort.apply(copy, arguments);
      this.replace(copy);
      return this;
    },
    remove: function remove(value) {
      var adm = this[$mobx];
      var idx = adm.dehanceValues_(adm.values_).indexOf(value);
      if (idx > -1) {
        this.splice(idx, 1);
        return true;
      }
      return false;
    }
  };
  addArrayExtension("concat", simpleFunc);
  addArrayExtension("flat", simpleFunc);
  addArrayExtension("includes", simpleFunc);
  addArrayExtension("indexOf", simpleFunc);
  addArrayExtension("join", simpleFunc);
  addArrayExtension("lastIndexOf", simpleFunc);
  addArrayExtension("slice", simpleFunc);
  addArrayExtension("toString", simpleFunc);
  addArrayExtension("toLocaleString", simpleFunc);
  addArrayExtension("every", mapLikeFunc);
  addArrayExtension("filter", mapLikeFunc);
  addArrayExtension("find", mapLikeFunc);
  addArrayExtension("findIndex", mapLikeFunc);
  addArrayExtension("flatMap", mapLikeFunc);
  addArrayExtension("forEach", mapLikeFunc);
  addArrayExtension("map", mapLikeFunc);
  addArrayExtension("some", mapLikeFunc);
  addArrayExtension("reduce", reduceLikeFunc);
  addArrayExtension("reduceRight", reduceLikeFunc);
  var isObservableArrayAdministration = createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
  var _Symbol$iterator;
  var _Symbol$toStringTag;
  var ObservableMapMarker = {};
  var ADD = "add";
  var DELETE = "delete";
  _Symbol$iterator = Symbol.iterator;
  _Symbol$toStringTag = Symbol.toStringTag;
  var ObservableMap = function() {
    function ObservableMap2(initialData, enhancer_, name_) {
      var _this = this;
      if (enhancer_ === undefined) {
        enhancer_ = deepEnhancer;
      }
      if (name_ === undefined) {
        name_ = "ObservableMap@" + getNextId();
      }
      this.enhancer_ = undefined;
      this.name_ = undefined;
      this[$mobx] = ObservableMapMarker;
      this.data_ = undefined;
      this.hasMap_ = undefined;
      this.keysAtom_ = undefined;
      this.interceptors_ = undefined;
      this.changeListeners_ = undefined;
      this.dehancer = undefined;
      this.enhancer_ = enhancer_;
      this.name_ = name_;
      if (!isFunction(Map)) {
        die(18);
      }
      this.keysAtom_ = createAtom(this.name_ + ".keys()");
      this.data_ = new Map;
      this.hasMap_ = new Map;
      allowStateChanges(true, function() {
        _this.merge(initialData);
      });
    }
    var _proto = ObservableMap2.prototype;
    _proto.has_ = function has_(key) {
      return this.data_.has(key);
    };
    _proto.has = function has(key) {
      var _this2 = this;
      if (!globalState.trackingDerivation) {
        return this.has_(key);
      }
      var entry = this.hasMap_.get(key);
      if (!entry) {
        var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer, this.name_ + "." + stringifyKey(key) + "?", false);
        this.hasMap_.set(key, newEntry);
        onBecomeUnobserved(newEntry, function() {
          return _this2.hasMap_["delete"](key);
        });
      }
      return entry.get();
    };
    _proto.set = function set(key, value) {
      var hasKey = this.has_(key);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: hasKey ? UPDATE : ADD,
          object: this,
          newValue: value,
          name: key
        });
        if (!change) {
          return this;
        }
        value = change.newValue;
      }
      if (hasKey) {
        this.updateValue_(key, value);
      } else {
        this.addValue_(key, value);
      }
      return this;
    };
    _proto["delete"] = function _delete(key) {
      var _this3 = this;
      checkIfStateModificationsAreAllowed(this.keysAtom_);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: DELETE,
          object: this,
          name: key
        });
        if (!change) {
          return false;
        }
      }
      if (this.has_(key)) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var _change = notify || notifySpy ? {
          observableKind: "map",
          debugObjectName: this.name_,
          type: DELETE,
          object: this,
          oldValue: this.data_.get(key).value_,
          name: key
        } : null;
        if (notifySpy) {
          spyReportStart(_change);
        }
        transaction(function() {
          var _this3$hasMap_$get;
          _this3.keysAtom_.reportChanged();
          (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null || _this3$hasMap_$get.setNewValue_(false);
          var observable2 = _this3.data_.get(key);
          observable2.setNewValue_(undefined);
          _this3.data_["delete"](key);
        });
        if (notify) {
          notifyListeners(this, _change);
        }
        if (notifySpy) {
          spyReportEnd();
        }
        return true;
      }
      return false;
    };
    _proto.updateValue_ = function updateValue_(key, newValue) {
      var observable2 = this.data_.get(key);
      newValue = observable2.prepareNewValue_(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
          observableKind: "map",
          debugObjectName: this.name_,
          type: UPDATE,
          object: this,
          oldValue: observable2.value_,
          name: key,
          newValue
        } : null;
        if (notifySpy) {
          spyReportStart(change);
        }
        observable2.setNewValue_(newValue);
        if (notify) {
          notifyListeners(this, change);
        }
        if (notifySpy) {
          spyReportEnd();
        }
      }
    };
    _proto.addValue_ = function addValue_(key, newValue) {
      var _this4 = this;
      checkIfStateModificationsAreAllowed(this.keysAtom_);
      transaction(function() {
        var _this4$hasMap_$get;
        var observable2 = new ObservableValue(newValue, _this4.enhancer_, _this4.name_ + "." + stringifyKey(key), false);
        _this4.data_.set(key, observable2);
        newValue = observable2.value_;
        (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null || _this4$hasMap_$get.setNewValue_(true);
        _this4.keysAtom_.reportChanged();
      });
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        name: key,
        newValue
      } : null;
      if (notifySpy) {
        spyReportStart(change);
      }
      if (notify) {
        notifyListeners(this, change);
      }
      if (notifySpy) {
        spyReportEnd();
      }
    };
    _proto.get = function get(key) {
      if (this.has(key)) {
        return this.dehanceValue_(this.data_.get(key).get());
      }
      return this.dehanceValue_(undefined);
    };
    _proto.dehanceValue_ = function dehanceValue_(value) {
      if (this.dehancer !== undefined) {
        return this.dehancer(value);
      }
      return value;
    };
    _proto.keys = function keys() {
      this.keysAtom_.reportObserved();
      return this.data_.keys();
    };
    _proto.values = function values() {
      var self2 = this;
      var keys2 = this.keys();
      return makeIterable({
        next: function next() {
          var _keys$next = keys2.next(), done = _keys$next.done, value = _keys$next.value;
          return {
            done,
            value: done ? undefined : self2.get(value)
          };
        }
      });
    };
    _proto.entries = function entries() {
      var self2 = this;
      var keys2 = this.keys();
      return makeIterable({
        next: function next() {
          var _keys$next2 = keys2.next(), done = _keys$next2.done, value = _keys$next2.value;
          return {
            done,
            value: done ? undefined : [value, self2.get(value)]
          };
        }
      });
    };
    _proto[_Symbol$iterator] = function() {
      return this.entries();
    };
    _proto.forEach = function forEach(callback, thisArg) {
      for (var _iterator = _createForOfIteratorHelperLoose(this), _step;!(_step = _iterator()).done; ) {
        var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
        callback.call(thisArg, value, key, this);
      }
    };
    _proto.merge = function merge(other) {
      var _this5 = this;
      if (isObservableMap(other)) {
        other = new Map(other);
      }
      transaction(function() {
        if (isPlainObject(other)) {
          getPlainObjectKeys(other).forEach(function(key) {
            return _this5.set(key, other[key]);
          });
        } else if (Array.isArray(other)) {
          other.forEach(function(_ref) {
            var key = _ref[0], value = _ref[1];
            return _this5.set(key, value);
          });
        } else if (isES6Map(other)) {
          if (other.constructor !== Map) {
            die(19, other);
          }
          other.forEach(function(value, key) {
            return _this5.set(key, value);
          });
        } else if (other !== null && other !== undefined) {
          die(20, other);
        }
      });
      return this;
    };
    _proto.clear = function clear() {
      var _this6 = this;
      transaction(function() {
        untracked(function() {
          for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2;!(_step2 = _iterator2()).done; ) {
            var key = _step2.value;
            _this6["delete"](key);
          }
        });
      });
    };
    _proto.replace = function replace(values2) {
      var _this7 = this;
      transaction(function() {
        var replacementMap = convertToMap(values2);
        var orderedData = new Map;
        var keysReportChangedCalled = false;
        for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3;!(_step3 = _iterator3()).done; ) {
          var key = _step3.value;
          if (!replacementMap.has(key)) {
            var deleted = _this7["delete"](key);
            if (deleted) {
              keysReportChangedCalled = true;
            } else {
              var value = _this7.data_.get(key);
              orderedData.set(key, value);
            }
          }
        }
        for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4;!(_step4 = _iterator4()).done; ) {
          var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];
          var keyExisted = _this7.data_.has(_key);
          _this7.set(_key, _value);
          if (_this7.data_.has(_key)) {
            var _value2 = _this7.data_.get(_key);
            orderedData.set(_key, _value2);
            if (!keyExisted) {
              keysReportChangedCalled = true;
            }
          }
        }
        if (!keysReportChangedCalled) {
          if (_this7.data_.size !== orderedData.size) {
            _this7.keysAtom_.reportChanged();
          } else {
            var iter1 = _this7.data_.keys();
            var iter2 = orderedData.keys();
            var next1 = iter1.next();
            var next2 = iter2.next();
            while (!next1.done) {
              if (next1.value !== next2.value) {
                _this7.keysAtom_.reportChanged();
                break;
              }
              next1 = iter1.next();
              next2 = iter2.next();
            }
          }
        }
        _this7.data_ = orderedData;
      });
      return this;
    };
    _proto.toString = function toString() {
      return "[object ObservableMap]";
    };
    _proto.toJSON = function toJSON() {
      return Array.from(this);
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      if (fireImmediately === true) {
        die("`observe` doesn't support fireImmediately=true in combination with maps.");
      }
      return registerListener(this, listener);
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _createClass(ObservableMap2, [{
      key: "size",
      get: function get() {
        this.keysAtom_.reportObserved();
        return this.data_.size;
      }
    }, {
      key: _Symbol$toStringTag,
      get: function get() {
        return "Map";
      }
    }]);
    return ObservableMap2;
  }();
  var isObservableMap = createInstanceofPredicate("ObservableMap", ObservableMap);
  var _Symbol$iterator$1;
  var _Symbol$toStringTag$1;
  var ObservableSetMarker = {};
  _Symbol$iterator$1 = Symbol.iterator;
  _Symbol$toStringTag$1 = Symbol.toStringTag;
  var ObservableSet = function() {
    function ObservableSet2(initialData, enhancer, name_) {
      if (enhancer === undefined) {
        enhancer = deepEnhancer;
      }
      if (name_ === undefined) {
        name_ = "ObservableSet@" + getNextId();
      }
      this.name_ = undefined;
      this[$mobx] = ObservableSetMarker;
      this.data_ = new Set;
      this.atom_ = undefined;
      this.changeListeners_ = undefined;
      this.interceptors_ = undefined;
      this.dehancer = undefined;
      this.enhancer_ = undefined;
      this.name_ = name_;
      if (!isFunction(Set)) {
        die(22);
      }
      this.atom_ = createAtom(this.name_);
      this.enhancer_ = function(newV, oldV) {
        return enhancer(newV, oldV, name_);
      };
      if (initialData) {
        this.replace(initialData);
      }
    }
    var _proto = ObservableSet2.prototype;
    _proto.dehanceValue_ = function dehanceValue_(value) {
      if (this.dehancer !== undefined) {
        return this.dehancer(value);
      }
      return value;
    };
    _proto.clear = function clear() {
      var _this = this;
      transaction(function() {
        untracked(function() {
          for (var _iterator = _createForOfIteratorHelperLoose(_this.data_.values()), _step;!(_step = _iterator()).done; ) {
            var value = _step.value;
            _this["delete"](value);
          }
        });
      });
    };
    _proto.forEach = function forEach(callbackFn, thisArg) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2;!(_step2 = _iterator2()).done; ) {
        var value = _step2.value;
        callbackFn.call(thisArg, value, value, this);
      }
    };
    _proto.add = function add(value) {
      var _this2 = this;
      checkIfStateModificationsAreAllowed(this.atom_);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: ADD,
          object: this,
          newValue: value
        });
        if (!change) {
          return this;
        }
      }
      if (!this.has(value)) {
        transaction(function() {
          _this2.data_.add(_this2.enhancer_(value, undefined));
          _this2.atom_.reportChanged();
        });
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var _change = notify || notifySpy ? {
          observableKind: "set",
          debugObjectName: this.name_,
          type: ADD,
          object: this,
          newValue: value
        } : null;
        if (notifySpy && true) {
          spyReportStart(_change);
        }
        if (notify) {
          notifyListeners(this, _change);
        }
        if (notifySpy && true) {
          spyReportEnd();
        }
      }
      return this;
    };
    _proto["delete"] = function _delete(value) {
      var _this3 = this;
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: DELETE,
          object: this,
          oldValue: value
        });
        if (!change) {
          return false;
        }
      }
      if (this.has(value)) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var _change2 = notify || notifySpy ? {
          observableKind: "set",
          debugObjectName: this.name_,
          type: DELETE,
          object: this,
          oldValue: value
        } : null;
        if (notifySpy && true) {
          spyReportStart(_change2);
        }
        transaction(function() {
          _this3.atom_.reportChanged();
          _this3.data_["delete"](value);
        });
        if (notify) {
          notifyListeners(this, _change2);
        }
        if (notifySpy && true) {
          spyReportEnd();
        }
        return true;
      }
      return false;
    };
    _proto.has = function has(value) {
      this.atom_.reportObserved();
      return this.data_.has(this.dehanceValue_(value));
    };
    _proto.entries = function entries() {
      var nextIndex = 0;
      var keys2 = Array.from(this.keys());
      var values2 = Array.from(this.values());
      return makeIterable({
        next: function next() {
          var index = nextIndex;
          nextIndex += 1;
          return index < values2.length ? {
            value: [keys2[index], values2[index]],
            done: false
          } : {
            done: true
          };
        }
      });
    };
    _proto.keys = function keys() {
      return this.values();
    };
    _proto.values = function values() {
      this.atom_.reportObserved();
      var self2 = this;
      var nextIndex = 0;
      var observableValues = Array.from(this.data_.values());
      return makeIterable({
        next: function next() {
          return nextIndex < observableValues.length ? {
            value: self2.dehanceValue_(observableValues[nextIndex++]),
            done: false
          } : {
            done: true
          };
        }
      });
    };
    _proto.replace = function replace(other) {
      var _this4 = this;
      if (isObservableSet(other)) {
        other = new Set(other);
      }
      transaction(function() {
        if (Array.isArray(other)) {
          _this4.clear();
          other.forEach(function(value) {
            return _this4.add(value);
          });
        } else if (isES6Set(other)) {
          _this4.clear();
          other.forEach(function(value) {
            return _this4.add(value);
          });
        } else if (other !== null && other !== undefined) {
          die("Cannot initialize set from " + other);
        }
      });
      return this;
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      if (fireImmediately === true) {
        die("`observe` doesn't support fireImmediately=true in combination with sets.");
      }
      return registerListener(this, listener);
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _proto.toJSON = function toJSON() {
      return Array.from(this);
    };
    _proto.toString = function toString() {
      return "[object ObservableSet]";
    };
    _proto[_Symbol$iterator$1] = function() {
      return this.values();
    };
    _createClass(ObservableSet2, [{
      key: "size",
      get: function get() {
        this.atom_.reportObserved();
        return this.data_.size;
      }
    }, {
      key: _Symbol$toStringTag$1,
      get: function get() {
        return "Set";
      }
    }]);
    return ObservableSet2;
  }();
  var isObservableSet = createInstanceofPredicate("ObservableSet", ObservableSet);
  var descriptorCache = Object.create(null);
  var REMOVE = "remove";
  var ObservableObjectAdministration = function() {
    function ObservableObjectAdministration2(target_, values_, name_, defaultAnnotation_) {
      if (values_ === undefined) {
        values_ = new Map;
      }
      if (defaultAnnotation_ === undefined) {
        defaultAnnotation_ = autoAnnotation;
      }
      this.target_ = undefined;
      this.values_ = undefined;
      this.name_ = undefined;
      this.defaultAnnotation_ = undefined;
      this.keysAtom_ = undefined;
      this.changeListeners_ = undefined;
      this.interceptors_ = undefined;
      this.proxy_ = undefined;
      this.isPlainObject_ = undefined;
      this.appliedAnnotations_ = undefined;
      this.pendingKeys_ = undefined;
      this.target_ = target_;
      this.values_ = values_;
      this.name_ = name_;
      this.defaultAnnotation_ = defaultAnnotation_;
      this.keysAtom_ = new Atom(this.name_ + ".keys");
      this.isPlainObject_ = isPlainObject(this.target_);
      if (!isAnnotation(this.defaultAnnotation_)) {
        die("defaultAnnotation must be valid annotation");
      }
      {
        this.appliedAnnotations_ = {};
      }
    }
    var _proto = ObservableObjectAdministration2.prototype;
    _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
      return this.values_.get(key).get();
    };
    _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
      var observable2 = this.values_.get(key);
      if (observable2 instanceof ComputedValue) {
        observable2.set(newValue);
        return true;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_ || this.target_,
          name: key,
          newValue
        });
        if (!change) {
          return null;
        }
        newValue = change.newValue;
      }
      newValue = observable2.prepareNewValue_(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notify = hasListeners(this);
        var notifySpy = isSpyEnabled();
        var _change = notify || notifySpy ? {
          type: UPDATE,
          observableKind: "object",
          debugObjectName: this.name_,
          object: this.proxy_ || this.target_,
          oldValue: observable2.value_,
          name: key,
          newValue
        } : null;
        if (notifySpy) {
          spyReportStart(_change);
        }
        observable2.setNewValue_(newValue);
        if (notify) {
          notifyListeners(this, _change);
        }
        if (notifySpy) {
          spyReportEnd();
        }
      }
      return true;
    };
    _proto.get_ = function get_(key) {
      if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
        this.has_(key);
      }
      return this.target_[key];
    };
    _proto.set_ = function set_(key, value, proxyTrap) {
      if (proxyTrap === undefined) {
        proxyTrap = false;
      }
      if (hasProp(this.target_, key)) {
        if (this.values_.has(key)) {
          return this.setObservablePropValue_(key, value);
        } else if (proxyTrap) {
          return Reflect.set(this.target_, key, value);
        } else {
          this.target_[key] = value;
          return true;
        }
      } else {
        return this.extend_(key, {
          value,
          enumerable: true,
          writable: true,
          configurable: true
        }, this.defaultAnnotation_, proxyTrap);
      }
    };
    _proto.has_ = function has_(key) {
      if (!globalState.trackingDerivation) {
        return key in this.target_;
      }
      this.pendingKeys_ || (this.pendingKeys_ = new Map);
      var entry = this.pendingKeys_.get(key);
      if (!entry) {
        entry = new ObservableValue(key in this.target_, referenceEnhancer, this.name_ + "." + stringifyKey(key) + "?", false);
        this.pendingKeys_.set(key, entry);
      }
      return entry.get();
    };
    _proto.make_ = function make_(key, annotation) {
      if (annotation === true) {
        annotation = this.defaultAnnotation_;
      }
      if (annotation === false) {
        return;
      }
      assertAnnotable(this, annotation, key);
      if (!(key in this.target_)) {
        var _this$target_$storedA;
        if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {
          return;
        } else {
          die(1, annotation.annotationType_, this.name_ + "." + key.toString());
        }
      }
      var source = this.target_;
      while (source && source !== objectPrototype) {
        var descriptor = getDescriptor(source, key);
        if (descriptor) {
          var outcome = annotation.make_(this, key, descriptor, source);
          if (outcome === 0) {
            return;
          }
          if (outcome === 1) {
            break;
          }
        }
        source = Object.getPrototypeOf(source);
      }
      recordAnnotationApplied(this, annotation, key);
    };
    _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
      if (proxyTrap === undefined) {
        proxyTrap = false;
      }
      if (annotation === true) {
        annotation = this.defaultAnnotation_;
      }
      if (annotation === false) {
        return this.defineProperty_(key, descriptor, proxyTrap);
      }
      assertAnnotable(this, annotation, key);
      var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
      if (outcome) {
        recordAnnotationApplied(this, annotation, key);
      }
      return outcome;
    };
    _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
      if (proxyTrap === undefined) {
        proxyTrap = false;
      }
      try {
        startBatch();
        var deleteOutcome = this.delete_(key);
        if (!deleteOutcome) {
          return deleteOutcome;
        }
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            object: this.proxy_ || this.target_,
            name: key,
            type: ADD,
            newValue: descriptor.value
          });
          if (!change) {
            return null;
          }
          var newValue = change.newValue;
          if (descriptor.value !== newValue) {
            descriptor = _extends({}, descriptor, {
              value: newValue
            });
          }
        }
        if (proxyTrap) {
          if (!Reflect.defineProperty(this.target_, key, descriptor)) {
            return false;
          }
        } else {
          defineProperty(this.target_, key, descriptor);
        }
        this.notifyPropertyAddition_(key, descriptor.value);
      } finally {
        endBatch();
      }
      return true;
    };
    _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
      if (proxyTrap === undefined) {
        proxyTrap = false;
      }
      try {
        startBatch();
        var deleteOutcome = this.delete_(key);
        if (!deleteOutcome) {
          return deleteOutcome;
        }
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            object: this.proxy_ || this.target_,
            name: key,
            type: ADD,
            newValue: value
          });
          if (!change) {
            return null;
          }
          value = change.newValue;
        }
        var cachedDescriptor = getCachedObservablePropDescriptor(key);
        var descriptor = {
          configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
          enumerable: true,
          get: cachedDescriptor.get,
          set: cachedDescriptor.set
        };
        if (proxyTrap) {
          if (!Reflect.defineProperty(this.target_, key, descriptor)) {
            return false;
          }
        } else {
          defineProperty(this.target_, key, descriptor);
        }
        var observable2 = new ObservableValue(value, enhancer, this.name_ + "." + key.toString(), false);
        this.values_.set(key, observable2);
        this.notifyPropertyAddition_(key, observable2.value_);
      } finally {
        endBatch();
      }
      return true;
    };
    _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
      if (proxyTrap === undefined) {
        proxyTrap = false;
      }
      try {
        startBatch();
        var deleteOutcome = this.delete_(key);
        if (!deleteOutcome) {
          return deleteOutcome;
        }
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            object: this.proxy_ || this.target_,
            name: key,
            type: ADD,
            newValue: undefined
          });
          if (!change) {
            return null;
          }
        }
        options.name || (options.name = this.name_ + "." + key.toString());
        options.context = this.proxy_ || this.target_;
        var cachedDescriptor = getCachedObservablePropDescriptor(key);
        var descriptor = {
          configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
          enumerable: false,
          get: cachedDescriptor.get,
          set: cachedDescriptor.set
        };
        if (proxyTrap) {
          if (!Reflect.defineProperty(this.target_, key, descriptor)) {
            return false;
          }
        } else {
          defineProperty(this.target_, key, descriptor);
        }
        this.values_.set(key, new ComputedValue(options));
        this.notifyPropertyAddition_(key, undefined);
      } finally {
        endBatch();
      }
      return true;
    };
    _proto.delete_ = function delete_(key, proxyTrap) {
      if (proxyTrap === undefined) {
        proxyTrap = false;
      }
      if (!hasProp(this.target_, key)) {
        return true;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: REMOVE
        });
        if (!change) {
          return null;
        }
      }
      try {
        var _this$pendingKeys_, _this$pendingKeys_$ge;
        startBatch();
        var notify = hasListeners(this);
        var notifySpy = isSpyEnabled();
        var observable2 = this.values_.get(key);
        var value = undefined;
        if (!observable2 && (notify || notifySpy)) {
          var _getDescriptor2;
          value = (_getDescriptor2 = getDescriptor(this.target_, key)) == null ? undefined : _getDescriptor2.value;
        }
        if (proxyTrap) {
          if (!Reflect.deleteProperty(this.target_, key)) {
            return false;
          }
        } else {
          delete this.target_[key];
        }
        if (true) {
          delete this.appliedAnnotations_[key];
        }
        if (observable2) {
          this.values_["delete"](key);
          if (observable2 instanceof ObservableValue) {
            value = observable2.value_;
          }
          propagateChanged(observable2);
        }
        this.keysAtom_.reportChanged();
        (_this$pendingKeys_ = this.pendingKeys_) == null || (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null || _this$pendingKeys_$ge.set(key in this.target_);
        if (notify || notifySpy) {
          var _change2 = {
            type: REMOVE,
            observableKind: "object",
            object: this.proxy_ || this.target_,
            debugObjectName: this.name_,
            oldValue: value,
            name: key
          };
          if (notifySpy) {
            spyReportStart(_change2);
          }
          if (notify) {
            notifyListeners(this, _change2);
          }
          if (notifySpy) {
            spyReportEnd();
          }
        }
      } finally {
        endBatch();
      }
      return true;
    };
    _proto.observe_ = function observe_(callback, fireImmediately) {
      if (fireImmediately === true) {
        die("`observe` doesn't support the fire immediately property for observable objects.");
      }
      return registerListener(this, callback);
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
      var _this$pendingKeys_2, _this$pendingKeys_2$g;
      var notify = hasListeners(this);
      var notifySpy = isSpyEnabled();
      if (notify || notifySpy) {
        var change = notify || notifySpy ? {
          type: ADD,
          observableKind: "object",
          debugObjectName: this.name_,
          object: this.proxy_ || this.target_,
          name: key,
          newValue: value
        } : null;
        if (notifySpy) {
          spyReportStart(change);
        }
        if (notify) {
          notifyListeners(this, change);
        }
        if (notifySpy) {
          spyReportEnd();
        }
      }
      (_this$pendingKeys_2 = this.pendingKeys_) == null || (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null || _this$pendingKeys_2$g.set(true);
      this.keysAtom_.reportChanged();
    };
    _proto.ownKeys_ = function ownKeys_() {
      this.keysAtom_.reportObserved();
      return ownKeys(this.target_);
    };
    _proto.keys_ = function keys_() {
      this.keysAtom_.reportObserved();
      return Object.keys(this.target_);
    };
    return ObservableObjectAdministration2;
  }();
  var isObservableObjectAdministration = createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
  var ENTRY_0 = createArrayEntryDescriptor(0);
  var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
  var StubArray = function StubArray() {
  };
  inherit(StubArray, Array.prototype);
  var LegacyObservableArray = function(_StubArray, _Symbol$toStringTag2, _Symbol$iterator2) {
    _inheritsLoose(LegacyObservableArray2, _StubArray);
    function LegacyObservableArray2(initialValues, enhancer, name, owned) {
      var _this;
      if (name === undefined) {
        name = "ObservableArray@" + getNextId();
      }
      if (owned === undefined) {
        owned = false;
      }
      _this = _StubArray.call(this) || this;
      var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
      adm.proxy_ = _assertThisInitialized(_this);
      addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);
      if (initialValues && initialValues.length) {
        var prev = allowStateChangesStart(true);
        _this.spliceWithArray(0, 0, initialValues);
        allowStateChangesEnd(prev);
      }
      {
        Object.defineProperty(_assertThisInitialized(_this), "0", ENTRY_0);
      }
      return _this;
    }
    var _proto = LegacyObservableArray2.prototype;
    _proto.concat = function concat() {
      this[$mobx].atom_.reportObserved();
      for (var _len = arguments.length, arrays = new Array(_len), _key = 0;_key < _len; _key++) {
        arrays[_key] = arguments[_key];
      }
      return Array.prototype.concat.apply(this.slice(), arrays.map(function(a) {
        return isObservableArray(a) ? a.slice() : a;
      }));
    };
    _proto[_Symbol$iterator2] = function() {
      var self2 = this;
      var nextIndex = 0;
      return makeIterable({
        next: function next() {
          return nextIndex < self2.length ? {
            value: self2[nextIndex++],
            done: false
          } : {
            done: true,
            value: undefined
          };
        }
      });
    };
    _createClass(LegacyObservableArray2, [{
      key: "length",
      get: function get() {
        return this[$mobx].getArrayLength_();
      },
      set: function set(newLength) {
        this[$mobx].setArrayLength_(newLength);
      }
    }, {
      key: _Symbol$toStringTag2,
      get: function get() {
        return "Array";
      }
    }]);
    return LegacyObservableArray2;
  }(StubArray, Symbol.toStringTag, Symbol.iterator);
  Object.entries(arrayExtensions).forEach(function(_ref) {
    var prop = _ref[0], fn = _ref[1];
    if (prop !== "concat") {
      addHiddenProp(LegacyObservableArray.prototype, prop, fn);
    }
  });
  reserveArrayBuffer(1000);
  var toString = objectPrototype.toString;
  ["Symbol", "Map", "Set"].forEach(function(m) {
    var g = getGlobal();
    if (typeof g[m] === "undefined") {
      die("MobX requires globalThis '" + m + "' to be available or polyfilled");
    }
  });
  if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
      spy,
      extras: {
        getDebugName
      },
      $mobx
    });
  }
  exports.$mobx = $mobx;
  exports.FlowCancellationError = FlowCancellationError;
  exports.ObservableMap = ObservableMap;
  exports.ObservableSet = ObservableSet;
  exports.Reaction = Reaction;
  exports._allowStateChanges = allowStateChanges;
  exports._allowStateChangesInsideComputed = runInAction;
  exports._allowStateReadsEnd = allowStateReadsEnd;
  exports._allowStateReadsStart = allowStateReadsStart;
  exports._autoAction = autoAction;
  exports._endAction = _endAction;
  exports._getAdministration = getAdministration;
  exports._getGlobalState = getGlobalState;
  exports._interceptReads = interceptReads;
  exports._isComputingDerivation = isComputingDerivation;
  exports._resetGlobalState = resetGlobalState;
  exports._startAction = _startAction;
  exports.action = action;
  exports.autorun = autorun;
  exports.comparer = comparer;
  exports.computed = computed;
  exports.configure = configure;
  exports.createAtom = createAtom;
  exports.defineProperty = apiDefineProperty;
  exports.entries = entries;
  exports.extendObservable = extendObservable;
  exports.flow = flow;
  exports.flowResult = flowResult;
  exports.get = get;
  exports.getAtom = getAtom;
  exports.getDebugName = getDebugName;
  exports.getDependencyTree = getDependencyTree;
  exports.getObserverTree = getObserverTree;
  exports.has = has;
  exports.intercept = intercept;
  exports.isAction = isAction;
  exports.isBoxedObservable = isObservableValue;
  exports.isComputed = isComputed;
  exports.isComputedProp = isComputedProp;
  exports.isFlow = isFlow;
  exports.isFlowCancellationError = isFlowCancellationError;
  exports.isObservable = isObservable;
  exports.isObservableArray = isObservableArray;
  exports.isObservableMap = isObservableMap;
  exports.isObservableObject = isObservableObject;
  exports.isObservableProp = isObservableProp;
  exports.isObservableSet = isObservableSet;
  exports.keys = keys;
  exports.makeAutoObservable = makeAutoObservable;
  exports.makeObservable = makeObservable;
  exports.observable = observable;
  exports.observe = observe;
  exports.onBecomeObserved = onBecomeObserved;
  exports.onBecomeUnobserved = onBecomeUnobserved;
  exports.onReactionError = onReactionError;
  exports.override = override;
  exports.ownKeys = apiOwnKeys;
  exports.reaction = reaction;
  exports.remove = remove;
  exports.runInAction = runInAction;
  exports.set = set;
  exports.spy = spy;
  exports.toJS = toJS;
  exports.trace = trace;
  exports.transaction = transaction;
  exports.untracked = untracked;
  exports.values = values;
  exports.when = when;
});

// ../../node_modules/mobx/dist/index.js
var require_dist = __commonJS((exports, module) => {
  if (false) {
  } else {
    module.exports = require_mobx_cjs_development();
  }
});

// ../../node_modules/cosmokit/lib/index.cjs
var require_lib = __commonJS((exports, module) => {
  var noop = function() {
  };
  var isNullable = function(value) {
    return value === null || value === undefined;
  };
  var isPlainObject = function(data) {
    return data && typeof data === "object" && !Array.isArray(data);
  };
  var filterKeys = function(object, filter) {
    return Object.fromEntries(Object.entries(object).filter(([key, value]) => filter(key, value)));
  };
  var mapValues = function(object, transform) {
    return Object.fromEntries(Object.entries(object).map(([key, value]) => [key, transform(value, key)]));
  };
  var pick = function(source, keys, forced) {
    if (!keys)
      return { ...source };
    const result = {};
    for (const key of keys) {
      if (forced || source[key] !== undefined)
        result[key] = source[key];
    }
    return result;
  };
  var omit = function(source, keys) {
    if (!keys)
      return { ...source };
    const result = { ...source };
    for (const key of keys) {
      Reflect.deleteProperty(result, key);
    }
    return result;
  };
  var defineProperty = function(object, key, value) {
    return Object.defineProperty(object, key, { writable: true, value, enumerable: false });
  };
  var contain = function(array1, array2) {
    return array2.every((item) => array1.includes(item));
  };
  var intersection = function(array1, array2) {
    return array1.filter((item) => array2.includes(item));
  };
  var difference = function(array1, array2) {
    return array1.filter((item) => !array2.includes(item));
  };
  var union = function(array1, array2) {
    return Array.from(new Set([...array1, ...array2]));
  };
  var deduplicate = function(array) {
    return [...new Set(array)];
  };
  var remove = function(list, item) {
    const index = list.indexOf(item);
    if (index >= 0) {
      list.splice(index, 1);
      return true;
    } else {
      return false;
    }
  };
  var makeArray = function(source) {
    return Array.isArray(source) ? source : isNullable(source) ? [] : [source];
  };
  var is = function(type, value) {
    if (arguments.length === 1)
      return (value2) => is(type, value2);
    return type in globalThis && value instanceof globalThis[type] || Object.prototype.toString.call(value).slice(8, -1) === type;
  };
  var isArrayBufferLike = function(value) {
    return is("ArrayBuffer", value) || is("SharedArrayBuffer", value);
  };
  var isArrayBufferSource = function(value) {
    return isArrayBufferLike(value) || ArrayBuffer.isView(value);
  };
  var clone = function(source) {
    if (!source || typeof source !== "object")
      return source;
    if (Array.isArray(source))
      return source.map(clone);
    if (is("Date", source))
      return new Date(source.valueOf());
    if (is("RegExp", source))
      return new RegExp(source.source, source.flags);
    if (isArrayBufferLike(source))
      return source.slice(0);
    if (ArrayBuffer.isView(source))
      return source.buffer.slice(source.byteOffset, source.byteOffset + source.byteLength);
    return mapValues(source, clone);
  };
  var deepEqual = function(a, b, strict) {
    if (a === b)
      return true;
    if (!strict && isNullable(a) && isNullable(b))
      return true;
    if (typeof a !== typeof b)
      return false;
    if (typeof a !== "object")
      return false;
    if (!a || !b)
      return false;
    function check(test, then) {
      return test(a) ? test(b) ? then(a, b) : false : test(b) ? false : undefined;
    }
    __name(check, "check");
    return check(Array.isArray, (a2, b2) => a2.length === b2.length && a2.every((item, index) => deepEqual(item, b2[index]))) ?? check(is("Date"), (a2, b2) => a2.valueOf() === b2.valueOf()) ?? check(is("RegExp"), (a2, b2) => a2.source === b2.source && a2.flags === b2.flags) ?? check(isArrayBufferLike, (a2, b2) => {
      if (a2.byteLength !== b2.byteLength)
        return false;
      const viewA = new Uint8Array(a2);
      const viewB = new Uint8Array(b2);
      for (let i = 0;i < viewA.length; i++) {
        if (viewA[i] !== viewB[i])
          return false;
      }
      return true;
    }) ?? Object.keys({ ...a, ...b }).every((key) => deepEqual(a[key], b[key], strict));
  };
  var capitalize = function(source) {
    return source.charAt(0).toUpperCase() + source.slice(1);
  };
  var uncapitalize = function(source) {
    return source.charAt(0).toLowerCase() + source.slice(1);
  };
  var camelCase = function(source) {
    return source.replace(/[_-][a-z]/g, (str) => str.slice(1).toUpperCase());
  };
  var paramCase = function(source) {
    return uncapitalize(source).replace(/_/g, "-").replace(/.[A-Z]+/g, (str) => str[0] + "-" + str.slice(1).toLowerCase());
  };
  var snakeCase = function(source) {
    return uncapitalize(source).replace(/-/g, "_").replace(/.[A-Z]+/g, (str) => str[0] + "_" + str.slice(1).toLowerCase());
  };
  var trimSlash = function(source) {
    return source.replace(/\/$/, "");
  };
  var sanitize = function(source) {
    if (!source.startsWith("/"))
      source = "/" + source;
    return trimSlash(source);
  };
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Binary: () => Binary,
    Time: () => Time,
    arrayBufferToBase64: () => arrayBufferToBase64,
    arrayBufferToHex: () => arrayBufferToHex,
    base64ToArrayBuffer: () => base64ToArrayBuffer,
    camelCase: () => camelCase,
    camelize: () => camelize,
    capitalize: () => capitalize,
    clone: () => clone,
    contain: () => contain,
    deduplicate: () => deduplicate,
    deepEqual: () => deepEqual,
    defineProperty: () => defineProperty,
    difference: () => difference,
    filterKeys: () => filterKeys,
    hexToArrayBuffer: () => hexToArrayBuffer,
    hyphenate: () => hyphenate,
    intersection: () => intersection,
    is: () => is,
    isNullable: () => isNullable,
    isPlainObject: () => isPlainObject,
    makeArray: () => makeArray,
    mapValues: () => mapValues,
    noop: () => noop,
    omit: () => omit,
    paramCase: () => paramCase,
    pick: () => pick,
    remove: () => remove,
    sanitize: () => sanitize,
    snakeCase: () => snakeCase,
    trimSlash: () => trimSlash,
    uncapitalize: () => uncapitalize,
    union: () => union,
    valueMap: () => mapValues
  });
  module.exports = __toCommonJS(src_exports);
  __name(noop, "noop");
  __name(isNullable, "isNullable");
  __name(isPlainObject, "isPlainObject");
  __name(filterKeys, "filterKeys");
  __name(mapValues, "mapValues");
  __name(pick, "pick");
  __name(omit, "omit");
  __name(defineProperty, "defineProperty");
  __name(contain, "contain");
  __name(intersection, "intersection");
  __name(difference, "difference");
  __name(union, "union");
  __name(deduplicate, "deduplicate");
  __name(remove, "remove");
  __name(makeArray, "makeArray");
  __name(is, "is");
  __name(isArrayBufferLike, "isArrayBufferLike");
  __name(isArrayBufferSource, "isArrayBufferSource");
  var Binary;
  ((Binary2) => {
    Binary2.is = isArrayBufferLike;
    Binary2.isSource = isArrayBufferSource;
    function fromSource(source) {
      if (ArrayBuffer.isView(source)) {
        return source.buffer.slice(source.byteOffset, source.byteOffset + source.byteLength);
      } else {
        return source;
      }
    }
    Binary2.fromSource = fromSource;
    __name(fromSource, "fromSource");
    function toBase64(source) {
      if (typeof Buffer !== "undefined") {
        return Buffer.from(source).toString("base64");
      }
      let binary = "";
      const bytes = new Uint8Array(source);
      for (let i = 0;i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }
    Binary2.toBase64 = toBase64;
    __name(toBase64, "toBase64");
    function fromBase64(source) {
      if (typeof Buffer !== "undefined")
        return fromSource(Buffer.from(source, "base64"));
      return Uint8Array.from(atob(source), (c) => c.charCodeAt(0));
    }
    Binary2.fromBase64 = fromBase64;
    __name(fromBase64, "fromBase64");
    function toHex(source) {
      if (typeof Buffer !== "undefined")
        return Buffer.from(source).toString("hex");
      return Array.from(new Uint8Array(source), (byte) => byte.toString(16).padStart(2, "0")).join("");
    }
    Binary2.toHex = toHex;
    __name(toHex, "toHex");
    function fromHex(source) {
      if (typeof Buffer !== "undefined")
        return fromSource(Buffer.from(source, "hex"));
      const hex = source.length % 2 === 0 ? source : source.slice(0, source.length - 1);
      const buffer = [];
      for (let i = 0;i < hex.length; i += 2) {
        buffer.push(parseInt(`${hex[i]}${hex[i + 1]}`, 16));
      }
      return Uint8Array.from(buffer).buffer;
    }
    Binary2.fromHex = fromHex;
    __name(fromHex, "fromHex");
  })(Binary || (Binary = {}));
  var base64ToArrayBuffer = Binary.fromBase64;
  var arrayBufferToBase64 = Binary.toBase64;
  var hexToArrayBuffer = Binary.fromHex;
  var arrayBufferToHex = Binary.toHex;
  __name(clone, "clone");
  __name(deepEqual, "deepEqual");
  __name(capitalize, "capitalize");
  __name(uncapitalize, "uncapitalize");
  __name(camelCase, "camelCase");
  __name(paramCase, "paramCase");
  __name(snakeCase, "snakeCase");
  var camelize = camelCase;
  var hyphenate = paramCase;
  __name(trimSlash, "trimSlash");
  __name(sanitize, "sanitize");
  var Time;
  ((Time2) => {
    Time2.millisecond = 1;
    Time2.second = 1000;
    Time2.minute = Time2.second * 60;
    Time2.hour = Time2.minute * 60;
    Time2.day = Time2.hour * 24;
    Time2.week = Time2.day * 7;
    let timezoneOffset = (new Date()).getTimezoneOffset();
    function setTimezoneOffset(offset) {
      timezoneOffset = offset;
    }
    Time2.setTimezoneOffset = setTimezoneOffset;
    __name(setTimezoneOffset, "setTimezoneOffset");
    function getTimezoneOffset() {
      return timezoneOffset;
    }
    Time2.getTimezoneOffset = getTimezoneOffset;
    __name(getTimezoneOffset, "getTimezoneOffset");
    function getDateNumber(date = new Date, offset) {
      if (typeof date === "number")
        date = new Date(date);
      if (offset === undefined)
        offset = timezoneOffset;
      return Math.floor((date.valueOf() / Time2.minute - offset) / 1440);
    }
    Time2.getDateNumber = getDateNumber;
    __name(getDateNumber, "getDateNumber");
    function fromDateNumber(value, offset) {
      const date = new Date(value * Time2.day);
      if (offset === undefined)
        offset = timezoneOffset;
      return new Date(+date + offset * Time2.minute);
    }
    Time2.fromDateNumber = fromDateNumber;
    __name(fromDateNumber, "fromDateNumber");
    const numeric = /\d+(?:\.\d+)?/.source;
    const timeRegExp = new RegExp(`^${[
      "w(?:eek(?:s)?)?",
      "d(?:ay(?:s)?)?",
      "h(?:our(?:s)?)?",
      "m(?:in(?:ute)?(?:s)?)?",
      "s(?:ec(?:ond)?(?:s)?)?"
    ].map((unit) => `(${numeric}${unit})?`).join("")}\$`);
    function parseTime(source) {
      const capture = timeRegExp.exec(source);
      if (!capture)
        return 0;
      return (parseFloat(capture[1]) * Time2.week || 0) + (parseFloat(capture[2]) * Time2.day || 0) + (parseFloat(capture[3]) * Time2.hour || 0) + (parseFloat(capture[4]) * Time2.minute || 0) + (parseFloat(capture[5]) * Time2.second || 0);
    }
    Time2.parseTime = parseTime;
    __name(parseTime, "parseTime");
    function parseDate(date) {
      const parsed = parseTime(date);
      if (parsed) {
        date = Date.now() + parsed;
      } else if (/^\d{1,2}(:\d{1,2}){1,2}$/.test(date)) {
        date = `${(new Date()).toLocaleDateString()}-${date}`;
      } else if (/^\d{1,2}-\d{1,2}-\d{1,2}(:\d{1,2}){1,2}$/.test(date)) {
        date = `${(new Date()).getFullYear()}-${date}`;
      }
      return date ? new Date(date) : new Date;
    }
    Time2.parseDate = parseDate;
    __name(parseDate, "parseDate");
    function format(ms) {
      const abs = Math.abs(ms);
      if (abs >= Time2.day - Time2.hour / 2) {
        return Math.round(ms / Time2.day) + "d";
      } else if (abs >= Time2.hour - Time2.minute / 2) {
        return Math.round(ms / Time2.hour) + "h";
      } else if (abs >= Time2.minute - Time2.second / 2) {
        return Math.round(ms / Time2.minute) + "m";
      } else if (abs >= Time2.second) {
        return Math.round(ms / Time2.second) + "s";
      }
      return ms + "ms";
    }
    Time2.format = format;
    __name(format, "format");
    function toDigits(source, length = 2) {
      return source.toString().padStart(length, "0");
    }
    Time2.toDigits = toDigits;
    __name(toDigits, "toDigits");
    function template(template2, time = new Date) {
      return template2.replace("yyyy", time.getFullYear().toString()).replace("yy", time.getFullYear().toString().slice(2)).replace("MM", toDigits(time.getMonth() + 1)).replace("dd", toDigits(time.getDate())).replace("hh", toDigits(time.getHours())).replace("mm", toDigits(time.getMinutes())).replace("ss", toDigits(time.getSeconds())).replace("SSS", toDigits(time.getMilliseconds(), 3));
    }
    Time2.template = template;
    __name(template, "template");
  })(Time || (Time = {}));
});

// ../../node_modules/@cordisjs/core/lib/index.cjs
var require_lib2 = __commonJS((exports, module) => {
  var isBailed = function(value) {
    return value !== null && value !== false && value !== undefined;
  };
  var isConstructor = function(func) {
    if (!func.prototype)
      return false;
    if (func instanceof GeneratorFunction)
      return false;
    if (AsyncGeneratorFunction !== Function && func instanceof AsyncGeneratorFunction)
      return false;
    return true;
  };
  var resolveConfig = function(plugin2, config) {
    const schema = plugin2["Config"] || plugin2["schema"];
    if (schema && plugin2["schema"] !== false)
      config = schema(config);
    return config ?? {};
  };
  var isUnproxyable = function(value) {
    return [Map, Set, Date, Promise].some((constructor) => value instanceof constructor);
  };
  var joinPrototype = function(proto1, proto2) {
    if (proto1 === Object.prototype)
      return proto2;
    const result = Object.create(joinPrototype(Object.getPrototypeOf(proto1), proto2));
    for (const key of Reflect.ownKeys(proto1)) {
      Object.defineProperty(result, key, Object.getOwnPropertyDescriptor(proto1, key));
    }
    return result;
  };
  var createTraceable = function(ctx, value) {
    const proxy = new Proxy(value, {
      get: (target, name, receiver) => {
        if (name === symbols.origin)
          return ctx;
        return Reflect.get(target, name, receiver);
      },
      apply: (target, thisArg, args) => {
        return applyTraceable(proxy, target, thisArg, args);
      }
    });
    return proxy;
  };
  var applyTraceable = function(proxy, value, thisArg, args) {
    if (!value[symbols.invoke])
      return Reflect.apply(value, thisArg, args);
    return value[symbols.invoke].apply(proxy, args);
  };
  var createCallable = function(name, proto) {
    const self2 = __name(function(...args) {
      const proxy = createTraceable(self2[symbols.origin], self2);
      return applyTraceable(proxy, self2, this, args);
    }, "self");
    (0, import_cosmokit2.defineProperty)(self2, "name", name);
    return Object.setPrototypeOf(self2, proto);
  };
  var isApplicable = function(object) {
    return object && typeof object === "object" && typeof object.apply === "function";
  };
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Context: () => Context2,
    CordisError: () => CordisError,
    EffectScope: () => EffectScope,
    ForkScope: () => ForkScope,
    Lifecycle: () => Lifecycle,
    MainScope: () => MainScope,
    Registry: () => Registry,
    ScopeStatus: () => ScopeStatus,
    Service: () => Service2,
    applyTraceable: () => applyTraceable,
    createCallable: () => createCallable,
    createTraceable: () => createTraceable,
    isApplicable: () => isApplicable,
    isBailed: () => isBailed,
    isConstructor: () => isConstructor,
    isUnproxyable: () => isUnproxyable,
    joinPrototype: () => joinPrototype,
    resolveConfig: () => resolveConfig,
    symbols: () => symbols
  });
  module.exports = __toCommonJS(src_exports);
  var import_cosmokit5 = require_lib();
  var import_cosmokit = require_lib();
  __name(isBailed, "isBailed");
  var Lifecycle = class {
    constructor(root) {
      this.root = root;
      (0, import_cosmokit.defineProperty)(this, Context2.origin, root);
      (0, import_cosmokit.defineProperty)(this.on("internal/listener", function(name, listener, options) {
        const method = options.prepend ? "unshift" : "push";
        if (name === "ready") {
          if (!this.lifecycle.isActive)
            return;
          this.scope.ensure(async () => listener());
          return () => false;
        } else if (name === "dispose") {
          this.scope.disposables[method](listener);
          (0, import_cosmokit.defineProperty)(listener, "name", "event <dispose>");
          return () => (0, import_cosmokit.remove)(this.scope.disposables, listener);
        } else if (name === "fork") {
          this.scope.runtime.forkables[method](listener);
          return this.scope.collect("event <fork>", () => (0, import_cosmokit.remove)(this.scope.runtime.forkables, listener));
        }
      }), Context2.static, root.scope);
      for (const level of ["info", "error", "warning"]) {
        (0, import_cosmokit.defineProperty)(this.on(`internal/${level}`, (format, ...param) => {
          if (this._hooks[`internal/${level}`].length > 1)
            return;
          console.info(format, ...param);
        }), Context2.static, root.scope);
      }
      (0, import_cosmokit.defineProperty)(this.on("internal/before-service", function(name) {
        for (const runtime of this.registry.values()) {
          if (!runtime.using.includes(name))
            continue;
          const scopes = runtime.isReusable ? runtime.children : [runtime];
          for (const scope of scopes) {
            if (!this[symbols.filter](scope.ctx))
              continue;
            scope.updateStatus();
            scope.reset();
          }
        }
      }, { globalThis: true }), Context2.static, root.scope);
      (0, import_cosmokit.defineProperty)(this.on("internal/service", function(name) {
        for (const runtime of this.registry.values()) {
          if (!runtime.using.includes(name))
            continue;
          const scopes = runtime.isReusable ? runtime.children : [runtime];
          for (const scope of scopes) {
            if (!this[symbols.filter](scope.ctx))
              continue;
            scope.start();
          }
        }
      }, { globalThis: true }), Context2.static, root.scope);
      (0, import_cosmokit.defineProperty)(this.on("internal/inject", function(name) {
        let parent = this;
        while (parent.runtime.plugin) {
          for (const key of parent.runtime.inject) {
            if (name === Context2.resolveInject(parent, key)[0])
              return true;
          }
          parent = parent.scope.parent;
        }
      }, { globalThis: true }), Context2.static, root.scope);
    }
    static {
      __name(this, "Lifecycle");
    }
    isActive = false;
    _tasks = new Set;
    _hooks = {};
    async flush() {
      while (this._tasks.size) {
        await Promise.all(Array.from(this._tasks));
      }
    }
    getHooks(name, thisArg) {
      const hooks = this._hooks[name] || [];
      return hooks.slice().filter(([context2, callback, options]) => {
        const filter = thisArg?.[Context2.filter];
        return options.globalThis || !filter || filter.call(thisArg, context2);
      }).map(([, callback]) => callback);
    }
    prepareEvent(type, args) {
      const thisArg = typeof args[0] === "object" || typeof args[0] === "function" ? args.shift() : null;
      const name = args.shift();
      if (name !== "internal/event") {
        this.emit("internal/event", type, name, args, thisArg);
      }
      return [this.getHooks(name, thisArg), thisArg ?? this[Context2.origin]];
    }
    async parallel(...args) {
      const [hooks, thisArg] = this.prepareEvent("parallel", args);
      await Promise.all(hooks.map(async (callback) => {
        await callback.apply(thisArg, args);
      }));
    }
    emit(...args) {
      const [hooks, thisArg] = this.prepareEvent("emit", args);
      for (const callback of hooks) {
        callback.apply(thisArg, args);
      }
    }
    async serial(...args) {
      const [hooks, thisArg] = this.prepareEvent("serial", args);
      for (const callback of hooks) {
        const result = await callback.apply(thisArg, args);
        if (isBailed(result))
          return result;
      }
    }
    bail(...args) {
      const [hooks, thisArg] = this.prepareEvent("bail", args);
      for (const callback of hooks) {
        const result = callback.apply(thisArg, args);
        if (isBailed(result))
          return result;
      }
    }
    register(label, hooks, listener, options) {
      const caller = this[Context2.origin];
      const method = options.prepend ? "unshift" : "push";
      hooks[method]([caller, listener, options]);
      return caller.state.collect(label, () => this.unregister(hooks, listener));
    }
    unregister(hooks, listener) {
      const index = hooks.findIndex(([context2, callback]) => callback === listener);
      if (index >= 0) {
        hooks.splice(index, 1);
        return true;
      }
    }
    on(name, listener, options) {
      if (typeof options !== "object") {
        options = { prepend: options };
      }
      const caller = this[Context2.origin];
      caller.scope.assertActive();
      const result = this.bail(caller, "internal/listener", name, listener, options);
      if (result)
        return result;
      const hooks = this._hooks[name] ||= [];
      const label = typeof name === "string" ? `event <${name}>` : "event (Symbol)";
      return this.register(label, hooks, listener, options);
    }
    once(name, listener, options) {
      const dispose = this.on(name, function(...args) {
        dispose();
        return listener.apply(this, args);
      }, options);
      return dispose;
    }
    off(name, listener) {
      return this.unregister(this._hooks[name] || [], listener);
    }
    async start() {
      this.isActive = true;
      const hooks = this._hooks.ready || [];
      while (hooks.length) {
        const [context2, callback] = hooks.shift();
        context2.scope.ensure(async () => callback());
      }
      await this.flush();
    }
    async stop() {
      this.isActive = false;
      this.root.scope.reset();
    }
  };
  var import_cosmokit4 = require_lib();
  var import_cosmokit3 = require_lib();
  var import_cosmokit2 = require_lib();
  var symbols = {
    origin: Symbol.for("cordis.origin"),
    events: Symbol.for("cordis.events"),
    static: Symbol.for("cordis.static"),
    filter: Symbol.for("cordis.filter"),
    expose: Symbol.for("cordis.expose"),
    isolate: Symbol.for("cordis.isolate"),
    internal: Symbol.for("cordis.internal"),
    intercept: Symbol.for("cordis.intercept"),
    setup: Symbol.for("cordis.setup"),
    invoke: Symbol.for("cordis.invoke"),
    extend: Symbol.for("cordis.extend"),
    provide: Symbol.for("cordis.provide"),
    immediate: Symbol.for("cordis.immediate")
  };
  var GeneratorFunction = function* () {
  }.constructor;
  var AsyncGeneratorFunction = async function* () {
  }.constructor;
  __name(isConstructor, "isConstructor");
  __name(resolveConfig, "resolveConfig");
  __name(isUnproxyable, "isUnproxyable");
  __name(joinPrototype, "joinPrototype");
  __name(createTraceable, "createTraceable");
  __name(applyTraceable, "applyTraceable");
  __name(createCallable, "createCallable");
  var ScopeStatus = ((ScopeStatus2) => {
    ScopeStatus2[ScopeStatus2["PENDING"] = 0] = "PENDING";
    ScopeStatus2[ScopeStatus2["LOADING"] = 1] = "LOADING";
    ScopeStatus2[ScopeStatus2["ACTIVE"] = 2] = "ACTIVE";
    ScopeStatus2[ScopeStatus2["FAILED"] = 3] = "FAILED";
    ScopeStatus2[ScopeStatus2["DISPOSED"] = 4] = "DISPOSED";
    return ScopeStatus2;
  })(ScopeStatus || {});
  var CordisError = class _CordisError extends Error {
    constructor(code, message) {
      super(message ?? _CordisError.Code[code]);
      this.code = code;
    }
    static {
      __name(this, "CordisError");
    }
  };
  ((CordisError2) => {
    CordisError2.Code = {
      INACTIVE_EFFECT: "cannot create effect on inactive context"
    };
  })(CordisError || (CordisError = {}));
  var EffectScope = class {
    constructor(parent, config) {
      this.parent = parent;
      this.config = config;
      this.uid = parent.registry ? parent.registry.counter : 0;
      this.ctx = this.context = parent.extend({ scope: this });
      this.proxy = new Proxy({}, {
        get: (target, key) => Reflect.get(this.config, key)
      });
    }
    static {
      __name(this, "EffectScope");
    }
    uid;
    ctx;
    disposables = [];
    error;
    status = 0;
    isActive = false;
    context;
    proxy;
    acceptors = [];
    tasks = new Set;
    hasError = false;
    get _config() {
      return this.runtime.isReactive ? this.proxy : this.config;
    }
    assertActive() {
      if (this.uid !== null || this.isActive)
        return;
      throw new CordisError("INACTIVE_EFFECT");
    }
    effect(callback, config) {
      this.assertActive();
      const result = isConstructor(callback) ? new callback(this.ctx, config) : callback(this.ctx, config);
      let disposed = false;
      const original = typeof result === "function" ? result : result.dispose.bind(result);
      const wrapped = __name((...args) => {
        if (disposed)
          return;
        disposed = true;
        (0, import_cosmokit3.remove)(this.disposables, wrapped);
        return original(...args);
      }, "wrapped");
      this.disposables.push(wrapped);
      if (typeof result === "function")
        return wrapped;
      result.dispose = wrapped;
      return result;
    }
    collect(label, callback) {
      const dispose = (0, import_cosmokit3.defineProperty)(() => {
        (0, import_cosmokit3.remove)(this.disposables, dispose);
        return callback();
      }, "name", label);
      this.disposables.push(dispose);
      return dispose;
    }
    restart() {
      this.reset();
      this.error = null;
      this.hasError = false;
      this.status = 0;
      this.start();
    }
    _getStatus() {
      if (this.uid === null)
        return 4;
      if (this.hasError)
        return 3;
      if (this.tasks.size)
        return 1;
      if (this.ready)
        return 2;
      return 0;
    }
    updateStatus(callback) {
      const oldValue = this.status;
      callback?.();
      this.status = this._getStatus();
      if (oldValue !== this.status) {
        this.context.emit("internal/status", this, oldValue);
      }
    }
    ensure(callback) {
      const task = callback().catch((reason) => {
        this.context.emit("internal/error", reason);
        this.cancel(reason);
      }).finally(() => {
        this.updateStatus(() => this.tasks.delete(task));
        this.context.events._tasks.delete(task);
      });
      this.updateStatus(() => this.tasks.add(task));
      this.context.events._tasks.add(task);
    }
    cancel(reason) {
      this.error = reason;
      this.updateStatus(() => this.hasError = true);
      this.reset();
    }
    get ready() {
      return this.runtime.using.every((name) => !(0, import_cosmokit3.isNullable)(this.ctx[name]));
    }
    reset() {
      this.isActive = false;
      this.disposables = this.disposables.splice(0).filter((dispose) => {
        if (this.uid !== null && dispose[Context2.static] === this)
          return true;
        (async () => dispose())().catch((reason) => {
          this.context.emit("internal/error", reason);
        });
      });
    }
    init(error) {
      if (!this.config) {
        this.cancel(error);
      } else {
        this.start();
      }
    }
    start() {
      if (!this.ready || this.isActive || this.uid === null)
        return true;
      this.isActive = true;
      this.updateStatus(() => this.hasError = false);
    }
    accept(...args) {
      const keys = Array.isArray(args[0]) ? args.shift() : null;
      const acceptor = { keys, callback: args[0], ...args[1] };
      return this.effect(() => {
        this.acceptors.push(acceptor);
        if (acceptor.immediate)
          acceptor.callback?.(this.config);
        return () => (0, import_cosmokit3.remove)(this.acceptors, acceptor);
      });
    }
    decline(keys) {
      return this.accept(keys, () => true);
    }
    checkUpdate(resolved, forced) {
      if (forced || !this.config)
        return [true, true];
      if (forced === false)
        return [false, false];
      const modified = Object.create(null);
      const checkPropertyUpdate = __name((key) => {
        const result = modified[key] ??= !(0, import_cosmokit3.deepEqual)(this.config[key], resolved[key]);
        hasUpdate ||= result;
        return result;
      }, "checkPropertyUpdate");
      const ignored = new Set;
      let hasUpdate = false, shouldRestart = false;
      let fallback = this.runtime.isReactive || null;
      for (const { keys, callback, passive } of this.acceptors) {
        if (!keys) {
          fallback ||= !passive;
        } else if (passive) {
          keys?.forEach((key) => ignored.add(key));
        } else {
          let hasUpdate2 = false;
          for (const key of keys) {
            hasUpdate2 ||= checkPropertyUpdate(key);
          }
          if (!hasUpdate2)
            continue;
        }
        const result = callback?.(resolved);
        if (result)
          shouldRestart = true;
      }
      for (const key in { ...this.config, ...resolved }) {
        if (fallback === false)
          continue;
        if (!(key in modified) && !ignored.has(key)) {
          const hasUpdate2 = checkPropertyUpdate(key);
          if (fallback === null)
            shouldRestart ||= hasUpdate2;
        }
      }
      return [hasUpdate, shouldRestart];
    }
  };
  var ForkScope = class extends EffectScope {
    constructor(parent, runtime, config, error) {
      super(parent, config);
      this.runtime = runtime;
      this.dispose = (0, import_cosmokit3.defineProperty)(parent.scope.collect(`fork <${parent.runtime.name}>`, () => {
        this.uid = null;
        this.reset();
        this.context.emit("internal/fork", this);
        const result = (0, import_cosmokit3.remove)(runtime.disposables, this.dispose);
        if ((0, import_cosmokit3.remove)(runtime.children, this) && !runtime.children.length) {
          parent.registry.delete(runtime.plugin);
        }
        return result;
      }), Context2.static, runtime);
      runtime.children.push(this);
      runtime.disposables.push(this.dispose);
      this.context.emit("internal/fork", this);
      this.init(error);
    }
    static {
      __name(this, "ForkScope");
    }
    dispose;
    start() {
      if (super.start())
        return true;
      for (const fork of this.runtime.forkables) {
        this.ensure(async () => fork(this.context, this._config));
      }
    }
    update(config, forced) {
      const oldConfig = this.config;
      const state = this.runtime.isForkable ? this : this.runtime;
      if (state.config !== oldConfig)
        return;
      const resolved = resolveConfig(this.runtime.plugin, config);
      const [hasUpdate, shouldRestart] = state.checkUpdate(resolved, forced);
      this.context.emit("internal/before-update", this, config);
      this.config = resolved;
      state.config = resolved;
      if (hasUpdate) {
        this.context.emit("internal/update", this, oldConfig);
      }
      if (shouldRestart)
        state.restart();
    }
  };
  var MainScope = class extends EffectScope {
    constructor(registry, plugin2, config, error) {
      super(registry[Context2.origin], config);
      this.plugin = plugin2;
      registry.set(plugin2, this);
      if (!plugin2) {
        this.name = "root";
        this.isActive = true;
      } else {
        this.setup();
        this.init(error);
      }
    }
    static {
      __name(this, "MainScope");
    }
    value;
    runtime = this;
    schema;
    name;
    using = [];
    inject = new Set;
    forkables = [];
    children = [];
    isReusable = false;
    isReactive = false;
    get isForkable() {
      return this.forkables.length > 0;
    }
    fork(parent, config, error) {
      return new ForkScope(parent, this, config, error);
    }
    dispose() {
      this.uid = null;
      this.reset();
      this.context.emit("internal/runtime", this);
      return true;
    }
    setInject(inject) {
      if (Array.isArray(inject)) {
        for (const name of inject) {
          this.using.push(name);
          this.inject.add(name);
        }
      } else if (inject) {
        for (const name of inject.required || []) {
          this.using.push(name);
          this.inject.add(name);
        }
        for (const name of inject.optional || []) {
          this.inject.add(name);
        }
      }
    }
    setup() {
      const { name } = this.plugin;
      if (name && name !== "apply")
        this.name = name;
      this.schema = this.plugin["Config"] || this.plugin["schema"];
      this.setInject(this.plugin["using"] || this.plugin["inject"]);
      this.isReusable = this.plugin["reusable"];
      this.isReactive = this.plugin["reactive"];
      this.context.emit("internal/runtime", this);
      if (this.isReusable) {
        this.forkables.push(this.apply);
      }
    }
    apply = (context2, config) => {
      if (typeof this.plugin !== "function") {
        return this.plugin.apply(context2, config);
      } else if (isConstructor(this.plugin)) {
        const instance = new this.plugin(context2, config);
        const name = instance[Context2.expose];
        if (name) {
          context2.set(name, instance);
        }
        if (instance["fork"]) {
          this.forkables.push(instance["fork"].bind(instance));
        }
        return instance;
      } else {
        return this.plugin(context2, config);
      }
    };
    reset() {
      super.reset();
      for (const fork of this.children) {
        fork.reset();
      }
    }
    start() {
      if (super.start())
        return true;
      if (!this.isReusable && this.plugin) {
        this.ensure(async () => this.value = this.apply(this.ctx, this._config));
      }
      for (const fork of this.children) {
        fork.start();
      }
    }
    update(config, forced) {
      if (this.isForkable) {
        this.context.emit("internal/warning", new Error(`attempting to update forkable plugin "${this.plugin.name}", which may lead to unexpected behavior`));
      }
      const oldConfig = this.config;
      const resolved = resolveConfig(this.runtime.plugin || this.context.constructor, config);
      const [hasUpdate, shouldRestart] = this.checkUpdate(resolved, forced);
      const state = this.children.find((fork) => fork.config === oldConfig);
      this.config = resolved;
      if (state) {
        this.context.emit("internal/before-update", state, config);
        state.config = resolved;
        if (hasUpdate) {
          this.context.emit("internal/update", state, oldConfig);
        }
      }
      if (shouldRestart)
        this.restart();
    }
  };
  __name(isApplicable, "isApplicable");
  var Registry = class {
    constructor(root, config) {
      this.root = root;
      (0, import_cosmokit4.defineProperty)(this, Context2.origin, root);
      root.scope = new MainScope(this, null, config);
      root.scope.runtime.isReactive = true;
    }
    static {
      __name(this, "Registry");
    }
    _counter = 0;
    _internal = new Map;
    get counter() {
      return ++this._counter;
    }
    get size() {
      return this._internal.size;
    }
    resolve(plugin2, assert = false) {
      if (plugin2 === null)
        return plugin2;
      if (typeof plugin2 === "function")
        return plugin2;
      if (isApplicable(plugin2))
        return plugin2.apply;
      if (assert)
        throw new Error('invalid plugin, expect function or object with an "apply" method, received ' + typeof plugin2);
    }
    get(plugin2) {
      const key = this.resolve(plugin2);
      return key && this._internal.get(key);
    }
    has(plugin2) {
      const key = this.resolve(plugin2);
      return !!key && this._internal.has(key);
    }
    set(plugin2, state) {
      const key = this.resolve(plugin2);
      this._internal.set(key, state);
    }
    delete(plugin2) {
      const key = this.resolve(plugin2);
      const runtime = key && this._internal.get(key);
      if (!runtime)
        return;
      this._internal.delete(key);
      runtime.dispose();
      return runtime;
    }
    keys() {
      return this._internal.keys();
    }
    values() {
      return this._internal.values();
    }
    entries() {
      return this._internal.entries();
    }
    forEach(callback) {
      return this._internal.forEach(callback);
    }
    using(inject, callback) {
      return this.inject(inject, callback);
    }
    inject(inject, callback) {
      return this.plugin({ inject, apply: callback, name: callback.name });
    }
    plugin(plugin2, config) {
      this.resolve(plugin2, true);
      const context2 = this[Context2.origin];
      context2.scope.assertActive();
      let error;
      try {
        config = resolveConfig(plugin2, config);
      } catch (reason) {
        context2.emit("internal/error", reason);
        error = reason;
        config = null;
      }
      let runtime = this.get(plugin2);
      if (runtime) {
        if (!runtime.isForkable) {
          context2.emit("internal/warning", new Error(`duplicate plugin detected: ${plugin2.name}`));
        }
        return runtime.fork(context2, config, error);
      }
      runtime = new MainScope(this, plugin2, config, error);
      return runtime.fork(context2, config, error);
    }
  };
  var Context2 = class _Context {
    static {
      __name(this, "Context");
    }
    static origin = symbols.origin;
    static events = symbols.events;
    static static = symbols.static;
    static filter = symbols.filter;
    static expose = symbols.expose;
    static isolate = symbols.isolate;
    static internal = symbols.internal;
    static intercept = symbols.intercept;
    static current = _Context.origin;
    static is(value) {
      return !!value?.[_Context.is];
    }
    static {
      _Context.is[Symbol.toPrimitive] = () => Symbol.for("cordis.is");
      _Context.prototype[_Context.is] = true;
    }
    static ensureInternal() {
      const ctx = this.prototype || this;
      if (Object.prototype.hasOwnProperty.call(ctx, symbols.internal)) {
        return ctx[symbols.internal];
      }
      const parent = _Context.ensureInternal.call(Object.getPrototypeOf(this));
      return ctx[symbols.internal] = Object.create(parent);
    }
    static resolveInject(ctx, name) {
      let internal = ctx[symbols.internal][name];
      while (internal?.type === "alias") {
        name = internal.name;
        internal = ctx[symbols.internal][name];
      }
      return [name, internal];
    }
    static handler = {
      get(target, prop, ctx) {
        if (typeof prop !== "string")
          return Reflect.get(target, prop, ctx);
        const checkInject = __name((name2) => {
          if (Reflect.has(target, name2))
            return;
          if (["prototype", "then", "registry", "lifecycle"].includes(name2))
            return;
          if (name2[0] === "$" || name2[0] === "_")
            return;
          if (!ctx.runtime.plugin)
            return;
          if (ctx.bail("internal/inject", name2))
            return;
          ctx.emit("internal/warning", new Error(`property ${name2} is not registered, declare it as \`inject\` to suppress this warning`));
        }, "checkInject");
        const [name, internal] = _Context.resolveInject(ctx, prop);
        if (!internal) {
          checkInject(name);
          return Reflect.get(target, name, ctx);
        } else if (internal.type === "accessor") {
          return internal.get.call(ctx);
        } else {
          if (!internal.builtin)
            checkInject(name);
          return ctx.get(name);
        }
      },
      set(target, prop, value, ctx) {
        if (typeof prop !== "string")
          return Reflect.set(target, prop, value, ctx);
        const [name, internal] = _Context.resolveInject(ctx, prop);
        if (!internal)
          return Reflect.set(target, name, value, ctx);
        if (internal.type === "accessor") {
          if (!internal.set)
            return false;
          return internal.set.call(ctx, value);
        } else {
          ctx.set(name, value);
          return true;
        }
      }
    };
    static associate(object, name) {
      return new Proxy(object, {
        get(target, key, receiver) {
          if (typeof key === "symbol")
            return Reflect.get(target, key, receiver);
          const caller = receiver[symbols.origin];
          if (!caller?.[symbols.internal][`${name}.${key}`])
            return Reflect.get(target, key, receiver);
          return caller[`${name}.${key}`];
        },
        set(target, key, value, receiver) {
          if (typeof key === "symbol")
            return Reflect.set(target, key, value, receiver);
          const caller = receiver[symbols.origin];
          if (!caller?.[symbols.internal][`${name}.${key}`])
            return Reflect.set(target, key, value, receiver);
          caller[`${name}.${key}`] = value;
          return true;
        }
      });
    }
    constructor(config) {
      const self2 = new Proxy(this, _Context.handler);
      config = resolveConfig(this.constructor, config);
      self2[symbols.isolate] = Object.create(null);
      self2[symbols.intercept] = Object.create(null);
      self2.root = self2;
      self2.mixin("scope", ["config", "runtime", "effect", "collect", "accept", "decline"]);
      self2.mixin("registry", ["using", "inject", "plugin", "dispose"]);
      self2.mixin("lifecycle", ["on", "once", "off", "after", "parallel", "emit", "serial", "bail", "start", "stop"]);
      self2.provide("registry", new Registry(self2, config), true);
      self2.provide("lifecycle", new Lifecycle(self2), true);
      const attach = __name((internal) => {
        if (!internal)
          return;
        attach(Object.getPrototypeOf(internal));
        for (const key of Object.getOwnPropertyNames(internal)) {
          const constructor = internal[key]["prototype"]?.constructor;
          if (!constructor)
            continue;
          self2[internal[key]["key"]] = new constructor(self2, config);
          (0, import_cosmokit5.defineProperty)(self2[internal[key]["key"]], symbols.origin, self2);
        }
      }, "attach");
      attach(this[symbols.internal]);
      return self2;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `Context <${this.name}>`;
    }
    get name() {
      let runtime = this.runtime;
      while (runtime && !runtime.name) {
        runtime = runtime.parent.runtime;
      }
      return runtime?.name;
    }
    get events() {
      return this.lifecycle;
    }
    get state() {
      return this.scope;
    }
    get(name) {
      const internal = this[symbols.internal][name];
      if (internal?.type !== "service")
        return;
      const value = this.root[this[symbols.isolate][name]];
      if (!value || typeof value !== "object" && typeof value !== "function")
        return value;
      if (isUnproxyable(value)) {
        (0, import_cosmokit5.defineProperty)(value, symbols.origin, this);
        return value;
      }
      return createTraceable(this, value);
    }
    set(name, value) {
      this.provide(name);
      const key = this[symbols.isolate][name];
      const oldValue = this.root[key];
      value ??= undefined;
      let dispose = __name(() => {
      }, "dispose");
      if (oldValue === value)
        return dispose;
      if (!(0, import_cosmokit5.isNullable)(value) && !(0, import_cosmokit5.isNullable)(oldValue)) {
        throw new Error(`service ${name} has been registered`);
      }
      const ctx = this;
      if (!(0, import_cosmokit5.isNullable)(value)) {
        dispose = ctx.effect(() => () => {
          ctx.set(name, undefined);
        });
      }
      if (isUnproxyable(value)) {
        ctx.emit("internal/warning", new Error(`service ${name} is an unproxyable object, which may lead to unexpected behavior`));
      }
      const self2 = Object.create(ctx);
      self2[symbols.filter] = (ctx2) => {
        return ctx[symbols.isolate][name] === ctx2[symbols.isolate][name];
      };
      ctx.emit(self2, "internal/before-service", name, value);
      ctx.root[key] = value;
      if (value instanceof Object) {
        (0, import_cosmokit5.defineProperty)(value, symbols.origin, ctx);
      }
      ctx.emit(self2, "internal/service", name, oldValue);
      return dispose;
    }
    provide(name, value, builtin) {
      const internal = _Context.ensureInternal.call(this.root);
      if (name in internal)
        return;
      const key = Symbol(name);
      internal[name] = { type: "service", builtin };
      this.root[key] = value;
      this.root[_Context.isolate][name] = key;
    }
    accessor(name, options) {
      const internal = _Context.ensureInternal.call(this.root);
      internal[name] ||= { type: "accessor", ...options };
    }
    alias(name, aliases) {
      const internal = _Context.ensureInternal.call(this.root);
      for (const key of aliases) {
        internal[key] ||= { type: "alias", name };
      }
    }
    mixin(name, mixins) {
      const entries = Array.isArray(mixins) ? mixins.map((key) => [key, key]) : Object.entries(mixins);
      for (const [key, value] of entries) {
        this.accessor(value, {
          get() {
            const service = this[name];
            if ((0, import_cosmokit5.isNullable)(service))
              return service;
            const value2 = Reflect.get(service, key);
            if (typeof value2 !== "function")
              return value2;
            return value2.bind(service);
          },
          set(value2) {
            return Reflect.set(this[name], key, value2);
          }
        });
      }
    }
    extend(meta = {}) {
      return Object.assign(Object.create(this), meta);
    }
    isolate(name, label) {
      const shadow = Object.create(this[symbols.isolate]);
      shadow[name] = label ?? Symbol(name);
      return this.extend({ [symbols.isolate]: shadow });
    }
    intercept(name, config) {
      const intercept = Object.create(this[symbols.intercept]);
      intercept[name] = config;
      return this.extend({ [symbols.intercept]: intercept });
    }
  };
  Context2.prototype[Context2.internal] = Object.create(null);
  var import_cosmokit6 = require_lib();
  var Service2 = class _Service {
    static {
      __name(this, "Service");
    }
    static setup = symbols.setup;
    static invoke = symbols.invoke;
    static extend = symbols.extend;
    static provide = symbols.provide;
    static immediate = symbols.immediate;
    start() {
    }
    stop() {
    }
    ctx;
    [symbols.origin];
    name;
    config;
    constructor(...args) {
      let _ctx, name, immediate, config;
      if (Context2.is(args[0])) {
        _ctx = args[0];
        if (typeof args[1] === "string") {
          name = args[1];
          immediate = args[2];
        } else {
          config = args[1];
        }
      } else {
        config = args[0];
      }
      name ??= this.constructor[symbols.provide];
      immediate ??= this.constructor[symbols.immediate];
      let self2 = this;
      if (self2[symbols.invoke]) {
        self2 = createCallable(name, joinPrototype(Object.getPrototypeOf(this), Function.prototype));
      }
      if (_ctx) {
        self2.ctx = _ctx;
      } else {
        self2[symbols.setup]();
      }
      self2.name = name;
      self2.config = config;
      (0, import_cosmokit6.defineProperty)(self2, symbols.origin, self2.ctx);
      self2.ctx.provide(name);
      self2.ctx.runtime.name = name;
      if (immediate) {
        if (_ctx)
          self2[symbols.expose] = name;
        else
          self2.ctx.set(name, self2);
      }
      self2.ctx.on("ready", async () => {
        await Promise.resolve();
        await self2.start();
        if (!immediate)
          self2.ctx.set(name, self2);
      });
      self2.ctx.on("dispose", () => self2.stop());
      return Context2.associate(self2, name);
    }
    [symbols.filter](ctx) {
      return ctx[symbols.isolate][this.name] === this.ctx[symbols.isolate][this.name];
    }
    [symbols.setup]() {
      this.ctx = new Context2;
    }
    [symbols.extend](props) {
      const caller = this[symbols.origin];
      let self2;
      if (this[_Service.invoke]) {
        self2 = createCallable(this.name, this);
      } else {
        self2 = Object.create(this);
      }
      (0, import_cosmokit6.defineProperty)(self2, symbols.origin, caller);
      return Context2.associate(Object.assign(self2, props), this.name);
    }
    static [Symbol.hasInstance](instance) {
      let constructor = instance.constructor;
      while (constructor) {
        if (constructor === this)
          return true;
        constructor = Object.getPrototypeOf(constructor);
      }
      return false;
    }
  };
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// ../../node_modules/reggol/node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var envForceColor = function() {
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        return 1;
      }
      if (env.FORCE_COLOR === "false") {
        return 0;
      }
      return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
  };
  var translateLevel = function(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  };
  var supportsColor = function(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== undefined) {
      flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
      return 0;
    }
    if (sniffFlags) {
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  };
  var getSupportLevel = function(stream2, options = {}) {
    const level = supportsColor(stream2, {
      streamIsTTY: stream2 && stream2.isTTY,
      ...options
    });
    return translateLevel(level);
  };
  var os = __require("os");
  var tty = __require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var flagForceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    flagForceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    flagForceColor = 1;
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
    stderr: getSupportLevel({ isTTY: tty.isatty(2) })
  };
});

// ../../node_modules/reggol/node_modules/cosmokit/lib/index.cjs
var require_lib3 = __commonJS((exports, module) => {
  var noop = function() {
  };
  var isNullable = function(value) {
    return value === null || value === undefined;
  };
  var isPlainObject = function(data) {
    return data && typeof data === "object" && !Array.isArray(data);
  };
  var filterKeys = function(object, filter) {
    return Object.fromEntries(Object.entries(object).filter(([key, value]) => filter(key, value)));
  };
  var mapValues = function(object, transform) {
    return Object.fromEntries(Object.entries(object).map(([key, value]) => [key, transform(value, key)]));
  };
  var is = function(type, value) {
    if (arguments.length === 1)
      return (value2) => is(type, value2);
    return type in globalThis && value instanceof globalThis[type] || Object.prototype.toString.call(value).slice(8, -1) === type;
  };
  var clone = function(source) {
    if (!source || typeof source !== "object")
      return source;
    if (Array.isArray(source))
      return source.map(clone);
    if (is("Date", source))
      return new Date(source.valueOf());
    if (is("RegExp", source))
      return new RegExp(source.source, source.flags);
    return mapValues(source, clone);
  };
  var deepEqual = function(a, b, strict) {
    var _a, _b, _c;
    if (a === b)
      return true;
    if (!strict && isNullable(a) && isNullable(b))
      return true;
    if (typeof a !== typeof b)
      return false;
    if (typeof a !== "object")
      return false;
    if (!a || !b)
      return false;
    function check(test, then) {
      return test(a) ? test(b) ? then(a, b) : false : test(b) ? false : undefined;
    }
    __name(check, "check");
    return (_c = (_b = (_a = check(Array.isArray, (a2, b2) => a2.length === b2.length && a2.every((item, index) => deepEqual(item, b2[index])))) != null ? _a : check(is("Date"), (a2, b2) => a2.valueOf() === b2.valueOf())) != null ? _b : check(is("RegExp"), (a2, b2) => a2.source === b2.source && a2.flags === b2.flags)) != null ? _c : Object.keys({ ...a, ...b }).every((key) => deepEqual(a[key], b[key], strict));
  };
  var pick = function(source, keys, forced) {
    if (!keys)
      return { ...source };
    const result = {};
    for (const key of keys) {
      if (forced || source[key] !== undefined)
        result[key] = source[key];
    }
    return result;
  };
  var omit = function(source, keys) {
    if (!keys)
      return { ...source };
    const result = { ...source };
    for (const key of keys) {
      Reflect.deleteProperty(result, key);
    }
    return result;
  };
  var defineProperty = function(object, key, value) {
    return Object.defineProperty(object, key, { writable: true, value, enumerable: false });
  };
  var contain = function(array1, array2) {
    return array2.every((item) => array1.includes(item));
  };
  var intersection = function(array1, array2) {
    return array1.filter((item) => array2.includes(item));
  };
  var difference = function(array1, array2) {
    return array1.filter((item) => !array2.includes(item));
  };
  var union = function(array1, array2) {
    return Array.from(new Set([...array1, ...array2]));
  };
  var deduplicate = function(array) {
    return [...new Set(array)];
  };
  var remove = function(list, item) {
    const index = list.indexOf(item);
    if (index >= 0) {
      list.splice(index, 1);
      return true;
    } else {
      return false;
    }
  };
  var makeArray = function(source) {
    return Array.isArray(source) ? source : isNullable(source) ? [] : [source];
  };
  var arrayBufferToBase64 = function(buffer) {
    if (typeof Buffer !== "undefined") {
      return Buffer.from(buffer).toString("base64");
    }
    let binary = "";
    const bytes = new Uint8Array(buffer);
    for (let i = 0;i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  };
  var base64ToArrayBuffer = function(base64) {
    if (typeof Buffer !== "undefined") {
      const buf = Buffer.from(base64, "base64");
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
    }
    const binary = atob(base64.replace(/\s/g, ""));
    const buffer = new Uint8Array(binary.length);
    for (let i = 0;i < binary.length; i++) {
      buffer[i] = binary.charCodeAt(i);
    }
    return buffer;
  };
  var capitalize = function(source) {
    return source.charAt(0).toUpperCase() + source.slice(1);
  };
  var uncapitalize = function(source) {
    return source.charAt(0).toLowerCase() + source.slice(1);
  };
  var camelCase = function(source) {
    return source.replace(/[_-][a-z]/g, (str) => str.slice(1).toUpperCase());
  };
  var paramCase = function(source) {
    return uncapitalize(source).replace(/_/g, "-").replace(/.[A-Z]+/g, (str) => str[0] + "-" + str.slice(1).toLowerCase());
  };
  var snakeCase = function(source) {
    return uncapitalize(source).replace(/-/g, "_").replace(/.[A-Z]+/g, (str) => str[0] + "_" + str.slice(1).toLowerCase());
  };
  var trimSlash = function(source) {
    return source.replace(/\/$/, "");
  };
  var sanitize = function(source) {
    if (!source.startsWith("/"))
      source = "/" + source;
    return trimSlash(source);
  };
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Time: () => Time,
    arrayBufferToBase64: () => arrayBufferToBase64,
    base64ToArrayBuffer: () => base64ToArrayBuffer,
    camelCase: () => camelCase,
    camelize: () => camelize,
    capitalize: () => capitalize,
    clone: () => clone,
    contain: () => contain,
    deduplicate: () => deduplicate,
    deepEqual: () => deepEqual,
    defineProperty: () => defineProperty,
    difference: () => difference,
    filterKeys: () => filterKeys,
    hyphenate: () => hyphenate,
    intersection: () => intersection,
    is: () => is,
    isNullable: () => isNullable,
    isPlainObject: () => isPlainObject,
    makeArray: () => makeArray,
    mapValues: () => mapValues,
    noop: () => noop,
    omit: () => omit,
    paramCase: () => paramCase,
    pick: () => pick,
    remove: () => remove,
    sanitize: () => sanitize,
    snakeCase: () => snakeCase,
    trimSlash: () => trimSlash,
    uncapitalize: () => uncapitalize,
    union: () => union,
    valueMap: () => mapValues
  });
  module.exports = __toCommonJS(src_exports);
  __name(noop, "noop");
  __name(isNullable, "isNullable");
  __name(isPlainObject, "isPlainObject");
  __name(filterKeys, "filterKeys");
  __name(mapValues, "mapValues");
  __name(is, "is");
  __name(clone, "clone");
  __name(deepEqual, "deepEqual");
  __name(pick, "pick");
  __name(omit, "omit");
  __name(defineProperty, "defineProperty");
  __name(contain, "contain");
  __name(intersection, "intersection");
  __name(difference, "difference");
  __name(union, "union");
  __name(deduplicate, "deduplicate");
  __name(remove, "remove");
  __name(makeArray, "makeArray");
  __name(arrayBufferToBase64, "arrayBufferToBase64");
  __name(base64ToArrayBuffer, "base64ToArrayBuffer");
  __name(capitalize, "capitalize");
  __name(uncapitalize, "uncapitalize");
  __name(camelCase, "camelCase");
  __name(paramCase, "paramCase");
  __name(snakeCase, "snakeCase");
  var camelize = camelCase;
  var hyphenate = paramCase;
  __name(trimSlash, "trimSlash");
  __name(sanitize, "sanitize");
  var Time;
  ((Time2) => {
    Time2.millisecond = 1;
    Time2.second = 1000;
    Time2.minute = Time2.second * 60;
    Time2.hour = Time2.minute * 60;
    Time2.day = Time2.hour * 24;
    Time2.week = Time2.day * 7;
    let timezoneOffset = (new Date()).getTimezoneOffset();
    function setTimezoneOffset(offset) {
      timezoneOffset = offset;
    }
    Time2.setTimezoneOffset = setTimezoneOffset;
    __name(setTimezoneOffset, "setTimezoneOffset");
    function getTimezoneOffset() {
      return timezoneOffset;
    }
    Time2.getTimezoneOffset = getTimezoneOffset;
    __name(getTimezoneOffset, "getTimezoneOffset");
    function getDateNumber(date = new Date, offset) {
      if (typeof date === "number")
        date = new Date(date);
      if (offset === undefined)
        offset = timezoneOffset;
      return Math.floor((date.valueOf() / Time2.minute - offset) / 1440);
    }
    Time2.getDateNumber = getDateNumber;
    __name(getDateNumber, "getDateNumber");
    function fromDateNumber(value, offset) {
      const date = new Date(value * Time2.day);
      if (offset === undefined)
        offset = timezoneOffset;
      return new Date(+date + offset * Time2.minute);
    }
    Time2.fromDateNumber = fromDateNumber;
    __name(fromDateNumber, "fromDateNumber");
    const numeric = /\d+(?:\.\d+)?/.source;
    const timeRegExp = new RegExp(`^${[
      "w(?:eek(?:s)?)?",
      "d(?:ay(?:s)?)?",
      "h(?:our(?:s)?)?",
      "m(?:in(?:ute)?(?:s)?)?",
      "s(?:ec(?:ond)?(?:s)?)?"
    ].map((unit) => `(${numeric}${unit})?`).join("")}\$`);
    function parseTime(source) {
      const capture = timeRegExp.exec(source);
      if (!capture)
        return 0;
      return (parseFloat(capture[1]) * Time2.week || 0) + (parseFloat(capture[2]) * Time2.day || 0) + (parseFloat(capture[3]) * Time2.hour || 0) + (parseFloat(capture[4]) * Time2.minute || 0) + (parseFloat(capture[5]) * Time2.second || 0);
    }
    Time2.parseTime = parseTime;
    __name(parseTime, "parseTime");
    function parseDate(date) {
      const parsed = parseTime(date);
      if (parsed) {
        date = Date.now() + parsed;
      } else if (/^\d{1,2}(:\d{1,2}){1,2}$/.test(date)) {
        date = `${(new Date()).toLocaleDateString()}-${date}`;
      } else if (/^\d{1,2}-\d{1,2}-\d{1,2}(:\d{1,2}){1,2}$/.test(date)) {
        date = `${(new Date()).getFullYear()}-${date}`;
      }
      return date ? new Date(date) : new Date;
    }
    Time2.parseDate = parseDate;
    __name(parseDate, "parseDate");
    function format(ms) {
      const abs = Math.abs(ms);
      if (abs >= Time2.day - Time2.hour / 2) {
        return Math.round(ms / Time2.day) + "d";
      } else if (abs >= Time2.hour - Time2.minute / 2) {
        return Math.round(ms / Time2.hour) + "h";
      } else if (abs >= Time2.minute - Time2.second / 2) {
        return Math.round(ms / Time2.minute) + "m";
      } else if (abs >= Time2.second) {
        return Math.round(ms / Time2.second) + "s";
      }
      return ms + "ms";
    }
    Time2.format = format;
    __name(format, "format");
    function toDigits(source, length = 2) {
      return source.toString().padStart(length, "0");
    }
    Time2.toDigits = toDigits;
    __name(toDigits, "toDigits");
    function template(template2, time = new Date) {
      return template2.replace("yyyy", time.getFullYear().toString()).replace("yy", time.getFullYear().toString().slice(2)).replace("MM", toDigits(time.getMonth() + 1)).replace("dd", toDigits(time.getDate())).replace("hh", toDigits(time.getHours())).replace("mm", toDigits(time.getMinutes())).replace("ss", toDigits(time.getSeconds())).replace("SSS", toDigits(time.getMilliseconds(), 3));
    }
    Time2.template = template;
    __name(template, "template");
  })(Time || (Time = {}));
});

// ../../node_modules/reggol/lib/shared.js
var require_shared = __commonJS((exports, module) => {
  var isAggregateError = function(error) {
    return error instanceof Error && Array.isArray(error["errors"]);
  };
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var import_supports_color = require_supports_color();
  var import_cosmokit = require_lib3();
  var c16 = [6, 2, 3, 4, 5, 1];
  var c256 = [
    20,
    21,
    26,
    27,
    32,
    33,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    56,
    57,
    62,
    63,
    68,
    69,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    92,
    93,
    98,
    99,
    112,
    113,
    129,
    134,
    135,
    148,
    149,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    178,
    179,
    184,
    185,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    214,
    215,
    220,
    221
  ];
  __name(isAggregateError, "isAggregateError");
  var _Logger = class _Logger2 {
    constructor(name, meta) {
      this.name = name;
      this.meta = meta;
      this.createMethod("success", _Logger2.SUCCESS);
      this.createMethod("error", _Logger2.ERROR);
      this.createMethod("info", _Logger2.INFO);
      this.createMethod("warn", _Logger2.WARN);
      this.createMethod("debug", _Logger2.DEBUG);
    }
    static format(name, formatter) {
      this.formatters[name] = formatter;
    }
    static color(target, code, value, decoration = "") {
      if (!target.colors)
        return "" + value;
      return `\x1B[3${code < 8 ? code : "8;5;" + code}${target.colors >= 2 ? decoration : ""}m${value}\x1B[0m`;
    }
    static code(name, target) {
      let hash = 0;
      for (let i = 0;i < name.length; i++) {
        hash = (hash << 3) - hash + name.charCodeAt(i) + 13;
        hash |= 0;
      }
      const colors = !target.colors ? [] : target.colors >= 2 ? c256 : c16;
      return colors[Math.abs(hash) % colors.length];
    }
    static render(target, record) {
      var _a, _b, _c, _d, _e, _f;
      const prefix = `[${record.type[0].toUpperCase()}]`;
      const space = " ".repeat((_b = (_a = target.label) == null ? undefined : _a.margin) != null ? _b : 1);
      let indent = 3 + space.length, output = "";
      if (target.showTime) {
        indent += target.showTime.length + space.length;
        output += _Logger2.color(target, 8, import_cosmokit.Time.template(target.showTime)) + space;
      }
      const code = _Logger2.code(record.name, target);
      const label = _Logger2.color(target, code, record.name, ";1");
      const padLength = ((_d = (_c = target.label) == null ? undefined : _c.width) != null ? _d : 0) + label.length - record.name.length;
      if (((_e = target.label) == null ? undefined : _e.align) === "right") {
        output += label.padStart(padLength) + space + prefix + space;
        indent += ((_f = target.label.width) != null ? _f : 0) + space.length;
      } else {
        output += prefix + space + label.padEnd(padLength) + space;
      }
      output += record.content.replace(/\n/g, "\n" + " ".repeat(indent));
      if (target.showDiff && target.timestamp) {
        const diff = record.timestamp - target.timestamp;
        output += _Logger2.color(target, code, " +" + import_cosmokit.Time.format(diff));
      }
      return output;
    }
    extend = (namespace) => {
      return new _Logger2(`${this.name}:${namespace}`);
    };
    warning = (format, ...args) => {
      this.warn(format, ...args);
    };
    createMethod(type, level) {
      this[type] = (...args) => {
        if (args.length === 1 && args[0] instanceof Error) {
          if (args[0].cause) {
            this[type](args[0].cause);
          } else if (isAggregateError(args[0])) {
            args[0].errors.forEach((error) => this[type](error));
            return;
          }
        }
        const id = ++_Logger2.id;
        const timestamp = Date.now();
        for (const target of _Logger2.targets) {
          if (this.getLevel(target) < level)
            continue;
          const content = this.format(target, ...args);
          const record = { id, type, level, name: this.name, meta: this.meta, content, timestamp };
          if (target.record) {
            target.record(record);
          } else {
            const { print = console.log } = target;
            print(_Logger2.render(target, record));
          }
          target.timestamp = timestamp;
        }
      };
    }
    format(target, ...args) {
      if (args[0] instanceof Error) {
        args[0] = args[0].stack || args[0].message;
        args.unshift("%s");
      } else if (typeof args[0] !== "string") {
        args.unshift("%o");
      }
      let format = args.shift();
      format = format.replace(/%([a-zA-Z%])/g, (match, char) => {
        if (match === "%%")
          return "%";
        const formatter = _Logger2.formatters[char];
        if (typeof formatter === "function") {
          const value = args.shift();
          return formatter(value, target, this);
        }
        return match;
      });
      for (let arg of args) {
        if (typeof arg === "object" && arg) {
          arg = _Logger2.formatters["o"](arg, target, this);
        }
        format += " " + arg;
      }
      const { maxLength = 10240 } = target;
      return format.split(/\r?\n/g).map((line) => {
        return line.slice(0, maxLength) + (line.length > maxLength ? "..." : "");
      }).join("\n");
    }
    getLevel(target) {
      var _a;
      const paths = this.name.split(":");
      let config = (target == null ? undefined : target.levels) || _Logger2.levels;
      do {
        config = (_a = config[paths.shift()]) != null ? _a : config["base"];
      } while (paths.length && typeof config === "object");
      return config;
    }
    get level() {
      return this.getLevel();
    }
    set level(value) {
      const paths = this.name.split(":");
      let config = _Logger2.levels;
      while (paths.length > 1) {
        const name = paths.shift();
        const value2 = config[name];
        if (typeof value2 === "object") {
          config = value2;
        } else {
          config = config[name] = { base: value2 != null ? value2 : config.base };
        }
      }
      config[paths[0]] = value;
    }
  };
  __name(_Logger, "Logger");
  __publicField(_Logger, "SILENT", 0);
  __publicField(_Logger, "SUCCESS", 1);
  __publicField(_Logger, "ERROR", 1);
  __publicField(_Logger, "INFO", 2);
  __publicField(_Logger, "WARN", 2);
  __publicField(_Logger, "DEBUG", 3);
  __publicField(_Logger, "id", 0);
  __publicField(_Logger, "targets", [{
    colors: import_supports_color.stdout && import_supports_color.stdout.level,
    print(text) {
      console.log(text);
    }
  }]);
  __publicField(_Logger, "formatters", Object.create(null));
  __publicField(_Logger, "levels", {
    base: 2
  });
  var Logger2 = _Logger;
  Logger2.format("s", (value) => value);
  Logger2.format("d", (value) => +value);
  Logger2.format("j", (value) => JSON.stringify(value));
  Logger2.format("c", (value, target, logger) => {
    return Logger2.color(target, Logger2.code(logger.name, target), value);
  });
  Logger2.format("C", (value, target) => {
    return Logger2.color(target, 15, value, ";1");
  });
  module.exports = Logger2;
});

// ../../node_modules/reggol/lib/node.js
var require_node = __commonJS((exports, module) => {
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var import_util = __require("util");
  var import_shared = __toESM2(require_shared());
  import_shared.default.format("o", (value, target) => {
    return (0, import_util.inspect)(value, { colors: !!target.colors, depth: Infinity }).replace(/\s*\n\s*/g, " ");
  });
  module.exports = import_shared.default;
});

// ../../node_modules/@cordisjs/logger/lib/index.cjs
var require_lib4 = __commonJS((exports, module) => {
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Logger: () => import_reggol.default,
    LoggerService: () => LoggerService,
    default: () => src_default
  });
  module.exports = __toCommonJS(src_exports);
  var import_core = require_lib2();
  var import_reggol = __toESM2(require_node(), 1);
  var LoggerService = class _LoggerService extends import_core.Service {
    static {
      __name(this, "LoggerService");
    }
    static [import_core.Service.provide] = "logger";
    constructor(ctx) {
      super(ctx, "logger", true);
      ctx.on("internal/info", function(format, ...args) {
        this.logger("app").info(format, ...args);
      });
      ctx.on("internal/error", function(format, ...args) {
        this.logger("app").error(format, ...args);
      });
      ctx.on("internal/warning", function(format, ...args) {
        this.logger("app").warn(format, ...args);
      });
    }
    [import_core.Service.invoke](name) {
      return new import_reggol.default(name, { [import_core.Context.current]: this });
    }
    static {
      for (const type of ["success", "error", "info", "warn", "debug", "extend"]) {
        _LoggerService.prototype[type] = function(...args) {
          const caller = this[import_core.Context.current];
          return this(caller.name)[type](...args);
        };
      }
    }
  };
  var src_default = LoggerService;
});

// ../../node_modules/@cordisjs/timer/node_modules/cosmokit/lib/index.cjs
var require_lib5 = __commonJS((exports, module) => {
  var noop = function() {
  };
  var isNullable = function(value) {
    return value === null || value === undefined;
  };
  var isPlainObject = function(data) {
    return data && typeof data === "object" && !Array.isArray(data);
  };
  var filterKeys = function(object, filter) {
    return Object.fromEntries(Object.entries(object).filter(([key, value]) => filter(key, value)));
  };
  var mapValues = function(object, transform) {
    return Object.fromEntries(Object.entries(object).map(([key, value]) => [key, transform(value, key)]));
  };
  var is = function(type, value) {
    if (arguments.length === 1)
      return (value2) => is(type, value2);
    return type in globalThis && value instanceof globalThis[type] || Object.prototype.toString.call(value).slice(8, -1) === type;
  };
  var clone = function(source) {
    if (!source || typeof source !== "object")
      return source;
    if (Array.isArray(source))
      return source.map(clone);
    if (is("Date", source))
      return new Date(source.valueOf());
    if (is("RegExp", source))
      return new RegExp(source.source, source.flags);
    return mapValues(source, clone);
  };
  var deepEqual = function(a, b, strict) {
    var _a, _b, _c;
    if (a === b)
      return true;
    if (!strict && isNullable(a) && isNullable(b))
      return true;
    if (typeof a !== typeof b)
      return false;
    if (typeof a !== "object")
      return false;
    if (!a || !b)
      return false;
    function check(test, then) {
      return test(a) ? test(b) ? then(a, b) : false : test(b) ? false : undefined;
    }
    __name(check, "check");
    return (_c = (_b = (_a = check(Array.isArray, (a2, b2) => a2.length === b2.length && a2.every((item, index) => deepEqual(item, b2[index])))) != null ? _a : check(is("Date"), (a2, b2) => a2.valueOf() === b2.valueOf())) != null ? _b : check(is("RegExp"), (a2, b2) => a2.source === b2.source && a2.flags === b2.flags)) != null ? _c : Object.keys({ ...a, ...b }).every((key) => deepEqual(a[key], b[key], strict));
  };
  var pick = function(source, keys, forced) {
    if (!keys)
      return { ...source };
    const result = {};
    for (const key of keys) {
      if (forced || source[key] !== undefined)
        result[key] = source[key];
    }
    return result;
  };
  var omit = function(source, keys) {
    if (!keys)
      return { ...source };
    const result = { ...source };
    for (const key of keys) {
      Reflect.deleteProperty(result, key);
    }
    return result;
  };
  var defineProperty = function(object, key, value) {
    return Object.defineProperty(object, key, { writable: true, value, enumerable: false });
  };
  var contain = function(array1, array2) {
    return array2.every((item) => array1.includes(item));
  };
  var intersection = function(array1, array2) {
    return array1.filter((item) => array2.includes(item));
  };
  var difference = function(array1, array2) {
    return array1.filter((item) => !array2.includes(item));
  };
  var union = function(array1, array2) {
    return Array.from(new Set([...array1, ...array2]));
  };
  var deduplicate = function(array) {
    return [...new Set(array)];
  };
  var remove = function(list, item) {
    const index = list.indexOf(item);
    if (index >= 0) {
      list.splice(index, 1);
      return true;
    } else {
      return false;
    }
  };
  var makeArray = function(source) {
    return Array.isArray(source) ? source : isNullable(source) ? [] : [source];
  };
  var arrayBufferToBase64 = function(buffer) {
    if (typeof Buffer !== "undefined") {
      return Buffer.from(buffer).toString("base64");
    }
    let binary = "";
    const bytes = new Uint8Array(buffer);
    for (let i = 0;i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  };
  var base64ToArrayBuffer = function(base64) {
    if (typeof Buffer !== "undefined") {
      const buf = Buffer.from(base64, "base64");
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
    }
    const binary = atob(base64.replace(/\s/g, ""));
    const buffer = new Uint8Array(binary.length);
    for (let i = 0;i < binary.length; i++) {
      buffer[i] = binary.charCodeAt(i);
    }
    return buffer;
  };
  var capitalize = function(source) {
    return source.charAt(0).toUpperCase() + source.slice(1);
  };
  var uncapitalize = function(source) {
    return source.charAt(0).toLowerCase() + source.slice(1);
  };
  var camelCase = function(source) {
    return source.replace(/[_-][a-z]/g, (str) => str.slice(1).toUpperCase());
  };
  var paramCase = function(source) {
    return uncapitalize(source).replace(/_/g, "-").replace(/.[A-Z]+/g, (str) => str[0] + "-" + str.slice(1).toLowerCase());
  };
  var snakeCase = function(source) {
    return uncapitalize(source).replace(/-/g, "_").replace(/.[A-Z]+/g, (str) => str[0] + "_" + str.slice(1).toLowerCase());
  };
  var trimSlash = function(source) {
    return source.replace(/\/$/, "");
  };
  var sanitize = function(source) {
    if (!source.startsWith("/"))
      source = "/" + source;
    return trimSlash(source);
  };
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Time: () => Time,
    arrayBufferToBase64: () => arrayBufferToBase64,
    base64ToArrayBuffer: () => base64ToArrayBuffer,
    camelCase: () => camelCase,
    camelize: () => camelize,
    capitalize: () => capitalize,
    clone: () => clone,
    contain: () => contain,
    deduplicate: () => deduplicate,
    deepEqual: () => deepEqual,
    defineProperty: () => defineProperty,
    difference: () => difference,
    filterKeys: () => filterKeys,
    hyphenate: () => hyphenate,
    intersection: () => intersection,
    is: () => is,
    isNullable: () => isNullable,
    isPlainObject: () => isPlainObject,
    makeArray: () => makeArray,
    mapValues: () => mapValues,
    noop: () => noop,
    omit: () => omit,
    paramCase: () => paramCase,
    pick: () => pick,
    remove: () => remove,
    sanitize: () => sanitize,
    snakeCase: () => snakeCase,
    trimSlash: () => trimSlash,
    uncapitalize: () => uncapitalize,
    union: () => union,
    valueMap: () => mapValues
  });
  module.exports = __toCommonJS(src_exports);
  __name(noop, "noop");
  __name(isNullable, "isNullable");
  __name(isPlainObject, "isPlainObject");
  __name(filterKeys, "filterKeys");
  __name(mapValues, "mapValues");
  __name(is, "is");
  __name(clone, "clone");
  __name(deepEqual, "deepEqual");
  __name(pick, "pick");
  __name(omit, "omit");
  __name(defineProperty, "defineProperty");
  __name(contain, "contain");
  __name(intersection, "intersection");
  __name(difference, "difference");
  __name(union, "union");
  __name(deduplicate, "deduplicate");
  __name(remove, "remove");
  __name(makeArray, "makeArray");
  __name(arrayBufferToBase64, "arrayBufferToBase64");
  __name(base64ToArrayBuffer, "base64ToArrayBuffer");
  __name(capitalize, "capitalize");
  __name(uncapitalize, "uncapitalize");
  __name(camelCase, "camelCase");
  __name(paramCase, "paramCase");
  __name(snakeCase, "snakeCase");
  var camelize = camelCase;
  var hyphenate = paramCase;
  __name(trimSlash, "trimSlash");
  __name(sanitize, "sanitize");
  var Time;
  ((Time2) => {
    Time2.millisecond = 1;
    Time2.second = 1000;
    Time2.minute = Time2.second * 60;
    Time2.hour = Time2.minute * 60;
    Time2.day = Time2.hour * 24;
    Time2.week = Time2.day * 7;
    let timezoneOffset = (new Date()).getTimezoneOffset();
    function setTimezoneOffset(offset) {
      timezoneOffset = offset;
    }
    Time2.setTimezoneOffset = setTimezoneOffset;
    __name(setTimezoneOffset, "setTimezoneOffset");
    function getTimezoneOffset() {
      return timezoneOffset;
    }
    Time2.getTimezoneOffset = getTimezoneOffset;
    __name(getTimezoneOffset, "getTimezoneOffset");
    function getDateNumber(date = new Date, offset) {
      if (typeof date === "number")
        date = new Date(date);
      if (offset === undefined)
        offset = timezoneOffset;
      return Math.floor((date.valueOf() / Time2.minute - offset) / 1440);
    }
    Time2.getDateNumber = getDateNumber;
    __name(getDateNumber, "getDateNumber");
    function fromDateNumber(value, offset) {
      const date = new Date(value * Time2.day);
      if (offset === undefined)
        offset = timezoneOffset;
      return new Date(+date + offset * Time2.minute);
    }
    Time2.fromDateNumber = fromDateNumber;
    __name(fromDateNumber, "fromDateNumber");
    const numeric = /\d+(?:\.\d+)?/.source;
    const timeRegExp = new RegExp(`^${[
      "w(?:eek(?:s)?)?",
      "d(?:ay(?:s)?)?",
      "h(?:our(?:s)?)?",
      "m(?:in(?:ute)?(?:s)?)?",
      "s(?:ec(?:ond)?(?:s)?)?"
    ].map((unit) => `(${numeric}${unit})?`).join("")}\$`);
    function parseTime(source) {
      const capture = timeRegExp.exec(source);
      if (!capture)
        return 0;
      return (parseFloat(capture[1]) * Time2.week || 0) + (parseFloat(capture[2]) * Time2.day || 0) + (parseFloat(capture[3]) * Time2.hour || 0) + (parseFloat(capture[4]) * Time2.minute || 0) + (parseFloat(capture[5]) * Time2.second || 0);
    }
    Time2.parseTime = parseTime;
    __name(parseTime, "parseTime");
    function parseDate(date) {
      const parsed = parseTime(date);
      if (parsed) {
        date = Date.now() + parsed;
      } else if (/^\d{1,2}(:\d{1,2}){1,2}$/.test(date)) {
        date = `${(new Date()).toLocaleDateString()}-${date}`;
      } else if (/^\d{1,2}-\d{1,2}-\d{1,2}(:\d{1,2}){1,2}$/.test(date)) {
        date = `${(new Date()).getFullYear()}-${date}`;
      }
      return date ? new Date(date) : new Date;
    }
    Time2.parseDate = parseDate;
    __name(parseDate, "parseDate");
    function format(ms) {
      const abs = Math.abs(ms);
      if (abs >= Time2.day - Time2.hour / 2) {
        return Math.round(ms / Time2.day) + "d";
      } else if (abs >= Time2.hour - Time2.minute / 2) {
        return Math.round(ms / Time2.hour) + "h";
      } else if (abs >= Time2.minute - Time2.second / 2) {
        return Math.round(ms / Time2.minute) + "m";
      } else if (abs >= Time2.second) {
        return Math.round(ms / Time2.second) + "s";
      }
      return ms + "ms";
    }
    Time2.format = format;
    __name(format, "format");
    function toDigits(source, length = 2) {
      return source.toString().padStart(length, "0");
    }
    Time2.toDigits = toDigits;
    __name(toDigits, "toDigits");
    function template(template2, time = new Date) {
      return template2.replace("yyyy", time.getFullYear().toString()).replace("yy", time.getFullYear().toString().slice(2)).replace("MM", toDigits(time.getMonth() + 1)).replace("dd", toDigits(time.getDate())).replace("hh", toDigits(time.getHours())).replace("mm", toDigits(time.getMinutes())).replace("ss", toDigits(time.getSeconds())).replace("SSS", toDigits(time.getMilliseconds(), 3));
    }
    Time2.template = template;
    __name(template, "template");
  })(Time || (Time = {}));
});

// ../../node_modules/@cordisjs/timer/lib/index.cjs
var require_lib6 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    TimerService: () => TimerService2,
    default: () => src_default
  });
  module.exports = __toCommonJS(src_exports);
  var import_core = require_lib2();
  var import_cosmokit = require_lib5();
  var TimerService2 = class extends import_core.Service {
    static {
      __name(this, "TimerService");
    }
    constructor(ctx) {
      super(ctx, "timer", true);
      ctx.mixin("timer", ["setTimeout", "setInterval", "sleep", "throttle", "debounce"]);
    }
    setTimeout(callback, delay) {
      const dispose = this[import_core.Context.current].effect(() => {
        const timer = setTimeout(() => {
          dispose();
          callback();
        }, delay);
        return () => clearTimeout(timer);
      });
      return dispose;
    }
    setInterval(callback, delay) {
      return this[import_core.Context.current].effect(() => {
        const timer = setInterval(callback, delay);
        return () => clearInterval(timer);
      });
    }
    sleep(delay) {
      const caller = this[import_core.Context.current];
      return new Promise((resolve2, reject2) => {
        const dispose1 = this.setTimeout(() => {
          dispose1();
          dispose2();
          resolve2();
        }, delay);
        const dispose2 = caller.on("dispose", () => {
          dispose1();
          dispose2();
          reject2(new Error("Context has been disposed"));
        });
      });
    }
    createWrapper(callback, isDisposed = false) {
      const caller = this[import_core.Context.current];
      caller.scope.assertActive();
      let timer;
      const dispose = __name(() => {
        isDisposed = true;
        (0, import_cosmokit.remove)(caller.scope.disposables, dispose);
        clearTimeout(timer);
      }, "dispose");
      const wrapper = __name((...args) => {
        clearTimeout(timer);
        timer = callback(args, () => !isDisposed && caller.scope.isActive);
      }, "wrapper");
      wrapper.dispose = dispose;
      caller.scope.disposables.push(dispose);
      return wrapper;
    }
    throttle(callback, delay, noTrailing) {
      let lastCall = -Infinity;
      const execute = __name((...args) => {
        lastCall = Date.now();
        callback(...args);
      }, "execute");
      return this.createWrapper((args, isActive) => {
        const now = Date.now();
        const remaining = delay - (now - lastCall);
        if (remaining <= 0) {
          execute(...args);
        } else if (isActive()) {
          return setTimeout(execute, remaining, ...args);
        }
      }, noTrailing);
    }
    debounce(callback, delay) {
      return this.createWrapper((args, isActive) => {
        if (!isActive())
          return;
        return setTimeout(callback, delay, ...args);
      });
    }
  };
  var src_default = TimerService2;
});

// ../../node_modules/schemastery/lib/index.cjs
var require_lib7 = __commonJS((exports, module) => {
  var mergeDesc = function(original, messages) {
    const result = typeof original === "string" ? { "": original } : { ...original };
    for (const locale in messages) {
      const value = messages[locale];
      if (value?.$description || value?.$desc) {
        result[locale] = value.$description || value.$desc;
      } else if (typeof value === "string") {
        result[locale] = value;
      }
    }
    return result;
  };
  var getInner = function(value) {
    return value?.$value ?? value?.$inner;
  };
  var extractKeys = function(data) {
    return (0, import_cosmokit.filterKeys)(data ?? {}, (key) => !key.startsWith("$"));
  };
  var checkWithinRange = function(data, meta, description, skipMin = false) {
    const { max = Infinity, min = -Infinity } = meta;
    if (data > max)
      throw new TypeError(`expected ${description} <= ${max} but got ${data}`);
    if (data < min && !skipMin)
      throw new TypeError(`expected ${description} >= ${min} but got ${data}`);
  };
  var decimalShift = function(data, digits) {
    const str = data.toString();
    if (str.includes("e"))
      return data * Math.pow(10, digits);
    const index = str.indexOf(".");
    if (index === -1)
      return data * Math.pow(10, digits);
    const frac = str.slice(index + 1);
    const integer = str.slice(0, index);
    if (frac.length <= digits)
      return +(integer + frac.padEnd(digits, "0"));
    return +(integer + frac.slice(0, digits) + "." + frac.slice(digits));
  };
  var isMultipleOf = function(data, min, step) {
    step = Math.abs(step);
    if (!/^\d+\.\d+$/.test(step.toString())) {
      return (data - min) % step === 0;
    }
    const index = step.toString().indexOf(".");
    const digits = step.toString().slice(index + 1).length;
    return Math.abs(decimalShift(data, digits) - decimalShift(min, digits)) % decimalShift(step, digits) === 0;
  };
  var property = function(data, key, schema, options) {
    try {
      const [value, adapted] = Schema2.resolve(data[key], schema, options);
      if (adapted !== undefined)
        data[key] = adapted;
      return value;
    } catch (e) {
      if (!options?.autofix)
        throw e;
      delete data[key];
      return schema.meta.default;
    }
  };
  var merge = function(result, data) {
    for (const key in data) {
      if (key in result)
        continue;
      result[key] = data[key];
    }
  };
  var defineMethod = function(name, keys, format) {
    formatters[name] = format;
    Object.assign(Schema2, {
      [name](...args) {
        const schema = new Schema2({ type: name });
        keys.forEach((key, index) => {
          switch (key) {
            case "sKey":
              schema.sKey = args[index] ?? Schema2.string();
              break;
            case "inner":
              schema.inner = Schema2.from(args[index]);
              break;
            case "list":
              schema.list = args[index].map(Schema2.from);
              break;
            case "dict":
              schema.dict = (0, import_cosmokit.valueMap)(args[index], Schema2.from);
              break;
            case "bits": {
              schema.bits = {};
              for (const key2 in args[index]) {
                if (typeof args[index][key2] !== "number")
                  continue;
                schema.bits[key2] = args[index][key2];
              }
              break;
            }
            case "callback": {
              schema.callback = args[index];
              schema.callback["toJSON"] ||= () => schema.callback.toString();
              break;
            }
            default:
              schema[key] = args[index];
          }
        });
        if (name === "object" || name === "dict") {
          schema.meta.default = {};
        } else if (name === "array" || name === "tuple") {
          schema.meta.default = [];
        } else if (name === "bitset") {
          schema.meta.default = 0;
        }
        return schema;
      }
    });
  };
  var __defProp2 = Object.defineProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var import_cosmokit = require_lib();
  var kSchema = Symbol.for("schemastery");
  globalThis.__schemastery_index__ ??= 0;
  var Schema2 = __name(function(options) {
    const schema = __name(function(data, options2) {
      return Schema2.resolve(data, schema, options2)[0];
    }, "schema");
    if (options.refs) {
      const refs2 = (0, import_cosmokit.valueMap)(options.refs, (options2) => new Schema2(options2));
      const getRef = __name((uid) => refs2[uid], "getRef");
      for (const key in refs2) {
        const options2 = refs2[key];
        options2.sKey = getRef(options2.sKey);
        options2.inner = getRef(options2.inner);
        options2.list = options2.list && options2.list.map(getRef);
        options2.dict = options2.dict && (0, import_cosmokit.valueMap)(options2.dict, getRef);
      }
      return refs2[options.uid];
    }
    Object.assign(schema, options);
    if (typeof schema.callback === "string") {
      try {
        schema.callback = new Function("return " + schema.callback)();
      } catch {
      }
    }
    Object.defineProperty(schema, "uid", { value: globalThis.__schemastery_index__++ });
    Object.setPrototypeOf(schema, Schema2.prototype);
    schema.meta ||= {};
    schema.toString = schema.toString.bind(schema);
    return schema;
  }, "Schema");
  Schema2.prototype = Object.create(Function.prototype);
  Schema2.prototype[kSchema] = true;
  var refs;
  Schema2.prototype.toJSON = __name(function toJSON() {
    if (refs) {
      refs[this.uid] ??= JSON.parse(JSON.stringify({ ...this }));
      return this.uid;
    }
    refs = { [this.uid]: { ...this } };
    refs[this.uid] = JSON.parse(JSON.stringify({ ...this }));
    const result = { uid: this.uid, refs };
    refs = undefined;
    return result;
  }, "toJSON");
  Schema2.prototype.set = __name(function set(key, value) {
    this.dict[key] = value;
    return this;
  }, "set");
  Schema2.prototype.push = __name(function push(value) {
    this.list.push(value);
    return this;
  }, "push");
  __name(mergeDesc, "mergeDesc");
  __name(getInner, "getInner");
  __name(extractKeys, "extractKeys");
  Schema2.prototype.i18n = __name(function i18n(messages) {
    const schema = Schema2(this);
    schema.meta.description = mergeDesc(schema.meta.description, messages);
    if (schema.dict) {
      schema.dict = (0, import_cosmokit.valueMap)(schema.dict, (inner, key) => {
        return inner.i18n((0, import_cosmokit.valueMap)(messages, (data) => getInner(data)?.[key] ?? data?.[key]));
      });
    }
    if (schema.list) {
      schema.list = schema.list.map((inner, index) => {
        return inner.i18n((0, import_cosmokit.valueMap)(messages, (data = {}) => {
          if (Array.isArray(getInner(data)))
            return getInner(data)[index];
          if (Array.isArray(data))
            return data[index];
          return extractKeys(data);
        }));
      });
    }
    if (schema.inner) {
      schema.inner = schema.inner.i18n((0, import_cosmokit.valueMap)(messages, (data) => {
        if (getInner(data))
          return getInner(data);
        return extractKeys(data);
      }));
    }
    if (schema.sKey) {
      schema.sKey = schema.sKey.i18n((0, import_cosmokit.valueMap)(messages, (data) => data?.$key));
    }
    return schema;
  }, "i18n");
  Schema2.prototype.extra = __name(function extra(key, value) {
    const schema = Schema2(this);
    schema.meta = { ...schema.meta, [key]: value };
    return schema;
  }, "extra");
  for (const key of ["required", "disabled", "collapse", "hidden", "loose"]) {
    Object.assign(Schema2.prototype, {
      [key](value = true) {
        const schema = Schema2(this);
        schema.meta = { ...schema.meta, [key]: value };
        return schema;
      }
    });
  }
  Schema2.prototype.deprecated = __name(function deprecated() {
    const schema = Schema2(this);
    schema.meta.badges ||= [];
    schema.meta.badges.push({ text: "deprecated", type: "danger" });
    return schema;
  }, "deprecated");
  Schema2.prototype.experimental = __name(function experimental() {
    const schema = Schema2(this);
    schema.meta.badges ||= [];
    schema.meta.badges.push({ text: "experimental", type: "warning" });
    return schema;
  }, "experimental");
  Schema2.prototype.pattern = __name(function pattern(regexp) {
    const schema = Schema2(this);
    const pattern2 = (0, import_cosmokit.pick)(regexp, ["source", "flags"]);
    schema.meta = { ...schema.meta, pattern: pattern2 };
    return schema;
  }, "pattern");
  Schema2.prototype.simplify = __name(function simplify(value) {
    if ((0, import_cosmokit.deepEqual)(value, this.meta.default, this.type === "dict"))
      return null;
    if ((0, import_cosmokit.isNullable)(value))
      return value;
    if (this.type === "object" || this.type === "dict") {
      const result = {};
      for (const key in value) {
        const schema = this.type === "object" ? this.dict[key] : this.inner;
        const item = schema?.simplify(value[key]);
        if (this.type === "dict" || !(0, import_cosmokit.isNullable)(item))
          result[key] = item;
      }
      if ((0, import_cosmokit.deepEqual)(result, this.meta.default, this.type === "dict"))
        return null;
      return result;
    } else if (this.type === "array" || this.type === "tuple") {
      const result = [];
      value.forEach((value2, index) => {
        const schema = this.type === "array" ? this.inner : this.list[index];
        const item = schema ? schema.simplify(value2) : value2;
        result.push(item);
      });
      return result;
    } else if (this.type === "intersect") {
      const result = {};
      for (const item of this.list) {
        Object.assign(result, item.simplify(value));
      }
      return result;
    } else if (this.type === "union") {
      for (const schema of this.list) {
        try {
          Schema2.resolve(value, schema);
          return schema.simplify(value);
        } catch {
        }
      }
    }
    return value;
  }, "simplify");
  Schema2.prototype.toString = __name(function toString(inline) {
    return formatters[this.type]?.(this, inline) ?? `Schema<${this.type}>`;
  }, "toString");
  Schema2.prototype.role = __name(function role(role, extra2) {
    const schema = Schema2(this);
    schema.meta = { ...schema.meta, role, extra: extra2 };
    return schema;
  }, "role");
  for (const key of ["default", "link", "comment", "description", "max", "min", "step"]) {
    Object.assign(Schema2.prototype, {
      [key](value) {
        const schema = Schema2(this);
        schema.meta = { ...schema.meta, [key]: value };
        return schema;
      }
    });
  }
  var resolvers = {};
  Schema2.extend = __name(function extend(type, resolve2) {
    resolvers[type] = resolve2;
  }, "extend");
  Schema2.resolve = __name(function resolve(data, schema, options = {}, strict = false) {
    if (!schema)
      return [data];
    if ((0, import_cosmokit.isNullable)(data)) {
      if (schema.meta.required)
        throw new TypeError(`missing required value`);
      let current = schema;
      let fallback = schema.meta.default;
      while (current?.type === "intersect" && (0, import_cosmokit.isNullable)(fallback)) {
        current = current.list[0];
        fallback = current?.meta.default;
      }
      if ((0, import_cosmokit.isNullable)(fallback))
        return [data];
      data = (0, import_cosmokit.clone)(fallback);
    }
    const callback = resolvers[schema.type];
    if (!callback)
      throw new TypeError(`unsupported type "${schema.type}"`);
    try {
      return callback(data, schema, options, strict);
    } catch (error) {
      if (!schema.meta.loose)
        throw error;
      return [schema.meta.default];
    }
  }, "resolve");
  Schema2.from = __name(function from(source) {
    if ((0, import_cosmokit.isNullable)(source)) {
      return Schema2.any();
    } else if (["string", "number", "boolean"].includes(typeof source)) {
      return Schema2.const(source).required();
    } else if (source[kSchema]) {
      return source;
    } else if (typeof source === "function") {
      switch (source) {
        case String:
          return Schema2.string().required();
        case Number:
          return Schema2.number().required();
        case Boolean:
          return Schema2.boolean().required();
        case Function:
          return Schema2.function().required();
        default:
          return Schema2.is(source).required();
      }
    } else {
      throw new TypeError(`cannot infer schema from ${source}`);
    }
  }, "from");
  Schema2.natural = __name(function natural() {
    return Schema2.number().step(1).min(0);
  }, "natural");
  Schema2.percent = __name(function percent() {
    return Schema2.number().step(0.01).min(0).max(1).role("slider");
  }, "percent");
  Schema2.date = __name(function date() {
    return Schema2.union([
      Schema2.is(Date),
      Schema2.transform(Schema2.string().role("datetime"), (value) => {
        const date2 = new Date(value);
        if (isNaN(+date2))
          throw new TypeError(`invalid date "${value}"`);
        return date2;
      }, true)
    ]);
  }, "date");
  Schema2.extend("any", (data) => {
    return [data];
  });
  Schema2.extend("never", (data) => {
    throw new TypeError(`expected nullable but got ${data}`);
  });
  Schema2.extend("const", (data, { value }) => {
    if (data === value)
      return [value];
    throw new TypeError(`expected ${value} but got ${data}`);
  });
  __name(checkWithinRange, "checkWithinRange");
  Schema2.extend("string", (data, { meta }) => {
    if (typeof data !== "string")
      throw new TypeError(`expected string but got ${data}`);
    if (meta.pattern) {
      const regexp = new RegExp(meta.pattern.source, meta.pattern.flags);
      if (!regexp.test(data))
        throw new TypeError(`expect string to match regexp ${regexp}`);
    }
    checkWithinRange(data.length, meta, "string length");
    return [data];
  });
  __name(decimalShift, "decimalShift");
  __name(isMultipleOf, "isMultipleOf");
  Schema2.extend("number", (data, { meta }) => {
    if (typeof data !== "number")
      throw new TypeError(`expected number but got ${data}`);
    checkWithinRange(data, meta, "number");
    const { step } = meta;
    if (step && !isMultipleOf(data, meta.min ?? 0, step)) {
      throw new TypeError(`expected number multiple of ${step} but got ${data}`);
    }
    return [data];
  });
  Schema2.extend("boolean", (data) => {
    if (typeof data === "boolean")
      return [data];
    throw new TypeError(`expected boolean but got ${data}`);
  });
  Schema2.extend("bitset", (data, { bits, meta }) => {
    let value = 0, keys = [];
    if (typeof data === "number") {
      value = data;
      for (const key in bits) {
        if (data & bits[key]) {
          keys.push(key);
        }
      }
    } else if (Array.isArray(data)) {
      keys = data;
      for (const key of keys) {
        if (typeof key !== "string")
          throw new TypeError(`expected string but got ${key}`);
        if (key in bits)
          value |= bits[key];
      }
    } else {
      throw new TypeError(`expected number or array but got ${data}`);
    }
    if (value === meta.default)
      return [value];
    return [value, keys];
  });
  Schema2.extend("function", (data) => {
    if (typeof data === "function")
      return [data];
    throw new TypeError(`expected function but got ${data}`);
  });
  Schema2.extend("is", (data, { callback }) => {
    if (data instanceof callback)
      return [data];
    throw new TypeError(`expected ${callback.name} but got ${data}`);
  });
  __name(property, "property");
  Schema2.extend("array", (data, { inner, meta }, options) => {
    if (!Array.isArray(data))
      throw new TypeError(`expected array but got ${data}`);
    checkWithinRange(data.length, meta, "array length", !(0, import_cosmokit.isNullable)(inner.meta.default));
    return [data.map((_, index) => property(data, index, inner, options))];
  });
  Schema2.extend("dict", (data, { inner, sKey }, options, strict) => {
    if (!(0, import_cosmokit.isPlainObject)(data))
      throw new TypeError(`expected object but got ${data}`);
    const result = {};
    for (const key in data) {
      let rKey;
      try {
        rKey = Schema2.resolve(key, sKey)[0];
      } catch (error) {
        if (strict)
          continue;
        throw error;
      }
      result[rKey] = property(data, key, inner, options);
      data[rKey] = data[key];
      if (key !== rKey)
        delete data[key];
    }
    return [result];
  });
  Schema2.extend("tuple", (data, { list }, options, strict) => {
    if (!Array.isArray(data))
      throw new TypeError(`expected array but got ${data}`);
    const result = list.map((inner, index) => property(data, index, inner, options));
    if (strict)
      return [result];
    result.push(...data.slice(list.length));
    return [result];
  });
  __name(merge, "merge");
  Schema2.extend("object", (data, { dict }, options, strict) => {
    if (!(0, import_cosmokit.isPlainObject)(data))
      throw new TypeError(`expected object but got ${data}`);
    const result = {};
    for (const key in dict) {
      const value = property(data, key, dict[key], options);
      if (!(0, import_cosmokit.isNullable)(value) || key in data) {
        result[key] = value;
      }
    }
    if (!strict)
      merge(result, data);
    return [result];
  });
  Schema2.extend("union", (data, { list, toString: toString2 }, options, strict) => {
    const messages = [];
    for (const inner of list) {
      try {
        return Schema2.resolve(data, inner, options, strict);
      } catch (error) {
        messages.push(error);
      }
    }
    throw new TypeError(`expected ${toString2()} but got ${JSON.stringify(data)}`);
  });
  Schema2.extend("intersect", (data, { list, toString: toString2 }, options, strict) => {
    let result;
    for (const inner of list) {
      const value = Schema2.resolve(data, inner, options, true)[0];
      if ((0, import_cosmokit.isNullable)(value))
        continue;
      if ((0, import_cosmokit.isNullable)(result)) {
        result = value;
      } else if (typeof result !== typeof value) {
        throw new TypeError(`expected ${toString2()} but got ${JSON.stringify(data)}`);
      } else if (typeof value === "object") {
        merge(result ??= {}, value);
      } else if (result !== value) {
        throw new TypeError(`expected ${toString2()} but got ${JSON.stringify(data)}`);
      }
    }
    if (!strict && (0, import_cosmokit.isPlainObject)(data))
      merge(result, data);
    return [result];
  });
  Schema2.extend("transform", (data, { inner, callback, preserve }, options) => {
    const [result, adapted = data] = Schema2.resolve(data, inner, options, true);
    if (preserve) {
      return [callback(result)];
    } else {
      return [callback(result), callback(adapted)];
    }
  });
  var formatters = {};
  __name(defineMethod, "defineMethod");
  defineMethod("is", ["callback"], ({ callback }) => callback.name);
  defineMethod("any", [], () => "any");
  defineMethod("never", [], () => "never");
  defineMethod("const", ["value"], ({ value }) => typeof value === "string" ? JSON.stringify(value) : value);
  defineMethod("string", [], () => "string");
  defineMethod("number", [], () => "number");
  defineMethod("boolean", [], () => "boolean");
  defineMethod("bitset", ["bits"], () => "bitset");
  defineMethod("function", [], () => "function");
  defineMethod("array", ["inner"], ({ inner }) => `${inner.toString(true)}[]`);
  defineMethod("dict", ["inner", "sKey"], ({ inner, sKey }) => `{ [key: ${sKey.toString()}]: ${inner.toString()} }`);
  defineMethod("tuple", ["list"], ({ list }) => `[${list.map((inner) => inner.toString()).join(", ")}]`);
  defineMethod("object", ["dict"], ({ dict }) => {
    if (Object.keys(dict).length === 0)
      return "{}";
    return `{ ${Object.entries(dict).map(([key, inner]) => {
      return `${key}${inner.meta.required ? "" : "?"}: ${inner.toString()}`;
    }).join(", ")} }`;
  });
  defineMethod("union", ["list"], ({ list }, inline) => {
    const result = list.map(({ toString: format }) => format()).join(" | ");
    return inline ? `(${result})` : result;
  });
  defineMethod("intersect", ["list"], ({ list }) => {
    return `${list.map((inner) => inner.toString(true)).join(" & ")}`;
  });
  defineMethod("transform", ["inner", "callback", "preserve"], ({ inner }, isInner) => inner.toString(isInner));
  module.exports = Schema2;
});

// ../../node_modules/cordis/lib/index.cjs
var require_lib8 = __commonJS((exports, module) => {
  var src_default = function() {
  };
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Context: () => Context2,
    Logger: () => import_logger2.Logger,
    Schema: () => import_schemastery.default,
    Service: () => Service2,
    TimerService: () => import_timer2.TimerService,
    default: () => src_default,
    z: () => import_schemastery.default
  });
  module.exports = __toCommonJS(src_exports);
  var core = __toESM2(require_lib2(), 1);
  var import_logger = require_lib4();
  var import_timer = require_lib6();
  __reExport(src_exports, require_lib2(), module.exports);
  var import_schemastery = __toESM2(require_lib7(), 1);
  var import_logger2 = require_lib4();
  var import_timer2 = require_lib6();
  var Context2 = class extends core.Context {
    static {
      __name(this, "Context");
    }
    baseDir;
    constructor(config) {
      super(config);
      this.baseDir = globalThis.process?.cwd() || "";
      this.provide("logger", undefined, true);
      this.provide("timer", undefined, true);
      this.plugin(import_logger.LoggerService);
      this.plugin(import_timer.TimerService);
    }
  };
  var Service2 = class extends core.Service {
    static {
      __name(this, "Service");
    }
    logger;
    constructor(...args) {
      super(...args);
      this.logger = this.ctx.logger(this.name);
    }
    [core.Service.setup]() {
      this.ctx = new Context2;
    }
  };
  __name(src_default, "default");
});

// ../../node_modules/strtok3/lib/FsPromise.js
var require_FsPromise = __commonJS((exports) => {
  async function stat(path) {
    return new Promise((resolve2, reject2) => {
      fs.stat(path, (err, stats) => {
        if (err)
          reject2(err);
        else
          resolve2(stats);
      });
    });
  }
  async function close(fd) {
    return new Promise((resolve2, reject2) => {
      fs.close(fd, (err) => {
        if (err)
          reject2(err);
        else
          resolve2();
      });
    });
  }
  async function open(path, mode) {
    return new Promise((resolve2, reject2) => {
      fs.open(path, mode, (err, fd) => {
        if (err)
          reject2(err);
        else
          resolve2(fd);
      });
    });
  }
  async function read(fd, buffer, offset, length, position) {
    return new Promise((resolve2, reject2) => {
      fs.read(fd, buffer, offset, length, position, (err, bytesRead, _buffer) => {
        if (err)
          reject2(err);
        else
          resolve2({ bytesRead, buffer: _buffer });
      });
    });
  }
  async function writeFile(path, data) {
    return new Promise((resolve2, reject2) => {
      fs.writeFile(path, data, (err) => {
        if (err)
          reject2(err);
        else
          resolve2();
      });
    });
  }
  var writeFileSync = function(path, data) {
    fs.writeFileSync(path, data);
  };
  async function readFile(path) {
    return new Promise((resolve2, reject2) => {
      fs.readFile(path, (err, buffer) => {
        if (err)
          reject2(err);
        else
          resolve2(buffer);
      });
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readFile = exports.writeFileSync = exports.writeFile = exports.read = exports.open = exports.close = exports.stat = exports.createReadStream = exports.pathExists = undefined;
  var fs = __require("fs");
  exports.pathExists = fs.existsSync;
  exports.createReadStream = fs.createReadStream;
  exports.stat = stat;
  exports.close = close;
  exports.open = open;
  exports.read = read;
  exports.writeFile = writeFile;
  exports.writeFileSync = writeFileSync;
  exports.readFile = readFile;
});

// ../../node_modules/peek-readable/lib/EndOfFileStream.js
var require_EndOfFileStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndOfStreamError = exports.defaultMessages = undefined;
  exports.defaultMessages = "End-Of-Stream";

  class EndOfStreamError extends Error {
    constructor() {
      super(exports.defaultMessages);
    }
  }
  exports.EndOfStreamError = EndOfStreamError;
});

// ../../node_modules/peek-readable/lib/Deferred.js
var require_Deferred = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deferred = undefined;

  class Deferred {
    constructor() {
      this.resolve = () => null;
      this.reject = () => null;
      this.promise = new Promise((resolve2, reject2) => {
        this.reject = reject2;
        this.resolve = resolve2;
      });
    }
  }
  exports.Deferred = Deferred;
});

// ../../node_modules/peek-readable/lib/StreamReader.js
var require_StreamReader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamReader = exports.EndOfStreamError = undefined;
  var EndOfFileStream_1 = require_EndOfFileStream();
  var Deferred_1 = require_Deferred();
  var EndOfFileStream_2 = require_EndOfFileStream();
  Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function() {
    return EndOfFileStream_2.EndOfStreamError;
  } });
  var maxStreamReadSize = 1 * 1024 * 1024;

  class StreamReader {
    constructor(s) {
      this.s = s;
      this.deferred = null;
      this.endOfStream = false;
      this.peekQueue = [];
      if (!s.read || !s.once) {
        throw new Error("Expected an instance of stream.Readable");
      }
      this.s.once("end", () => this.reject(new EndOfFileStream_1.EndOfStreamError));
      this.s.once("error", (err) => this.reject(err));
      this.s.once("close", () => this.reject(new Error("Stream closed")));
    }
    async peek(uint8Array, offset, length) {
      const bytesRead = await this.read(uint8Array, offset, length);
      this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead));
      return bytesRead;
    }
    async read(buffer, offset, length) {
      if (length === 0) {
        return 0;
      }
      if (this.peekQueue.length === 0 && this.endOfStream) {
        throw new EndOfFileStream_1.EndOfStreamError;
      }
      let remaining = length;
      let bytesRead = 0;
      while (this.peekQueue.length > 0 && remaining > 0) {
        const peekData = this.peekQueue.pop();
        if (!peekData)
          throw new Error("peekData should be defined");
        const lenCopy = Math.min(peekData.length, remaining);
        buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
        bytesRead += lenCopy;
        remaining -= lenCopy;
        if (lenCopy < peekData.length) {
          this.peekQueue.push(peekData.subarray(lenCopy));
        }
      }
      while (remaining > 0 && !this.endOfStream) {
        const reqLen = Math.min(remaining, maxStreamReadSize);
        const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
        bytesRead += chunkLen;
        if (chunkLen < reqLen)
          break;
        remaining -= chunkLen;
      }
      return bytesRead;
    }
    async readFromStream(buffer, offset, length) {
      const readBuffer = this.s.read(length);
      if (readBuffer) {
        buffer.set(readBuffer, offset);
        return readBuffer.length;
      } else {
        const request = {
          buffer,
          offset,
          length,
          deferred: new Deferred_1.Deferred
        };
        this.deferred = request.deferred;
        this.s.once("readable", () => {
          this.readDeferred(request);
        });
        return request.deferred.promise;
      }
    }
    readDeferred(request) {
      const readBuffer = this.s.read(request.length);
      if (readBuffer) {
        request.buffer.set(readBuffer, request.offset);
        request.deferred.resolve(readBuffer.length);
        this.deferred = null;
      } else {
        this.s.once("readable", () => {
          this.readDeferred(request);
        });
      }
    }
    reject(err) {
      this.endOfStream = true;
      if (this.deferred) {
        this.deferred.reject(err);
        this.deferred = null;
      }
    }
  }
  exports.StreamReader = StreamReader;
});

// ../../node_modules/peek-readable/lib/index.js
var require_lib9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamReader = exports.EndOfStreamError = undefined;
  var EndOfFileStream_1 = require_EndOfFileStream();
  Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function() {
    return EndOfFileStream_1.EndOfStreamError;
  } });
  var StreamReader_1 = require_StreamReader();
  Object.defineProperty(exports, "StreamReader", { enumerable: true, get: function() {
    return StreamReader_1.StreamReader;
  } });
});

// ../../node_modules/strtok3/lib/AbstractTokenizer.js
var require_AbstractTokenizer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbstractTokenizer = undefined;
  var peek_readable_1 = require_lib9();

  class AbstractTokenizer {
    constructor(fileInfo) {
      this.position = 0;
      this.numBuffer = new Uint8Array(8);
      this.fileInfo = fileInfo ? fileInfo : {};
    }
    async readToken(token, position = this.position) {
      const uint8Array = Buffer.alloc(token.len);
      const len = await this.readBuffer(uint8Array, { position });
      if (len < token.len)
        throw new peek_readable_1.EndOfStreamError;
      return token.get(uint8Array, 0);
    }
    async peekToken(token, position = this.position) {
      const uint8Array = Buffer.alloc(token.len);
      const len = await this.peekBuffer(uint8Array, { position });
      if (len < token.len)
        throw new peek_readable_1.EndOfStreamError;
      return token.get(uint8Array, 0);
    }
    async readNumber(token) {
      const len = await this.readBuffer(this.numBuffer, { length: token.len });
      if (len < token.len)
        throw new peek_readable_1.EndOfStreamError;
      return token.get(this.numBuffer, 0);
    }
    async peekNumber(token) {
      const len = await this.peekBuffer(this.numBuffer, { length: token.len });
      if (len < token.len)
        throw new peek_readable_1.EndOfStreamError;
      return token.get(this.numBuffer, 0);
    }
    async ignore(length) {
      if (this.fileInfo.size !== undefined) {
        const bytesLeft = this.fileInfo.size - this.position;
        if (length > bytesLeft) {
          this.position += bytesLeft;
          return bytesLeft;
        }
      }
      this.position += length;
      return length;
    }
    async close() {
    }
    normalizeOptions(uint8Array, options) {
      if (options && options.position !== undefined && options.position < this.position) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      if (options) {
        return {
          mayBeLess: options.mayBeLess === true,
          offset: options.offset ? options.offset : 0,
          length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
          position: options.position ? options.position : this.position
        };
      }
      return {
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      };
    }
  }
  exports.AbstractTokenizer = AbstractTokenizer;
});

// ../../node_modules/strtok3/lib/ReadStreamTokenizer.js
var require_ReadStreamTokenizer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadStreamTokenizer = undefined;
  var AbstractTokenizer_1 = require_AbstractTokenizer();
  var peek_readable_1 = require_lib9();
  var maxBufferSize = 256000;

  class ReadStreamTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
    constructor(stream2, fileInfo) {
      super(fileInfo);
      this.streamReader = new peek_readable_1.StreamReader(stream2);
    }
    async getFileInfo() {
      return this.fileInfo;
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        await this.ignore(skipBytes);
        return this.readBuffer(uint8Array, options);
      } else if (skipBytes < 0) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      if (normOptions.length === 0) {
        return 0;
      }
      const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
      this.position += bytesRead;
      if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
        throw new peek_readable_1.EndOfStreamError;
      }
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      let bytesRead = 0;
      if (normOptions.position) {
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
          bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
          uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
          return bytesRead - skipBytes;
        } else if (skipBytes < 0) {
          throw new Error("Cannot peek from a negative offset in a stream");
        }
      }
      if (normOptions.length > 0) {
        try {
          bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
        } catch (err) {
          if (options && options.mayBeLess && err instanceof peek_readable_1.EndOfStreamError) {
            return 0;
          }
          throw err;
        }
        if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
          throw new peek_readable_1.EndOfStreamError;
        }
      }
      return bytesRead;
    }
    async ignore(length) {
      const bufSize = Math.min(maxBufferSize, length);
      const buf = new Uint8Array(bufSize);
      let totBytesRead = 0;
      while (totBytesRead < length) {
        const remaining = length - totBytesRead;
        const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
        if (bytesRead < 0) {
          return bytesRead;
        }
        totBytesRead += bytesRead;
      }
      return totBytesRead;
    }
  }
  exports.ReadStreamTokenizer = ReadStreamTokenizer;
});

// ../../node_modules/strtok3/lib/BufferTokenizer.js
var require_BufferTokenizer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BufferTokenizer = undefined;
  var peek_readable_1 = require_lib9();
  var AbstractTokenizer_1 = require_AbstractTokenizer();

  class BufferTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
    constructor(uint8Array, fileInfo) {
      super(fileInfo);
      this.uint8Array = uint8Array;
      this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
    }
    async readBuffer(uint8Array, options) {
      if (options && options.position) {
        if (options.position < this.position) {
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        }
        this.position = options.position;
      }
      const bytesRead = await this.peekBuffer(uint8Array, options);
      this.position += bytesRead;
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
      if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
        throw new peek_readable_1.EndOfStreamError;
      } else {
        uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
        return bytes2read;
      }
    }
    async close() {
    }
  }
  exports.BufferTokenizer = BufferTokenizer;
});

// ../../node_modules/strtok3/lib/core.js
var require_core = __commonJS((exports) => {
  var fromStream = function(stream2, fileInfo) {
    fileInfo = fileInfo ? fileInfo : {};
    return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream2, fileInfo);
  };
  var fromBuffer = function(uint8Array, fileInfo) {
    return new BufferTokenizer_1.BufferTokenizer(uint8Array, fileInfo);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromBuffer = exports.fromStream = exports.EndOfStreamError = undefined;
  var ReadStreamTokenizer_1 = require_ReadStreamTokenizer();
  var BufferTokenizer_1 = require_BufferTokenizer();
  var peek_readable_1 = require_lib9();
  Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function() {
    return peek_readable_1.EndOfStreamError;
  } });
  exports.fromStream = fromStream;
  exports.fromBuffer = fromBuffer;
});

// ../../node_modules/strtok3/lib/FileTokenizer.js
var require_FileTokenizer = __commonJS((exports) => {
  async function fromFile(sourceFilePath) {
    const stat = await fs.stat(sourceFilePath);
    if (!stat.isFile) {
      throw new Error(`File not a file: ${sourceFilePath}`);
    }
    const fd = await fs.open(sourceFilePath, "r");
    return new FileTokenizer(fd, { path: sourceFilePath, size: stat.size });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromFile = exports.FileTokenizer = undefined;
  var AbstractTokenizer_1 = require_AbstractTokenizer();
  var peek_readable_1 = require_lib9();
  var fs = require_FsPromise();

  class FileTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
    constructor(fd, fileInfo) {
      super(fileInfo);
      this.fd = fd;
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      this.position = normOptions.position;
      const res = await fs.read(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
      this.position += res.bytesRead;
      if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
        throw new peek_readable_1.EndOfStreamError;
      }
      return res.bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const res = await fs.read(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
      if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
        throw new peek_readable_1.EndOfStreamError;
      }
      return res.bytesRead;
    }
    async close() {
      return fs.close(this.fd);
    }
  }
  exports.FileTokenizer = FileTokenizer;
  exports.fromFile = fromFile;
});

// ../../node_modules/strtok3/lib/index.js
var require_lib10 = __commonJS((exports) => {
  async function fromStream(stream2, fileInfo) {
    fileInfo = fileInfo ? fileInfo : {};
    if (stream2.path) {
      const stat = await fs.stat(stream2.path);
      fileInfo.path = stream2.path;
      fileInfo.size = stat.size;
    }
    return core.fromStream(stream2, fileInfo);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromStream = exports.fromBuffer = exports.EndOfStreamError = exports.fromFile = undefined;
  var fs = require_FsPromise();
  var core = require_core();
  var FileTokenizer_1 = require_FileTokenizer();
  Object.defineProperty(exports, "fromFile", { enumerable: true, get: function() {
    return FileTokenizer_1.fromFile;
  } });
  var core_1 = require_core();
  Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function() {
    return core_1.EndOfStreamError;
  } });
  Object.defineProperty(exports, "fromBuffer", { enumerable: true, get: function() {
    return core_1.fromBuffer;
  } });
  exports.fromStream = fromStream;
});

// ../../node_modules/ieee754/index.js
var require_ieee754 = __commonJS((exports) => {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (;nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (;nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (;mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (;eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer[offset + i - d] |= s * 128;
  };
});

// ../../node_modules/token-types/lib/index.js
var require_lib11 = __commonJS((exports) => {
  var dv = function(array) {
    return new DataView(array.buffer, array.byteOffset);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnsiStringType = exports.StringType = exports.BufferType = exports.Uint8ArrayType = exports.IgnoreType = exports.Float80_LE = exports.Float80_BE = exports.Float64_LE = exports.Float64_BE = exports.Float32_LE = exports.Float32_BE = exports.Float16_LE = exports.Float16_BE = exports.INT64_BE = exports.UINT64_BE = exports.INT64_LE = exports.UINT64_LE = exports.INT32_LE = exports.INT32_BE = exports.INT24_BE = exports.INT24_LE = exports.INT16_LE = exports.INT16_BE = exports.INT8 = exports.UINT32_BE = exports.UINT32_LE = exports.UINT24_BE = exports.UINT24_LE = exports.UINT16_BE = exports.UINT16_LE = exports.UINT8 = undefined;
  var ieee754 = require_ieee754();
  exports.UINT8 = {
    len: 1,
    get(array, offset) {
      return dv(array).getUint8(offset);
    },
    put(array, offset, value) {
      dv(array).setUint8(offset, value);
      return offset + 1;
    }
  };
  exports.UINT16_LE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value, true);
      return offset + 2;
    }
  };
  exports.UINT16_BE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value);
      return offset + 2;
    }
  };
  exports.UINT24_LE = {
    len: 3,
    get(array, offset) {
      const dataView = dv(array);
      return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
    },
    put(array, offset, value) {
      const dataView = dv(array);
      dataView.setUint8(offset, value & 255);
      dataView.setUint16(offset + 1, value >> 8, true);
      return offset + 3;
    }
  };
  exports.UINT24_BE = {
    len: 3,
    get(array, offset) {
      const dataView = dv(array);
      return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
    },
    put(array, offset, value) {
      const dataView = dv(array);
      dataView.setUint16(offset, value >> 8);
      dataView.setUint8(offset + 2, value & 255);
      return offset + 3;
    }
  };
  exports.UINT32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value, true);
      return offset + 4;
    }
  };
  exports.UINT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value);
      return offset + 4;
    }
  };
  exports.INT8 = {
    len: 1,
    get(array, offset) {
      return dv(array).getInt8(offset);
    },
    put(array, offset, value) {
      dv(array).setInt8(offset, value);
      return offset + 1;
    }
  };
  exports.INT16_BE = {
    len: 2,
    get(array, offset) {
      return dv(array).getInt16(offset);
    },
    put(array, offset, value) {
      dv(array).setInt16(offset, value);
      return offset + 2;
    }
  };
  exports.INT16_LE = {
    len: 2,
    get(array, offset) {
      return dv(array).getInt16(offset, true);
    },
    put(array, offset, value) {
      dv(array).setInt16(offset, value, true);
      return offset + 2;
    }
  };
  exports.INT24_LE = {
    len: 3,
    get(array, offset) {
      const unsigned = exports.UINT24_LE.get(array, offset);
      return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
    },
    put(array, offset, value) {
      const dataView = dv(array);
      dataView.setUint8(offset, value & 255);
      dataView.setUint16(offset + 1, value >> 8, true);
      return offset + 3;
    }
  };
  exports.INT24_BE = {
    len: 3,
    get(array, offset) {
      const unsigned = exports.UINT24_BE.get(array, offset);
      return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
    },
    put(array, offset, value) {
      const dataView = dv(array);
      dataView.setUint16(offset, value >> 8);
      dataView.setUint8(offset + 2, value & 255);
      return offset + 3;
    }
  };
  exports.INT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getInt32(offset);
    },
    put(array, offset, value) {
      dv(array).setInt32(offset, value);
      return offset + 4;
    }
  };
  exports.INT32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getInt32(offset, true);
    },
    put(array, offset, value) {
      dv(array).setInt32(offset, value, true);
      return offset + 4;
    }
  };
  exports.UINT64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigUint64(offset, true);
    },
    put(array, offset, value) {
      dv(array).setBigUint64(offset, value, true);
      return offset + 8;
    }
  };
  exports.INT64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigInt64(offset, true);
    },
    put(array, offset, value) {
      dv(array).setBigInt64(offset, value, true);
      return offset + 8;
    }
  };
  exports.UINT64_BE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigUint64(offset);
    },
    put(array, offset, value) {
      dv(array).setBigUint64(offset, value);
      return offset + 8;
    }
  };
  exports.INT64_BE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigInt64(offset);
    },
    put(array, offset, value) {
      dv(array).setBigInt64(offset, value);
      return offset + 8;
    }
  };
  exports.Float16_BE = {
    len: 2,
    get(dataView, offset) {
      return ieee754.read(dataView, offset, false, 10, this.len);
    },
    put(dataView, offset, value) {
      ieee754.write(dataView, value, offset, false, 10, this.len);
      return offset + this.len;
    }
  };
  exports.Float16_LE = {
    len: 2,
    get(array, offset) {
      return ieee754.read(array, offset, true, 10, this.len);
    },
    put(array, offset, value) {
      ieee754.write(array, value, offset, true, 10, this.len);
      return offset + this.len;
    }
  };
  exports.Float32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getFloat32(offset);
    },
    put(array, offset, value) {
      dv(array).setFloat32(offset, value);
      return offset + 4;
    }
  };
  exports.Float32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getFloat32(offset, true);
    },
    put(array, offset, value) {
      dv(array).setFloat32(offset, value, true);
      return offset + 4;
    }
  };
  exports.Float64_BE = {
    len: 8,
    get(array, offset) {
      return dv(array).getFloat64(offset);
    },
    put(array, offset, value) {
      dv(array).setFloat64(offset, value);
      return offset + 8;
    }
  };
  exports.Float64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getFloat64(offset, true);
    },
    put(array, offset, value) {
      dv(array).setFloat64(offset, value, true);
      return offset + 8;
    }
  };
  exports.Float80_BE = {
    len: 10,
    get(array, offset) {
      return ieee754.read(array, offset, false, 63, this.len);
    },
    put(array, offset, value) {
      ieee754.write(array, value, offset, false, 63, this.len);
      return offset + this.len;
    }
  };
  exports.Float80_LE = {
    len: 10,
    get(array, offset) {
      return ieee754.read(array, offset, true, 63, this.len);
    },
    put(array, offset, value) {
      ieee754.write(array, value, offset, true, 63, this.len);
      return offset + this.len;
    }
  };

  class IgnoreType {
    constructor(len) {
      this.len = len;
    }
    get(array, off) {
    }
  }
  exports.IgnoreType = IgnoreType;

  class Uint8ArrayType {
    constructor(len) {
      this.len = len;
    }
    get(array, offset) {
      return array.subarray(offset, offset + this.len);
    }
  }
  exports.Uint8ArrayType = Uint8ArrayType;

  class BufferType {
    constructor(len) {
      this.len = len;
    }
    get(uint8Array, off) {
      return Buffer.from(uint8Array.subarray(off, off + this.len));
    }
  }
  exports.BufferType = BufferType;

  class StringType {
    constructor(len, encoding) {
      this.len = len;
      this.encoding = encoding;
    }
    get(uint8Array, offset) {
      return Buffer.from(uint8Array).toString(this.encoding, offset, offset + this.len);
    }
  }
  exports.StringType = StringType;

  class AnsiStringType {
    constructor(len) {
      this.len = len;
    }
    static decode(buffer, offset, until) {
      let str = "";
      for (let i = offset;i < until; ++i) {
        str += AnsiStringType.codePointToString(AnsiStringType.singleByteDecoder(buffer[i]));
      }
      return str;
    }
    static inRange(a, min, max) {
      return min <= a && a <= max;
    }
    static codePointToString(cp) {
      if (cp <= 65535) {
        return String.fromCharCode(cp);
      } else {
        cp -= 65536;
        return String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
      }
    }
    static singleByteDecoder(bite) {
      if (AnsiStringType.inRange(bite, 0, 127)) {
        return bite;
      }
      const codePoint = AnsiStringType.windows1252[bite - 128];
      if (codePoint === null) {
        throw Error("invaliding encoding");
      }
      return codePoint;
    }
    get(buffer, offset = 0) {
      return AnsiStringType.decode(buffer, offset, offset + this.len);
    }
  }
  exports.AnsiStringType = AnsiStringType;
  AnsiStringType.windows1252 = [
    8364,
    129,
    8218,
    402,
    8222,
    8230,
    8224,
    8225,
    710,
    8240,
    352,
    8249,
    338,
    141,
    381,
    143,
    144,
    8216,
    8217,
    8220,
    8221,
    8226,
    8211,
    8212,
    732,
    8482,
    353,
    8250,
    339,
    157,
    382,
    376,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255
  ];
});

// ../../node_modules/file-type/util.js
var require_util = __commonJS((exports) => {
  exports.stringToBytes = (string) => [...string].map((character) => character.charCodeAt(0));
  exports.tarHeaderChecksumMatches = (buffer, offset = 0) => {
    const readSum = parseInt(buffer.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
    if (isNaN(readSum)) {
      return false;
    }
    let sum = 8 * 32;
    for (let i = offset;i < offset + 148; i++) {
      sum += buffer[i];
    }
    for (let i = offset + 156;i < offset + 512; i++) {
      sum += buffer[i];
    }
    return readSum === sum;
  };
  exports.uint32SyncSafeToken = {
    get: (buffer, offset) => {
      return buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21;
    },
    len: 4
  };
});

// ../../node_modules/file-type/supported.js
var require_supported = __commonJS((exports, module) => {
  module.exports = {
    extensions: [
      "jpg",
      "png",
      "apng",
      "gif",
      "webp",
      "flif",
      "xcf",
      "cr2",
      "cr3",
      "orf",
      "arw",
      "dng",
      "nef",
      "rw2",
      "raf",
      "tif",
      "bmp",
      "icns",
      "jxr",
      "psd",
      "indd",
      "zip",
      "tar",
      "rar",
      "gz",
      "bz2",
      "7z",
      "dmg",
      "mp4",
      "mid",
      "mkv",
      "webm",
      "mov",
      "avi",
      "mpg",
      "mp2",
      "mp3",
      "m4a",
      "oga",
      "ogg",
      "ogv",
      "opus",
      "flac",
      "wav",
      "spx",
      "amr",
      "pdf",
      "epub",
      "exe",
      "swf",
      "rtf",
      "wasm",
      "woff",
      "woff2",
      "eot",
      "ttf",
      "otf",
      "ico",
      "flv",
      "ps",
      "xz",
      "sqlite",
      "nes",
      "crx",
      "xpi",
      "cab",
      "deb",
      "ar",
      "rpm",
      "Z",
      "lz",
      "cfb",
      "mxf",
      "mts",
      "blend",
      "bpg",
      "docx",
      "pptx",
      "xlsx",
      "3gp",
      "3g2",
      "jp2",
      "jpm",
      "jpx",
      "mj2",
      "aif",
      "qcp",
      "odt",
      "ods",
      "odp",
      "xml",
      "mobi",
      "heic",
      "cur",
      "ktx",
      "ape",
      "wv",
      "dcm",
      "ics",
      "glb",
      "pcap",
      "dsf",
      "lnk",
      "alias",
      "voc",
      "ac3",
      "m4v",
      "m4p",
      "m4b",
      "f4v",
      "f4p",
      "f4b",
      "f4a",
      "mie",
      "asf",
      "ogm",
      "ogx",
      "mpc",
      "arrow",
      "shp",
      "aac",
      "mp1",
      "it",
      "s3m",
      "xm",
      "ai",
      "skp",
      "avif",
      "eps",
      "lzh",
      "pgp",
      "asar",
      "stl",
      "chm",
      "3mf",
      "zst",
      "jxl",
      "vcf"
    ],
    mimeTypes: [
      "image/jpeg",
      "image/png",
      "image/gif",
      "image/webp",
      "image/flif",
      "image/x-xcf",
      "image/x-canon-cr2",
      "image/x-canon-cr3",
      "image/tiff",
      "image/bmp",
      "image/vnd.ms-photo",
      "image/vnd.adobe.photoshop",
      "application/x-indesign",
      "application/epub+zip",
      "application/x-xpinstall",
      "application/vnd.oasis.opendocument.text",
      "application/vnd.oasis.opendocument.spreadsheet",
      "application/vnd.oasis.opendocument.presentation",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "application/vnd.openxmlformats-officedocument.presentationml.presentation",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      "application/zip",
      "application/x-tar",
      "application/x-rar-compressed",
      "application/gzip",
      "application/x-bzip2",
      "application/x-7z-compressed",
      "application/x-apple-diskimage",
      "application/x-apache-arrow",
      "video/mp4",
      "audio/midi",
      "video/x-matroska",
      "video/webm",
      "video/quicktime",
      "video/vnd.avi",
      "audio/vnd.wave",
      "audio/qcelp",
      "audio/x-ms-asf",
      "video/x-ms-asf",
      "application/vnd.ms-asf",
      "video/mpeg",
      "video/3gpp",
      "audio/mpeg",
      "audio/mp4",
      "audio/opus",
      "video/ogg",
      "audio/ogg",
      "application/ogg",
      "audio/x-flac",
      "audio/ape",
      "audio/wavpack",
      "audio/amr",
      "application/pdf",
      "application/x-msdownload",
      "application/x-shockwave-flash",
      "application/rtf",
      "application/wasm",
      "font/woff",
      "font/woff2",
      "application/vnd.ms-fontobject",
      "font/ttf",
      "font/otf",
      "image/x-icon",
      "video/x-flv",
      "application/postscript",
      "application/eps",
      "application/x-xz",
      "application/x-sqlite3",
      "application/x-nintendo-nes-rom",
      "application/x-google-chrome-extension",
      "application/vnd.ms-cab-compressed",
      "application/x-deb",
      "application/x-unix-archive",
      "application/x-rpm",
      "application/x-compress",
      "application/x-lzip",
      "application/x-cfb",
      "application/x-mie",
      "application/mxf",
      "video/mp2t",
      "application/x-blender",
      "image/bpg",
      "image/jp2",
      "image/jpx",
      "image/jpm",
      "image/mj2",
      "audio/aiff",
      "application/xml",
      "application/x-mobipocket-ebook",
      "image/heif",
      "image/heif-sequence",
      "image/heic",
      "image/heic-sequence",
      "image/icns",
      "image/ktx",
      "application/dicom",
      "audio/x-musepack",
      "text/calendar",
      "text/vcard",
      "model/gltf-binary",
      "application/vnd.tcpdump.pcap",
      "audio/x-dsf",
      "application/x.ms.shortcut",
      "application/x.apple.alias",
      "audio/x-voc",
      "audio/vnd.dolby.dd-raw",
      "audio/x-m4a",
      "image/apng",
      "image/x-olympus-orf",
      "image/x-sony-arw",
      "image/x-adobe-dng",
      "image/x-nikon-nef",
      "image/x-panasonic-rw2",
      "image/x-fujifilm-raf",
      "video/x-m4v",
      "video/3gpp2",
      "application/x-esri-shape",
      "audio/aac",
      "audio/x-it",
      "audio/x-s3m",
      "audio/x-xm",
      "video/MP1S",
      "video/MP2P",
      "application/vnd.sketchup.skp",
      "image/avif",
      "application/x-lzh-compressed",
      "application/pgp-encrypted",
      "application/x-asar",
      "model/stl",
      "application/vnd.ms-htmlhelp",
      "model/3mf",
      "image/jxl",
      "application/zstd"
    ]
  };
});

// ../../node_modules/file-type/core.js
var require_core2 = __commonJS((exports, module) => {
  async function fromStream(stream3) {
    const tokenizer = await strtok3.fromStream(stream3);
    try {
      return await fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async function fromBuffer(input) {
    if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
      throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
    }
    const buffer = input instanceof Buffer ? input : Buffer.from(input);
    if (!(buffer && buffer.length > 1)) {
      return;
    }
    const tokenizer = strtok3.fromBuffer(buffer);
    return fromTokenizer(tokenizer);
  }
  var _check = function(buffer, headers, options) {
    options = {
      offset: 0,
      ...options
    };
    for (const [index, header] of headers.entries()) {
      if (options.mask) {
        if (header !== (options.mask[index] & buffer[index + options.offset])) {
          return false;
        }
      } else if (header !== buffer[index + options.offset]) {
        return false;
      }
    }
    return true;
  };
  async function fromTokenizer(tokenizer) {
    try {
      return _fromTokenizer(tokenizer);
    } catch (error) {
      if (!(error instanceof strtok3.EndOfStreamError)) {
        throw error;
      }
    }
  }
  async function _fromTokenizer(tokenizer) {
    let buffer = Buffer.alloc(minimumBytes);
    const bytesRead = 12;
    const check = (header, options) => _check(buffer, header, options);
    const checkString = (header, options) => check(stringToBytes(header), options);
    if (!tokenizer.fileInfo.size) {
      tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
    }
    await tokenizer.peekBuffer(buffer, { length: bytesRead, mayBeLess: true });
    if (check([66, 77])) {
      return {
        ext: "bmp",
        mime: "image/bmp"
      };
    }
    if (check([11, 119])) {
      return {
        ext: "ac3",
        mime: "audio/vnd.dolby.dd-raw"
      };
    }
    if (check([120, 1])) {
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
      };
    }
    if (check([77, 90])) {
      return {
        ext: "exe",
        mime: "application/x-msdownload"
      };
    }
    if (check([37, 33])) {
      await tokenizer.peekBuffer(buffer, { length: 24, mayBeLess: true });
      if (checkString("PS-Adobe-", { offset: 2 }) && checkString(" EPSF-", { offset: 14 })) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      return {
        ext: "ps",
        mime: "application/postscript"
      };
    }
    if (check([31, 160]) || check([31, 157])) {
      return {
        ext: "Z",
        mime: "application/x-compress"
      };
    }
    if (check([255, 216, 255])) {
      return {
        ext: "jpg",
        mime: "image/jpeg"
      };
    }
    if (check([73, 73, 188])) {
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
      };
    }
    if (check([31, 139, 8])) {
      return {
        ext: "gz",
        mime: "application/gzip"
      };
    }
    if (check([66, 90, 104])) {
      return {
        ext: "bz2",
        mime: "application/x-bzip2"
      };
    }
    if (checkString("ID3")) {
      await tokenizer.ignore(6);
      const id3HeaderLen = await tokenizer.readToken(uint32SyncSafeToken);
      if (tokenizer.position + id3HeaderLen > tokenizer.fileInfo.size) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      await tokenizer.ignore(id3HeaderLen);
      return fromTokenizer(tokenizer);
    }
    if (checkString("MP+")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if ((buffer[0] === 67 || buffer[0] === 70) && check([87, 83], { offset: 1 })) {
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
      };
    }
    if (check([71, 73, 70])) {
      return {
        ext: "gif",
        mime: "image/gif"
      };
    }
    if (checkString("FLIF")) {
      return {
        ext: "flif",
        mime: "image/flif"
      };
    }
    if (checkString("8BPS")) {
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
      };
    }
    if (checkString("WEBP", { offset: 8 })) {
      return {
        ext: "webp",
        mime: "image/webp"
      };
    }
    if (checkString("MPCK")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if (checkString("FORM")) {
      return {
        ext: "aif",
        mime: "audio/aiff"
      };
    }
    if (checkString("icns", { offset: 0 })) {
      return {
        ext: "icns",
        mime: "image/icns"
      };
    }
    if (check([80, 75, 3, 4])) {
      try {
        while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
          await tokenizer.readBuffer(buffer, { length: 30 });
          const zipHeader = {
            compressedSize: buffer.readUInt32LE(18),
            uncompressedSize: buffer.readUInt32LE(22),
            filenameLength: buffer.readUInt16LE(26),
            extraFieldLength: buffer.readUInt16LE(28)
          };
          zipHeader.filename = await tokenizer.readToken(new Token.StringType(zipHeader.filenameLength, "utf-8"));
          await tokenizer.ignore(zipHeader.extraFieldLength);
          if (zipHeader.filename === "META-INF/mozilla.rsa") {
            return {
              ext: "xpi",
              mime: "application/x-xpinstall"
            };
          }
          if (zipHeader.filename.endsWith(".rels") || zipHeader.filename.endsWith(".xml")) {
            const type = zipHeader.filename.split("/")[0];
            switch (type) {
              case "_rels":
                break;
              case "word":
                return {
                  ext: "docx",
                  mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                };
              case "ppt":
                return {
                  ext: "pptx",
                  mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                };
              case "xl":
                return {
                  ext: "xlsx",
                  mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                };
              default:
                break;
            }
          }
          if (zipHeader.filename.startsWith("xl/")) {
            return {
              ext: "xlsx",
              mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            };
          }
          if (zipHeader.filename.startsWith("3D/") && zipHeader.filename.endsWith(".model")) {
            return {
              ext: "3mf",
              mime: "model/3mf"
            };
          }
          if (zipHeader.filename === "mimetype" && zipHeader.compressedSize === zipHeader.uncompressedSize) {
            const mimeType = await tokenizer.readToken(new Token.StringType(zipHeader.compressedSize, "utf-8"));
            switch (mimeType) {
              case "application/epub+zip":
                return {
                  ext: "epub",
                  mime: "application/epub+zip"
                };
              case "application/vnd.oasis.opendocument.text":
                return {
                  ext: "odt",
                  mime: "application/vnd.oasis.opendocument.text"
                };
              case "application/vnd.oasis.opendocument.spreadsheet":
                return {
                  ext: "ods",
                  mime: "application/vnd.oasis.opendocument.spreadsheet"
                };
              case "application/vnd.oasis.opendocument.presentation":
                return {
                  ext: "odp",
                  mime: "application/vnd.oasis.opendocument.presentation"
                };
              default:
            }
          }
          if (zipHeader.compressedSize === 0) {
            let nextHeaderIndex = -1;
            while (nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size) {
              await tokenizer.peekBuffer(buffer, { mayBeLess: true });
              nextHeaderIndex = buffer.indexOf("504B0304", 0, "hex");
              await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : buffer.length);
            }
          } else {
            await tokenizer.ignore(zipHeader.compressedSize);
          }
        }
      } catch (error) {
        if (!(error instanceof strtok3.EndOfStreamError)) {
          throw error;
        }
      }
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (checkString("OggS")) {
      await tokenizer.ignore(28);
      const type = Buffer.alloc(8);
      await tokenizer.readBuffer(type);
      if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
        return {
          ext: "ogv",
          mime: "video/ogg"
        };
      }
      if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
        return {
          ext: "ogm",
          mime: "video/ogg"
        };
      }
      if (_check(type, [127, 70, 76, 65, 67])) {
        return {
          ext: "oga",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
        return {
          ext: "spx",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      return {
        ext: "ogx",
        mime: "application/ogg"
      };
    }
    if (check([80, 75]) && (buffer[2] === 3 || buffer[2] === 5 || buffer[2] === 7) && (buffer[3] === 4 || buffer[3] === 6 || buffer[3] === 8)) {
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (checkString("ftyp", { offset: 4 }) && (buffer[8] & 96) !== 0) {
      const brandMajor = buffer.toString("binary", 8, 12).replace("\0", " ").trim();
      switch (brandMajor) {
        case "avif":
          return { ext: "avif", mime: "image/avif" };
        case "mif1":
          return { ext: "heic", mime: "image/heif" };
        case "msf1":
          return { ext: "heic", mime: "image/heif-sequence" };
        case "heic":
        case "heix":
          return { ext: "heic", mime: "image/heic" };
        case "hevc":
        case "hevx":
          return { ext: "heic", mime: "image/heic-sequence" };
        case "qt":
          return { ext: "mov", mime: "video/quicktime" };
        case "M4V":
        case "M4VH":
        case "M4VP":
          return { ext: "m4v", mime: "video/x-m4v" };
        case "M4P":
          return { ext: "m4p", mime: "video/mp4" };
        case "M4B":
          return { ext: "m4b", mime: "audio/mp4" };
        case "M4A":
          return { ext: "m4a", mime: "audio/x-m4a" };
        case "F4V":
          return { ext: "f4v", mime: "video/mp4" };
        case "F4P":
          return { ext: "f4p", mime: "video/mp4" };
        case "F4A":
          return { ext: "f4a", mime: "audio/mp4" };
        case "F4B":
          return { ext: "f4b", mime: "audio/mp4" };
        case "crx":
          return { ext: "cr3", mime: "image/x-canon-cr3" };
        default:
          if (brandMajor.startsWith("3g")) {
            if (brandMajor.startsWith("3g2")) {
              return { ext: "3g2", mime: "video/3gpp2" };
            }
            return { ext: "3gp", mime: "video/3gpp" };
          }
          return { ext: "mp4", mime: "video/mp4" };
      }
    }
    if (checkString("MThd")) {
      return {
        ext: "mid",
        mime: "audio/midi"
      };
    }
    if (checkString("wOFF") && (check([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff",
        mime: "font/woff"
      };
    }
    if (checkString("wOF2") && (check([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff2",
        mime: "font/woff2"
      };
    }
    if (check([212, 195, 178, 161]) || check([161, 178, 195, 212])) {
      return {
        ext: "pcap",
        mime: "application/vnd.tcpdump.pcap"
      };
    }
    if (checkString("DSD ")) {
      return {
        ext: "dsf",
        mime: "audio/x-dsf"
      };
    }
    if (checkString("LZIP")) {
      return {
        ext: "lz",
        mime: "application/x-lzip"
      };
    }
    if (checkString("fLaC")) {
      return {
        ext: "flac",
        mime: "audio/x-flac"
      };
    }
    if (check([66, 80, 71, 251])) {
      return {
        ext: "bpg",
        mime: "image/bpg"
      };
    }
    if (checkString("wvpk")) {
      return {
        ext: "wv",
        mime: "audio/wavpack"
      };
    }
    if (checkString("%PDF")) {
      await tokenizer.ignore(1350);
      const maxBufferSize = 10 * 1024 * 1024;
      const buffer2 = Buffer.alloc(Math.min(maxBufferSize, tokenizer.fileInfo.size));
      await tokenizer.readBuffer(buffer2, { mayBeLess: true });
      if (buffer2.includes(Buffer.from("AIPrivateData"))) {
        return {
          ext: "ai",
          mime: "application/postscript"
        };
      }
      return {
        ext: "pdf",
        mime: "application/pdf"
      };
    }
    if (check([0, 97, 115, 109])) {
      return {
        ext: "wasm",
        mime: "application/wasm"
      };
    }
    if (check([73, 73, 42, 0])) {
      if (checkString("CR", { offset: 8 })) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (check([28, 0, 254, 0], { offset: 8 }) || check([31, 0, 11, 0], { offset: 8 })) {
        return {
          ext: "nef",
          mime: "image/x-nikon-nef"
        };
      }
      if (check([8, 0, 0, 0], { offset: 4 }) && (check([45, 0, 254, 0], { offset: 8 }) || check([39, 0, 254, 0], { offset: 8 }))) {
        return {
          ext: "dng",
          mime: "image/x-adobe-dng"
        };
      }
      buffer = Buffer.alloc(24);
      await tokenizer.peekBuffer(buffer);
      if ((check([16, 251, 134, 1], { offset: 4 }) || check([8, 0, 0, 0], { offset: 4 })) && check([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 })) {
        return {
          ext: "arw",
          mime: "image/x-sony-arw"
        };
      }
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (check([77, 77, 0, 42])) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (checkString("MAC ")) {
      return {
        ext: "ape",
        mime: "audio/ape"
      };
    }
    if (check([26, 69, 223, 163])) {
      async function readField() {
        const msb = await tokenizer.peekNumber(Token.UINT8);
        let mask = 128;
        let ic = 0;
        while ((msb & mask) === 0 && mask !== 0) {
          ++ic;
          mask >>= 1;
        }
        const id = Buffer.alloc(ic + 1);
        await tokenizer.readBuffer(id);
        return id;
      }
      async function readElement() {
        const id = await readField();
        const lenField = await readField();
        lenField[0] ^= 128 >> lenField.length - 1;
        const nrLen = Math.min(6, lenField.length);
        return {
          id: id.readUIntBE(0, id.length),
          len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
        };
      }
      async function readChildren(level, children) {
        while (children > 0) {
          const e = await readElement();
          if (e.id === 17026) {
            return tokenizer.readToken(new Token.StringType(e.len, "utf-8"));
          }
          await tokenizer.ignore(e.len);
          --children;
        }
      }
      const re = await readElement();
      const docType = await readChildren(1, re.len);
      switch (docType) {
        case "webm":
          return {
            ext: "webm",
            mime: "video/webm"
          };
        case "matroska":
          return {
            ext: "mkv",
            mime: "video/x-matroska"
          };
        default:
          return;
      }
    }
    if (check([82, 73, 70, 70])) {
      if (check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/vnd.avi"
        };
      }
      if (check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/vnd.wave"
        };
      }
      if (check([81, 76, 67, 77], { offset: 8 })) {
        return {
          ext: "qcp",
          mime: "audio/qcelp"
        };
      }
    }
    if (checkString("SQLi")) {
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
      };
    }
    if (check([78, 69, 83, 26])) {
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
      };
    }
    if (checkString("Cr24")) {
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
      };
    }
    if (checkString("MSCF") || checkString("ISc(")) {
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
      };
    }
    if (check([237, 171, 238, 219])) {
      return {
        ext: "rpm",
        mime: "application/x-rpm"
      };
    }
    if (check([197, 208, 211, 198])) {
      return {
        ext: "eps",
        mime: "application/eps"
      };
    }
    if (check([40, 181, 47, 253])) {
      return {
        ext: "zst",
        mime: "application/zstd"
      };
    }
    if (check([79, 84, 84, 79, 0])) {
      return {
        ext: "otf",
        mime: "font/otf"
      };
    }
    if (checkString("#!AMR")) {
      return {
        ext: "amr",
        mime: "audio/amr"
      };
    }
    if (checkString("{\\rtf")) {
      return {
        ext: "rtf",
        mime: "application/rtf"
      };
    }
    if (check([70, 76, 86, 1])) {
      return {
        ext: "flv",
        mime: "video/x-flv"
      };
    }
    if (checkString("IMPM")) {
      return {
        ext: "it",
        mime: "audio/x-it"
      };
    }
    if (checkString("-lh0-", { offset: 2 }) || checkString("-lh1-", { offset: 2 }) || checkString("-lh2-", { offset: 2 }) || checkString("-lh3-", { offset: 2 }) || checkString("-lh4-", { offset: 2 }) || checkString("-lh5-", { offset: 2 }) || checkString("-lh6-", { offset: 2 }) || checkString("-lh7-", { offset: 2 }) || checkString("-lzs-", { offset: 2 }) || checkString("-lz4-", { offset: 2 }) || checkString("-lz5-", { offset: 2 }) || checkString("-lhd-", { offset: 2 })) {
      return {
        ext: "lzh",
        mime: "application/x-lzh-compressed"
      };
    }
    if (check([0, 0, 1, 186])) {
      if (check([33], { offset: 4, mask: [241] })) {
        return {
          ext: "mpg",
          mime: "video/MP1S"
        };
      }
      if (check([68], { offset: 4, mask: [196] })) {
        return {
          ext: "mpg",
          mime: "video/MP2P"
        };
      }
    }
    if (checkString("ITSF")) {
      return {
        ext: "chm",
        mime: "application/vnd.ms-htmlhelp"
      };
    }
    if (check([253, 55, 122, 88, 90, 0])) {
      return {
        ext: "xz",
        mime: "application/x-xz"
      };
    }
    if (checkString("<?xml ")) {
      return {
        ext: "xml",
        mime: "application/xml"
      };
    }
    if (check([55, 122, 188, 175, 39, 28])) {
      return {
        ext: "7z",
        mime: "application/x-7z-compressed"
      };
    }
    if (check([82, 97, 114, 33, 26, 7]) && (buffer[6] === 0 || buffer[6] === 1)) {
      return {
        ext: "rar",
        mime: "application/x-rar-compressed"
      };
    }
    if (checkString("solid ")) {
      return {
        ext: "stl",
        mime: "model/stl"
      };
    }
    if (checkString("BLENDER")) {
      return {
        ext: "blend",
        mime: "application/x-blender"
      };
    }
    if (checkString("!<arch>")) {
      await tokenizer.ignore(8);
      const str = await tokenizer.readToken(new Token.StringType(13, "ascii"));
      if (str === "debian-binary") {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      return {
        ext: "ar",
        mime: "application/x-unix-archive"
      };
    }
    if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
      await tokenizer.ignore(8);
      async function readChunkHeader() {
        return {
          length: await tokenizer.readToken(Token.INT32_BE),
          type: await tokenizer.readToken(new Token.StringType(4, "binary"))
        };
      }
      do {
        const chunk = await readChunkHeader();
        if (chunk.length < 0) {
          return;
        }
        switch (chunk.type) {
          case "IDAT":
            return {
              ext: "png",
              mime: "image/png"
            };
          case "acTL":
            return {
              ext: "apng",
              mime: "image/apng"
            };
          default:
            await tokenizer.ignore(chunk.length + 4);
        }
      } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
      return {
        ext: "png",
        mime: "image/png"
      };
    }
    if (check([65, 82, 82, 79, 87, 49, 0, 0])) {
      return {
        ext: "arrow",
        mime: "application/x-apache-arrow"
      };
    }
    if (check([103, 108, 84, 70, 2, 0, 0, 0])) {
      return {
        ext: "glb",
        mime: "model/gltf-binary"
      };
    }
    if (check([102, 114, 101, 101], { offset: 4 }) || check([109, 100, 97, 116], { offset: 4 }) || check([109, 111, 111, 118], { offset: 4 }) || check([119, 105, 100, 101], { offset: 4 })) {
      return {
        ext: "mov",
        mime: "video/quicktime"
      };
    }
    if (check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
      return {
        ext: "orf",
        mime: "image/x-olympus-orf"
      };
    }
    if (checkString("gimp xcf ")) {
      return {
        ext: "xcf",
        mime: "image/x-xcf"
      };
    }
    if (check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
      return {
        ext: "rw2",
        mime: "image/x-panasonic-rw2"
      };
    }
    if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
      async function readHeader() {
        const guid = Buffer.alloc(16);
        await tokenizer.readBuffer(guid);
        return {
          id: guid,
          size: Number(await tokenizer.readToken(Token.UINT64_LE))
        };
      }
      await tokenizer.ignore(30);
      while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
        const header = await readHeader();
        let payload = header.size - 24;
        if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
          const typeId = Buffer.alloc(16);
          payload -= await tokenizer.readBuffer(typeId);
          if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "audio/x-ms-asf"
            };
          }
          if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "video/x-ms-asf"
            };
          }
          break;
        }
        await tokenizer.ignore(payload);
      }
      return {
        ext: "asf",
        mime: "application/vnd.ms-asf"
      };
    }
    if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
      return {
        ext: "ktx",
        mime: "image/ktx"
      };
    }
    if ((check([126, 16, 4]) || check([126, 24, 4])) && check([48, 77, 73, 69], { offset: 4 })) {
      return {
        ext: "mie",
        mime: "application/x-mie"
      };
    }
    if (check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
      return {
        ext: "shp",
        mime: "application/x-esri-shape"
      };
    }
    if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
      await tokenizer.ignore(20);
      const type = await tokenizer.readToken(new Token.StringType(4, "ascii"));
      switch (type) {
        case "jp2 ":
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        case "jpx ":
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        case "jpm ":
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        case "mjp2":
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        default:
          return;
      }
    }
    if (check([255, 10]) || check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
      return {
        ext: "jxl",
        mime: "image/jxl"
      };
    }
    if (check([0, 0, 1, 186]) || check([0, 0, 1, 179])) {
      return {
        ext: "mpg",
        mime: "video/mpeg"
      };
    }
    if (check([0, 1, 0, 0, 0])) {
      return {
        ext: "ttf",
        mime: "font/ttf"
      };
    }
    if (check([0, 0, 1, 0])) {
      return {
        ext: "ico",
        mime: "image/x-icon"
      };
    }
    if (check([0, 0, 2, 0])) {
      return {
        ext: "cur",
        mime: "image/x-icon"
      };
    }
    if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
      return {
        ext: "cfb",
        mime: "application/x-cfb"
      };
    }
    await tokenizer.peekBuffer(buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
    if (checkString("BEGIN:")) {
      if (checkString("VCARD", { offset: 6 })) {
        return {
          ext: "vcf",
          mime: "text/vcard"
        };
      }
      if (checkString("VCALENDAR", { offset: 6 })) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
    }
    if (checkString("FUJIFILMCCD-RAW")) {
      return {
        ext: "raf",
        mime: "image/x-fujifilm-raf"
      };
    }
    if (checkString("Extended Module:")) {
      return {
        ext: "xm",
        mime: "audio/x-xm"
      };
    }
    if (checkString("Creative Voice File")) {
      return {
        ext: "voc",
        mime: "audio/x-voc"
      };
    }
    if (check([4, 0, 0, 0]) && buffer.length >= 16) {
      const jsonSize = buffer.readUInt32LE(12);
      if (jsonSize > 12 && buffer.length >= jsonSize + 16) {
        try {
          const header = buffer.slice(16, jsonSize + 16).toString();
          const json = JSON.parse(header);
          if (json.files) {
            return {
              ext: "asar",
              mime: "application/x-asar"
            };
          }
        } catch (_) {
        }
      }
    }
    if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
      return {
        ext: "mxf",
        mime: "application/mxf"
      };
    }
    if (checkString("SCRM", { offset: 44 })) {
      return {
        ext: "s3m",
        mime: "audio/x-s3m"
      };
    }
    if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
      return {
        ext: "mobi",
        mime: "application/x-mobipocket-ebook"
      };
    }
    if (check([68, 73, 67, 77], { offset: 128 })) {
      return {
        ext: "dcm",
        mime: "application/dicom"
      };
    }
    if (check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
      return {
        ext: "lnk",
        mime: "application/x.ms.shortcut"
      };
    }
    if (check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
      return {
        ext: "alias",
        mime: "application/x.apple.alias"
      };
    }
    if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
      return {
        ext: "eot",
        mime: "application/vnd.ms-fontobject"
      };
    }
    if (check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
      return {
        ext: "indd",
        mime: "application/x-indesign"
      };
    }
    await tokenizer.peekBuffer(buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
    if (tarHeaderChecksumMatches(buffer)) {
      return {
        ext: "tar",
        mime: "application/x-tar"
      };
    }
    if (check([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0])) {
      return {
        ext: "skp",
        mime: "application/vnd.sketchup.skp"
      };
    }
    if (checkString("-----BEGIN PGP MESSAGE-----")) {
      return {
        ext: "pgp",
        mime: "application/pgp-encrypted"
      };
    }
    if (buffer.length >= 2 && check([255, 224], { offset: 0, mask: [255, 224] })) {
      if (check([16], { offset: 1, mask: [22] })) {
        if (check([8], { offset: 1, mask: [8] })) {
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        return {
          ext: "aac",
          mime: "audio/aac"
        };
      }
      if (check([2], { offset: 1, mask: [6] })) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (check([4], { offset: 1, mask: [6] })) {
        return {
          ext: "mp2",
          mime: "audio/mpeg"
        };
      }
      if (check([6], { offset: 1, mask: [6] })) {
        return {
          ext: "mp1",
          mime: "audio/mpeg"
        };
      }
    }
  }
  var Token = require_lib11();
  var strtok3 = require_core();
  var {
    stringToBytes,
    tarHeaderChecksumMatches,
    uint32SyncSafeToken
  } = require_util();
  var supported = require_supported();
  var minimumBytes = 4100;
  var stream2 = (readableStream) => new Promise((resolve, reject) => {
    const stream = eval("require")("stream");
    readableStream.on("error", reject);
    readableStream.once("readable", async () => {
      const pass = new stream.PassThrough;
      let outputStream;
      if (stream.pipeline) {
        outputStream = stream.pipeline(readableStream, pass, () => {
        });
      } else {
        outputStream = readableStream.pipe(pass);
      }
      const chunk = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
      try {
        const fileType2 = await fromBuffer(chunk);
        pass.fileType = fileType2;
      } catch (error) {
        reject(error);
      }
      resolve(outputStream);
    });
  });
  var fileType = {
    fromStream,
    fromTokenizer,
    fromBuffer,
    stream: stream2
  };
  Object.defineProperty(fileType, "extensions", {
    get() {
      return new Set(supported.extensions);
    }
  });
  Object.defineProperty(fileType, "mimeTypes", {
    get() {
      return new Set(supported.mimeTypes);
    }
  });
  module.exports = fileType;
});

// ../../node_modules/file-type/index.js
var require_file_type = __commonJS((exports, module) => {
  async function fromFile(path) {
    const tokenizer = await strtok3.fromFile(path);
    try {
      return await core.fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  var strtok3 = require_lib10();
  var core = require_core2();
  var fileType = {
    fromFile
  };
  Object.assign(fileType, core);
  Object.defineProperty(fileType, "extensions", {
    get() {
      return core.extensions;
    }
  });
  Object.defineProperty(fileType, "mimeTypes", {
    get() {
      return core.mimeTypes;
    }
  });
  module.exports = fileType;
});

// ../../node_modules/ws/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  module.exports = {
    BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {
    }
  };
});

// ../../node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports, module) => {
  var concat = function(list, totalLength) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0;i < list.length; i++) {
      const buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength) {
      return new FastBuffer(target.buffer, target.byteOffset, offset);
    }
    return target;
  };
  var _mask = function(source, mask, output, offset, length) {
    for (let i = 0;i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  };
  var _unmask = function(buffer, mask) {
    for (let i = 0;i < buffer.length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  };
  var toArrayBuffer = function(buf) {
    if (buf.length === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
  };
  var toBuffer = function(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = new FastBuffer(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  };
  var { EMPTY_BUFFER } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil = (()=>{throw new Error(`Cannot require module "bufferutil"`);})();
      module.exports.mask = function(source, mask, output, offset, length) {
        if (length < 48)
          _mask(source, mask, output, offset, length);
        else
          bufferUtil.mask(source, mask, output, offset, length);
      };
      module.exports.unmask = function(buffer, mask) {
        if (buffer.length < 32)
          _unmask(buffer, mask);
        else
          bufferUtil.unmask(buffer, mask);
      };
    } catch (e) {
    }
  }
});

// ../../node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports, module) => {
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");

  class Limiter {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  module.exports = Limiter;
});

// ../../node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var deflateOnData = function(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  };
  var inflateOnData = function(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  };
  var inflateOnError = function(err) {
    this[kPerMessageDeflate]._inflate = null;
    err[kStatusCode] = 1007;
    this[kCallback](err);
  };
  var zlib = __require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var { kStatusCode } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;

  class PerMessageDeflate {
    constructor(options, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params = response[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params;
    }
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key) => {
          let value = params[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params[key] = value;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin) {
          data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
        }
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  }
  module.exports = PerMessageDeflate;
});

// ../../node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports, module) => {
  var isValidStatusCode = function(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  };
  var _isValidUTF8 = function(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  };
  var { isUtf8 } = __require("buffer");
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  module.exports = {
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (isUtf8) {
    module.exports.isValidUTF8 = function(buf) {
      return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
  } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = (()=>{throw new Error(`Cannot require module "utf-8-validate"`);})();
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e) {
    }
  }
});

// ../../node_modules/ws/lib/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var queueMicrotaskShim = function(cb) {
    promise.then(cb).catch(throwErrorNextTick);
  };
  var throwError = function(err) {
    throw err;
  };
  var throwErrorNextTick = function(err) {
    process.nextTick(throwError, err);
  };
  var { Writable } = __require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants();
  var { concat, toArrayBuffer, unmask } = require_buffer_util();
  var { isValidStatusCode, isValidUTF8 } = require_validation();
  var FastBuffer = Buffer[Symbol.species];
  var promise = Promise.resolve();
  var queueTask = typeof queueMicrotask === "function" ? queueMicrotask : queueMicrotaskShim;
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  var DEFER_EVENT = 6;

  class Receiver extends Writable {
    constructor(options = {}) {
      super();
      this._allowSynchronousEvents = !!options.allowSynchronousEvents;
      this._binaryType = options.binaryType || BINARY_TYPES[0];
      this._extensions = options.extensions || {};
      this._isServer = !!options.isServer;
      this._maxPayload = options.maxPayload | 0;
      this._skipUTF8Validation = !!options.skipUTF8Validation;
      this[kWebSocket] = undefined;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = undefined;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._errored = false;
      this._loop = false;
      this._state = GET_INFO;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        return new FastBuffer(buf.buffer, buf.byteOffset, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n;
        if (n >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            this.getInfo(cb);
            break;
          case GET_PAYLOAD_LENGTH_16:
            this.getPayloadLength16(cb);
            break;
          case GET_PAYLOAD_LENGTH_64:
            this.getPayloadLength64(cb);
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            this.getData(cb);
            break;
          case INFLATING:
          case DEFER_EVENT:
            this._loop = false;
            return;
        }
      } while (this._loop);
      if (!this._errored)
        cb();
    }
    getInfo(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        const error = this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        cb(error);
        return;
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        cb(error);
        return;
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (!this._fragmented) {
          const error = this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          const error = this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          cb(error);
          return;
        }
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
          const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          cb(error);
          return;
        }
      } else {
        const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        cb(error);
        return;
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          const error = this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          cb(error);
          return;
        }
      } else if (this._masked) {
        const error = this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        cb(error);
        return;
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        this.haveLength(cb);
    }
    getPayloadLength16(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      this.haveLength(cb);
    }
    getPayloadLength64(cb) {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        const error = this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        cb(error);
        return;
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      this.haveLength(cb);
    }
    haveLength(cb) {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          cb(error);
          return;
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }
      if (this._opcode > 7) {
        this.controlMessage(data, cb);
        return;
      }
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      this.dataMessage(cb);
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
            cb(error);
            return;
          }
          this._fragments.push(buf);
        }
        this.dataMessage(cb);
        if (this._state === GET_INFO)
          this.startLoop(cb);
      });
    }
    dataMessage(cb) {
      if (!this._fin) {
        this._state = GET_INFO;
        return;
      }
      const messageLength = this._messageLength;
      const fragments = this._fragments;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];
      if (this._opcode === 2) {
        let data;
        if (this._binaryType === "nodebuffer") {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === "arraybuffer") {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data = fragments;
        }
        if (this._state === INFLATING || this._allowSynchronousEvents) {
          this.emit("message", data, true);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          queueTask(() => {
            this.emit("message", data, true);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      } else {
        const buf = concat(fragments, messageLength);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          cb(error);
          return;
        }
        if (this._state === INFLATING || this._allowSynchronousEvents) {
          this.emit("message", buf, false);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          queueTask(() => {
            this.emit("message", buf, false);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
    }
    controlMessage(data, cb) {
      if (this._opcode === 8) {
        if (data.length === 0) {
          this._loop = false;
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            cb(error);
            return;
          }
          const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            cb(error);
            return;
          }
          this._loop = false;
          this.emit("conclude", code, buf);
          this.end();
        }
        this._state = GET_INFO;
        return;
      }
      if (this._allowSynchronousEvents) {
        this.emit(this._opcode === 9 ? "ping" : "pong", data);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        queueTask(() => {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
    createError(ErrorCtor, message, prefix, statusCode, errorCode) {
      this._loop = false;
      this._errored = true;
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, this.createError);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
  module.exports = Receiver;
});

// ../../node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports, module) => {
  var { Duplex } = __require("stream");
  var { randomFillSync } = __require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var { EMPTY_BUFFER } = require_constants();
  var { isValidStatusCode } = require_validation();
  var { mask: applyMask, toBuffer } = require_buffer_util();
  var kByteLength = Symbol("kByteLength");
  var maskBuffer = Buffer.alloc(4);

  class Sender {
    constructor(socket, extensions, generateMask) {
      this._extensions = extensions || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._deflating = false;
      this._queue = [];
    }
    static frame(data, options) {
      let mask;
      let merge = false;
      let offset = 2;
      let skipMasking = false;
      if (options.mask) {
        mask = options.maskBuffer || maskBuffer;
        if (options.generateMask) {
          options.generateMask(mask);
        } else {
          randomFillSync(mask, 0, 4);
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data === "string") {
        if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
          dataLength = options[kByteLength];
        } else {
          data = Buffer.from(data);
          dataLength = data.length;
        }
      } else {
        dataLength = data.length;
        merge = options.mask && options.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
      target[0] = options.fin ? options.opcode | 128 : options.opcode;
      if (options.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target[2] = target[3] = 0;
        target.writeUIntBE(dataLength, 4, 6);
      }
      if (!options.mask)
        return [target, data];
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (skipMasking)
        return [target, data];
      if (merge) {
        applyMask(data, mask, target, offset, dataLength);
        return [target];
      }
      applyMask(data, mask, data, 0, dataLength);
      return [target, data];
    }
    close(code, data, mask, cb) {
      let buf;
      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length = Buffer.byteLength(data);
        if (length > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        if (typeof data === "string") {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }
      const options = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, buf, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options), cb);
      }
    }
    ping(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    pong(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    send(data, options, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options.binary ? 2 : 1;
      let rsv1 = options.compress;
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options.fin)
        this._firstFragment = true;
      if (perMessageDeflate) {
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      } else {
        this.sendFrame(Sender.frame(data, {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }), cb);
      }
    }
    dispatch(data, compress, options, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options[kByteLength];
      this._deflating = true;
      perMessageDeflate.compress(data, options.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while data was being compressed");
          if (typeof cb === "function")
            cb(err);
          for (let i = 0;i < this._queue.length; i++) {
            const params = this._queue[i];
            const callback = params[params.length - 1];
            if (typeof callback === "function")
              callback(err);
          }
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        this._deflating = false;
        options.readOnly = false;
        this.sendFrame(Sender.frame(buf, options), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (!this._deflating && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[3][kByteLength];
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    enqueue(params) {
      this._bufferedBytes += params[3][kByteLength];
      this._queue.push(params);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }
  module.exports = Sender;
});

// ../../node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports, module) => {
  var callListener = function(listener, thisArg, event) {
    if (typeof listener === "object" && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  };
  var { kForOnEventAttribute, kListener } = require_constants();
  var kCode = Symbol("kCode");
  var kData = Symbol("kData");
  var kError = Symbol("kError");
  var kMessage = Symbol("kMessage");
  var kReason = Symbol("kReason");
  var kTarget = Symbol("kTarget");
  var kType = Symbol("kType");
  var kWasClean = Symbol("kWasClean");

  class Event {
    constructor(type) {
      this[kTarget] = null;
      this[kType] = type;
    }
    get target() {
      return this[kTarget];
    }
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event.prototype, "target", { enumerable: true });
  Object.defineProperty(Event.prototype, "type", { enumerable: true });

  class CloseEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kCode] = options.code === undefined ? 0 : options.code;
      this[kReason] = options.reason === undefined ? "" : options.reason;
      this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
    }
    get code() {
      return this[kCode];
    }
    get reason() {
      return this[kReason];
    }
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

  class ErrorEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kError] = options.error === undefined ? null : options.error;
      this[kMessage] = options.message === undefined ? "" : options.message;
    }
    get error() {
      return this[kError];
    }
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

  class MessageEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kData] = options.data === undefined ? null : options.data;
    }
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  var EventTarget = {
    addEventListener(type, handler, options = {}) {
      for (const listener of this.listeners(type)) {
        if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          return;
        }
      }
      let wrapper;
      if (type === "message") {
        wrapper = function onMessage(data, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "close") {
        wrapper = function onClose(code, message) {
          const event = new CloseEvent("close", {
            code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "error") {
        wrapper = function onError(error) {
          const event = new ErrorEvent("error", {
            error,
            message: error.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "open") {
        wrapper = function onOpen() {
          const event = new Event("open");
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    removeEventListener(type, handler) {
      for (const listener of this.listeners(type)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    }
  };
  module.exports = {
    CloseEvent,
    ErrorEvent,
    Event,
    EventTarget,
    MessageEvent
  };
});

// ../../node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  var push = function(dest, name, elem) {
    if (dest[name] === undefined)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  };
  var parse = function(header) {
    const offers = Object.create(null);
    let params = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let code = -1;
    let end = -1;
    let i = 0;
    for (;i < header.length; i++) {
      code = header.charCodeAt(i);
      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          push(params, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start === -1)
            start = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          let value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start === -1 || inQuotes || code === 32 || code === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i;
    const token = header.slice(start, end);
    if (extensionName === undefined) {
      push(offers, token, params);
    } else {
      if (paramName === undefined) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  };
  var format = function(extensions) {
    return Object.keys(extensions).map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params) => {
        return [extension].concat(Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  };
  var { tokenChars } = require_validation();
  module.exports = { format, parse };
});

// ../../node_modules/ws/lib/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var initAsClient = function(websocket, address, protocols, options) {
    const opts = {
      allowSynchronousEvents: false,
      autoPong: true,
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options,
      createConnection: undefined,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: "GET",
      host: undefined,
      path: undefined,
      port: undefined
    };
    websocket._autoPong = opts.autoPong;
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address instanceof URL2) {
      parsedUrl = address;
    } else {
      try {
        parsedUrl = new URL2(address);
      } catch (e) {
        throw new SyntaxError(`Invalid URL: ${address}`);
      }
    }
    if (parsedUrl.protocol === "http:") {
      parsedUrl.protocol = "ws:";
    } else if (parsedUrl.protocol === "https:") {
      parsedUrl.protocol = "wss:";
    }
    websocket._url = parsedUrl.href;
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = 'The URL\'s protocol must be one of "ws:", "wss:", ' + '"http:", "https", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err = new SyntaxError(invalidUrlMessage);
      if (websocket._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket, err);
        return;
      }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes(16).toString("base64");
    const request = isSecure ? https.request : http.request;
    const protocolSet = new Set;
    let perMessageDeflate;
    opts.createConnection = isSecure ? tlsConnect : netConnect;
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol of protocols) {
        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError("An invalid or duplicated subprotocol was specified");
        }
        protocolSet.add(protocol);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket._redirects === 0) {
        websocket._originalIpc = isIpcUrl;
        websocket._originalSecure = isSecure;
        websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options && options.headers;
        options = { ...options, headers: {} };
        if (headers) {
          for (const [key2, value] of Object.entries(headers)) {
            options.headers[key2.toLowerCase()] = value;
          }
        }
      } else if (websocket.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
        if (!isSameHost || websocket._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost)
            delete opts.headers.host;
          opts.auth = undefined;
        }
      }
      if (opts.auth && !options.headers.authorization) {
        options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket._req = request(opts);
      if (websocket._redirects) {
        websocket.emit("redirect", websocket.url, req);
      }
    } else {
      req = websocket._req = request(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req[kAborted])
        return;
      req = websocket._req = null;
      emitErrorAndClose(websocket, err);
    });
    req.on("response", (res) => {
      const location = res.headers.location;
      const statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL2(location, address);
        } catch (e) {
          const err = new SyntaxError(`Invalid URL: ${location}`);
          emitErrorAndClose(websocket, err);
          return;
        }
        initAsClient(websocket, addr, protocols, options);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket2.CONNECTING)
        return;
      req = websocket._req = null;
      if (res.headers.upgrade.toLowerCase() !== "websocket") {
        abortHandshake(websocket, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension " + "was requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        let extensions;
        try {
          extensions = parse(secWebSocketExtensions);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket.setSocket(socket, head, {
        allowSynchronousEvents: opts.allowSynchronousEvents,
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    if (opts.finishRequest) {
      opts.finishRequest(req, websocket);
    } else {
      req.end();
    }
  };
  var emitErrorAndClose = function(websocket, err) {
    websocket._readyState = WebSocket2.CLOSING;
    websocket.emit("error", err);
    websocket.emitClose();
  };
  var netConnect = function(options) {
    options.path = options.socketPath;
    return net.connect(options);
  };
  var tlsConnect = function(options) {
    options.path = undefined;
    if (!options.servername && options.servername !== "") {
      options.servername = net.isIP(options.host) ? "" : options.host;
    }
    return tls.connect(options);
  };
  var abortHandshake = function(websocket, stream2, message) {
    websocket._readyState = WebSocket2.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream2.setHeader) {
      stream2[kAborted] = true;
      stream2.abort();
      if (stream2.socket && !stream2.socket.destroyed) {
        stream2.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket, err);
    } else {
      stream2.destroy(err);
      stream2.once("error", websocket.emit.bind(websocket, "error"));
      stream2.once("close", websocket.emitClose.bind(websocket));
    }
  };
  var sendAfterClose = function(websocket, data, cb) {
    if (data) {
      const length = toBuffer(data).length;
      if (websocket._socket)
        websocket._sender._bufferedBytes += length;
      else
        websocket._bufferedAmount += length;
    }
    if (cb) {
      const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
      process.nextTick(cb, err);
    }
  };
  var receiverOnConclude = function(code, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket] === undefined)
      return;
    websocket._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket._socket);
    if (code === 1005)
      websocket.close();
    else
      websocket.close(code, reason);
  };
  var receiverOnDrain = function() {
    const websocket = this[kWebSocket];
    if (!websocket.isPaused)
      websocket._socket.resume();
  };
  var receiverOnError = function(err) {
    const websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      websocket.close(err[kStatusCode]);
    }
    websocket.emit("error", err);
  };
  var receiverOnFinish = function() {
    this[kWebSocket].emitClose();
  };
  var receiverOnMessage = function(data, isBinary) {
    this[kWebSocket].emit("message", data, isBinary);
  };
  var receiverOnPing = function(data) {
    const websocket = this[kWebSocket];
    if (websocket._autoPong)
      websocket.pong(data, !this._isServer, NOOP);
    websocket.emit("ping", data);
  };
  var receiverOnPong = function(data) {
    this[kWebSocket].emit("pong", data);
  };
  var resume = function(stream2) {
    stream2.resume();
  };
  var socketOnClose = function() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket._readyState = WebSocket2.CLOSING;
    let chunk;
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
      websocket._receiver.write(chunk);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  };
  var socketOnData = function(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  };
  var socketOnEnd = function() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket2.CLOSING;
    websocket._receiver.end();
    this.end();
  };
  var socketOnError = function() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket) {
      websocket._readyState = WebSocket2.CLOSING;
      this.destroy();
    }
  };
  var EventEmitter = __require("events");
  var https = __require("https");
  var http = __require("http");
  var net = __require("net");
  var tls = __require("tls");
  var { randomBytes, createHash } = __require("crypto");
  var { Duplex, Readable } = __require("stream");
  var { URL: URL2 } = __require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var Receiver = require_receiver();
  var Sender = require_sender();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants();
  var {
    EventTarget: { addEventListener, removeEventListener }
  } = require_event_target();
  var { format, parse } = require_extension();
  var { toBuffer } = require_buffer_util();
  var closeTimeout = 30 * 1000;
  var kAborted = Symbol("kAborted");
  var protocolVersions = [8, 13];
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  class WebSocket2 extends EventEmitter {
    constructor(address, protocols, options) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket2.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address, protocols, options);
      } else {
        this._autoPong = options.autoPong;
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get isPaused() {
      return this._paused;
    }
    get onclose() {
      return null;
    }
    get onerror() {
      return null;
    }
    get onopen() {
      return null;
    }
    get onmessage() {
      return null;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head, options) {
      const receiver = new Receiver({
        allowSynchronousEvents: options.allowSynchronousEvents,
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options.maxPayload,
        skipUTF8Validation: options.skipUTF8Validation
      });
      this._sender = new Sender(socket, this._extensions, options.generateMask);
      this._receiver = receiver;
      this._socket = socket;
      receiver[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      if (socket.setTimeout)
        socket.setTimeout(0);
      if (socket.setNoDelay)
        socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket2.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket2.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket2.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
      if (this.readyState === WebSocket2.CLOSED)
        return;
      if (this.readyState === WebSocket2.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this.readyState === WebSocket2.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket2.CLOSING;
      this._sender.close(code, data, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
    }
    pause() {
      if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    ping(data, mask, cb) {
      if (this.readyState === WebSocket2.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket2.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (this.readyState === WebSocket2.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket2.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    resume() {
      if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain)
        this._socket.resume();
    }
    send(data, options, cb) {
      if (this.readyState === WebSocket2.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket2.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket2.CLOSED)
        return;
      if (this.readyState === WebSocket2.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this._socket) {
        this._readyState = WebSocket2.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket2, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket2, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket2.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket2, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket2.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket2, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket2.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket2.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute])
            return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function")
          return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket2.prototype.addEventListener = addEventListener;
  WebSocket2.prototype.removeEventListener = removeEventListener;
  module.exports = WebSocket2;
});

// ../../node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var emitClose = function(stream2) {
    stream2.emit("close");
  };
  var duplexOnEnd = function() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  };
  var duplexOnError = function(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  };
  var createWebSocketStream = function(ws, options) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
      ...options,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data))
        ws.pause();
    });
    ws.once("error", function error(err) {
      if (duplex.destroyed)
        return;
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy)
        ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused)
        ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  };
  var { Duplex } = __require("stream");
  module.exports = createWebSocketStream;
});

// ../../node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS((exports, module) => {
  var parse = function(header) {
    const protocols = new Set;
    let start = -1;
    let end = -1;
    let i = 0;
    for (i;i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        const protocol2 = header.slice(start, end);
        if (protocols.has(protocol2)) {
          throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
        }
        protocols.add(protocol2);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
    if (start === -1 || end !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol = header.slice(start, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
  };
  var { tokenChars } = require_validation();
  module.exports = { parse };
});

// ../../node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports, module) => {
  var addListeners = function(server, map) {
    for (const event of Object.keys(map))
      server.on(event, map[event]);
    return function removeListeners() {
      for (const event of Object.keys(map)) {
        server.removeListener(event, map[event]);
      }
    };
  };
  var emitClose = function(server) {
    server._state = CLOSED;
    server.emit("close");
  };
  var socketOnError = function() {
    this.destroy();
  };
  var abortHandshake = function(socket, code, message, headers) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h2) => `${h2}: ${headers[h2]}`).join("\r\n") + "\r\n\r\n" + message);
  };
  var abortHandshakeOrEmitwsClientError = function(server, req, socket, code, message) {
    if (server.listenerCount("wsClientError")) {
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err, socket, req);
    } else {
      abortHandshake(socket, code, message);
    }
  };
  var EventEmitter = __require("events");
  var http = __require("http");
  var { Duplex } = __require("stream");
  var { createHash } = __require("crypto");
  var extension = require_extension();
  var PerMessageDeflate = require_permessage_deflate();
  var subprotocol = require_subprotocol();
  var WebSocket2 = require_websocket();
  var { GUID, kWebSocket } = require_constants();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  class WebSocketServer extends EventEmitter {
    constructor(options, callback) {
      super();
      options = {
        allowSynchronousEvents: false,
        autoPong: true,
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket: WebSocket2,
        ...options
      };
      if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + "must be specified");
      }
      if (options.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options.port, options.host, options.backlog, callback);
      } else if (options.server) {
        this._server = options.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options.perMessageDeflate === true)
        options.perMessageDeflate = {};
      if (options.clientTracking) {
        this.clients = new Set;
        this._shouldEmitClose = false;
      }
      this.options = options;
      this._state = RUNNING;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb)
        this.once("close", cb);
      if (this._state === CLOSING)
        return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"];
      const version = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (req.headers.upgrade.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (!key || !keyRegex.test(key)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version !== 8 && version !== 13) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = new Set;
      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same " + "socket, possibly due to a misconfiguration");
      }
      if (this._state > RUNNING)
        return abortHandshake(socket, 503);
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null, undefined, this.options);
      if (protocols.size) {
        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params = extensions[PerMessageDeflate.extensionName].params;
        const value = extension.format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat("\r\n").join("\r\n"));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, {
        allowSynchronousEvents: this.options.allowSynchronousEvents,
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  module.exports = WebSocketServer;
});

// ../../node_modules/ws/index.js
var require_ws = __commonJS((exports, module) => {
  var WebSocket2 = require_websocket();
  WebSocket2.createWebSocketStream = require_stream();
  WebSocket2.Server = require_websocket_server();
  WebSocket2.Receiver = require_receiver();
  WebSocket2.Sender = require_sender();
  WebSocket2.WebSocket = WebSocket2;
  WebSocket2.WebSocketServer = WebSocket2.Server;
  module.exports = WebSocket2;
});

// ../../node_modules/@cordisjs/plugin-http/lib/adapter/node.cjs
var require_node2 = __commonJS((exports, module) => {
  async function loadFile(url) {
    if (url.startsWith("file://")) {
      const data = await (0, import_promises.readFile)((0, import_node_url.fileURLToPath)(url));
      const result = await import_file_type.default.fromBuffer(data);
      return {
        type: result?.mime,
        mime: result?.mime,
        filename: (0, import_node_path.basename)(url),
        data: import_cosmokit.Binary.fromSource(data)
      };
    }
  }
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var node_exports = {};
  __export2(node_exports, {
    WebSocket: () => import_ws.WebSocket,
    loadFile: () => loadFile,
    lookup: () => import_promises2.lookup
  });
  module.exports = __toCommonJS(node_exports);
  var import_node_url = __require("node:url");
  var import_node_path = __require("node:path");
  var import_file_type = __toESM2(require_file_type(), 1);
  var import_promises = __require("node:fs/promises");
  var import_cosmokit = require_lib();
  var import_promises2 = __require("node:dns/promises");
  var import_ws = require_ws();
  __name(loadFile, "loadFile");
});

// ../../node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-globalThis": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.globalThis": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/globalThis": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/globalThis-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/globalThis-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/globalThis-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step": {
      source: "iana"
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// ../../node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_db();
});

// ../../node_modules/@cordisjs/plugin-http/lib/index.cjs
var require_lib12 = __commonJS((exports, module) => {
  var parseIPv4 = function(ip) {
    return ip.split(".").reduce((a, b) => (a << 8n) + BigInt(b), 0n);
  };
  var parseIPv6 = function(ip) {
    const exp = ip.indexOf("::");
    let num = 0n;
    if (exp !== -1 && exp !== 0) {
      ip.slice(0, exp).split(":").forEach((piece, i) => {
        num |= BigInt(`0x${piece}`) << BigInt((7 - i) * 16);
      });
    }
    if (exp === ip.length - 2) {
      return num;
    }
    const rest = exp === -1 ? ip : ip.slice(exp + 2);
    const v4 = rest.includes(".");
    const pieces = rest.split(":");
    let start = 0;
    if (v4) {
      start += 2;
      const [addr] = pieces.splice(-1, 1);
      num |= parseIPv4(addr);
    }
    pieces.reverse().forEach((piece, i) => {
      num |= BigInt(`0x${piece}`) << BigInt((start + i) * 8);
    });
    return num;
  };
  async function isLocalAddress({ address, family }) {
    if (family !== 4 && family !== 6)
      return false;
    const { bogons, length, parse } = family === 4 ? { bogons: bogonV4, length: 32, parse: parseIPv4 } : { bogons: bogonV6, length: 128, parse: parseIPv6 };
    const num = parse(address);
    for (const bogon of bogons) {
      const [prefix, cidr] = bogon.split("/");
      const mask = (1n << BigInt(cidr)) - 1n << BigInt(length - +cidr);
      if ((num & mask) === parse(prefix))
        return true;
    }
    return false;
  }
  var encodeRequest = function(data) {
    if (data instanceof URLSearchParams)
      return [null, data];
    if (data instanceof ArrayBuffer)
      return [null, data];
    if (ArrayBuffer.isView(data))
      return [null, data];
    if (data instanceof Blob)
      return [null, data];
    if (data instanceof FormData)
      return [null, data];
    return ["application/json", JSON.stringify(data)];
  };
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    HTTP: () => HTTP2,
    default: () => src_default
  });
  module.exports = __toCommonJS(src_exports);
  var import_cordis = require_lib8();
  var import_cosmokit = require_lib();
  var import_adapter = require_node2();
  var bogonV4 = [
    "0.0.0.0/8",
    "10.0.0.0/8",
    "100.64.0.0/10",
    "127.0.0.0/8",
    "169.254.0.0/16",
    "172.16.0.0/12",
    "192.0.2.0/24",
    "192.88.99.0/24",
    "192.168.0.0/16",
    "198.18.0.0/15",
    "198.51.100.0/24",
    "203.0.113.0/24",
    "224.0.0.0/4",
    "240.0.0.0/4"
  ];
  var bogonV6 = [
    "::/8",
    "0100::/64",
    "2001:2::/48",
    "2001:10::/28",
    "2001:db8::/32",
    "2002::/16",
    "3ffe::/16",
    "fc00::/7",
    "fe80::/10",
    "fec0::/10",
    "ff00::/8"
  ];
  __name(parseIPv4, "parseIPv4");
  __name(parseIPv6, "parseIPv6");
  __name(isLocalAddress, "isLocalAddress");
  var import_mime_db = __toESM2(require_mime_db(), 1);
  var kHTTPError = Symbol.for("cordis.http.error");
  var HTTPError = class extends Error {
    constructor(message, code) {
      super(message);
      this.code = code;
    }
    static {
      __name(this, "HTTPError");
    }
    [kHTTPError] = true;
    response;
    static is(error) {
      return !!error?.[kHTTPError];
    }
  };
  __name(encodeRequest, "encodeRequest");
  var HTTP2 = class _HTTP extends import_cordis.Service {
    static {
      __name(this, "HTTP");
    }
    static Error = HTTPError;
    static isAxiosError = HTTPError.is;
    static [import_cordis.Service.provide] = "http";
    static [import_cordis.Service.immediate] = true;
    static {
      for (const method of ["get", "delete"]) {
        (0, import_cosmokit.defineProperty)(_HTTP.prototype, method, async function(url, config) {
          const response = await this(url, { method, ...config });
          return response.data;
        });
      }
      for (const method of ["patch", "post", "put"]) {
        (0, import_cosmokit.defineProperty)(_HTTP.prototype, method, async function(url, data, config) {
          const response = await this(url, { method, data, ...config });
          return response.data;
        });
      }
    }
    isError = HTTPError.is;
    _decoders = Object.create(null);
    constructor(...args) {
      super(args[0], args[1]);
      this.decoder("json", (raw) => raw.json());
      this.decoder("text", (raw) => raw.text());
      this.decoder("blob", (raw) => raw.blob());
      this.decoder("arraybuffer", (raw) => raw.arrayBuffer());
      this.decoder("formdata", (raw) => raw.formData());
      this.decoder("stream", (raw) => raw.body);
      this.ctx.on("http/file", (url, options) => (0, import_adapter.loadFile)(url));
    }
    static mergeConfig = (target, source) => ({
      ...target,
      ...source,
      headers: {
        ...target?.headers,
        ...source?.headers
      }
    });
    decoder(type, decoder) {
      return this[import_cordis.Context.origin].effect(() => {
        this._decoders[type] = decoder;
        return () => delete this._decoders[type];
      });
    }
    extend(config = {}) {
      return this[import_cordis.Service.extend]({
        config: _HTTP.mergeConfig(this.config, config)
      });
    }
    resolveConfig(init) {
      const caller = this[import_cordis.Context.origin];
      let result = { headers: {}, ...this.config };
      caller.emit(this, "http/config", result);
      let intercept = caller[import_cordis.Context.intercept];
      while (intercept) {
        result = _HTTP.mergeConfig(result, intercept.http);
        intercept = Object.getPrototypeOf(intercept);
      }
      result = _HTTP.mergeConfig(result, init);
      return result;
    }
    resolveURL(url, config, isWebSocket = false) {
      if (config.endpoint) {
        try {
          new URL(url);
        } catch {
          url = (0, import_cosmokit.trimSlash)(config.endpoint) + url;
        }
      }
      try {
        url = new URL(url, config.baseURL);
      } catch (error) {
        throw new TypeError(`Invalid URL: ${url}`);
      }
      if (isWebSocket)
        url.protocol = url.protocol.replace(/^http/, "ws");
      for (const [key, value] of Object.entries(config.params ?? {})) {
        if ((0, import_cosmokit.isNullable)(value))
          continue;
        url.searchParams.append(key, value);
      }
      return url;
    }
    defaultDecoder(response) {
      const type = response.headers.get("Content-Type");
      if (type?.startsWith("application/json")) {
        return response.json();
      } else if (type?.startsWith("text/")) {
        return response.text();
      } else {
        return response.arrayBuffer();
      }
    }
    async[import_cordis.Service.invoke](...args) {
      const caller = this[import_cordis.Context.origin];
      let method;
      if (typeof args[1] === "string" || args[1] instanceof URL) {
        method = args.shift();
      }
      const config = this.resolveConfig(args[1]);
      const url = this.resolveURL(args[0], config);
      method ??= config.method ?? "GET";
      const controller = new AbortController;
      if (config.signal) {
        if (config.signal.aborted) {
          throw config.signal.reason;
        }
        config.signal.addEventListener("abort", () => {
          controller.abort(config.signal.reason);
        });
      }
      const dispose = caller.effect(() => {
        const timer = config.timeout && setTimeout(() => {
          controller.abort(new HTTPError("request timeout", "ETIMEDOUT"));
        }, config.timeout);
        return (done) => {
          clearTimeout(timer);
          if (done)
            return;
          controller.abort(new HTTPError("context disposed", "ETIMEDOUT"));
        };
      });
      controller.signal.addEventListener("abort", () => dispose());
      try {
        const headers = new Headers(config.headers);
        const init = {
          method,
          headers,
          body: config.data,
          keepalive: config.keepAlive,
          redirect: config.redirect,
          signal: controller.signal
        };
        if (config.data && typeof config.data === "object") {
          const [type, body] = encodeRequest(config.data);
          init.body = body;
          if (type && !headers.has("Content-Type")) {
            headers.append("Content-Type", type);
          }
        }
        caller.emit(this, "http/fetch-init", url, init, config);
        const raw = await fetch(url, init).catch((cause) => {
          if (_HTTP.Error.is(cause))
            throw cause;
          const error = new _HTTP.Error(`fetch ${url} failed`);
          error.cause = cause;
          throw error;
        });
        const response = {
          data: null,
          url: raw.url,
          status: raw.status,
          statusText: raw.statusText,
          headers: raw.headers
        };
        const validateStatus = config.validateStatus ?? ((status) => status < 400);
        if (!validateStatus(raw.status)) {
          const error = new _HTTP.Error(raw.statusText);
          error.response = response;
          try {
            response.data = await this.defaultDecoder(raw);
          } catch {
          }
          throw error;
        }
        if (config.responseType) {
          if (!(config.responseType in this._decoders)) {
            throw new TypeError(`Unknown responseType: ${config.responseType}`);
          }
          const decoder = this._decoders[config.responseType];
          response.data = await decoder(raw);
        } else {
          response.data = await this.defaultDecoder(raw);
        }
        return response;
      } finally {
        dispose(true);
      }
    }
    async head(url, config) {
      const response = await this(url, { method: "HEAD", ...config });
      return response.headers;
    }
    axios(...args) {
      const caller = this[import_cordis.Context.origin];
      caller.emit("internal/warning", "ctx.http.axios() is deprecated, use ctx.http() instead");
      if (typeof args[0] === "string") {
        return this(args[0], args[1]);
      } else {
        return this(args[0].url, args[0]);
      }
    }
    ws(url, init) {
      const caller = this[import_cordis.Context.origin];
      const config = this.resolveConfig(init);
      url = this.resolveURL(url, config, true);
      let options;
      if (import_adapter.WebSocket !== globalThis.WebSocket) {
        options = {
          handshakeTimeout: config?.timeout,
          headers: config?.headers
        };
        caller.emit(this, "http/websocket-init", url, options, config);
      }
      const socket = new import_adapter.WebSocket(url, options);
      const dispose = caller.on("dispose", () => {
        socket.close(1000, "context disposed");
      });
      socket.addEventListener("close", () => {
        dispose();
      });
      return socket;
    }
    async file(url, options = {}) {
      const task = await this[import_cordis.Context.origin].serial(this, "http/file", url, options);
      if (task)
        return task;
      const capture = /^data:([\w/-]+);base64,(.*)$/.exec(url);
      if (capture) {
        const [, type2, base64] = capture;
        let name2 = "file";
        const ext = type2 && import_mime_db.default[type2]?.extensions?.[0];
        if (ext)
          name2 += `.${ext}`;
        return { type: type2, mime: type2, data: import_cosmokit.Binary.fromBase64(base64), filename: name2 };
      }
      const { headers, data, url: responseUrl } = await this(url, {
        method: "GET",
        responseType: "arraybuffer",
        timeout: +options.timeout || undefined
      });
      const type = headers.get("content-type");
      const [, name] = responseUrl.match(/.+\/([^/?]*)(?=\?)?/);
      return { type, mime: type, filename: name, data };
    }
    async isLocal(url) {
      let { hostname, protocol } = new URL(url);
      if (protocol !== "http:" && protocol !== "https:")
        return true;
      if (/^\[.+\]$/.test(hostname)) {
        hostname = hostname.slice(1, -1);
      }
      try {
        const address = await (0, import_adapter.lookup)(hostname);
        return isLocalAddress(address);
      } catch {
        return false;
      }
    }
  };
  var src_default = HTTP2;
});

// ../../node_modules/@satorijs/element/lib/index.cjs
var require_lib13 = __commonJS((exports, module) => {
  var Element2 = function(type, ...args) {
    const el = Object.create(ElementConstructor.prototype);
    const attrs = {}, children = [];
    if (args[0] && typeof args[0] === "object" && !Element2.isElement(args[0]) && !Array.isArray(args[0])) {
      const props = args.shift();
      for (const [key, value] of Object.entries(props)) {
        if ((0, import_cosmokit.isNullable)(value))
          continue;
        if (key === "children") {
          args.push(...(0, import_cosmokit.makeArray)(value));
        } else {
          attrs[(0, import_cosmokit.camelize)(key)] = value;
        }
      }
    }
    for (const child of args) {
      children.push(...Element2.toElementArray(child));
    }
    if (typeof type === "function") {
      attrs.is = type;
      type = "component";
    }
    return Object.assign(el, { type, attrs, children });
  };
  var __defProp2 = Object.defineProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var import_cosmokit = require_lib();
  var kElement = Symbol.for("satori.element");
  var ElementConstructor = class {
    static {
      __name(this, "ElementConstructor");
    }
    get data() {
      return this.attrs;
    }
    getTagName() {
      if (this.type === "component") {
        return this.attrs.is?.name ?? "component";
      } else {
        return this.type;
      }
    }
    toAttrString() {
      return Object.entries(this.attrs).map(([key, value]) => {
        if ((0, import_cosmokit.isNullable)(value))
          return "";
        key = (0, import_cosmokit.hyphenate)(key);
        if (value === true)
          return ` ${key}`;
        if (value === false)
          return ` no-${key}`;
        return ` ${key}="${Element2.escape("" + value, true)}"`;
      }).join("");
    }
    toString(strip = false) {
      if (this.type === "text" && "content" in this.attrs) {
        return strip ? this.attrs.content : Element2.escape(this.attrs.content);
      }
      const inner = this.children.map((child) => child.toString(strip)).join("");
      if (strip)
        return inner;
      const attrs = this.toAttrString();
      const tag = this.getTagName();
      if (!this.children.length)
        return `<${tag}${attrs}/>`;
      return `<${tag}${attrs}>${inner}</${tag}>`;
    }
  };
  (0, import_cosmokit.defineProperty)(ElementConstructor, "name", "Element");
  (0, import_cosmokit.defineProperty)(ElementConstructor.prototype, kElement, true);
  __name(Element2, "Element");
  var evaluate = new Function("expr", "context", `
  try {
    with (context) {
      return eval(expr)
    }
  } catch {}
`);
  ((Element22) => {
    Element22.jsx = Element22;
    Element22.jsxs = Element22;
    Element22.jsxDEV = Element22;
    Element22.Fragment = "template";
    function isElement(source) {
      return source && typeof source === "object" && source[kElement];
    }
    Element22.isElement = isElement;
    __name(isElement, "isElement");
    function toElement(content) {
      if (typeof content === "string" || typeof content === "number" || typeof content === "boolean") {
        content = "" + content;
        if (content)
          return Element22("text", { content });
      } else if (isElement(content)) {
        return content;
      } else if (!(0, import_cosmokit.isNullable)(content)) {
        throw new TypeError(`Invalid content: ${content}`);
      }
    }
    Element22.toElement = toElement;
    __name(toElement, "toElement");
    function toElementArray(content) {
      if (Array.isArray(content)) {
        return content.map(toElement).filter((x) => x);
      } else {
        return [toElement(content)].filter((x) => x);
      }
    }
    Element22.toElementArray = toElementArray;
    __name(toElementArray, "toElementArray");
    function normalize(source, context2) {
      return typeof source === "string" ? parse(source, context2) : toElementArray(source);
    }
    Element22.normalize = normalize;
    __name(normalize, "normalize");
    function escape(source, inline = false) {
      const result = (source ?? "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      return inline ? result.replace(/"/g, "&quot;") : result;
    }
    Element22.escape = escape;
    __name(escape, "escape");
    function unescape(source) {
      return source.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#(\d+);/g, (_, code) => code === "38" ? _ : String.fromCharCode(+code)).replace(/&#x([0-9a-f]+);/gi, (_, code) => code === "26" ? _ : String.fromCharCode(parseInt(code, 16))).replace(/&(amp|#38|#x26);/g, "&");
    }
    Element22.unescape = unescape;
    __name(unescape, "unescape");
    function from(source, options = {}) {
      const elements = parse(source);
      if (options.caret) {
        if (options.type && elements[0]?.type !== options.type)
          return;
        return elements[0];
      }
      return select(elements, options.type || "*")[0];
    }
    Element22.from = from;
    __name(from, "from");
    const combRegExp = / *([ >+~]) */g;
    function parseSelector(input) {
      return input.split(",").map((query) => {
        const selectors = [];
        query = query.trim();
        let combCap, combinator = " ";
        while (combCap = combRegExp.exec(query)) {
          selectors.push({ type: query.slice(0, combCap.index), combinator });
          combinator = combCap[1];
          query = query.slice(combCap.index + combCap[0].length);
        }
        selectors.push({ type: query, combinator });
        return selectors;
      });
    }
    Element22.parseSelector = parseSelector;
    __name(parseSelector, "parseSelector");
    function select(source, query) {
      if (!source || !query)
        return [];
      if (typeof source === "string")
        source = parse(source);
      if (typeof query === "string")
        query = parseSelector(query);
      if (!query.length)
        return [];
      let adjacent = [];
      const results = [];
      for (const [index, element] of source.entries()) {
        const inner = [];
        const local = [...query, ...adjacent];
        adjacent = [];
        let matched = false;
        for (const group of local) {
          const { type, combinator } = group[0];
          if (type === element.type || type === "*") {
            if (group.length === 1) {
              matched = true;
            } else if ([" ", ">"].includes(group[1].combinator)) {
              inner.push(group.slice(1));
            } else if (group[1].combinator === "+") {
              adjacent.push(group.slice(1));
            } else {
              query.push(group.slice(1));
            }
          }
          if (combinator === " ") {
            inner.push(group);
          }
        }
        if (matched)
          results.push(source[index]);
        results.push(...select(element.children, inner));
      }
      return results;
    }
    Element22.select = select;
    __name(select, "select");
    function interpolate(expr, context2) {
      expr = expr.trim();
      if (!/^[\w.]+$/.test(expr)) {
        return evaluate(expr, context2) ?? "";
      }
      let value = context2;
      for (const part of expr.split(".")) {
        value = value[part];
        if ((0, import_cosmokit.isNullable)(value))
          return "";
      }
      return value ?? "";
    }
    Element22.interpolate = interpolate;
    __name(interpolate, "interpolate");
    const tagRegExp1 = /(?<comment><!--[\s\S]*?-->)|(?<tag><(\/?)([^!\s>/]*)([^>]*?)\s*(\/?)>)/;
    const tagRegExp2 = /(?<comment><!--[\s\S]*?-->)|(?<tag><(\/?)([^!\s>/]*)([^>]*?)\s*(\/?)>)|(?<curly>\{(?<derivative>[@:/#][^\s}]*)?[\s\S]*?\})/;
    const attrRegExp1 = /([^\s=]+)(?:="(?<value1>[^"]*)"|='(?<value2>[^']*)')?/g;
    const attrRegExp2 = /([^\s=]+)(?:="(?<value1>[^"]*)"|='(?<value2>[^']*)'|=\{(?<curly>[^}]+)\})?/g;
    let Position;
    ((Position2) => {
      Position2[Position2["OPEN"] = 0] = "OPEN";
      Position2[Position2["CLOSE"] = 1] = "CLOSE";
      Position2[Position2["EMPTY"] = 2] = "EMPTY";
      Position2[Position2["CONTINUE"] = 3] = "CONTINUE";
    })(Position || (Position = {}));
    function parse(source, context2) {
      const tokens = [];
      function pushText(content) {
        if (content)
          tokens.push(content);
      }
      __name(pushText, "pushText");
      const tagRegExp = context2 ? tagRegExp2 : tagRegExp1;
      let tagCap;
      let trimStart = true;
      while (tagCap = tagRegExp.exec(source)) {
        const trimEnd = !tagCap.groups.curly;
        parseContent(source.slice(0, tagCap.index), trimStart, trimEnd);
        trimStart = trimEnd;
        source = source.slice(tagCap.index + tagCap[0].length);
        const [_, , , close, type, extra, empty] = tagCap;
        if (tagCap.groups.comment)
          continue;
        if (tagCap.groups.curly) {
          let name = "", position = 2;
          if (tagCap.groups.derivative) {
            name = tagCap.groups.derivative.slice(1);
            position = {
              "@": 2,
              "#": 0,
              "/": 1,
              ":": 3
            }[tagCap.groups.derivative[0]];
          }
          tokens.push({
            type: "curly",
            name,
            position,
            source: tagCap.groups.curly,
            extra: tagCap.groups.curly.slice(1 + (tagCap.groups.derivative ?? "").length, -1)
          });
          continue;
        }
        tokens.push({
          type: "angle",
          source: _,
          name: type || Element22.Fragment,
          position: close ? 1 : empty ? 2 : 0,
          extra
        });
      }
      parseContent(source, trimStart, true);
      function parseContent(source2, trimStart2, trimEnd) {
        source2 = unescape(source2);
        if (trimStart2)
          source2 = source2.replace(/^\s*\n\s*/, "");
        if (trimEnd)
          source2 = source2.replace(/\s*\n\s*$/, "");
        pushText(source2);
      }
      __name(parseContent, "parseContent");
      return parseTokens(foldTokens(tokens), context2);
    }
    Element22.parse = parse;
    __name(parse, "parse");
    function foldTokens(tokens) {
      const stack = [[{
        type: "angle",
        name: Element22.Fragment,
        position: 0,
        source: "",
        extra: "",
        children: { default: [] }
      }, "default"]];
      function pushToken(...tokens2) {
        const [token, slot] = stack[0];
        token.children[slot].push(...tokens2);
      }
      __name(pushToken, "pushToken");
      for (const token of tokens) {
        if (typeof token === "string") {
          pushToken(token);
          continue;
        }
        const { name, position } = token;
        if (position === 1) {
          if (stack[0][0].name === name) {
            stack.shift();
          }
        } else if (position === 3) {
          stack[0][0].children[name] = [];
          stack[0][1] = name;
        } else if (position === 0) {
          pushToken(token);
          token.children = { default: [] };
          stack.unshift([token, "default"]);
        } else {
          pushToken(token);
        }
      }
      return stack[stack.length - 1][0].children.default;
    }
    __name(foldTokens, "foldTokens");
    function parseTokens(tokens, context2) {
      const result = [];
      for (const token of tokens) {
        if (typeof token === "string") {
          result.push(Element22("text", { content: token }));
        } else if (token.type === "angle") {
          const attrs = {};
          const attrRegExp = context2 ? attrRegExp2 : attrRegExp1;
          let attrCap;
          while (attrCap = attrRegExp.exec(token.extra)) {
            const [, key, v1, v2 = v1, v3] = attrCap;
            if (v3) {
              attrs[key] = interpolate(v3, context2);
            } else if (!(0, import_cosmokit.isNullable)(v2)) {
              attrs[key] = unescape(v2);
            } else if (key.startsWith("no-")) {
              attrs[key.slice(3)] = false;
            } else {
              attrs[key] = true;
            }
          }
          result.push(Element22(token.name, attrs, token.children && parseTokens(token.children.default, context2)));
        } else if (!token.name) {
          result.push(...toElementArray(interpolate(token.extra, context2)));
        } else if (token.name === "if") {
          if (evaluate(token.extra, context2)) {
            result.push(...parseTokens(token.children.default, context2));
          } else {
            result.push(...parseTokens(token.children.else || [], context2));
          }
        } else if (token.name === "each") {
          const [expr, ident] = token.extra.split(/\s+as\s+/);
          const items = interpolate(expr, context2);
          if (!items || !items[Symbol.iterator])
            continue;
          for (const item of items) {
            result.push(...parseTokens(token.children.default, { ...context2, [ident]: item }));
          }
        }
      }
      return result;
    }
    __name(parseTokens, "parseTokens");
    function visit(element, rules, session) {
      const { type, attrs, children } = element;
      if (typeof rules === "function") {
        return rules(element, session);
      } else {
        let result = rules[typeof type === "string" ? type : ""] ?? rules.default ?? true;
        if (typeof result === "function") {
          result = result(attrs, children, session);
        }
        return result;
      }
    }
    __name(visit, "visit");
    function transform(source, rules, session) {
      const elements = typeof source === "string" ? parse(source) : source;
      const output = [];
      elements.forEach((element) => {
        const { type, attrs, children } = element;
        const result = visit(element, rules, session);
        if (result === true) {
          output.push(Element22(type, attrs, transform(children, rules, session)));
        } else if (result !== false) {
          output.push(...toElementArray(result));
        }
      });
      return typeof source === "string" ? output.join("") : output;
    }
    Element22.transform = transform;
    __name(transform, "transform");
    async function transformAsync(source, rules, session) {
      const elements = typeof source === "string" ? parse(source) : source;
      const children = (await Promise.all(elements.map(async (element) => {
        const { type, attrs, children: children2 } = element;
        const result = await visit(element, rules, session);
        if (result === true) {
          return [Element22(type, attrs, await transformAsync(children2, rules, session))];
        } else if (result !== false) {
          return toElementArray(result);
        } else {
          return [];
        }
      }))).flat(1);
      return typeof source === "string" ? children.join("") : children;
    }
    Element22.transformAsync = transformAsync;
    __name(transformAsync, "transformAsync");
    function createFactory(type, ...keys) {
      return (...args) => {
        const element = Element22(type);
        keys.forEach((key, index) => {
          if (!(0, import_cosmokit.isNullable)(args[index])) {
            element.attrs[key] = args[index];
          }
        });
        if (args[keys.length]) {
          Object.assign(element.attrs, args[keys.length]);
        }
        return element;
      };
    }
    __name(createFactory, "createFactory");
    Element22.warn = __name(() => {
    }, "warn");
    function createAssetFactory(type) {
      return (src, ...args) => {
        let prefix = "base64://";
        if (typeof args[0] === "string") {
          prefix = `data:${args.shift()};base64,`;
        }
        if ((0, import_cosmokit.is)("Buffer", src)) {
          src = prefix + src.toString("base64");
        } else if ((0, import_cosmokit.is)("ArrayBuffer", src)) {
          src = prefix + (0, import_cosmokit.arrayBufferToBase64)(src);
        } else if (ArrayBuffer.isView(src)) {
          src = prefix + (0, import_cosmokit.arrayBufferToBase64)(src.buffer);
        }
        if (src.startsWith("base64://")) {
          (0, Element22.warn)(`protocol "base64:" is deprecated and will be removed in the future, please use "data:" instead`);
        }
        return Element22(type, { ...args[0], src });
      };
    }
    __name(createAssetFactory, "createAssetFactory");
    Element22.text = createFactory("text", "content");
    Element22.at = createFactory("at", "id");
    Element22.sharp = createFactory("sharp", "id");
    Element22.quote = createFactory("quote", "id");
    Element22.image = createAssetFactory("img");
    Element22.img = createAssetFactory("img");
    Element22.video = createAssetFactory("video");
    Element22.audio = createAssetFactory("audio");
    Element22.file = createAssetFactory("file");
    function i18n(path, children) {
      return Element22("i18n", typeof path === "string" ? { path } : path, children);
    }
    Element22.i18n = i18n;
    __name(i18n, "i18n");
  })(Element2 || (Element2 = {}));
  module.exports = Element2;
});

// ../../node_modules/@satorijs/protocol/lib/index.cjs
var require_lib14 = __commonJS((exports, module) => {
  var Field = function(name) {
    return { name };
  };
  var Method = function(name, fields, isForm = false) {
    return { name, fields: fields.map(Field), isForm };
  };
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Channel: () => Channel,
    Methods: () => Methods,
    Opcode: () => Opcode,
    Status: () => Status,
    WebSocket: () => WebSocket2
  });
  module.exports = __toCommonJS(src_exports);
  __name(Field, "Field");
  __name(Method, "Method");
  var Methods = {
    "channel.get": Method("getChannel", ["channel_id", "guild_id"]),
    "channel.list": Method("getChannelList", ["guild_id", "next"]),
    "channel.create": Method("createChannel", ["guild_id", "data"]),
    "channel.update": Method("updateChannel", ["channel_id", "data"]),
    "channel.delete": Method("deleteChannel", ["channel_id"]),
    "channel.mute": Method("muteChannel", ["channel_id", "guild_id", "enable"]),
    "message.create": Method("createMessage", ["channel_id", "content"]),
    "message.update": Method("editMessage", ["channel_id", "message_id", "content"]),
    "message.delete": Method("deleteMessage", ["channel_id", "message_id"]),
    "message.get": Method("getMessage", ["channel_id", "message_id"]),
    "message.list": Method("getMessageList", ["channel_id", "next", "direction", "limit", "order"]),
    "reaction.create": Method("createReaction", ["channel_id", "message_id", "emoji"]),
    "reaction.delete": Method("deleteReaction", ["channel_id", "message_id", "emoji", "user_id"]),
    "reaction.clear": Method("clearReaction", ["channel_id", "message_id", "emoji"]),
    "reaction.list": Method("getReactionList", ["channel_id", "message_id", "emoji", "next"]),
    "upload.create": Method("createUpload", [], true),
    "guild.get": Method("getGuild", ["guild_id"]),
    "guild.list": Method("getGuildList", ["next"]),
    "guild.member.get": Method("getGuildMember", ["guild_id", "user_id"]),
    "guild.member.list": Method("getGuildMemberList", ["guild_id", "next"]),
    "guild.member.kick": Method("kickGuildMember", ["guild_id", "user_id", "permanent"]),
    "guild.member.mute": Method("muteGuildMember", ["guild_id", "user_id", "duration", "reason"]),
    "guild.member.role.set": Method("setGuildMemberRole", ["guild_id", "user_id", "role_id"]),
    "guild.member.role.unset": Method("unsetGuildMemberRole", ["guild_id", "user_id", "role_id"]),
    "guild.role.list": Method("getGuildRoleList", ["guild_id", "next"]),
    "guild.role.create": Method("createGuildRole", ["guild_id", "data"]),
    "guild.role.update": Method("updateGuildRole", ["guild_id", "role_id", "data"]),
    "guild.role.delete": Method("deleteGuildRole", ["guild_id", "role_id"]),
    "login.get": Method("getLogin", []),
    "user.get": Method("getUser", ["user_id"]),
    "user.channel.create": Method("createDirectChannel", ["user_id", "guild_id"]),
    "friend.list": Method("getFriendList", ["next"]),
    "friend.delete": Method("deleteFriend", ["user_id"]),
    "friend.approve": Method("handleFriendRequest", ["message_id", "approve", "comment"]),
    "guild.approve": Method("handleGuildRequest", ["message_id", "approve", "comment"]),
    "guild.member.approve": Method("handleGuildMemberRequest", ["message_id", "approve", "comment"])
  };
  var Channel;
  ((Channel2) => {
    let Type;
    ((Type2) => {
      Type2[Type2["TEXT"] = 0] = "TEXT";
      Type2[Type2["DIRECT"] = 1] = "DIRECT";
      Type2[Type2["VOICE"] = 2] = "VOICE";
      Type2[Type2["CATEGORY"] = 3] = "CATEGORY";
    })(Type = Channel2.Type || (Channel2.Type = {}));
  })(Channel || (Channel = {}));
  var Status = ((Status2) => {
    Status2[Status2["OFFLINE"] = 0] = "OFFLINE";
    Status2[Status2["ONLINE"] = 1] = "ONLINE";
    Status2[Status2["CONNECT"] = 2] = "CONNECT";
    Status2[Status2["DISCONNECT"] = 3] = "DISCONNECT";
    Status2[Status2["RECONNECT"] = 4] = "RECONNECT";
    return Status2;
  })(Status || {});
  var Opcode = ((Opcode2) => {
    Opcode2[Opcode2["EVENT"] = 0] = "EVENT";
    Opcode2[Opcode2["PING"] = 1] = "PING";
    Opcode2[Opcode2["PONG"] = 2] = "PONG";
    Opcode2[Opcode2["IDENTIFY"] = 3] = "IDENTIFY";
    Opcode2[Opcode2["READY"] = 4] = "READY";
    return Opcode2;
  })(Opcode || {});
  var WebSocket2;
  ((WebSocket22) => {
    WebSocket22.CONNECTING = 0;
    WebSocket22.OPEN = 1;
    WebSocket22.CLOSING = 2;
    WebSocket22.CLOSED = 3;
  })(WebSocket2 || (WebSocket2 = {}));
});

// ../../node_modules/@satorijs/core/lib/index.cjs
var require_lib15 = __commonJS((exports, module) => {
  var defineAccessor = function(prototype, name, keys) {
    Object.defineProperty(prototype, name, {
      get() {
        return keys.reduce((data, key) => data?.[key], this);
      },
      set(value) {
        if (value === undefined)
          return;
        const _keys = keys.slice();
        const last = _keys.pop();
        const data = _keys.reduce((data2, key) => data2[key] ??= {}, this);
        data[last] = value;
      }
    });
  };
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Adapter: () => Adapter,
    Bot: () => Bot,
    Context: () => SatoriContext,
    Element: () => import_element3.default,
    HTTP: () => import_plugin_http.HTTP,
    MessageEncoder: () => MessageEncoder,
    Messenger: () => MessageEncoder,
    Modulator: () => MessageEncoder,
    Quester: () => import_plugin_http.HTTP,
    Satori: () => Satori,
    Session: () => Session,
    Universal: () => Universal,
    default: () => src_default,
    defineAccessor: () => defineAccessor,
    h: () => import_element3.default,
    segment: () => import_element3.default
  });
  module.exports = __toCommonJS(src_exports);
  var import_cordis4 = require_lib8();
  var import_cosmokit4 = require_lib();
  var import_plugin_http = require_lib12();
  var import_element3 = __toESM2(require_lib13(), 1);
  __reExport(src_exports, require_lib8(), module.exports);
  __reExport(src_exports, require_lib(), module.exports);
  var Universal = __toESM2(require_lib14(), 1);
  var import_cosmokit2 = require_lib();
  var import_cordis2 = require_lib8();
  var import_protocol = require_lib14();
  var import_cosmokit = require_lib();
  var import_cordis = require_lib8();
  var import_element = __toESM2(require_lib13(), 1);
  var Session = class _Session {
    static {
      __name(this, "Session");
    }
    static counter = 0;
    id;
    bot;
    app;
    event;
    locales = [];
    constructor(bot, event) {
      event.selfId ??= bot.selfId;
      event.platform ??= bot.platform;
      event.timestamp ??= Date.now();
      this.event = event;
      this.id = ++_Session.counter;
      (0, import_cosmokit.defineProperty)(this, "bot", bot);
      (0, import_cosmokit.defineProperty)(this, "app", bot.ctx.root);
      (0, import_cosmokit.defineProperty)(this, import_cordis.Context.current, bot.ctx);
      return import_cordis.Context.associate(this, "session");
    }
    get data() {
      return this.event;
    }
    get isDirect() {
      return this.event.channel.type === import_protocol.Channel.Type.DIRECT;
    }
    set isDirect(value) {
      (this.event.channel ??= {}).type = value ? import_protocol.Channel.Type.DIRECT : import_protocol.Channel.Type.TEXT;
    }
    get author() {
      return {
        ...this.event.user,
        ...this.event.member,
        userId: this.event.user?.id,
        username: this.event.user?.name,
        nickname: this.event.member?.name
      };
    }
    get uid() {
      return `${this.platform}:${this.userId}`;
    }
    get gid() {
      return `${this.platform}:${this.guildId}`;
    }
    get cid() {
      return `${this.platform}:${this.channelId}`;
    }
    get fid() {
      return `${this.platform}:${this.channelId}:${this.userId}`;
    }
    get sid() {
      return `${this.platform}:${this.selfId}`;
    }
    get elements() {
      return this.event.message?.elements;
    }
    set elements(value) {
      this.event.message ??= {};
      this.event.message.elements = value;
    }
    get content() {
      return this.event.message?.elements?.join("");
    }
    set content(value) {
      this.event.message ??= {};
      this.event.message.elements = (0, import_cosmokit.isNullable)(value) ? value : import_element.default.parse(value);
    }
    setInternal(type, data) {
      this.event._type = type;
      this.event._data = data;
      const internal = Object.create(this.bot.internal);
      (0, import_cosmokit.defineProperty)(this, type, Object.assign(internal, data));
    }
    async transform(elements) {
      return await import_element.default.transformAsync(elements, ({ type, attrs, children }, session) => {
        const render = type === "component" ? attrs.is : this.app.get("component:" + type);
        return render?.(attrs, children, session) ?? true;
      }, this);
    }
    toJSON() {
      return { ...this.event, id: this.id };
    }
  };
  __name(defineAccessor, "defineAccessor");
  defineAccessor(Session.prototype, "type", ["event", "type"]);
  defineAccessor(Session.prototype, "subtype", ["event", "subtype"]);
  defineAccessor(Session.prototype, "subsubtype", ["event", "subsubtype"]);
  defineAccessor(Session.prototype, "selfId", ["event", "selfId"]);
  defineAccessor(Session.prototype, "platform", ["event", "platform"]);
  defineAccessor(Session.prototype, "timestamp", ["event", "timestamp"]);
  defineAccessor(Session.prototype, "userId", ["event", "user", "id"]);
  defineAccessor(Session.prototype, "channelId", ["event", "channel", "id"]);
  defineAccessor(Session.prototype, "channelName", ["event", "channel", "name"]);
  defineAccessor(Session.prototype, "guildId", ["event", "guild", "id"]);
  defineAccessor(Session.prototype, "guildName", ["event", "guild", "name"]);
  defineAccessor(Session.prototype, "messageId", ["event", "message", "id"]);
  defineAccessor(Session.prototype, "operatorId", ["event", "operator", "id"]);
  defineAccessor(Session.prototype, "roleId", ["event", "role", "id"]);
  defineAccessor(Session.prototype, "quote", ["event", "message", "quote"]);
  var import_protocol2 = require_lib14();
  var eventAliases = [
    ["message-created", "message"],
    ["guild-removed", "guild-deleted"],
    ["guild-member-removed", "guild-member-deleted"]
  ];
  var Bot = class {
    constructor(ctx, config, platform) {
      this.ctx = ctx;
      this.config = config;
      this.internal = null;
      this.context = ctx;
      this[import_cordis2.Context.current] = ctx;
      const self2 = import_cordis2.Context.associate(this, "bot");
      ctx.bots.push(self2);
      self2.context.emit("bot-added", self2);
      if (platform) {
        self2.logger = ctx.logger(platform);
        self2.platform = platform;
      }
      this.proxyUrls = [`upload://temp/${ctx.satori.uid}/`];
      this.features = Object.entries(import_protocol2.Methods).filter(([, value]) => this[value.name]).map(([key]) => key);
      ctx.on("ready", async () => {
        await Promise.resolve();
        self2.dispatchLoginEvent("login-added");
        return self2.start();
      });
      ctx.on("dispose", () => self2.dispose());
      ctx.on("interaction/button", (session) => {
        const cb = this.callbacks[session.event.button.id];
        if (cb)
          cb(session);
      });
      return self2;
    }
    static {
      __name(this, "Bot");
    }
    static reusable = true;
    static MessageEncoder;
    self = this;
    user = {};
    isBot = true;
    hidden = false;
    platform;
    features;
    proxyUrls;
    adapter;
    error;
    callbacks = {};
    logger;
    [import_cordis2.Context.current];
    context;
    _status = import_protocol2.Status.OFFLINE;
    registerUpload(path, callback) {
      this.ctx.satori.upload(path, callback, this.proxyUrls);
    }
    update(login) {
      const { status, ...rest } = login;
      Object.assign(this, rest);
      this.status = status;
    }
    dispose() {
      (0, import_cosmokit2.remove)(this.ctx.bots, this);
      this.context.emit("bot-removed", this);
      this.dispatchLoginEvent("login-removed");
      return this.stop();
    }
    dispatchLoginEvent(type) {
      const session = this.session();
      session.type = type;
      session.event.login = this.toJSON();
      this.dispatch(session);
    }
    get status() {
      return this._status;
    }
    set status(value) {
      if (value === this._status)
        return;
      this._status = value;
      if (this.ctx.bots?.includes(this)) {
        this.context.emit("bot-status-updated", this);
        this.dispatchLoginEvent("login-updated");
      }
    }
    get isActive() {
      return this._status !== import_protocol2.Status.OFFLINE && this._status !== import_protocol2.Status.DISCONNECT;
    }
    online() {
      this.status = import_protocol2.Status.ONLINE;
      this.error = null;
    }
    offline(error) {
      this.status = import_protocol2.Status.OFFLINE;
      this.error = error;
    }
    async start() {
      if (this.isActive)
        return;
      this.status = import_protocol2.Status.CONNECT;
      try {
        await this.context.parallel("bot-connect", this);
        await this.adapter?.connect(this);
      } catch (error) {
        this.offline(error);
      }
    }
    async stop() {
      if (!this.isActive)
        return;
      this.status = import_protocol2.Status.DISCONNECT;
      try {
        await this.context.parallel("bot-disconnect", this);
        await this.adapter?.disconnect(this);
      } catch (error) {
        this.context.emit("internal/error", error);
      } finally {
        this.offline();
      }
    }
    get sid() {
      return `${this.platform}:${this.selfId}`;
    }
    session(event = {}) {
      return new Session(this, event);
    }
    dispatch(session) {
      if (!this.ctx.lifecycle.isActive)
        return;
      let events = [session.type];
      for (const aliases of eventAliases) {
        if (aliases.includes(session.type)) {
          events = aliases;
          session.type = aliases[0];
          break;
        }
      }
      this.context.emit("internal/session", session);
      if (session.type === "internal") {
        this.context.emit(session.event._type, session.event._data, session.bot);
        return;
      }
      for (const event of events) {
        this.context.emit(session, event, session);
      }
    }
    async createMessage(channelId, content, guildId, options) {
      const { MessageEncoder: MessageEncoder2 } = this.constructor;
      return new MessageEncoder2(this, channelId, guildId, options).send(content);
    }
    async sendMessage(channelId, content, guildId, options) {
      const messages = await this.createMessage(channelId, content, guildId, options);
      return messages.map((message) => message.id);
    }
    async sendPrivateMessage(userId, content, guildId, options) {
      const { id } = await this.createDirectChannel(userId, guildId ?? options?.session?.guildId);
      return this.sendMessage(id, content, null, options);
    }
    async createUpload(...uploads) {
      const ids = [];
      for (const upload of uploads) {
        const id = Math.random().toString(36).slice(2);
        const headers = new Headers;
        headers.set("content-type", upload.type);
        if (upload.filename) {
          headers.set("content-disposition", `attachment; filename="${upload.filename}"`);
        }
        this.ctx.satori._tempStore[id] = {
          status: 200,
          data: upload.data,
          headers
        };
        ids.push(id);
      }
      const timer = setTimeout(() => dispose(), 600000);
      const dispose = __name(() => {
        _dispose();
        clearTimeout(timer);
        for (const id of ids) {
          delete this.ctx.satori._tempStore[id];
        }
      }, "dispose");
      const _dispose = this[import_cordis2.Context.current].on("dispose", dispose);
      return ids.map((id) => `upload://temp/${this.ctx.satori.uid}/${id}`);
    }
    async supports(name, session = {}) {
      return !!this[import_protocol2.Methods[name]?.name];
    }
    async checkPermission(name, session) {
      if (name.startsWith("bot.")) {
        return this.supports(name.slice(4), session);
      }
    }
    toJSON() {
      return (0, import_cosmokit2.clone)((0, import_cosmokit2.pick)(this, ["platform", "selfId", "status", "user", "hidden", "features", "proxyUrls"]));
    }
    async getLogin() {
      return this.toJSON();
    }
    async getSelf() {
      const { user } = await this.getLogin();
      return user;
    }
  };
  var iterableMethods = [
    "getMessage",
    "getReaction",
    "getFriend",
    "getGuild",
    "getGuildMember",
    "getGuildRole",
    "getChannel"
  ];
  for (const name of iterableMethods) {
    Bot.prototype[name + "Iter"] = function(...args) {
      let list;
      if (!this[name + "List"])
        throw new Error(`not implemented: ${name}List`);
      const getList = __name(async () => {
        list = await this[name + "List"](...args, list?.next);
        if (name === "getMessage")
          list.data.reverse();
      }, "getList");
      return {
        async next() {
          if (list?.data.length)
            return { done: false, value: list.data.shift() };
          if (list && !list?.next)
            return { done: true, value: undefined };
          await getList();
          return this.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    };
  }
  defineAccessor(Bot.prototype, "selfId", ["user", "id"]);
  defineAccessor(Bot.prototype, "userId", ["user", "id"]);
  var import_cosmokit3 = require_lib();
  var import_protocol3 = require_lib14();
  var import_cordis3 = require_lib8();
  var Adapter = class {
    constructor(ctx) {
      this.ctx = ctx;
    }
    static {
      __name(this, "Adapter");
    }
    static schema = false;
    bots = [];
    async connect(bot) {
    }
    async disconnect(bot) {
    }
    fork(ctx, bot) {
      bot.adapter = this;
      this.bots.push(bot);
      ctx.on("dispose", () => {
        (0, import_cosmokit3.remove)(this.bots, bot);
      });
    }
  };
  ((Adapter2) => {
    Adapter2.WsClientConfig = import_cordis3.z.object({
      retryTimes: import_cordis3.z.natural().description("\u521D\u6B21\u8FDE\u63A5\u65F6\u7684\u6700\u5927\u91CD\u8BD5\u6B21\u6570\u3002").default(6),
      retryInterval: import_cordis3.z.natural().role("ms").description("\u521D\u6B21\u8FDE\u63A5\u65F6\u7684\u91CD\u8BD5\u65F6\u95F4\u95F4\u9694\u3002").default(5 * import_cosmokit3.Time.second),
      retryLazy: import_cordis3.z.natural().role("ms").description("\u8FDE\u63A5\u5173\u95ED\u540E\u7684\u91CD\u8BD5\u65F6\u95F4\u95F4\u9694\u3002").default(import_cosmokit3.Time.minute)
    }).description("\u8FDE\u63A5\u8BBE\u7F6E");

    class WsClientBase extends Adapter2 {
      constructor(ctx, config) {
        super(ctx);
        this.config = config;
      }
      static {
        __name(this, "WsClientBase");
      }
      socket;
      async start() {
        let _retryCount = 0;
        const logger = this.ctx.logger("adapter");
        const { retryTimes, retryInterval, retryLazy } = this.config;
        const reconnect = __name(async (initial = false) => {
          logger.debug("websocket client opening");
          let socket;
          try {
            socket = await this.prepare();
          } catch (error) {
            logger.warn(error);
            return;
          }
          const url = socket.url.replace(/\?.+/, "");
          socket.addEventListener("error", (event) => {
            if (event.message)
              logger.warn(event.message);
          });
          socket.addEventListener("close", ({ code, reason }) => {
            this.socket = null;
            logger.debug(`websocket closed with ${code}`);
            if (!this.getActive())
              return;
            const message = reason.toString() || `failed to connect to ${url}, code: ${code}`;
            let timeout = retryInterval;
            if (_retryCount >= retryTimes) {
              if (initial) {
                return this.setStatus(import_protocol3.Status.OFFLINE, new Error(message));
              } else {
                timeout = retryLazy;
              }
            }
            _retryCount++;
            this.setStatus(import_protocol3.Status.RECONNECT);
            logger.warn(`${message}, will retry in ${import_cosmokit3.Time.format(timeout)}...`);
            setTimeout(() => {
              if (this.getActive())
                reconnect();
            }, timeout);
          });
          socket.addEventListener("open", () => {
            _retryCount = 0;
            this.socket = socket;
            logger.info("connect to server: %c", url);
            this.accept(socket);
          });
        }, "reconnect");
        reconnect(true);
      }
      async stop() {
        this.socket?.close();
      }
    }
    Adapter2.WsClientBase = WsClientBase;

    class WsClient extends WsClientBase {
      constructor(ctx, bot) {
        super(ctx, bot.config);
        this.bot = bot;
        bot.adapter = this;
      }
      static {
        __name(this, "WsClient");
      }
      static reusable = true;
      getActive() {
        return this.bot.isActive;
      }
      setStatus(status, error = null) {
        this.bot.status = status;
        this.bot.error = error;
      }
      async connect(bot) {
        this.start();
      }
      async disconnect(bot) {
        this.stop();
      }
    }
    Adapter2.WsClient = WsClient;
  })(Adapter || (Adapter = {}));
  var import_element2 = __toESM2(require_lib13(), 1);
  var AggregateError = class extends Error {
    constructor(errors, message = "") {
      super(message);
      this.errors = errors;
    }
    static {
      __name(this, "AggregateError");
    }
  };
  var MessageEncoder = class {
    constructor(bot, channelId, guildId, options = {}) {
      this.bot = bot;
      this.channelId = channelId;
      this.guildId = guildId;
      this.options = options;
    }
    static {
      __name(this, "MessageEncoder");
    }
    errors = [];
    results = [];
    session;
    async prepare() {
    }
    async render(elements, flush) {
      for (const element of elements) {
        await this.visit(element);
      }
      if (flush) {
        await this.flush();
      }
    }
    async send(content) {
      this.session = this.bot.session({
        type: "send",
        channel: { id: this.channelId, ...this.options.session?.event.channel },
        guild: this.options.session?.event.guild
      });
      for (const key in this.options.session || {}) {
        if (key === "id" || key === "event")
          continue;
        this.session[key] = this.options.session[key];
      }
      await this.prepare();
      const session = this.options.session ?? this.session;
      this.session.elements = await session.transform(import_element2.default.normalize(content));
      const btns = import_element2.default.select(this.session.elements, "button").filter((v) => v.attrs.type !== "link" && !v.attrs.id);
      for (const btn of btns) {
        const r = Math.random().toString(36).slice(2);
        btn.attrs.id ||= r;
        if (typeof btn.attrs.action === "function")
          this.bot.callbacks[btn.attrs.id] = btn.attrs.action;
      }
      if (await this.session.app.serial(this.session, "before-send", this.session, this.options))
        return;
      await this.render(this.session.elements);
      await this.flush();
      if (this.errors.length) {
        throw new AggregateError(this.errors);
      } else {
        return this.results;
      }
    }
  };
  import_element3.default.warn = new import_cordis4.Logger("element").warn;
  (0, import_cosmokit4.defineProperty)(import_plugin_http.HTTP, "Config", import_cordis4.z.object({
    timeout: import_cordis4.z.natural().role("ms").description("\u7B49\u5F85\u8FDE\u63A5\u5EFA\u7ACB\u7684\u6700\u957F\u65F6\u95F4\u3002"),
    proxyAgent: import_cordis4.z.string().description("\u4F7F\u7528\u7684\u4EE3\u7406\u670D\u52A1\u5668\u5730\u5740\u3002"),
    keepAlive: import_cordis4.z.boolean().description("\u662F\u5426\u4FDD\u6301\u8FDE\u63A5\u3002")
  }).description("\u8BF7\u6C42\u8BBE\u7F6E"));
  import_plugin_http.HTTP.createConfig = __name(function createConfig(endpoint) {
    return import_cordis4.z.object({
      endpoint: import_cordis4.z.string().role("link").description("\u8981\u8FDE\u63A5\u7684\u670D\u52A1\u5668\u5730\u5740\u3002").default(typeof endpoint === "string" ? endpoint : null).required(typeof endpoint === "boolean" ? endpoint : false),
      headers: import_cordis4.z.dict(String).role("table").description("\u8981\u9644\u52A0\u7684\u989D\u5916\u8BF7\u6C42\u5934\u3002"),
      ...this.Config.dict
    }).description("\u8BF7\u6C42\u8BBE\u7F6E");
  }, "createConfig");
  var SatoriContext = class extends import_cordis4.Context {
    static {
      __name(this, "SatoriContext");
    }
    constructor(config) {
      super(config);
      this.provide("satori", undefined, true);
      this.plugin(Satori);
    }
  };
  var Satori = class extends import_cordis4.Service {
    static {
      __name(this, "Satori");
    }
    static [import_cordis4.Service.provide] = "satori";
    static [import_cordis4.Service.immediate] = true;
    uid = Math.random().toString(36).slice(2);
    _uploadRoutes = [];
    _tempStore = Object.create(null);
    constructor(ctx) {
      super(ctx);
      ctx.mixin("satori", ["bots", "component"]);
      this.upload(`/temp/${this.uid}/`, async (path) => {
        const id = path.split("/").pop();
        return this._tempStore[id] ?? { status: 404 };
      });
      const self2 = this;
      ctx.on("http/file", async function(url, options) {
        if (!url.startsWith("upload://"))
          return;
        const { status, data, headers } = await self2.download(url.slice(9));
        if (status >= 400)
          throw new Error(`Failed to fetch ${url}, status code: ${status}`);
        if (status >= 300) {
          const location = headers?.get("location");
          return this.file(location, options);
        }
        const type = headers?.get("content-type");
        const filename = headers?.get("content-disposition")?.split("filename=")[1];
        return { data, filename, type, mime: type };
      });
    }
    bots = new Proxy([], {
      get(target, prop) {
        if (prop in target || typeof prop === "symbol") {
          return Reflect.get(target, prop);
        }
        return target.find((bot) => bot.sid === prop);
      },
      deleteProperty(target, prop) {
        if (prop in target || typeof prop === "symbol") {
          return Reflect.deleteProperty(target, prop);
        }
        const bot = target.findIndex((bot2) => bot2.sid === prop);
        if (bot < 0)
          return true;
        target.splice(bot, 1);
        return true;
      }
    });
    component(name, component, options = {}) {
      const render = __name(async (attrs, children, session) => {
        if (options.session && session.type === "send") {
          throw new Error("interactive components is not available outside sessions");
        }
        const result = await component(attrs, children, session);
        return session.transform(import_element3.default.normalize(result));
      }, "render");
      return this.ctx.set("component:" + name, render);
    }
    upload(path, callback, proxyUrls = []) {
      return this[import_cordis4.Context.current].effect(() => {
        const route = { path, callback };
        this._uploadRoutes.push(route);
        proxyUrls.push(path);
        return () => {
          (0, import_cosmokit4.remove)(this._uploadRoutes, route);
          (0, import_cosmokit4.remove)(proxyUrls, path);
        };
      });
    }
    async download(path) {
      for (const route of this._uploadRoutes) {
        const paths = (0, import_cosmokit4.makeArray)(typeof route.path === "function" ? route.path() : route.path);
        if (paths.some((prefix) => path.startsWith(prefix))) {
          return route.callback(path);
        }
      }
      return { status: 404 };
    }
  };
  var src_default = Satori;
});

// D:/workspace/qqchannel-bot/node_modules/@paotuan/adapter-qq/lib/index.cjs
var require_lib16 = __commonJS((exports, module) => {
  var decodeGroupMessage = function(bot, data, message = {}, payload = message) {
    message.id = data.id;
    const date = data.timestamp.slice(0, data.timestamp.indexOf("m=")).trim().replace(/\+(\d{4}) CST/, "GMT+$1");
    message.timestamp = new Date(date).valueOf();
    message.elements = [];
    if (data.content.length)
      message.elements.push(import_core.h.text(data.content));
    for (const attachment of data.attachments ?? []) {
      if (attachment.content_type === "file") {
        message.elements.push(import_core.h.file(attachment.url, {
          filename: attachment.filename
        }));
      } else if (attachment.content_type.startsWith("image/")) {
        message.elements.push(import_core.h.image(attachment.url));
      } else if (attachment.content_type === "voice") {
        message.elements.push(import_core.h.audio(attachment.url));
      } else if (attachment.content_type === "video") {
        message.elements.push(import_core.h.video(attachment.url));
      }
    }
    message.content = message.elements.join("");
    message.guild = { id: data.group_id };
    message.user = { id: data.author.id };
    return message;
  };
  async function decodeMessage(bot, data, message = {}, payload = message) {
    message.id = message.messageId = data.id;
    message.content = (data.content ?? "").replace(/<@!(\d+)>/g, (_, $1) => import_core.h.at($1).toString());
    const { attachments = [] } = data;
    if (attachments.length && !/\s$/.test(message.content))
      message.content += " ";
    message.content = attachments.filter(({ content_type }) => content_type.startsWith("image")).reduce((content, attachment) => content + import_core.h.image("https://" + attachment.url), message.content);
    message.elements = import_core.h.parse(message.content);
    message.elements = import_core.h.transform(message.elements, {
      text: (attrs) => import_core.h.unescape(attrs.content)
    });
    if (data.message_reference) {
      message.quote = bot.getMessage ? await bot.getMessage(data.channel_id, data.message_reference.message_id) : { id: data.message_reference.message_id };
    }
    if (!payload)
      return message;
    payload.timestamp = new Date(data.timestamp).valueOf();
    payload.user = data.author ? decodeUser(data.author) : undefined;
    payload.member = data.member ? decodeGuildMember(data.member) : undefined;
    if (data.direct_message) {
      payload.guild = { id: `${data.src_guild_id}_${data.guild_id}` };
      payload.channel = { id: `${data.guild_id}_${data.channel_id}`, type: import_core.Universal.Channel.Type.DIRECT };
    } else {
      payload.guild = { id: data.guild_id };
      payload.channel = { id: data.channel_id, type: import_core.Universal.Channel.Type.TEXT };
    }
    return message;
  }
  var setupReaction = function(session, data) {
    session.userId = data.user_id;
    session.guildId = data.guild_id;
    session.channelId = data.channel_id;
    session.content = `${data.emoji.type}:${data.emoji.id}`;
    session.messageId = data.target.id;
    session.isDirect = false;
    return session;
  };
  async function adaptSession(bot, input) {
    let session = bot.session();
    if (![
      "GROUP_AT_MESSAGE_CREATE",
      "C2C_MESSAGE_CREATE",
      "FRIEND_ADD",
      "FRIEND_DEL",
      "GROUP_ADD_ROBOT",
      "GROUP_DEL_ROBOT",
      "INTERACTION_CREATE"
    ].includes(input.t)) {
      session = bot.guildBot.session();
      session.setInternal(bot.guildBot.platform, input);
    } else {
      session.setInternal(bot.platform, input);
    }
    if (input.t === "MESSAGE_CREATE" || input.t === "AT_MESSAGE_CREATE" || input.t === "DIRECT_MESSAGE_CREATE") {
      if (bot.config.type === "private" && input.t === "AT_MESSAGE_CREATE" && bot.config.intents & 512)
        return;
      session.type = "message";
      await decodeMessage(bot, input.d, session.event.message = {}, session.event);
    } else if (input.t === "MESSAGE_REACTION_ADD") {
      if (input.d.target.type !== "ReactionTargetType_MSG")
        return;
      setupReaction(session, input.d);
      session.type = "reaction-added";
    } else if (input.t === "MESSAGE_REACTION_REMOVE") {
      if (input.d.target.type !== "ReactionTargetType_MSG")
        return;
      setupReaction(session, input.d);
      session.type = "reaction-removed";
    } else if (input.t === "CHANNEL_CREATE" || input.t === "CHANNEL_UPDATE" || input.t === "CHANNEL_DELETE") {
      session.type = {
        CHANNEL_CREATE: "channel-added",
        CHANNEL_UPDATE: "channel-updated",
        CHANNEL_DELETE: "channel-deleted"
      }[input.t];
      session.guildId = input.d.guild_id;
      session.event.channel = decodeChannel(input.d);
    } else if (input.t === "GUILD_CREATE" || input.t === "GUILD_UPDATE" || input.t === "GUILD_DELETE") {
      session.type = {
        GUILD_CREATE: "guild-added",
        GUILD_UPDATE: "guild-updated",
        GUILD_DELETE: "guild-deleted"
      }[input.t];
      session.event.guild = decodeGuild(input.d);
    } else if (input.t === "DIRECT_MESSAGE_DELETE" || input.t === "MESSAGE_DELETE" || input.t === "PUBLIC_MESSAGE_DELETE") {
      if (bot.config.type === "private" && input.t === "PUBLIC_MESSAGE_DELETE" && bot.config.intents & 512)
        return;
      session.type = "message-deleted";
      session.userId = input.d.message.author.id;
      session.operatorId = input.d.op_user.id;
      session.messageId = input.d.message.id;
      session.isDirect = input.d.message.direct_message;
      if (session.isDirect) {
        session.guildId = `${input.d.message.src_guild_id}_${input.d.message.guild_id}`;
        session.channelId = `${input.d.message.guild_id}_${input.d.message.channel_id}`;
      } else {
        session.guildId = input.d.message.guild_id;
        session.channelId = input.d.message.channel_id;
      }
    } else if (input.t === "GROUP_AT_MESSAGE_CREATE") {
      session.type = "message";
      session.isDirect = false;
      decodeGroupMessage(bot, input.d, session.event.message = {}, session.event);
      session.guildId = session.event.message.guild.id;
      session.channelId = session.guildId;
      session.userId = session.event.message.user.id;
      session.elements.unshift(import_core.h.at(session.selfId));
    } else if (input.t === "C2C_MESSAGE_CREATE") {
      session.type = "message";
      session.isDirect = true;
      decodeGroupMessage(bot, input.d, session.event.message = {}, session.event);
      session.userId = input.d.author.id;
      session.channelId = session.userId;
    } else if (input.t === "FRIEND_ADD") {
      session.type = "friend-added";
      session.timestamp = input.d.timestamp;
      session.userId = input.d.openid;
    } else if (input.t === "FRIEND_DEL") {
      session.type = "friend-added";
      session.timestamp = input.d.timestamp;
      session.userId = input.d.openid;
    } else if (input.t === "GROUP_ADD_ROBOT") {
      session.type = "guild-added";
      session.timestamp = input.d.timestamp;
      session.guildId = input.d.group_openid;
      session.operatorId = input.d.op_member_openid;
    } else if (input.t === "GROUP_DEL_ROBOT") {
      session.type = "guild-removed";
      session.timestamp = input.d.timestamp;
      session.guildId = input.d.group_openid;
      session.operatorId = input.d.op_member_openid;
    } else if (input.t === "INTERACTION_CREATE") {
      session.type = "interaction/button";
      session.userId = input.d.group_member_openid ?? input.d.user_openid ?? input.d.data.resolved.user_id;
      if (input.d.chat_type === 1) {
        session.guildId = input.d.group_openid;
        session.channelId = input.d.group_openid;
        session.isDirect = false;
      } else if (input.d.chat_type === 3) {
        session.channelId = input.d.channel_id;
        session.isDirect = false;
      } else if (input.d.chat_type === 2) {
        session.isDirect = true;
        session.channelId = session.userId;
      }
      session.event.button = {
        id: input.d.data.resolved.button_id
      };
      bot.internal.acknowledgeInteraction(input.d.id, { code: 0 }).catch(() => {
      });
    } else if (input.t === "GUILD_MEMBER_ADD" || input.t === "GUILD_MEMBER_DELETE" || input.t === "GUILD_MEMBER_UPDATE") {
      session.type = {
        GUILD_MEMBER_ADD: "guild-member-added",
        GUILD_MEMBER_UPDATE: "guild-member-updated",
        GUILD_MEMBER_DELETE: "guild-member-removed"
      }[input.t];
      session.guildId = input.d.guild_id;
      session.operatorId = input.d.op_user_id;
      session.timestamp = Date.now();
      session.event.user = decodeUser(input.d.user);
    } else {
      return;
    }
    return session;
  }
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    QQ: () => types_exports,
    QQBot: () => QQBot,
    QQGuildMessageEncoder: () => QQGuildMessageEncoder,
    QQMessageEncoder: () => QQMessageEncoder,
    WsClient: () => WsClient,
    adaptSession: () => adaptSession,
    decodeChannel: () => decodeChannel,
    decodeGroupMessage: () => decodeGroupMessage,
    decodeGuild: () => decodeGuild,
    decodeGuildMember: () => decodeGuildMember,
    decodeMessage: () => decodeMessage,
    decodeUser: () => decodeUser,
    default: () => src_default,
    escapeMarkdown: () => escapeMarkdown,
    setupReaction: () => setupReaction
  });
  module.exports = __toCommonJS(src_exports);
  var types_exports = {};
  __export2(types_exports, {
    AnnounceType: () => AnnounceType,
    ChannelPrivateType: () => ChannelPrivateType,
    ChannelSpeakPermission: () => ChannelSpeakPermission,
    ChannelSubType: () => ChannelSubType,
    ChannelType: () => ChannelType,
    ChatType: () => ChatType,
    DefaultRoles: () => DefaultRoles,
    DeleteHistoryMsgDays: () => DeleteHistoryMsgDays,
    EmojiType: () => EmojiType,
    Forum: () => Forum,
    Intents: () => Intents,
    Message: () => Message,
    Opcode: () => Opcode,
    ReactionTargetType: () => ReactionTargetType,
    RemindType: () => RemindType
  });
  var Intents = ((Intents2) => {
    Intents2[Intents2["GUILDS"] = 1] = "GUILDS";
    Intents2[Intents2["GUILD_MEMBERS"] = 2] = "GUILD_MEMBERS";
    Intents2[Intents2["GUILD_MESSAGES"] = 512] = "GUILD_MESSAGES";
    Intents2[Intents2["GUILD_MESSAGE_REACTIONS"] = 1024] = "GUILD_MESSAGE_REACTIONS";
    Intents2[Intents2["DIRECT_MESSAGES"] = 4096] = "DIRECT_MESSAGES";
    Intents2[Intents2["OPEN_FORUMS_EVENT"] = 262144] = "OPEN_FORUMS_EVENT";
    Intents2[Intents2["AUDIO_OR_LIVE_CHANNEL_MEMBER"] = 524288] = "AUDIO_OR_LIVE_CHANNEL_MEMBER";
    Intents2[Intents2["USER_MESSAGE"] = 33554432] = "USER_MESSAGE";
    Intents2[Intents2["INTERACTIONS"] = 67108864] = "INTERACTIONS";
    Intents2[Intents2["MESSAGE_AUDIT"] = 134217728] = "MESSAGE_AUDIT";
    Intents2[Intents2["FORUM_EVENT"] = 268435456] = "FORUM_EVENT";
    Intents2[Intents2["AUDIO_ACTION"] = 536870912] = "AUDIO_ACTION";
    Intents2[Intents2["PUBLIC_GUILD_MESSAGES"] = 1073741824] = "PUBLIC_GUILD_MESSAGES";
    return Intents2;
  })(Intents || {});
  var Opcode = ((Opcode2) => {
    Opcode2[Opcode2["DISPATCH"] = 0] = "DISPATCH";
    Opcode2[Opcode2["HEARTBEAT"] = 1] = "HEARTBEAT";
    Opcode2[Opcode2["IDENTIFY"] = 2] = "IDENTIFY";
    Opcode2[Opcode2["RESUME"] = 6] = "RESUME";
    Opcode2[Opcode2["RECONNECT"] = 7] = "RECONNECT";
    Opcode2[Opcode2["INVALID_SESSION"] = 9] = "INVALID_SESSION";
    Opcode2[Opcode2["HELLO"] = 10] = "HELLO";
    Opcode2[Opcode2["HEARTBEAT_ACK"] = 11] = "HEARTBEAT_ACK";
    Opcode2[Opcode2["HTTP_CAKKBACK_ACK"] = 12] = "HTTP_CAKKBACK_ACK";
    return Opcode2;
  })(Opcode || {});
  var Message;
  ((Message2) => {
    let Type;
    ((Type2) => {
      Type2[Type2["TEXT"] = 0] = "TEXT";
      Type2[Type2["MIXED"] = 1] = "MIXED";
      Type2[Type2["MARKDOWN"] = 2] = "MARKDOWN";
      Type2[Type2["ARK"] = 3] = "ARK";
      Type2[Type2["EMBED"] = 4] = "EMBED";
      Type2[Type2["MEDIA"] = 7] = "MEDIA";
    })(Type = Message2.Type || (Message2.Type = {}));
    let File;
    ((File2) => {
      let Type2;
      ((Type3) => {
        Type3[Type3["IMAGE"] = 1] = "IMAGE";
        Type3[Type3["VIDEO"] = 2] = "VIDEO";
        Type3[Type3["AUDIO"] = 3] = "AUDIO";
        Type3[Type3["FILE"] = 4] = "FILE";
      })(Type2 = File2.Type || (File2.Type = {}));
    })(File = Message2.File || (Message2.File = {}));
  })(Message || (Message = {}));
  var DefaultRoles = ((DefaultRoles2) => {
    DefaultRoles2[DefaultRoles2["ALL"] = 1] = "ALL";
    DefaultRoles2[DefaultRoles2["ADMIN"] = 2] = "ADMIN";
    DefaultRoles2[DefaultRoles2["OWNER"] = 4] = "OWNER";
    DefaultRoles2[DefaultRoles2["SUBCHANNEL_ADMIN"] = 5] = "SUBCHANNEL_ADMIN";
    return DefaultRoles2;
  })(DefaultRoles || {});
  var ChannelType = ((ChannelType2) => {
    ChannelType2[ChannelType2["TEXT"] = 0] = "TEXT";
    ChannelType2[ChannelType2["VOICE"] = 2] = "VOICE";
    ChannelType2[ChannelType2["GROUP"] = 4] = "GROUP";
    ChannelType2[ChannelType2["LIVE"] = 10005] = "LIVE";
    ChannelType2[ChannelType2["APPLICATION"] = 10006] = "APPLICATION";
    ChannelType2[ChannelType2["FORUM"] = 10007] = "FORUM";
    return ChannelType2;
  })(ChannelType || {});
  var ChannelSubType = ((ChannelSubType2) => {
    ChannelSubType2[ChannelSubType2["IDLE"] = 0] = "IDLE";
    ChannelSubType2[ChannelSubType2["ANNOUNCEMENT"] = 1] = "ANNOUNCEMENT";
    ChannelSubType2[ChannelSubType2["STRATEGY"] = 2] = "STRATEGY";
    ChannelSubType2[ChannelSubType2["BLACK"] = 3] = "BLACK";
    return ChannelSubType2;
  })(ChannelSubType || {});
  var ChannelPrivateType = ((ChannelPrivateType2) => {
    ChannelPrivateType2[ChannelPrivateType2["PUBLIC"] = 0] = "PUBLIC";
    ChannelPrivateType2[ChannelPrivateType2["ADMIN_ONLY"] = 1] = "ADMIN_ONLY";
    ChannelPrivateType2[ChannelPrivateType2["SELECTED_MEMBERS"] = 2] = "SELECTED_MEMBERS";
    return ChannelPrivateType2;
  })(ChannelPrivateType || {});
  var ChannelSpeakPermission = ((ChannelSpeakPermission2) => {
    ChannelSpeakPermission2[ChannelSpeakPermission2["INVALID"] = 0] = "INVALID";
    ChannelSpeakPermission2[ChannelSpeakPermission2["ALL"] = 1] = "ALL";
    ChannelSpeakPermission2[ChannelSpeakPermission2["SELECTED_MEMBERS"] = 2] = "SELECTED_MEMBERS";
    return ChannelSpeakPermission2;
  })(ChannelSpeakPermission || {});
  var AnnounceType = ((AnnounceType2) => {
    AnnounceType2[AnnounceType2["MEMBER"] = 0] = "MEMBER";
    AnnounceType2[AnnounceType2["WELCOME"] = 1] = "WELCOME";
    return AnnounceType2;
  })(AnnounceType || {});
  var ReactionTargetType = ((ReactionTargetType2) => {
    ReactionTargetType2["MESSAGE"] = "ReactionTargetType_MSG";
    ReactionTargetType2["POST"] = "ReactionTargetType_FEED";
    ReactionTargetType2["COMMENT"] = "ReactionTargetType_COMMNENT";
    ReactionTargetType2["REPLY"] = "ReactionTargetType_REPLY";
    return ReactionTargetType2;
  })(ReactionTargetType || {});
  var EmojiType = ((EmojiType2) => {
    EmojiType2[EmojiType2["SYSTEM"] = 1] = "SYSTEM";
    EmojiType2[EmojiType2["DEFAULT"] = 2] = "DEFAULT";
    return EmojiType2;
  })(EmojiType || {});
  var RemindType = ((RemindType2) => {
    RemindType2["NEVER"] = "0";
    RemindType2["START"] = "1";
    RemindType2["BEFORE_5"] = "2";
    RemindType2["BEFORE_15"] = "3";
    RemindType2["BEFORE_30"] = "4";
    RemindType2["BEFORE_60"] = "5";
    return RemindType2;
  })(RemindType || {});
  var DeleteHistoryMsgDays = ((DeleteHistoryMsgDays2) => {
    DeleteHistoryMsgDays2[DeleteHistoryMsgDays2["ALL"] = -1] = "ALL";
    DeleteHistoryMsgDays2[DeleteHistoryMsgDays2["NONE"] = 0] = "NONE";
    DeleteHistoryMsgDays2[DeleteHistoryMsgDays2["DAY_3"] = 3] = "DAY_3";
    DeleteHistoryMsgDays2[DeleteHistoryMsgDays2["DAY_7"] = 7] = "DAY_7";
    DeleteHistoryMsgDays2[DeleteHistoryMsgDays2["DAY_15"] = 15] = "DAY_15";
    DeleteHistoryMsgDays2[DeleteHistoryMsgDays2["DAY_30"] = 30] = "DAY_30";
    return DeleteHistoryMsgDays2;
  })(DeleteHistoryMsgDays || {});
  var Forum;
  ((Forum2) => {
    let AuditType;
    ((AuditType2) => {
      AuditType2[AuditType2["PUBLISH_THREAD"] = 1] = "PUBLISH_THREAD";
      AuditType2[AuditType2["PUBLISH_POST"] = 2] = "PUBLISH_POST";
      AuditType2[AuditType2["PUBLISH_REPLY"] = 3] = "PUBLISH_REPLY";
    })(AuditType = Forum2.AuditType || (Forum2.AuditType = {}));
    let RichType;
    ((RichType2) => {
      RichType2[RichType2["TEXT"] = 1] = "TEXT";
      RichType2[RichType2["AT"] = 2] = "AT";
      RichType2[RichType2["URL"] = 3] = "URL";
      RichType2[RichType2["EMOJI"] = 4] = "EMOJI";
      RichType2[RichType2["CHANNEL"] = 5] = "CHANNEL";
      RichType2[RichType2["VIDEO"] = 10] = "VIDEO";
      RichType2[RichType2["IMAGE"] = 11] = "IMAGE";
    })(RichType = Forum2.RichType || (Forum2.RichType = {}));
    let AtType;
    ((AtType2) => {
      AtType2[AtType2["AT_EXPLICIT_USER"] = 1] = "AT_EXPLICIT_USER";
      AtType2[AtType2["AT_ROLE_GROUP"] = 2] = "AT_ROLE_GROUP";
      AtType2[AtType2["AT_GUILD"] = 3] = "AT_GUILD";
    })(AtType = Forum2.AtType || (Forum2.AtType = {}));
    let ElemType;
    ((ElemType2) => {
      ElemType2[ElemType2["ELEM_TYPE_TEXT"] = 1] = "ELEM_TYPE_TEXT";
      ElemType2[ElemType2["ELEM_TYPE_IMAGE"] = 2] = "ELEM_TYPE_IMAGE";
      ElemType2[ElemType2["ELEM_TYPE_VIDEO"] = 3] = "ELEM_TYPE_VIDEO";
      ElemType2[ElemType2["ELEM_TYPE_URL"] = 4] = "ELEM_TYPE_URL";
    })(ElemType = Forum2.ElemType || (Forum2.ElemType = {}));
    let Alignment;
    ((Alignment2) => {
      Alignment2[Alignment2["ALIGNMENT_LEFT"] = 0] = "ALIGNMENT_LEFT";
      Alignment2[Alignment2["ALIGNMENT_MIDDLE"] = 1] = "ALIGNMENT_MIDDLE";
      Alignment2[Alignment2["ALIGNMENT_RIGHT"] = 2] = "ALIGNMENT_RIGHT";
    })(Alignment || (Alignment = {}));
    let PostFormat;
    ((PostFormat2) => {
      PostFormat2[PostFormat2["FORMAT_TEXT"] = 1] = "FORMAT_TEXT";
      PostFormat2[PostFormat2["FORMAT_HTML"] = 2] = "FORMAT_HTML";
      PostFormat2[PostFormat2["FORMAT_MARKDOWN"] = 3] = "FORMAT_MARKDOWN";
      PostFormat2[PostFormat2["FORMAT_JSON"] = 4] = "FORMAT_JSON";
    })(PostFormat = Forum2.PostFormat || (Forum2.PostFormat = {}));
  })(Forum || (Forum = {}));
  var ChatType = ((ChatType2) => {
    ChatType2[ChatType2["GROUP"] = 1] = "GROUP";
    ChatType2[ChatType2["DIRECT"] = 2] = "DIRECT";
    ChatType2[ChatType2["CHANNEL"] = 3] = "CHANNEL";
    return ChatType2;
  })(ChatType || {});
  var import_core6 = require_lib15();
  var import_core2 = require_lib15();
  var import_core = require_lib15();
  var decodeGuild = (guild) => ({
    id: guild.id,
    name: guild.name,
    avatar: guild.icon
  });
  var decodeChannel = (channel) => ({
    id: channel.id,
    name: channel.name,
    type: channel.type === 0 ? import_core.Universal.Channel.Type.TEXT : channel.type === 2 ? import_core.Universal.Channel.Type.VOICE : channel.type === 4 ? import_core.Universal.Channel.Type.CATEGORY : channel.type === 10005 ? 10005 : -1,
    parentId: channel.parent_id,
    position: channel.position
  });
  var decodeUser = (user) => ({
    id: user.id,
    name: user.username,
    isBot: user.bot,
    avatar: user.avatar
  });
  var decodeGuildMember = (member) => ({
    user: member.user ? decodeUser(member.user) : undefined,
    nick: member.nick,
    roles: member.roles,
    joinedAt: new Date(member.joined_at).getTime()
  });
  var WsClient = class extends import_core2.Adapter.WsClient {
    _sessionId = "";
    _s = null;
    _ping;
    async prepare() {
      await this.bot.getAccessToken();
      let { url } = await this.bot.internal.getGateway();
      url = url.replace("api.sgroup.qq.com", new URL(this.bot.config.endpoint).host);
      this.bot.logger.debug("url: %s", url);
      return this.bot.http.ws(url);
    }
    heartbeat() {
      this.socket.send(JSON.stringify({
        op: 1,
        s: this._s
      }));
    }
    async accept() {
      this.socket.addEventListener("message", async ({ data }) => {
        const parsed = JSON.parse(data.toString());
        this.bot.logger.debug("websocket receives %o", parsed);
        if (parsed.op === 10) {
          const token = await this.bot.getAccessToken();
          if (this._sessionId) {
            this.socket.send(JSON.stringify({
              op: 6,
              d: {
                token: `QQBot ${token}`,
                session_id: this._sessionId,
                seq: this._s
              }
            }));
          } else {
            this.socket.send(JSON.stringify({
              op: 2,
              d: {
                token: `QQBot ${token}`,
                intents: this.bot.config.intents,
                shard: [0, 1]
              }
            }));
          }
          this._ping = setInterval(() => this.heartbeat(), parsed.d.heartbeat_interval);
        } else if (parsed.op === 9) {
          this._sessionId = "";
          this._s = null;
          this.bot.logger.warn("offline: invalid session");
          this.socket?.close();
        } else if (parsed.op === 7) {
          this.bot.logger.warn("offline: server request reconnect");
          this.socket?.close();
        } else if (parsed.op === 0) {
          this.bot.dispatch(this.bot.session({
            type: "internal",
            _type: "qq/" + parsed.t.toLowerCase().replace(/_/g, "-"),
            _data: parsed.d
          }));
          this._s = parsed.s;
          if (parsed.t === "READY") {
            this._sessionId = parsed.d.session_id;
            this.bot.user = decodeUser(parsed.d.user);
            this.bot.guildBot.user = this.bot.user;
            await this.bot.initialize();
            return this.bot.online();
          }
          if (parsed.t === "RESUMED") {
            return this.bot.online();
          }
          const session = await adaptSession(this.bot, parsed);
          if (session)
            this.bot.dispatch(session);
        }
      });
      this.socket.addEventListener("close", (e) => {
        this.bot.logger.debug("websocket closed, code %o, reason: %s", e.code, e.reason);
        clearInterval(this._ping);
      });
    }
  };
  ((WsClient2) => {
    WsClient2.Options = import_core2.Schema.intersect([
      import_core2.Adapter.WsClientConfig
    ]);
  })(WsClient || (WsClient = {}));
  var import_core5 = require_lib15();
  var import_core3 = require_lib15();
  var Internal = class {
    constructor(bot, http) {
      this.bot = bot;
      this.http = http;
    }
    static define(isGuild, routes) {
      for (const path in routes) {
        for (const key in routes[path]) {
          const method = key;
          for (const name of (0, import_core3.makeArray)(routes[path][method])) {
            (isGuild ? GuildInternal : GroupInternal).prototype[name] = async function(...args) {
              const raw = args.join(", ");
              const url = path.replace(/\{([^}]+)\}/g, () => {
                if (!args.length)
                  throw new Error(`too few arguments for ${path}, received ${raw}`);
                return args.shift();
              });
              const config = {};
              if (args.length === 1) {
                if (method === "GET" || method === "DELETE") {
                  config.params = args[0];
                } else {
                  config.data = args[0];
                }
              } else if (args.length === 2 && method !== "GET" && method !== "DELETE") {
                config.data = args[0];
                config.params = args[1];
              } else if (args.length > 1) {
                throw new Error(`too many arguments for ${path}, received ${raw}`);
              }
              const http = this.http();
              try {
                this.bot.logger.debug(`${method} ${url} request: %o`, config);
                const response = await http(url, { ...config, method });
                this.bot.logger.debug(`${method} ${url} response: %o, trace id: %s`, response.data, response.headers.get("x-tps-trace-id"));
                return response.data;
              } catch (error) {
                this.bot.logger.warn(`${method} ${url} request: %o`, config);
                if (!http.isError(error) || !error.response)
                  throw error;
                this.bot.logger.warn(`${method} ${url} response: %o, trace id: %s`, error.response.data, error.response.headers.get("x-tps-trace-id"));
                throw error;
              }
            };
          }
        }
      }
    }
  };
  var GroupInternal = class extends Internal {
  };
  var GuildInternal = class extends Internal {
  };
  GroupInternal.define(false, {
    "/v2/groups/{channel.id}/messages": {
      POST: "sendMessage"
    },
    "/v2/groups/{channel.id}/messages/{message.id}": {
      DELETE: "deleteMessage"
    },
    "/v2/users/{user.id}/messages": {
      POST: "sendPrivateMessage"
    },
    "/v2/users/{user.id}/messages/{message.id}": {
      DELETE: "deletePrivateMessage"
    },
    "/v2/users/{user.id}/files": {
      POST: "sendFilePrivate"
    },
    "/v2/groups/{channel.id}/files": {
      POST: "sendFileGuild"
    },
    "/interactions/{interaction.id}": {
      PUT: "acknowledgeInteraction"
    },
    "/gateway": {
      GET: "getGateway"
    },
    "/gateway/bot": {
      GET: "getGatewayBot"
    }
  });
  GuildInternal.define(true, {
    "/users/@me": {
      GET: "getMe"
    },
    "/users/@me/guilds": {
      GET: "getGuilds"
    },
    "/guilds/{guild.id}": {
      GET: "getGuild"
    },
    "/guilds/{guild.id}/channels": {
      GET: "getChannels",
      POST: "createGuildChannel"
    },
    "/channels/{channel.id}": {
      GET: "getChannel",
      PATCH: "modifyChannel",
      DELETE: "deleteChannel"
    },
    "/channels/{channel.id}/online_nums": {
      GET: "getChannelOnlineNums"
    },
    "/guilds/{guild.id}/members": {
      GET: "getGuildMembers"
    },
    "/guilds/{guild.id}/roles/{role.id}/members": {
      GET: "getGuildRoleMembers"
    },
    "/guilds/{guild.id}/members/{user.id}": {
      GET: "getGuildMember",
      DELETE: "removeGuildMember"
    },
    "/guilds/{guild.id}/roles": {
      GET: "getGuildRoles",
      POST: "createGuildRole"
    },
    "/guilds/{guild.id}/roles/{role.id}": {
      PATCH: "modifyGuildRole",
      DELETE: "removeGuildRole"
    },
    "/guilds/{guild.id}/members/{user.id}/roles/{role.id}": {
      PUT: "addGuildMemberRole",
      DELETE: "removeGuildMemberRole"
    },
    "/channels/{channel.id}/members/{user.id}/permissions": {
      GET: "getChannelMemberPermissions",
      PUT: "modifyChannelMemberPermissions"
    },
    "/channels/{channel.id}/roles/{role.id}/permissions": {
      GET: "getChannelRole",
      PUT: "modifyChannelRole"
    },
    "/channels/{channel.id}/messages/{message.id}": {
      GET: "getMessage",
      DELETE: "deleteMessage"
    },
    "/channels/{channel.id}/messages": {
      POST: "sendMessage"
    },
    "/dms/{guild.id}/messages": {
      POST: "sendDM"
    },
    "/guilds/{guild.id}/messages/setting": {
      GET: "getMessageSetting"
    },
    "/users/@me/dms": {
      POST: "createDMS"
    },
    "/dms/{guild.id}/messages/{message.id}": {
      DELETE: "deleteDM"
    },
    "/guilds/{guild.id}/mute": {
      PATCH: "muteGuildOrMembers"
    },
    "/guilds/{guild.id}/members/{user.id}/mute": {
      PATCH: "muteGuildMember"
    },
    "/guilds/{guild.id}/announces": {
      POST: "createGuildAnnounce"
    },
    "/guilds/{guild.id}/announces/{message.id}": {
      DELETE: "removeGuildAnnounce"
    },
    "/channels/{channel.id}/pins/{message.id}": {
      PUT: "createPinsMessage",
      DELETE: "removePinsMessage"
    },
    "/channels/{channel.id}/pins": {
      GET: "getPinsMessage"
    },
    "/channels/{channel.id}/schedules": {
      GET: "getSchedules",
      POST: "createSchedule"
    },
    "/channels/{channel.id}/schedules/{schedule.id}": {
      GET: "getSchedule",
      PATCH: "modifySchedule",
      DELETE: "removeSchedule"
    },
    "/channels/{channel.id}/messages/{message.id}/reactions/{type}/{id}": {
      PUT: "createReaction",
      DELETE: "deleteReaction",
      GET: "getReactions"
    },
    "/channels/{channel.id}/threads": {
      GET: "listThreads",
      PUT: "createPost"
    },
    "/channels/{channel.id}/threads/{thread.id}": {
      DELETE: "removePost"
    },
    "/guilds/{guild.id}/api_permissions": {
      GET: "getGuildApiPermissions"
    },
    "/guilds/{guild.id}/api_permissions/demand": {
      POST: "createGuildApiPermissionDemand"
    }
  });
  var import_core4 = require_lib15();
  var escapeMarkdown = (val) => val.replace(/([\\`*_[\*_~`\]\-(#!>])/g, "\\$&");
  var QQGuildMessageEncoder = class extends import_core4.MessageEncoder {
    content = "";
    file;
    filename;
    fileUrl;
    passiveId;
    passiveEventId;
    reference;
    retry = false;
    async flush() {
      if (!this.content.trim().length && !this.file && !this.fileUrl) {
        return;
      }
      const isDirect = this.channelId.includes("_");
      let endpoint = `/channels/${this.channelId}/messages`;
      if (isDirect)
        endpoint = `/dms/${this.channelId.split("_")[0]}/messages`;
      const useFormData = Boolean(this.file);
      let msg_id = this.options?.session?.messageId;
      if (this.options?.session && Date.now() - this.options?.session?.timestamp > MSG_TIMEOUT) {
        msg_id = null;
      }
      if (this.passiveId)
        msg_id = this.passiveId;
      let r;
      this.bot.logger.debug("use form data %s", useFormData);
      try {
        if (useFormData) {
          const form = new FormData;
          form.append("content", this.content);
          if (this.options?.session && msg_id) {
            form.append("msg_id", msg_id);
          }
          if (this.passiveEventId) {
            form.append("event_id", this.passiveEventId);
          }
          if (this.file) {
            form.append("file_image", this.file, this.filename);
          }
          r = await this.bot.http.post(endpoint, form);
        } else {
          const payload = {
            ...{
              content: this.content,
              msg_id,
              image: this.fileUrl
            },
            ...this.reference ? {
              message_reference: {
                message_id: this.reference
              }
            } : {},
            ...this.passiveEventId ? {
              event_id: this.passiveEventId
            } : {}
          };
          if (isDirect)
            r = await this.bot.internal.sendDM(this.channelId.split("_")[0], payload);
          else
            r = await this.bot.internal.sendMessage(this.channelId, payload);
        }
      } catch (e) {
        if (this.bot.http.isError(e)) {
          if (this.bot.parent.config.retryWhen.includes(e.response.data.code) && !this.retry && this.fileUrl) {
            this.bot.logger.warn("retry image sending");
            this.retry = true;
            await this.resolveFile(null, true);
            await this.flush();
          }
          if (useFormData) {
            this.bot.logger.warn(`POST ${endpoint} response: %o, trace id: %s`, e.response.data, e.response.headers.get("x-tps-trace-id"));
          }
        }
      }
      const session = this.bot.session();
      session.type = "send";
      session.guildId = this.session.guildId;
      session.channelId = this.channelId;
      session.isDirect = isDirect;
      if (r?.id) {
        session.messageId = r.id;
        session.app.emit(session, "send", session);
        this.results.push(session.event.message);
      } else if (r?.code === 304023 && this.bot.config.parent.intents & 134217728) {
        try {
          const auditData = await this.audit(r.data.message_audit.audit_id);
          session.messageId = auditData.message_id;
          session.app.emit(session, "send", session);
          this.results.push(session.event.message);
        } catch (e) {
          this.bot.logger.error(e);
        }
      }
      this.content = "";
      this.file = null;
      this.filename = null;
      this.fileUrl = null;
      this.retry = false;
    }
    async audit(audit_id) {
      return new Promise((resolve2, reject2) => {
        const dispose = this.bot.ctx.on("qq/message-audit-pass", (data) => {
          if (data.audit_id === audit_id) {
            dispose();
            dispose2();
            resolve2(data);
          }
        });
        const dispose2 = this.bot.ctx.on("qq/message-audit-reject", (data) => {
          if (data.audit_id === audit_id) {
            dispose();
            dispose2();
            reject2(data);
          }
        });
      });
    }
    async resolveFile(attrs, download = false) {
      if (!download && !await this.bot.ctx.http.isLocal(attrs.src || attrs.url)) {
        return this.fileUrl = attrs.src || attrs.url;
      }
      const { data, filename, type } = await this.bot.ctx.http.file(this.fileUrl || attrs.src || attrs.url, attrs);
      this.file = new Blob([data], { type });
      this.filename = filename;
      this.fileUrl = null;
    }
    async visit(element) {
      const { type, attrs, children } = element;
      if (type === "text") {
        this.content += attrs.content;
      } else if (type === "at") {
        switch (attrs.type) {
          case "all":
            this.content += `@everyone`;
            break;
          default:
            this.content += `<@${attrs.id}>`;
        }
      } else if (type === "br") {
        this.content += "\n";
      } else if (type === "p") {
        if (!this.content.endsWith("\n"))
          this.content += "\n";
        await this.render(children);
        if (!this.content.endsWith("\n"))
          this.content += "\n";
      } else if (type === "sharp") {
        this.content += `<#${attrs.id}>`;
      } else if (type === "quote") {
        this.reference = attrs.id;
        await this.flush();
      } else if (type === "passive") {
        if (attrs.messageId)
          this.passiveId = attrs.messageId;
        if (attrs.eventId)
          this.passiveEventId = attrs.eventId;
      } else if ((type === "img" || type === "image") && (attrs.src || attrs.url)) {
        await this.flush();
        await this.resolveFile(attrs);
        await this.flush();
      } else if (type === "message") {
        await this.flush();
        await this.render(children);
        await this.flush();
      } else {
        await this.render(children);
      }
    }
  };
  var MSG_TIMEOUT = 5 * 60 * 1000 - 2000;
  var QQMessageEncoder = class extends import_core4.MessageEncoder {
    content = "";
    passiveId;
    passiveSeq;
    useMarkdown = false;
    rows = [];
    attachedFile;
    retry = false;
    async flush() {
      if (!this.content.trim() && !this.rows.flat().length && !this.attachedFile)
        return;
      this.trimButtons();
      let msg_id, msg_seq;
      if (this.options?.session?.messageId && Date.now() - this.options.session.timestamp < MSG_TIMEOUT) {
        this.options.session["seq"] ||= 0;
        msg_id = this.options.session.messageId;
        msg_seq = ++this.options.session["seq"];
      }
      if (this.passiveId)
        msg_id = this.passiveId;
      if (this.passiveSeq)
        msg_seq = this.passiveSeq;
      const data = {
        content: this.content,
        msg_type: Message.Type.TEXT,
        msg_id,
        msg_seq
      };
      if (this.attachedFile) {
        if (!data.content.length)
          data.content = " ";
        data.media = this.attachedFile;
        data.msg_type = Message.Type.MEDIA;
      }
      if (this.useMarkdown) {
        data.msg_type = Message.Type.MARKDOWN;
        delete data.content;
        data.markdown = {
          content: escapeMarkdown(this.content) || " "
        };
        if (this.rows.length) {
          data.keyboard = {
            content: {
              rows: this.exportButtons()
            }
          };
        }
      }
      const session = this.bot.session();
      session.type = "send";
      const send = async () => {
        try {
          if (this.session.isDirect) {
            const { sendResult: { msg_id: msg_id2 } } = await this.bot.internal.sendPrivateMessage(this.session.channelId, data);
            session.messageId = msg_id2;
          } else {
            const resp = await this.bot.internal.sendMessage(this.session.channelId, data);
            if (resp.id) {
              session.messageId = resp.id;
              session.timestamp = new Date(resp.timestamp).valueOf();
              session.channelId = this.session.channelId;
              session.guildId = this.session.guildId;
              session.app.emit(session, "send", session);
              this.results.push(session.event.message);
            } else if (resp.code === 304023 && this.bot.config.intents & 134217728) {
              try {
                const auditData = await this.audit(resp.data.message_audit.audit_id);
                session.messageId = auditData.message_id;
                session.app.emit(session, "send", session);
                this.results.push(session.event.message);
              } catch (e) {
                this.bot.logger.error(e);
              }
            }
          }
        } catch (e) {
          if (!this.bot.http.isError(e))
            throw e;
          this.errors.push(e);
          if (!this.retry && this.bot.config.retryWhen.includes(e.response.data.code)) {
            this.bot.logger.warn("%s retry message sending", this.session.cid);
            this.retry = true;
            await send();
          }
        }
      };
      await send();
      this.content = "";
      this.attachedFile = null;
      this.rows = [];
      this.retry = false;
    }
    async audit(audit_id) {
      return new Promise((resolve2, reject2) => {
        const dispose = this.bot.ctx.on("qq/message-audit-pass", (data) => {
          if (data.audit_id === audit_id) {
            dispose();
            dispose2();
            resolve2(data);
          }
        });
        const dispose2 = this.bot.ctx.on("qq/message-audit-reject", (data) => {
          if (data.audit_id === audit_id) {
            dispose();
            dispose2();
            reject2(data);
          }
        });
      });
    }
    async sendFile(type, attrs) {
      const url = attrs.src || attrs.url;
      let file_type = 0;
      if (type === "img" || type === "image")
        file_type = 1;
      else if (type === "video")
        file_type = 2;
      else if (type === "audio")
        file_type = 3;
      else
        return;
      const data = {
        file_type,
        srv_send_msg: false
      };
      const capture = /^data:([\w/-]+);base64,(.*)$/.exec(url);
      if (capture?.[2]) {
        data.file_data = capture[2];
      } else if (await this.bot.ctx.http.isLocal(url)) {
        data.file_data = Buffer.from((await this.bot.ctx.http.file(url)).data).toString("base64");
      } else {
        data.url = url;
      }
      let res;
      try {
        if (this.session.isDirect) {
          res = await this.bot.internal.sendFilePrivate(this.options.session.event.message.user.id, data);
        } else {
          res = await this.bot.internal.sendFileGuild(this.session.guildId, data);
        }
      } catch (e) {
        if (!this.bot.http.isError(e))
          throw e;
        this.errors.push(e);
        if (!this.retry && this.bot.config.retryWhen.includes(e.response.data.code)) {
          this.bot.logger.warn("%s retry message sending", this.session.cid);
          this.retry = true;
          await this.sendFile(type, attrs);
        }
      }
      this.retry = false;
      return res;
    }
    decodeButton(attrs, label) {
      const result = {
        id: attrs.id,
        render_data: {
          label,
          visited_label: label,
          style: attrs.class === "primary" ? 1 : 0
        },
        action: {
          type: attrs.type === "input" ? 2 : attrs.type === "link" ? 0 : 1,
          permission: {
            type: 2
          },
          data: attrs.type === "input" ? attrs.text : attrs.type === "link" ? attrs.href : attrs.id
        }
      };
      return result;
    }
    lastRow() {
      if (!this.rows.length)
        this.rows.push([]);
      let last = this.rows[this.rows.length - 1];
      if (last.length >= 5) {
        this.rows.push([]);
        last = this.rows[this.rows.length - 1];
      }
      return last;
    }
    trimButtons() {
      if (this.rows.length && this.rows[this.rows.length - 1].length === 0)
        this.rows.pop();
    }
    exportButtons() {
      return this.rows.map((v) => ({
        buttons: v
      }));
    }
    async visit(element) {
      const { type, attrs, children } = element;
      if (type === "text") {
        this.content += attrs.content;
      } else if (type === "passive") {
        this.passiveId = attrs.messageId;
        this.passiveSeq = Number(attrs.seq);
      } else if ((type === "img" || type === "image") && (attrs.src || attrs.url)) {
        await this.flush();
        const data = await this.sendFile(type, attrs);
        if (data)
          this.attachedFile = data;
      } else if (type === "video" && (attrs.src || attrs.url)) {
        await this.flush();
        const data = await this.sendFile(type, attrs);
        if (data)
          this.attachedFile = data;
        await this.flush();
      } else if (type === "audio" && (attrs.src || attrs.url)) {
        await this.flush();
        const { data } = await this.bot.ctx.http.file(attrs.src || attrs.url, attrs);
        if (data.slice(0, 7).toString().includes("#!SILK")) {
          const onlineFile = await this.sendFile(type, {
            src: `data:audio/amr;base64,` + Buffer.from(data).toString("base64")
          });
          this.attachedFile = onlineFile;
        } else {
          const silk = this.bot.ctx.get("silk");
          if (!silk)
            return this.bot.logger.warn("missing silk service, cannot send non-silk audio");
          if (silk.isWav(data)) {
            const result = await silk.encode(data, 0);
            const onlineFile = await this.sendFile(type, {
              src: `data:audio/amr;base64,` + Buffer.from(result.data).toString("base64")
            });
            if (onlineFile)
              this.attachedFile = onlineFile;
          } else {
            if (!this.bot.ctx.get("ffmpeg"))
              return this.bot.logger.warn("missing ffmpeg service, cannot send non-silk audio except wav");
            const wavBuf = await this.bot.ctx.get("ffmpeg").builder().input(Buffer.from(data)).outputOption("-ar", "24000", "-ac", "1", "-f", "s16le").run("buffer");
            const result = await silk.encode(wavBuf, 24000);
            const onlineFile = await this.sendFile(type, {
              src: `data:audio/amr;base64,` + Buffer.from(result.data).toString("base64")
            });
            if (onlineFile)
              this.attachedFile = onlineFile;
          }
        }
        await this.flush();
      } else if (type === "br") {
        this.content += "\n";
      } else if (type === "p") {
        if (!this.content.endsWith("\n"))
          this.content += "\n";
        await this.render(children);
        if (!this.content.endsWith("\n"))
          this.content += "\n";
      } else if (type === "button-group") {
        this.useMarkdown = true;
        this.rows.push([]);
        await this.render(children);
        this.rows.push([]);
      } else if (type === "button") {
        this.useMarkdown = true;
        const last = this.lastRow();
        last.push(this.decodeButton(attrs, children.join("")));
      } else if (type === "message") {
        await this.flush();
        await this.render(children);
        await this.flush();
      } else {
        await this.render(children);
      }
    }
  };
  var QQGuildBot = class extends import_core5.Bot {
    hidden = true;
    internal;
    http;
    static MessageEncoder = QQGuildMessageEncoder;
    constructor(ctx, config) {
      super(ctx, config, "qq");
      this.parent = config.parent;
      this.parent.guildBot = this;
      this.platform = "qqguild";
      this.internal = new GuildInternal(this, () => config.parent.guildHttp);
      this.http = config.parent.guildHttp;
    }
    get status() {
      return this.parent.status;
    }
    set status(status) {
      this.parent.status = status;
    }
    async getUser(userId, guildId) {
      const { user } = await this.getGuildMember(guildId, userId);
      return user;
    }
    async getGuildList(next) {
      const guilds = await this.internal.getGuilds();
      return { data: guilds.map(decodeGuild) };
    }
    async getGuild(guildId) {
      const guild = await this.internal.getGuild(guildId);
      return decodeGuild(guild);
    }
    async getChannelList(guildId, next) {
      const channels = await this.internal.getChannels(guildId);
      return { data: channels.map(decodeChannel) };
    }
    async getChannel(channelId) {
      const channel = await this.internal.getChannel(channelId);
      return decodeChannel(channel);
    }
    async createChannel(guildId, data) {
      const channel = await this.internal.createGuildChannel(guildId, {
        name: data.name,
        type: data.type === import_core5.Universal.Channel.Type.TEXT ? 0 : data.type === import_core5.Universal.Channel.Type.CATEGORY ? 4 : data.type === import_core5.Universal.Channel.Type.VOICE ? 2 : 0,
        parent_id: data.parentId,
        position: data.position,
        sub_type: 0,
        private_type: 0,
        speak_permission: 1,
        private_user_ids: []
      });
      return decodeChannel(channel);
    }
    async getGuildMemberList(guildId, next) {
      const members = await this.internal.getGuildMembers(guildId, {
        limit: 400,
        after: next
      });
      return { data: members.map(decodeGuildMember), next: members[members.length - 1].user.id };
    }
    async getGuildMember(guildId, userId) {
      const member = await this.internal.getGuildMember(guildId, userId);
      return decodeGuildMember(member);
    }
    async kickGuildMember(guildId, userId) {
      await this.internal.removeGuildMember(guildId, userId);
    }
    async muteGuildMember(guildId, userId, duration) {
      await this.internal.muteGuildMember(guildId, userId, {
        mute_seconds: Math.floor(duration / 1000)
      });
    }
    async getReactionList(channelId, messageId, emoji, next) {
      const [type, id] = emoji.split(":");
      const { users, cookie } = await this.internal.getReactions(channelId, messageId, type, id, {
        limit: 50,
        cookie: next
      });
      return { next: cookie, data: users.map(decodeUser) };
    }
    async createReaction(channelId, messageId, emoji) {
      const [type, id] = emoji.split(":");
      await this.internal.createReaction(channelId, messageId, type, id);
    }
    async deleteReaction(channelId, messageId, emoji) {
      const [type, id] = emoji.split(":");
      await this.internal.deleteReaction(channelId, messageId, type, id);
    }
    async getMessage(channelId, messageId) {
      const r = await this.internal.getMessage(channelId, messageId);
      return decodeMessage(this, r);
    }
    async deleteMessage(channelId, messageId) {
      if (channelId.includes("_")) {
        const [guildId] = channelId.split("_");
        await this.internal.deleteDM(guildId, messageId);
      } else {
        await this.internal.deleteMessage(channelId, messageId);
      }
    }
    async getLogin() {
      return this.parent.getLogin();
    }
    async createDirectChannel(id, guild_id) {
      let input_guild_id = guild_id;
      if (guild_id?.includes("_"))
        input_guild_id = guild_id.split("_")[0];
      const dms = await this.internal.createDMS({
        recipient_id: id,
        source_guild_id: input_guild_id
      });
      return { id: `${dms.guild_id}_${input_guild_id}`, type: import_core5.Universal.Channel.Type.DIRECT };
    }
  };
  var QQBot = class extends import_core6.Bot {
    static MessageEncoder = QQMessageEncoder;
    static inject = ["http"];
    guildBot;
    internal;
    http;
    guildHttp;
    _token;
    _timer;
    constructor(ctx, config) {
      super(ctx, config, "qq");
      let endpoint = config.endpoint;
      if (config.sandbox) {
        endpoint = endpoint.replace(/^(https?:\/\/)/, "$1sandbox.");
      }
      this.guildHttp = ctx.http.extend({
        endpoint,
        headers: {
          Authorization: `Bot ${this.config.id}.${this.config.token}`
        }
      });
      this.ctx.plugin(QQGuildBot, {
        parent: this
      });
      this.internal = new GroupInternal(this, () => this.http);
      this.ctx.plugin(WsClient, this);
    }
    async initialize() {
      try {
        const user = await this.guildBot.internal.getMe();
        Object.assign(this.user, decodeUser(user));
      } catch (e) {
        this.logger.error(e);
      }
    }
    async stop() {
      clearTimeout(this._timer);
      if (this.guildBot) {
        delete this.ctx.bots[this.guildBot.sid];
      }
      await super.stop();
    }
    async _ensureAccessToken() {
      try {
        const result = await this.ctx.http("https://bots.qq.com/app/getAppAccessToken", {
          method: "POST",
          data: {
            appId: this.config.id,
            clientSecret: this.config.secret
          }
        });
        if (!result.data.access_token) {
          this.logger.warn(`POST https://bots.qq.com/app/getAppAccessToken response: %o, trace id: %s`, result.data, result.headers.get("x-tps-trace-id"));
          throw new Error("failed to refresh access token");
        }
        let endpoint = this.config.endpoint;
        if (this.config.sandbox) {
          endpoint = endpoint.replace(/^(https?:\/\/)/, "$1sandbox.");
        }
        this._token = result.data.access_token;
        this.http = this.ctx.http.extend({
          endpoint,
          headers: {
            Authorization: `QQBot ${this._token}`,
            "X-Union-Appid": this.config.id
          }
        });
        this._timer = setTimeout(() => {
          this._ensureAccessToken();
        }, (result.data.expires_in - 40) * 1000);
      } catch (e) {
        if (!this.ctx.http.isError(e) || !e.response)
          throw e;
        this.logger.warn(`POST https://bots.qq.com/app/getAppAccessToken response: %o, trace id: %s`, e.response.data, e.response.headers.get("x-tps-trace-id"));
        throw e;
      }
    }
    async getAccessToken() {
      if (!this._token) {
        await this._ensureAccessToken();
      }
      return this._token;
    }
    async getLogin() {
      await this.initialize();
      return this.toJSON();
    }
    async createDirectChannel(id) {
      return { id, type: import_core6.Universal.Channel.Type.DIRECT };
    }
    async deleteMessage(channelId, messageId) {
      try {
        await this.internal.deleteMessage(channelId, messageId);
      } catch (e) {
        await this.internal.deletePrivateMessage(channelId, messageId);
      }
    }
  };
  ((QQBot2) => {
    QQBot2.Config = import_core6.Schema.intersect([
      import_core6.Schema.object({
        id: import_core6.Schema.string().description("\u673A\u5668\u4EBA id\u3002").required(),
        secret: import_core6.Schema.string().description("\u673A\u5668\u4EBA\u5BC6\u94A5\u3002").role("secret"),
        token: import_core6.Schema.string().description("\u673A\u5668\u4EBA\u4EE4\u724C\u3002").role("secret"),
        type: import_core6.Schema.union(["public", "private"]).description("\u673A\u5668\u4EBA\u7C7B\u578B\u3002").required(),
        sandbox: import_core6.Schema.boolean().description("\u662F\u5426\u5F00\u542F\u6C99\u7BB1\u6A21\u5F0F\u3002").default(false),
        endpoint: import_core6.Schema.string().role("link").description("\u8981\u8FDE\u63A5\u7684\u670D\u52A1\u5668\u5730\u5740\u3002").default("https://api.sgroup.qq.com/"),
        authType: import_core6.Schema.union(["bot", "bearer"]).description("\u91C7\u7528\u7684\u9A8C\u8BC1\u65B9\u5F0F\u3002").default("bot"),
        intents: import_core6.Schema.bitset(Intents).description("\u9700\u8981\u8BA2\u9605\u7684\u673A\u5668\u4EBA\u4E8B\u4EF6\u3002"),
        retryWhen: import_core6.Schema.array(Number).description("\u53D1\u9001\u6D88\u606F\u9047\u5230\u5E73\u53F0\u9519\u8BEF\u7801\u65F6\u91CD\u8BD5\u3002").default([])
      }),
      WsClient.Options
    ]);
  })(QQBot || (QQBot = {}));
  var src_default = QQBot;
});

// D:/workspace/qqchannel-bot/node_modules/@paotuan/adapter-kook/lib/index.cjs
var require_lib17 = __commonJS((exports, module) => {
  var hasPermission = function(permissions, permission) {
    return (permissions & 1 << permission) === 1 << permission;
  };
  var encodeBit = function(value) {
    return (0, import_core.isNullable)(value) ? value : value ? 1 : 0;
  };
  var transformCardElement = function(data) {
    const { type, modules, text, elements, fields, ...attrs } = data;
    const children = modules || elements || fields || (text ? [text] : []);
    return (0, import_core.h)(type, attrs, children.map(transformCardElement));
  };
  var adaptMessageMeta = function(base, data, message = {}, payload = message) {
    if (base.type === 1) {
      message.content = base.content.replace(/@(.+?)#(\d+)/, (_, name, id) => (0, import_core.h)("at", { id, name }).toString()).replace(/@/, () => (0, import_core.h)("at", { type: "all" }).toString()).replace(/@/, () => (0, import_core.h)("at", { type: "here" }).toString()).replace(/@role:(\d+);/, (_, role) => (0, import_core.h)("at", { role }).toString()).replace(/#channel:(\d+);/, (_, id) => import_core.h.sharp(id).toString());
      message.elements = import_core.h.parse(message.content);
    } else if (base.type === 2) {
      const element = (0, import_core.h)("img", { src: base.content, file: data.attachments?.name });
      message.elements = [element];
      message.content = element.toString();
    } else if (base.type === 10) {
      const data2 = JSON.parse(base.content);
      message.elements = data2.map(transformCardElement);
      message.content = message.elements.join("");
    } else if (base.type === 9) {
      let content = base.content;
      let buffer = "";
      let cap;
      const elements = [];
      const flushText = () => {
        if (!buffer)
          return;
        elements.push(import_core.h.text(buffer.replace(/\\(.)/g, (_, char) => char)));
        buffer = "";
      };
      while (content) {
        if (content.startsWith("\\") && content.length > 1) {
          buffer += content[1];
          content = content.slice(2);
        } else if (cap = /^(\((met|chn|rol)\))(\w+)\1/.exec(content)) {
          content = content.slice(cap[0].length);
          flushText();
          if (cap[2] === "met") {
            if (cap[3] === "all" || cap[3] === "here") {
              elements.push((0, import_core.h)("at", { type: cap[3] }));
            } else {
              const name = data.kmarkdown.mention_part.find((mention) => mention.id === cap[3])?.username;
              elements.push((0, import_core.h)("at", { id: cap[3], name }));
            }
          } else if (cap[2] === "chn") {
            elements.push(import_core.h.sharp(cap[3]));
          } else if (cap[2] === "rol") {
            const name = data.kmarkdown.mention_role_part.find((mention) => mention.role_id + "" === cap[3])?.name;
            elements.push((0, import_core.h)("at", { role: cap[3], name }));
          }
        } else {
          buffer += content[0];
          content = content.slice(1);
        }
      }
      flushText();
      message.content = elements.join("");
      message.elements = elements;
    }
    if (data.author) {
      payload.user = adaptUser(data.author);
      payload.member = decodeGuildMember(data.author);
    }
    return message;
  };
  var adaptMessage = function(data, message = {}, payload = message) {
    adaptMessageMeta(data, data, message, payload);
    message.id = message.messageId = data.id;
    return message;
  };
  var adaptMessageSession = function(data, meta, message = {}, payload = message) {
    adaptMessageMeta(data, meta, message);
    message.id = message.messageId = data.msg_id;
    message.timestamp = data.msg_timestamp;
    if (meta.quote) {
      message.quote = adaptMessageMeta(meta.quote, meta.quote);
      message.quote.messageId = message.quote.id = meta.quote.rong_id;
    }
    return message;
  };
  var adaptMessageCreate = function(data, meta, session) {
    session.guildId = meta.guild_id;
    if (data.channel_type === "GROUP") {
      session.isDirect = false;
      session.channelId = data.target_id;
    } else {
      session.isDirect = true;
      session.channelId = meta.code;
    }
    session.event.channel.name = meta.channel_name;
    session.event.member = decodeGuildMember(data.extra.author);
    session.event.user = session.event.member.user;
    delete session.event.member.user;
    adaptMessageSession(data, meta, session.event.message = {}, session.event);
  };
  async function adaptMessageModify(bot, data, meta, session) {
    session.guildId = meta.guild_id;
    session.event.user = meta.user_info && adaptUser(meta.user_info);
    session.userId = meta.author_id;
    if ((meta.channel_type || data.channel_type) === "GROUP") {
      session.isDirect = false;
      session.channelId = meta.channel_id || meta.target_id;
    } else {
      session.isDirect = true;
      session.channelId = meta.chat_code || (await bot.createDirectChannel(session.userId)).id;
    }
    adaptMessageSession(data, meta, session.event.message = {}, session.event);
  }
  var adaptReaction = function(data, body, session) {
    if (data.channel_type === "GROUP") {
      session.guildId = data.target_id;
    }
    session.channelId = body.channel_id;
    session.messageId = body.msg_id;
    session.userId = body.user_id;
    session["emoji"] = body.emoji.id;
  };
  async function adaptSession(bot, input) {
    const session = bot.session();
    session.setInternal("kook", input);
    if (input.type === 255) {
      const { type, body } = input.extra;
      bot.dispatch(bot.session({
        type: "internal",
        _type: "kook/" + type.replace(/_/g, "-"),
        _data: body
      }));
      switch (type) {
        case "message_btn_click":
          session.type = "interaction/button";
          await adaptMessageModify(bot, input, body, session);
          session.event.button = {
            id: body.value
          };
          break;
        case "updated_message":
        case "updated_private_message":
          session.type = "message-updated";
          await adaptMessageModify(bot, input, body, session);
          break;
        case "deleted_message":
        case "deleted_private_message":
          session.type = "message-deleted";
          await adaptMessageModify(bot, input, body, session);
          break;
        case "added_reaction":
        case "private_added_reaction":
          session.type = "reaction-added";
          adaptReaction(input, body, session);
          break;
        case "deleted_reaction":
        case "private_deleted_reaction":
          session.type = "reaction-deleted";
          adaptReaction(input, body, session);
          break;
        case "updated_channel":
        case "deleted_channel":
          session.type = "channel-deleted";
          session.subtype = "group";
          session.channelId = body.id;
          break;
        case "pinned_message":
        case "unpinned_message":
          session.type = type === "pinned_message" ? "message-pinned" : "message-unpinned";
          session.operatorId = body.operator_id;
          session.messageId = body.msg_id;
          session.channelId = body.channel_id;
          break;
        case "joined_guild":
        case "exited_guild":
        case "updated_guild":
        case "deleted_guild":
        case "self_joined_guild":
        case "self_exited_guild":
        case "updated_guild_member":
          session.type = {
            joined_guild: "guild-member-added",
            exited_guild: "guild-member-deleted",
            updated_guild: "guild-updated",
            deleted_guild: "guild-deleted",
            self_joined_guild: "guild-added",
            self_exited_guild: "guild-deleted",
            updated_guild_member: "guild-member-updated"
          }[type];
          session.guildId = input.target_id;
          session.userId = body.user_id || bot.selfId;
          break;
        case "added_role":
        case "deleted_role":
        case "updated_role":
          session.type = {
            added_role: "guild-role-added",
            deleted_role: "guild-role-deleted",
            updated_role: "guild-role-updated"
          }[type];
          session.guildId = input.target_id;
          session.roleId = "" + body.role_id;
          session.event.role = decodeRole(body);
          break;
        default:
          return;
      }
    } else {
      session.type = "message";
      adaptMessageCreate(input, input.extra, session);
      if (!session.content)
        return;
    }
    return session;
  }
  var isDirectChannel = function(channelId) {
    return channelId.length > 30;
  };
  var encodeButton = function({ attrs, children }) {
    let theme = "primary";
    if (attrs.class === "secondary")
      theme = "info";
    if (attrs.class === "warning")
      theme = "warning";
    if (attrs.class === "danger")
      theme = "danger";
    if (attrs.class === "success")
      theme = "success";
    return {
      type: "button",
      theme,
      value: attrs.type === "link" ? attrs.href : attrs.id,
      click: attrs.type === "link" ? "link" : "return-val",
      text: {
        type: "kmarkdown",
        content: encodeMarkdown(children)
      }
    };
  };
  var encodeMarkdown = function(children) {
    let content = "";
    for (const element of children) {
      const { type, attrs, children: children2 } = element;
      if (type === "text") {
        content += attrs.content.replace(/[\\*`~()]/g, "\\$&");
      } else if (type === "b" || type === "strong") {
        content += "**" + encodeMarkdown(children2) + "**";
      } else if (type === "i" || type === "em") {
        content += "*" + encodeMarkdown(children2) + "*";
      } else if (type === "u" || type === "ins") {
        content += "(ins)" + encodeMarkdown(children2) + "(ins)";
      } else if (type === "s" || type === "del") {
        content += "~~" + encodeMarkdown(children2) + "~~";
      } else if (type === "spl") {
        content += "(spl)" + encodeMarkdown(children2) + "(spl)";
      } else if (type === "code") {
        content += "`" + element.toString(true) + "`";
      } else if (type === "a") {
        content += `[${encodeMarkdown(children2)}](${attrs.href})`;
      }
    }
    return content;
  };
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Card: () => Card,
    GuildMute: () => GuildMute,
    HttpServer: () => HttpServer,
    Internal: () => Internal,
    Kook: () => utils_exports,
    KookBot: () => KookBot,
    KookMessageEncoder: () => KookMessageEncoder,
    Permissions: () => Permissions,
    Signal: () => Signal,
    Type: () => Type,
    UserStatus: () => UserStatus,
    WsClient: () => WsClient,
    adaptChannel: () => adaptChannel,
    adaptGroup: () => adaptGroup,
    adaptMessage: () => adaptMessage,
    adaptSession: () => adaptSession,
    adaptUser: () => adaptUser,
    decodeGuildMember: () => decodeGuildMember,
    decodeRole: () => decodeRole,
    default: () => src_default,
    encodeRole: () => encodeRole,
    hasPermission: () => hasPermission,
    isDirectChannel: () => isDirectChannel
  });
  module.exports = __toCommonJS(src_exports);
  var import_core5 = require_lib15();
  var utils_exports = {};
  __export2(utils_exports, {
    Card: () => Card,
    GuildMute: () => GuildMute,
    Internal: () => Internal,
    Permissions: () => Permissions,
    Signal: () => Signal,
    Type: () => Type,
    UserStatus: () => UserStatus,
    adaptChannel: () => adaptChannel,
    adaptGroup: () => adaptGroup,
    adaptMessage: () => adaptMessage,
    adaptSession: () => adaptSession,
    adaptUser: () => adaptUser,
    decodeGuildMember: () => decodeGuildMember,
    decodeRole: () => decodeRole,
    encodeRole: () => encodeRole,
    hasPermission: () => hasPermission
  });
  var import_core = require_lib15();
  var Signal = ((Signal2) => {
    Signal2[Signal2["event"] = 0] = "event";
    Signal2[Signal2["hello"] = 1] = "hello";
    Signal2[Signal2["ping"] = 2] = "ping";
    Signal2[Signal2["pong"] = 3] = "pong";
    Signal2[Signal2["reconnect"] = 4] = "reconnect";
    Signal2[Signal2["resume"] = 5] = "resume";
    return Signal2;
  })(Signal || {});
  var Type = ((Type2) => {
    Type2[Type2["text"] = 1] = "text";
    Type2[Type2["image"] = 2] = "image";
    Type2[Type2["video"] = 3] = "video";
    Type2[Type2["file"] = 4] = "file";
    Type2[Type2["unknown"] = 7] = "unknown";
    Type2[Type2["audio"] = 8] = "audio";
    Type2[Type2["kmarkdown"] = 9] = "kmarkdown";
    Type2[Type2["card"] = 10] = "card";
    Type2[Type2["system"] = 255] = "system";
    return Type2;
  })(Type || {});
  var Card;
  ((Card2) => {
    Card2.Theme = ["primary", "secondary", "warning", "danger", "info", "none", "success"];
    let Button;
    ((Button2) => {
      Button2.Theme = ["primary", "secondary", "warning", "danger", "info", "none", "success"];
    })(Button = Card2.Button || (Card2.Button = {}));
  })(Card || (Card = {}));
  var UserStatus = ((UserStatus2) => {
    UserStatus2[UserStatus2["normal"] = 0] = "normal";
    UserStatus2[UserStatus2["normal_1"] = 1] = "normal_1";
    UserStatus2[UserStatus2["banned"] = 10] = "banned";
    return UserStatus2;
  })(UserStatus || {});
  var Permissions = ((Permissions2) => {
    Permissions2[Permissions2["GUILD_ADMIN"] = 0] = "GUILD_ADMIN";
    Permissions2[Permissions2["GUILD_MANAGE"] = 1] = "GUILD_MANAGE";
    Permissions2[Permissions2["GUILD_LOG"] = 2] = "GUILD_LOG";
    Permissions2[Permissions2["GUILD_INVITE_CREATE"] = 3] = "GUILD_INVITE_CREATE";
    Permissions2[Permissions2["GUILD_INVITE_MANAGE"] = 4] = "GUILD_INVITE_MANAGE";
    Permissions2[Permissions2["CHANNEL_MANAGE"] = 5] = "CHANNEL_MANAGE";
    Permissions2[Permissions2["GUILD_USER_KICK"] = 6] = "GUILD_USER_KICK";
    Permissions2[Permissions2["GUILD_USER_BAN"] = 7] = "GUILD_USER_BAN";
    Permissions2[Permissions2["GUILD_EMOJI_MANAGE"] = 8] = "GUILD_EMOJI_MANAGE";
    Permissions2[Permissions2["GUILD_USER_NAME_CHANGE"] = 9] = "GUILD_USER_NAME_CHANGE";
    Permissions2[Permissions2["GUILD_ROLE_MANAGE"] = 10] = "GUILD_ROLE_MANAGE";
    Permissions2[Permissions2["CHANNEL_VIEW"] = 11] = "CHANNEL_VIEW";
    Permissions2[Permissions2["CHANNEL_MESSAGE"] = 12] = "CHANNEL_MESSAGE";
    Permissions2[Permissions2["CHANNEL_MANAGE_MESSAGE"] = 13] = "CHANNEL_MANAGE_MESSAGE";
    Permissions2[Permissions2["CHANNEL_UPLOAD"] = 14] = "CHANNEL_UPLOAD";
    Permissions2[Permissions2["CHANNEL_VOICE_CONNECT"] = 15] = "CHANNEL_VOICE_CONNECT";
    Permissions2[Permissions2["CHANNEL_VOICE_MANAGE"] = 16] = "CHANNEL_VOICE_MANAGE";
    Permissions2[Permissions2["CHANNEL_MESSAGE_AT_ALL"] = 17] = "CHANNEL_MESSAGE_AT_ALL";
    Permissions2[Permissions2["CHANNEL_MESSAGE_REACTION_CREATE"] = 18] = "CHANNEL_MESSAGE_REACTION_CREATE";
    Permissions2[Permissions2["CHANNEL_MESSAGE_REACTION_FOLLOW"] = 19] = "CHANNEL_MESSAGE_REACTION_FOLLOW";
    Permissions2[Permissions2["CHANNEL_VOICE_CONNECT_PASSIVE"] = 20] = "CHANNEL_VOICE_CONNECT_PASSIVE";
    Permissions2[Permissions2["CHANNEL_VOICE_SPEAK_KEY_ONLY"] = 21] = "CHANNEL_VOICE_SPEAK_KEY_ONLY";
    Permissions2[Permissions2["CHANNEL_VOICR_SPEAK_FREE"] = 22] = "CHANNEL_VOICR_SPEAK_FREE";
    Permissions2[Permissions2["CHANNEL_VOICE_SPEAK"] = 23] = "CHANNEL_VOICE_SPEAK";
    Permissions2[Permissions2["GUILD_USER_DEAFEN"] = 24] = "GUILD_USER_DEAFEN";
    Permissions2[Permissions2["GUILD_USER_MUTEGUILD_USER_NAME_CHANGE_OTHER"] = 25] = "GUILD_USER_MUTEGUILD_USER_NAME_CHANGE_OTHER";
    Permissions2[Permissions2["GUILD_USER_NAME_CHANGE_OTHER"] = 26] = "GUILD_USER_NAME_CHANGE_OTHER";
    Permissions2[Permissions2["CHANNEL_VOICE_BGM"] = 27] = "CHANNEL_VOICE_BGM";
    return Permissions2;
  })(Permissions || {});
  var GuildMute;
  ((GuildMute2) => {
    let Type2;
    ((Type3) => {
      Type3[Type3["mic"] = 1] = "mic";
      Type3[Type3["headset"] = 2] = "headset";
    })(Type2 = GuildMute2.Type || (GuildMute2.Type = {}));
  })(GuildMute || (GuildMute = {}));
  var Internal = class _Internal {
    constructor(http) {
      this.http = http;
    }
    static define(name, method, path) {
      _Internal.prototype[name] = async function(...args) {
        const config = {};
        if (method === "GET" || method === "DELETE") {
          config.params = args[0];
        } else {
          config.data = args[0];
        }
        const { data } = await this.http(method, path, config);
        if (data?.code !== 0)
          throw new Error(data?.message || "Unexpected Error");
        return data?.data;
      };
    }
  };
  Internal.define("getGuildList", "GET", "/guild/list");
  Internal.define("getGuildView", "GET", "/guild/view");
  Internal.define("getGuildUserList", "GET", "/guild/user-list");
  Internal.define("setGuildUserNickname", "POST", "/guild/nickname");
  Internal.define("leaveGuild", "POST", "/guild/leave");
  Internal.define("kickoutGuildUser", "POST", "/guild/kickout");
  Internal.define("getGuildMuteList", "GET", "/guild-mute/list");
  Internal.define("createGuildMute", "POST", "/guild-mute/create");
  Internal.define("deleteGuildMute", "POST", "/guild-mute/delete");
  Internal.define("getGuildBoostHistory", "GET", "/guild-boost/history");
  Internal.define("getChannelList", "GET", "/channel/list");
  Internal.define("getChannelView", "GET", "/channel/view");
  Internal.define("createChannel", "POST", "/channel/create");
  Internal.define("updateChannel", "POST", "/channel/update");
  Internal.define("deleteChannel", "POST", "/channel/delete");
  Internal.define("getChannelUserList", "GET", "/channel/user-list");
  Internal.define("kickChannelUser", "POST", "/channel/kickout");
  Internal.define("moveChannelUser", "POST", "/channel/move-user");
  Internal.define("getChannelRoleIndex", "GET", "/channel-role/index");
  Internal.define("createChannelRole", "POST", "/channel-role/create");
  Internal.define("updateChannelRole", "POST", "/channel-role/update");
  Internal.define("deleteChannelRole", "POST", "/channel-role/delete");
  Internal.define("getMessageList", "GET", "/message/list");
  Internal.define("getMessageView", "GET", "/message/view");
  Internal.define("createMessage", "POST", "/message/create");
  Internal.define("updateMessage", "POST", "/message/update");
  Internal.define("deleteMessage", "POST", "/message/delete");
  Internal.define("getMessageReactionList", "GET", "/message/reaction-list");
  Internal.define("addMessageReaction", "POST", "/message/add-reaction");
  Internal.define("deleteMessageReaction", "POST", "/message/delete-reaction");
  Internal.define("getChannelJoinedUserList", "GET", "/channel-user/get-joined-channel");
  Internal.define("getPrivateChatList", "GET", "/user-chat/list");
  Internal.define("getPrivateChatView", "GET", "/user-chat/view");
  Internal.define("createPrivateChat", "POST", "/user-chat/create");
  Internal.define("deletePrivateChat", "POST", "/user-chat/delete");
  Internal.define("getDirectMessageList", "GET", "/direct-message/list");
  Internal.define("createDirectMessage", "POST", "/direct-message/create");
  Internal.define("updateDirectMessage", "POST", "/direct-message/update");
  Internal.define("deleteDirectMessage", "POST", "/direct-message/delete");
  Internal.define("getDirectMessageReactionList", "GET", "/direct-message/reaction-list");
  Internal.define("addDirectMessageReaction", "POST", "/direct-message/add-reaction");
  Internal.define("deleteDirectMessageReaction", "POST", "/direct-message/delete-reaction");
  Internal.define("getGateway", "GET", "/gateway/index");
  Internal.define("getToken", "POST", "/oauth2/token");
  Internal.define("createAsset", "POST", "/asset/create");
  Internal.define("getUserMe", "GET", "/user/me");
  Internal.define("getUserView", "GET", "/user/view");
  Internal.define("offline", "POST", "/user/offline");
  Internal.define("getGuildRoleList", "GET", "/guild-role/list");
  Internal.define("createGuildRole", "POST", "/guild-role/create");
  Internal.define("updateGuildRole", "POST", "/guild-role/update");
  Internal.define("deleteGuildRole", "POST", "/guild-role/delete");
  Internal.define("grantGuildRole", "POST", "/guild-role/grant");
  Internal.define("revokeGuildRole", "POST", "/guild-role/revoke");
  Internal.define("getIntimacy", "GET", "/intimacy/index");
  Internal.define("updateIntimacy", "POST", "/intimacy/update");
  Internal.define("getGuildEmojiList", "GET", "/guild-emoji/list");
  Internal.define("createGuildEmoji", "POST", "/guild-emoji/create");
  Internal.define("updateGuildEmoji", "POST", "/guild-emoji/update");
  Internal.define("deleteGuildEmoji", "POST", "/guild-emoji/delete");
  Internal.define("getInviteList", "GET", "/invite/list");
  Internal.define("createInvite", "POST", "/invite/create");
  Internal.define("deleteInvite", "POST", "/invite/delete");
  Internal.define("getBlacklist", "GET", "/blacklist/list");
  Internal.define("createBlacklist", "POST", "/blacklist/create");
  Internal.define("deleteBlacklist", "POST", "/blacklist/delete");
  Internal.define("getGuildBadge", "GET", "/badge/guild");
  Internal.define("getGameList", "GET", "/game");
  Internal.define("createGame", "POST", "/game/create");
  Internal.define("updateGame", "POST", "/game/update");
  Internal.define("deleteGame", "POST", "/game/delete");
  Internal.define("createGameActivity", "POST", "/game/activity");
  Internal.define("deleteGameActivity", "POST", "/game/delete-activity");
  var adaptGroup = (data) => ({
    id: data.id,
    name: data.name,
    avatar: data.icon
  });
  var adaptChannel = (data) => ({
    id: data.id,
    type: data.is_category ? import_core.Universal.Channel.Type.CATEGORY : data.type === 1 ? import_core.Universal.Channel.Type.TEXT : data.type === 2 ? import_core.Universal.Channel.Type.VOICE : -1,
    name: data.name,
    parentId: data.parent_id
  });
  var adaptUser = (user) => ({
    id: user.id,
    name: user.username,
    userId: user.id,
    avatar: user.avatar,
    username: user.username,
    discriminator: user.identify_num
  });
  var decodeGuildMember = (member) => ({
    user: adaptUser(member),
    nick: member.nickname
  });
  var decodeRole = (role) => ({
    ...role,
    id: "" + role.role_id,
    permissions: BigInt(role.permissions),
    hoist: !!role.hoist,
    mentionable: !!role.mentionable
  });
  var encodeRole = (role) => ({
    ...role,
    role_id: +role.id,
    permissions: role.permissions && Number(role.permissions),
    hoist: encodeBit(role.hoist),
    mentionable: encodeBit(role.mentionable)
  });
  var import_core2 = require_lib15();
  var heartbeatIntervals = [6, 2, 4];
  var WsClient = class extends import_core2.Adapter.WsClient {
    _sn = 0;
    _ping;
    _heartbeat;
    async prepare() {
      const { url } = await this.bot.request("GET", "/gateway/index?compress=0");
      const headers = { Authorization: `Bot ${this.bot.config.token}` };
      return this.bot.ctx.http.ws(url, { headers });
    }
    heartbeat() {
      if (!this.socket || this.bot.status !== import_core2.Universal.Status.ONLINE) {
        clearInterval(this._heartbeat);
        return;
      }
      let trials = 0;
      const send = () => {
        if (!this.socket)
          return;
        if (trials >= 2) {
          return this.socket.close(1000);
        }
        this.socket.send(JSON.stringify({ s: 2, sn: this._sn }));
        this._ping = setTimeout(send, heartbeatIntervals[trials++] * import_core2.Time.second);
      };
      send();
    }
    async accept() {
      this._sn = 0;
      clearInterval(this._heartbeat);
      this.socket.addEventListener("message", async ({ data }) => {
        let parsed;
        data = data.toString();
        try {
          parsed = JSON.parse(data);
        } catch (error) {
          return this.bot.logger.warn("cannot parse message", data);
        }
        this.bot.logger.debug("[receive] %o", parsed);
        if (parsed.s === 0) {
          this._sn = Math.max(this._sn, parsed.sn);
          const session = await adaptSession(this.bot, parsed.d);
          if (session)
            this.bot.dispatch(session);
        } else if (parsed.s === 1) {
          this._heartbeat = setInterval(() => this.heartbeat(), import_core2.Time.minute * 0.5);
          await this.bot.getLogin();
          this.bot.online();
        } else if (parsed.s === 3) {
          clearTimeout(this._ping);
        } else if (parsed.s === 5) {
          this.socket.close(1000);
        }
      });
    }
  };
  ((WsClient2) => {
    WsClient2.Options = import_core2.Schema.intersect([
      import_core2.Schema.object({
        protocol: import_core2.Schema.const("ws").required(process.env.KOISHI_ENV !== "browser"),
        token: import_core2.Schema.string().description("\u673A\u5668\u4EBA\u7684\u7528\u6237\u4EE4\u724C\u3002").role("secret").required()
      }),
      import_core2.Adapter.WsClientConfig
    ]);
  })(WsClient || (WsClient = {}));
  var import_core3 = require_lib15();
  var HttpServer = class extends import_core3.Adapter {
    static inject = ["server"];
    logger;
    constructor(ctx, bot) {
      super(ctx);
      this.logger = ctx.logger("kook");
      let { path } = bot.config;
      path = (0, import_core3.sanitize)(path);
      ctx.server.post(path, async (ctx2) => {
        const { body } = ctx2.request;
        this.logger.debug("receive %o", body);
        const { challenge } = body.d;
        ctx2.status = 200;
        if (challenge) {
          ctx2.body = { challenge };
          return;
        }
        const bot2 = this.bots.find((bot3) => bot3.config.verifyToken === body.d.verify_token);
        if (!bot2)
          return;
        const session = await adaptSession(bot2, body.d);
        if (session)
          bot2.dispatch(session);
      });
    }
    async connect(bot) {
      await bot.getLogin();
      bot.online();
    }
  };
  ((HttpServer2) => {
    HttpServer2.Options = import_core3.Schema.object({
      protocol: import_core3.Schema.const("http").required(),
      token: import_core3.Schema.string().description("\u673A\u5668\u4EBA\u4EE4\u724C\u3002").role("secret").required(),
      verifyToken: import_core3.Schema.string().description("\u9A8C\u8BC1\u4EE4\u724C\u3002").role("secret").required(),
      path: import_core3.Schema.string().description("\u670D\u52A1\u5668\u76D1\u542C\u7684\u8DEF\u5F84\u3002").default("/kook")
    });
  })(HttpServer || (HttpServer = {}));
  var import_core4 = require_lib15();
  var KookMessageEncoder = class extends import_core4.MessageEncoder {
    path;
    params = {};
    additional = {};
    textBuffer = "";
    cardBuffer = {
      type: "card",
      modules: []
    };
    async prepare() {
      if (isDirectChannel(this.session.channelId)) {
        this.session.isDirect = true;
        this.params.chat_code = this.session.channelId;
        this.path = "/user-chat/create-msg";
      } else {
        this.session.isDirect = false;
        this.params.target_id = this.session.channelId;
        this.path = "/message/create";
      }
    }
    async post(type, content) {
      try {
        const params = { ...this.params, ...this.additional, type, content };
        const result = await this.bot.request("POST", this.path, params);
        if (!result.msg_id)
          return;
        const session = this.bot.session();
        session.type = "send";
        session.content = "";
        session.messageId = result.msg_id;
        session.timestamp = result.timestamp;
        this.results.push(session.event.message);
        session.app.emit(session, "send", session);
      } catch (e) {
        this.errors.push(e);
      }
    }
    async transformUrl({ type, attrs }) {
      const src = attrs.src || attrs.url;
      if (await this.bot.http.isLocal(src)) {
        const payload = new FormData;
        const { data, type: type2, filename } = await this.bot.http.file(src, attrs);
        payload.append("file", new Blob([data], { type: type2 }), attrs.file || filename);
        const { data: { url } } = await this.bot.http.post("/asset/create", payload);
        return url;
      } else if (!src.includes("kookapp.cn")) {
        const { data, headers } = await this.bot.ctx.http("GET", src, {
          headers: { accept: type + "/*" },
          responseType: "arraybuffer",
          timeout: +attrs.timeout || undefined
        });
        const payload = new FormData;
        payload.append("file", new Blob([data], { type: headers.get("Content-Type") }), "file");
        const { data: { url } } = await this.bot.http.post("/asset/create", payload);
        return url;
      } else {
        return src;
      }
    }
    flushText() {
      const content = this.textBuffer.trim();
      if (!content)
        return;
      this.textBuffer = "";
      this.cardBuffer.modules.push({
        type: "section",
        text: {
          type: "kmarkdown",
          content
        }
      });
    }
    async flush(forceCard = false) {
      if (this.cardBuffer.modules.length || forceCard) {
        this.flushText();
        await this.post(10, JSON.stringify([this.cardBuffer]));
        this.cardBuffer = {
          type: "card",
          modules: []
        };
      } else {
        const content = this.textBuffer.trim();
        if (!content)
          return;
        this.textBuffer = "";
        await this.post(9, content);
      }
      this.additional = {};
    }
    async visit(element) {
      const { type, attrs, children } = element;
      if (type === "text") {
        this.textBuffer += attrs.content.replace(/[\\*`~()]/g, "\\$&");
      } else if (type === "b" || type === "strong") {
        this.textBuffer += "**";
        await this.render(children);
        this.textBuffer += "**";
      } else if (type === "i" || type === "em") {
        this.textBuffer += "*";
        await this.render(children);
        this.textBuffer += "*";
      } else if (type === "u" || type === "ins") {
        this.textBuffer += "(ins)";
        await this.render(children);
        this.textBuffer += "(ins)";
      } else if (type === "s" || type === "del") {
        this.textBuffer += "~~";
        await this.render(children);
        this.textBuffer += "~~";
      } else if (type === "spl") {
        this.textBuffer += "(spl)";
        await this.render(children);
        this.textBuffer += "(spl)";
      } else if (type === "code") {
        this.textBuffer += "`";
        await this.render(children);
        this.textBuffer += "`";
      } else if (type === "a") {
        this.textBuffer += `[`;
        await this.render(children);
        this.textBuffer += `](${attrs.href})`;
      } else if (type === "br") {
        this.textBuffer += "\n";
      } else if (type === "p") {
        if (!this.textBuffer.endsWith("\n"))
          this.textBuffer += "\n";
        await this.render(children);
        if (!this.textBuffer.endsWith("\n"))
          this.textBuffer += "\n";
      } else if (type === "at") {
        if (attrs.id) {
          this.textBuffer += `(met)${attrs.id}(met)`;
        } else if (attrs.type === "all") {
          this.textBuffer += `(met)all(met)`;
        } else if (attrs.type === "here") {
          this.textBuffer += `(met)here(met)`;
        } else if (attrs.role) {
          this.textBuffer += `(rol)${attrs.role}(rol)`;
        }
      } else if (type === "code") {
        this.textBuffer += `\`${element.toString(true)}\``;
      } else if (type === "sharp") {
        this.textBuffer += `(chn)${attrs.id}(chn)`;
      } else if (["video", "audio", "file", "kook:video", "kook:audio", "kook:file"].includes(type)) {
        this.flushText();
        this.cardBuffer.modules.push({
          type: type.startsWith("kook:") ? type.slice(5) : type,
          src: await this.transformUrl(element),
          title: attrs.title,
          cover: attrs.poster
        });
      } else if (type === "img" || type === "image" || type === "kook:image") {
        this.flushText();
        this.cardBuffer.modules.push({
          type: "container",
          elements: [{
            type: "image",
            src: await this.transformUrl(element)
          }]
        });
      } else if (type === "kook:image-group") {
        this.flushText();
        const elements = await Promise.all(element.children.map(async (child) => ({
          type: "image",
          src: await this.transformUrl(child),
          title: child.attrs.title
        })));
        while (elements.length) {
          this.cardBuffer.modules.push({
            type: "image-group",
            elements: elements.splice(0, 9)
          });
        }
      } else if (type === "button" || type === "kook:button") {
        this.flushText();
        this.cardBuffer.modules.push({
          type: "action-group",
          elements: [encodeButton(element)]
        });
      } else if (type === "button-group" || type === "kook:action-group") {
        this.flushText();
        const elements = element.children.map(encodeButton);
        while (elements.length) {
          this.cardBuffer.modules.push({
            type: "action-group",
            elements: elements.splice(0, 4)
          });
        }
      } else if (type === "hr" || type === "kook:divider") {
        this.flushText();
        this.cardBuffer.modules.push({
          type: "divider"
        });
      } else if (type === "kook:header") {
        this.flushText();
        this.cardBuffer.modules.push({
          type: "header",
          text: {
            type: attrs.type,
            content: attrs.content
          }
        });
      } else if (type === "kook:countdown") {
        this.flushText();
        this.cardBuffer.modules.push({
          type: "countdown",
          startTime: +attrs.startTime,
          endTime: +attrs.endTime,
          mode: attrs.mode
        });
      } else if (type === "kook:invite") {
        this.flushText();
        this.cardBuffer.modules.push({
          type: "invite",
          code: attrs.code
        });
      } else if (type === "kook:card") {
        await this.flush();
        this.cardBuffer.theme = attrs["kook:theme"] ?? (Card.Theme.includes(attrs.class) ? attrs.class : "primary");
        this.cardBuffer.size = attrs["kook:size"];
        await this.render(children);
        await this.flush(true);
      } else if (type === "quote") {
        await this.flush();
        this.additional.quote = attrs.id;
      } else if (type === "message") {
        await this.flush();
        await this.render(children);
        await this.flush();
      } else {
        await this.render(children);
      }
    }
  };
  ((KookMessageEncoder2) => {
    KookMessageEncoder2.Config = import_core4.Schema.object({
      handleMixedContent: import_core4.Schema.union([
        import_core4.Schema.const("separate").description("\u5C06\u6BCF\u4E2A\u4E0D\u540C\u5F62\u5F0F\u7684\u5185\u5BB9\u5206\u5F00\u53D1\u9001"),
        import_core4.Schema.const("card").description("\u4F7F\u7528\u5361\u7247\u53D1\u9001\u5185\u5BB9"),
        import_core4.Schema.const("mixed").description("\u4F7F\u7528\u6DF7\u5408\u6A21\u5F0F\u53D1\u9001\u5185\u5BB9")
      ]).role("radio").description("\u53D1\u9001\u56FE\u6587\u7B49\u6DF7\u5408\u5185\u5BB9\u65F6\u91C7\u7528\u7684\u65B9\u5F0F\u3002").default("separate")
    }).description("\u53D1\u9001\u8BBE\u7F6E");
  })(KookMessageEncoder || (KookMessageEncoder = {}));
  var KookBot = class extends import_core5.Bot {
    static MessageEncoder = KookMessageEncoder;
    static inject = ["http"];
    http;
    internal;
    constructor(ctx, config) {
      super(ctx, config, "kook");
      this.http = ctx.http.extend({
        headers: {
          Authorization: `Bot ${config.token}`
        }
      }).extend(config);
      this.proxyUrls.push("https://www.kookapp.cn/");
      this.internal = new Internal(this.http);
      if (config.protocol === "http") {
        ctx.plugin(HttpServer, this);
      } else if (config.protocol === "ws") {
        ctx.plugin(WsClient, this);
      }
    }
    async request(method, path, data = {}, headers = {}) {
      if (method === "GET") {
        return (await this.http.get(path, { params: data, headers })).data;
      } else {
        return (await this.http(method, path, { data, headers })).data?.data;
      }
    }
    async deleteMessage(channelId, msg_id) {
      if (isDirectChannel(channelId)) {
        await this.request("POST", "/user-chat/delete-msg", { msg_id });
      } else {
        await this.request("POST", "/message/delete", { msg_id });
      }
    }
    async editMessage(channelId, msg_id, content) {
      content = import_core5.h.normalize(content).join("");
      if (isDirectChannel(channelId)) {
        await this.request("POST", "/user-chat/update-msg", { msg_id, content });
      } else {
        await this.request("POST", "/message/update", { msg_id, content });
      }
    }
    async getMessage(channelId, msg_id) {
      if (isDirectChannel(channelId)) {
        return adaptMessage(await this.request("GET", "/user-chat/view", { msg_id }));
      } else {
        return adaptMessage(await this.request("GET", "/message/view", { msg_id }));
      }
    }
    async $createReaction(channelId, msg_id, emoji) {
      if (isDirectChannel(channelId)) {
        await this.request("POST", "/direct-message/add-reaction", { msg_id, emoji });
      } else {
        await this.request("POST", "/message/add-reaction", { msg_id, emoji });
      }
    }
    async $deleteReaction(channelId, messageId, emoji, user_id) {
      if (isDirectChannel(channelId)) {
        await this.request("POST", "/direct-message/delete-reaction", { msg_id: messageId, emoji });
      } else {
        await this.request("POST", "/message/delete-reaction", { msg_id: messageId, emoji, user_id });
      }
    }
    async getLogin() {
      this.user = adaptUser(await this.request("GET", "/user/me"));
      return this.toJSON();
    }
    async getGuildList() {
      const { items } = await this.request("GET", "/guild/list");
      return { data: items.map(adaptGroup) };
    }
    async getChannelList(guildId, next) {
      const channels = await this.internal.getChannelList({ guild_id: guildId });
      return { data: channels.items.map(adaptChannel) };
    }
    async createChannel(guildId, data) {
      const channel = await this.internal.createChannel({
        guild_id: guildId,
        name: data.name,
        type: data.type === import_core5.Universal.Channel.Type.TEXT ? 1 : data.type === import_core5.Universal.Channel.Type.VOICE ? 2 : 1,
        parent_id: data.parentId,
        is_category: data.type === import_core5.Universal.Channel.Type.CATEGORY ? 1 : 0
      });
      return adaptChannel(channel);
    }
    async getGuildMemberList(guild_id) {
      const { items } = await this.request("GET", "/guild/user-list", { guild_id });
      return { data: items.map(decodeGuildMember) };
    }
    async setGroupNickname(guild_id, user_id, nickname) {
      await this.request("POST", "/guild/nickname", { guild_id, user_id, nickname });
    }
    async leaveGroup(guild_id) {
      await this.request("POST", "/guild/leave", { guild_id });
    }
    async kickGroup(guild_id, user_id) {
      await this.request("POST", "/guild/kickout", { guild_id, user_id });
    }
    async createDirectChannel(userId) {
      const { code } = await this.request("POST", "/user-chat/create", { target_id: userId });
      return { id: code, type: import_core5.Universal.Channel.Type.DIRECT };
    }
    createReaction(channelId, messageId, emoji) {
      if (isDirectChannel(channelId)) {
        return this.internal.addDirectMessageReaction({ msg_id: messageId, emoji });
      } else {
        return this.internal.addMessageReaction({ msg_id: messageId, emoji });
      }
    }
    deleteReaction(channelId, messageId, emoji, userId) {
      if (isDirectChannel(channelId)) {
        return this.internal.deleteDirectMessageReaction({ msg_id: messageId, emoji, user_id: userId });
      } else {
        return this.internal.deleteMessageReaction({ msg_id: messageId, emoji, user_id: userId });
      }
    }
    async getReactionList(channelId, messageId, emoji) {
      let users;
      if (isDirectChannel(channelId)) {
        users = await this.internal.getDirectMessageReactionList({ msg_id: messageId, emoji });
      } else {
        users = await this.internal.getMessageReactionList({ msg_id: messageId, emoji });
      }
      return { data: users.map(adaptUser) };
    }
    async setGuildMemberRole(guildId, userId, roleId) {
      await this.internal.grantGuildRole({ guild_id: guildId, user_id: userId, role_id: +roleId });
    }
    async unsetGuildMemberRole(guildId, userId, roleId) {
      await this.internal.revokeGuildRole({ guild_id: guildId, user_id: userId, role_id: +roleId });
    }
    async getGuildRoles(guildId) {
      const { items } = await this.internal.getGuildRoleList({ guild_id: guildId });
      return { data: items.map(decodeRole) };
    }
    async createGuildRole(guildId, data) {
      const role = await this.internal.createGuildRole({
        guild_id: guildId,
        ...data
      });
      return decodeRole(role);
    }
    async updateGuildRole(guildId, roleId, data) {
      await this.internal.updateGuildRole({
        guild_id: guildId,
        ...encodeRole(data),
        role_id: +roleId
      });
    }
    async deleteGuildRole(guildId, roleId) {
      await this.internal.deleteGuildRole({ guild_id: guildId, role_id: +roleId });
    }
  };
  ((KookBot2) => {
    KookBot2.Config = import_core5.Schema.intersect([
      import_core5.Schema.object({
        protocol: process.env.KOISHI_ENV === "browser" ? import_core5.Schema.const("ws").default("ws") : import_core5.Schema.union(["http", "ws"]).description("\u9009\u62E9\u8981\u4F7F\u7528\u7684\u534F\u8BAE\u3002").required()
      }),
      import_core5.Schema.union([
        WsClient.Options,
        HttpServer.Options
      ]),
      KookMessageEncoder.Config,
      import_core5.HTTP.createConfig("https://www.kookapp.cn/api/v3")
    ]);
  })(KookBot || (KookBot = {}));
  var src_default = KookBot;
});

// ../../packages/dicecore/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS((exports, module) => {
  var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
  var hasAbortController = typeof AbortController === "function";
  var AC = hasAbortController ? AbortController : class AbortController2 {
    constructor() {
      this.signal = new AS;
    }
    abort() {
      this.signal.dispatchEvent("abort");
    }
  };
  var hasAbortSignal = typeof AbortSignal === "function";
  var hasACAbortSignal = typeof AC.AbortSignal === "function";
  var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal2 {
    constructor() {
      this.aborted = false;
      this._listeners = [];
    }
    dispatchEvent(type) {
      if (type === "abort") {
        this.aborted = true;
        const e = { type, target: this };
        this.onabort(e);
        this._listeners.forEach((f) => f(e), this);
      }
    }
    onabort() {
    }
    addEventListener(ev, fn) {
      if (ev === "abort") {
        this._listeners.push(fn);
      }
    }
    removeEventListener(ev, fn) {
      if (ev === "abort") {
        this._listeners = this._listeners.filter((f) => f !== fn);
      }
    }
  };
  var warned = new Set;
  var deprecatedOption = (opt, instead) => {
    const code = `LRU_CACHE_OPTION_${opt}`;
    if (shouldWarn(code)) {
      warn(code, `${opt} option`, `options.${instead}`, LRUCache);
    }
  };
  var deprecatedMethod = (method, instead) => {
    const code = `LRU_CACHE_METHOD_${method}`;
    if (shouldWarn(code)) {
      const { prototype } = LRUCache;
      const { get } = Object.getOwnPropertyDescriptor(prototype, method);
      warn(code, `${method} method`, `cache.${instead}()`, get);
    }
  };
  var deprecatedProperty = (field, instead) => {
    const code = `LRU_CACHE_PROPERTY_${field}`;
    if (shouldWarn(code)) {
      const { prototype } = LRUCache;
      const { get } = Object.getOwnPropertyDescriptor(prototype, field);
      warn(code, `${field} property`, `cache.${instead}`, get);
    }
  };
  var emitWarning = (...a) => {
    typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
  };
  var shouldWarn = (code) => !warned.has(code);
  var warn = (code, what, instead, fn) => {
    warned.add(code);
    const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
    emitWarning(msg, "DeprecationWarning", code, fn);
  };
  var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
  var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

  class ZeroArray extends Array {
    constructor(size) {
      super(size);
      this.fill(0);
    }
  }

  class Stack {
    constructor(max) {
      if (max === 0) {
        return [];
      }
      const UintArray = getUintArray(max);
      this.heap = new UintArray(max);
      this.length = 0;
    }
    push(n) {
      this.heap[this.length++] = n;
    }
    pop() {
      return this.heap[--this.length];
    }
  }

  class LRUCache {
    constructor(options = {}) {
      const {
        max = 0,
        ttl,
        ttlResolution = 1,
        ttlAutopurge,
        updateAgeOnGet,
        updateAgeOnHas,
        allowStale,
        dispose,
        disposeAfter,
        noDisposeOnSet,
        noUpdateTTL,
        maxSize = 0,
        maxEntrySize = 0,
        sizeCalculation,
        fetchMethod,
        fetchContext,
        noDeleteOnFetchRejection,
        noDeleteOnStaleGet
      } = options;
      const { length, maxAge, stale } = options instanceof LRUCache ? {} : options;
      if (max !== 0 && !isPosInt(max)) {
        throw new TypeError("max option must be a nonnegative integer");
      }
      const UintArray = max ? getUintArray(max) : Array;
      if (!UintArray) {
        throw new Error("invalid max value: " + max);
      }
      this.max = max;
      this.maxSize = maxSize;
      this.maxEntrySize = maxEntrySize || this.maxSize;
      this.sizeCalculation = sizeCalculation || length;
      if (this.sizeCalculation) {
        if (!this.maxSize && !this.maxEntrySize) {
          throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        }
        if (typeof this.sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation set to non-function");
        }
      }
      this.fetchMethod = fetchMethod || null;
      if (this.fetchMethod && typeof this.fetchMethod !== "function") {
        throw new TypeError("fetchMethod must be a function if specified");
      }
      this.fetchContext = fetchContext;
      if (!this.fetchMethod && fetchContext !== undefined) {
        throw new TypeError("cannot set fetchContext without fetchMethod");
      }
      this.keyMap = new Map;
      this.keyList = new Array(max).fill(null);
      this.valList = new Array(max).fill(null);
      this.next = new UintArray(max);
      this.prev = new UintArray(max);
      this.head = 0;
      this.tail = 0;
      this.free = new Stack(max);
      this.initialFill = 1;
      this.size = 0;
      if (typeof dispose === "function") {
        this.dispose = dispose;
      }
      if (typeof disposeAfter === "function") {
        this.disposeAfter = disposeAfter;
        this.disposed = [];
      } else {
        this.disposeAfter = null;
        this.disposed = null;
      }
      this.noDisposeOnSet = !!noDisposeOnSet;
      this.noUpdateTTL = !!noUpdateTTL;
      this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
      if (this.maxEntrySize !== 0) {
        if (this.maxSize !== 0) {
          if (!isPosInt(this.maxSize)) {
            throw new TypeError("maxSize must be a positive integer if specified");
          }
        }
        if (!isPosInt(this.maxEntrySize)) {
          throw new TypeError("maxEntrySize must be a positive integer if specified");
        }
        this.initializeSizeTracking();
      }
      this.allowStale = !!allowStale || !!stale;
      this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
      this.updateAgeOnGet = !!updateAgeOnGet;
      this.updateAgeOnHas = !!updateAgeOnHas;
      this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
      this.ttlAutopurge = !!ttlAutopurge;
      this.ttl = ttl || maxAge || 0;
      if (this.ttl) {
        if (!isPosInt(this.ttl)) {
          throw new TypeError("ttl must be a positive integer if specified");
        }
        this.initializeTTLTracking();
      }
      if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
        throw new TypeError("At least one of max, maxSize, or ttl is required");
      }
      if (!this.ttlAutopurge && !this.max && !this.maxSize) {
        const code = "LRU_CACHE_UNBOUNDED";
        if (shouldWarn(code)) {
          warned.add(code);
          const msg = "TTL caching without ttlAutopurge, max, or maxSize can " + "result in unbounded memory consumption.";
          emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
        }
      }
      if (stale) {
        deprecatedOption("stale", "allowStale");
      }
      if (maxAge) {
        deprecatedOption("maxAge", "ttl");
      }
      if (length) {
        deprecatedOption("length", "sizeCalculation");
      }
    }
    getRemainingTTL(key) {
      return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
    }
    initializeTTLTracking() {
      this.ttls = new ZeroArray(this.max);
      this.starts = new ZeroArray(this.max);
      this.setItemTTL = (index, ttl, start = perf.now()) => {
        this.starts[index] = ttl !== 0 ? start : 0;
        this.ttls[index] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (this.isStale(index)) {
              this.delete(this.keyList[index]);
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
        }
      };
      this.updateItemAge = (index) => {
        this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
      };
      let cachedNow = 0;
      const getNow = () => {
        const n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index = this.keyMap.get(key);
        if (index === undefined) {
          return 0;
        }
        return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
      };
      this.isStale = (index) => {
        return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
      };
    }
    updateItemAge(index) {
    }
    setItemTTL(index, ttl, start) {
    }
    isStale(index) {
      return false;
    }
    initializeSizeTracking() {
      this.calculatedSize = 0;
      this.sizes = new ZeroArray(this.max);
      this.removeItemSize = (index) => {
        this.calculatedSize -= this.sizes[index];
        this.sizes[index] = 0;
      };
      this.requireSize = (k, v, size, sizeCalculation) => {
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v, k);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer)");
          }
        }
        return size;
      };
      this.addItemSize = (index, size) => {
        this.sizes[index] = size;
        const maxSize = this.maxSize - this.sizes[index];
        while (this.calculatedSize > maxSize) {
          this.evict(true);
        }
        this.calculatedSize += this.sizes[index];
      };
    }
    removeItemSize(index) {
    }
    addItemSize(index, size) {
    }
    requireSize(k, v, size, sizeCalculation) {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
    }
    *indexes({ allowStale = this.allowStale } = {}) {
      if (this.size) {
        for (let i = this.tail;; ) {
          if (!this.isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.isStale(i)) {
            yield i;
          }
          if (i === this.head) {
            break;
          } else {
            i = this.prev[i];
          }
        }
      }
    }
    *rindexes({ allowStale = this.allowStale } = {}) {
      if (this.size) {
        for (let i = this.head;; ) {
          if (!this.isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.isStale(i)) {
            yield i;
          }
          if (i === this.tail) {
            break;
          } else {
            i = this.next[i];
          }
        }
      }
    }
    isValidIndex(index) {
      return this.keyMap.get(this.keyList[index]) === index;
    }
    *entries() {
      for (const i of this.indexes()) {
        yield [this.keyList[i], this.valList[i]];
      }
    }
    *rentries() {
      for (const i of this.rindexes()) {
        yield [this.keyList[i], this.valList[i]];
      }
    }
    *keys() {
      for (const i of this.indexes()) {
        yield this.keyList[i];
      }
    }
    *rkeys() {
      for (const i of this.rindexes()) {
        yield this.keyList[i];
      }
    }
    *values() {
      for (const i of this.indexes()) {
        yield this.valList[i];
      }
    }
    *rvalues() {
      for (const i of this.rindexes()) {
        yield this.valList[i];
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    find(fn, getOptions = {}) {
      for (const i of this.indexes()) {
        if (fn(this.valList[i], this.keyList[i], this)) {
          return this.get(this.keyList[i], getOptions);
        }
      }
    }
    forEach(fn, thisp = this) {
      for (const i of this.indexes()) {
        fn.call(thisp, this.valList[i], this.keyList[i], this);
      }
    }
    rforEach(fn, thisp = this) {
      for (const i of this.rindexes()) {
        fn.call(thisp, this.valList[i], this.keyList[i], this);
      }
    }
    get prune() {
      deprecatedMethod("prune", "purgeStale");
      return this.purgeStale;
    }
    purgeStale() {
      let deleted = false;
      for (const i of this.rindexes({ allowStale: true })) {
        if (this.isStale(i)) {
          this.delete(this.keyList[i]);
          deleted = true;
        }
      }
      return deleted;
    }
    dump() {
      const arr = [];
      for (const i of this.indexes({ allowStale: true })) {
        const key = this.keyList[i];
        const v = this.valList[i];
        const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        const entry = { value };
        if (this.ttls) {
          entry.ttl = this.ttls[i];
          const age = perf.now() - this.starts[i];
          entry.start = Math.floor(Date.now() - age);
        }
        if (this.sizes) {
          entry.size = this.sizes[i];
        }
        arr.unshift([key, entry]);
      }
      return arr;
    }
    load(arr) {
      this.clear();
      for (const [key, entry] of arr) {
        if (entry.start) {
          const age = Date.now() - entry.start;
          entry.start = perf.now() - age;
        }
        this.set(key, entry.value, entry);
      }
    }
    dispose(v, k, reason) {
    }
    set(k, v, {
      ttl = this.ttl,
      start,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL
    } = {}) {
      size = this.requireSize(k, v, size, sizeCalculation);
      if (this.maxEntrySize && size > this.maxEntrySize) {
        return this;
      }
      let index = this.size === 0 ? undefined : this.keyMap.get(k);
      if (index === undefined) {
        index = this.newIndex();
        this.keyList[index] = k;
        this.valList[index] = v;
        this.keyMap.set(k, index);
        this.next[this.tail] = index;
        this.prev[index] = this.tail;
        this.tail = index;
        this.size++;
        this.addItemSize(index, size);
        noUpdateTTL = false;
      } else {
        const oldVal = this.valList[index];
        if (v !== oldVal) {
          if (this.isBackgroundFetch(oldVal)) {
            oldVal.__abortController.abort();
          } else {
            if (!noDisposeOnSet) {
              this.dispose(oldVal, k, "set");
              if (this.disposeAfter) {
                this.disposed.push([oldVal, k, "set"]);
              }
            }
          }
          this.removeItemSize(index);
          this.valList[index] = v;
          this.addItemSize(index, size);
        }
        this.moveToTail(index);
      }
      if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
        this.initializeTTLTracking();
      }
      if (!noUpdateTTL) {
        this.setItemTTL(index, ttl, start);
      }
      if (this.disposeAfter) {
        while (this.disposed.length) {
          this.disposeAfter(...this.disposed.shift());
        }
      }
      return this;
    }
    newIndex() {
      if (this.size === 0) {
        return this.tail;
      }
      if (this.size === this.max && this.max !== 0) {
        return this.evict(false);
      }
      if (this.free.length !== 0) {
        return this.free.pop();
      }
      return this.initialFill++;
    }
    pop() {
      if (this.size) {
        const val = this.valList[this.head];
        this.evict(true);
        return val;
      }
    }
    evict(free) {
      const head = this.head;
      const k = this.keyList[head];
      const v = this.valList[head];
      if (this.isBackgroundFetch(v)) {
        v.__abortController.abort();
      } else {
        this.dispose(v, k, "evict");
        if (this.disposeAfter) {
          this.disposed.push([v, k, "evict"]);
        }
      }
      this.removeItemSize(head);
      if (free) {
        this.keyList[head] = null;
        this.valList[head] = null;
        this.free.push(head);
      }
      this.head = this.next[head];
      this.keyMap.delete(k);
      this.size--;
      return head;
    }
    has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
      const index = this.keyMap.get(k);
      if (index !== undefined) {
        if (!this.isStale(index)) {
          if (updateAgeOnHas) {
            this.updateItemAge(index);
          }
          return true;
        }
      }
      return false;
    }
    peek(k, { allowStale = this.allowStale } = {}) {
      const index = this.keyMap.get(k);
      if (index !== undefined && (allowStale || !this.isStale(index))) {
        const v = this.valList[index];
        return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
    }
    backgroundFetch(k, index, options, context2) {
      const v = index === undefined ? undefined : this.valList[index];
      if (this.isBackgroundFetch(v)) {
        return v;
      }
      const ac = new AC;
      const fetchOpts = {
        signal: ac.signal,
        options,
        context: context2
      };
      const cb = (v2) => {
        if (!ac.signal.aborted) {
          this.set(k, v2, fetchOpts.options);
        }
        return v2;
      };
      const eb = (er) => {
        if (this.valList[index] === p) {
          const del = !options.noDeleteOnFetchRejection || p.__staleWhileFetching === undefined;
          if (del) {
            this.delete(k);
          } else {
            this.valList[index] = p.__staleWhileFetching;
          }
        }
        if (p.__returned === p) {
          throw er;
        }
      };
      const pcall = (res) => res(this.fetchMethod(k, v, fetchOpts));
      const p = new Promise(pcall).then(cb, eb);
      p.__abortController = ac;
      p.__staleWhileFetching = v;
      p.__returned = null;
      if (index === undefined) {
        this.set(k, p, fetchOpts.options);
        index = this.keyMap.get(k);
      } else {
        this.valList[index] = p;
      }
      return p;
    }
    isBackgroundFetch(p) {
      return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(p, "__staleWhileFetching") && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
    }
    async fetch(k, {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      fetchContext = this.fetchContext,
      forceRefresh = false
    } = {}) {
      if (!this.fetchMethod) {
        return this.get(k, {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet
        });
      }
      const options = {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        ttl,
        noDisposeOnSet,
        size,
        sizeCalculation,
        noUpdateTTL,
        noDeleteOnFetchRejection
      };
      let index = this.keyMap.get(k);
      if (index === undefined) {
        const p = this.backgroundFetch(k, index, options, fetchContext);
        return p.__returned = p;
      } else {
        const v = this.valList[index];
        if (this.isBackgroundFetch(v)) {
          return allowStale && v.__staleWhileFetching !== undefined ? v.__staleWhileFetching : v.__returned = v;
        }
        if (!forceRefresh && !this.isStale(index)) {
          this.moveToTail(index);
          if (updateAgeOnGet) {
            this.updateItemAge(index);
          }
          return v;
        }
        const p = this.backgroundFetch(k, index, options, fetchContext);
        return allowStale && p.__staleWhileFetching !== undefined ? p.__staleWhileFetching : p.__returned = p;
      }
    }
    get(k, {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet
    } = {}) {
      const index = this.keyMap.get(k);
      if (index !== undefined) {
        const value = this.valList[index];
        const fetching = this.isBackgroundFetch(value);
        if (this.isStale(index)) {
          if (!fetching) {
            if (!noDeleteOnStaleGet) {
              this.delete(k);
            }
            return allowStale ? value : undefined;
          } else {
            return allowStale ? value.__staleWhileFetching : undefined;
          }
        } else {
          if (fetching) {
            return;
          }
          this.moveToTail(index);
          if (updateAgeOnGet) {
            this.updateItemAge(index);
          }
          return value;
        }
      }
    }
    connect(p, n) {
      this.prev[n] = p;
      this.next[p] = n;
    }
    moveToTail(index) {
      if (index !== this.tail) {
        if (index === this.head) {
          this.head = this.next[index];
        } else {
          this.connect(this.prev[index], this.next[index]);
        }
        this.connect(this.tail, index);
        this.tail = index;
      }
    }
    get del() {
      deprecatedMethod("del", "delete");
      return this.delete;
    }
    delete(k) {
      let deleted = false;
      if (this.size !== 0) {
        const index = this.keyMap.get(k);
        if (index !== undefined) {
          deleted = true;
          if (this.size === 1) {
            this.clear();
          } else {
            this.removeItemSize(index);
            const v = this.valList[index];
            if (this.isBackgroundFetch(v)) {
              v.__abortController.abort();
            } else {
              this.dispose(v, k, "delete");
              if (this.disposeAfter) {
                this.disposed.push([v, k, "delete"]);
              }
            }
            this.keyMap.delete(k);
            this.keyList[index] = null;
            this.valList[index] = null;
            if (index === this.tail) {
              this.tail = this.prev[index];
            } else if (index === this.head) {
              this.head = this.next[index];
            } else {
              this.next[this.prev[index]] = this.next[index];
              this.prev[this.next[index]] = this.prev[index];
            }
            this.size--;
            this.free.push(index);
          }
        }
      }
      if (this.disposed) {
        while (this.disposed.length) {
          this.disposeAfter(...this.disposed.shift());
        }
      }
      return deleted;
    }
    clear() {
      for (const index of this.rindexes({ allowStale: true })) {
        const v = this.valList[index];
        if (this.isBackgroundFetch(v)) {
          v.__abortController.abort();
        } else {
          const k = this.keyList[index];
          this.dispose(v, k, "delete");
          if (this.disposeAfter) {
            this.disposed.push([v, k, "delete"]);
          }
        }
      }
      this.keyMap.clear();
      this.valList.fill(null);
      this.keyList.fill(null);
      if (this.ttls) {
        this.ttls.fill(0);
        this.starts.fill(0);
      }
      if (this.sizes) {
        this.sizes.fill(0);
      }
      this.head = 0;
      this.tail = 0;
      this.initialFill = 1;
      this.free.length = 0;
      this.calculatedSize = 0;
      this.size = 0;
      if (this.disposed) {
        while (this.disposed.length) {
          this.disposeAfter(...this.disposed.shift());
        }
      }
    }
    get reset() {
      deprecatedMethod("reset", "clear");
      return this.clear;
    }
    get length() {
      deprecatedProperty("length", "size");
      return this.size;
    }
    static get AbortController() {
      return AC;
    }
    static get AbortSignal() {
      return AS;
    }
  }
  module.exports = LRUCache;
});

// ../../node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS((exports, module) => {
  var _extends = function() {
    module.exports = _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1;i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _extends.apply(this, arguments);
  };
  module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// ../../node_modules/typed-function/lib/umd/typed-function.js
var require_typed_function = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.typed = factory());
  })(exports, function() {
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len);i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function ok() {
      return true;
    }
    function notOk() {
      return false;
    }
    function undef() {
      return;
    }
    var NOT_TYPED_FUNCTION = "Argument is not a typed-function.";
    function create() {
      function isPlainObject(x) {
        return _typeof(x) === "object" && x !== null && x.constructor === Object;
      }
      var _types = [{
        name: "number",
        test: function test(x) {
          return typeof x === "number";
        }
      }, {
        name: "string",
        test: function test(x) {
          return typeof x === "string";
        }
      }, {
        name: "boolean",
        test: function test(x) {
          return typeof x === "boolean";
        }
      }, {
        name: "Function",
        test: function test(x) {
          return typeof x === "function";
        }
      }, {
        name: "Array",
        test: Array.isArray
      }, {
        name: "Date",
        test: function test(x) {
          return x instanceof Date;
        }
      }, {
        name: "RegExp",
        test: function test(x) {
          return x instanceof RegExp;
        }
      }, {
        name: "Object",
        test: isPlainObject
      }, {
        name: "null",
        test: function test(x) {
          return x === null;
        }
      }, {
        name: "undefined",
        test: function test(x) {
          return x === undefined;
        }
      }];
      var anyType = {
        name: "any",
        test: ok,
        isAny: true
      };
      var typeMap;
      var typeList;
      var nConversions = 0;
      var typed = {
        createCount: 0
      };
      function findType(typeName) {
        var type = typeMap.get(typeName);
        if (type) {
          return type;
        }
        var message = 'Unknown type "' + typeName + '"';
        var name = typeName.toLowerCase();
        var otherName;
        var _iterator = _createForOfIteratorHelper(typeList), _step;
        try {
          for (_iterator.s();!(_step = _iterator.n()).done; ) {
            otherName = _step.value;
            if (otherName.toLowerCase() === name) {
              message += '. Did you mean "' + otherName + '" ?';
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        throw new TypeError(message);
      }
      function addTypes(types4) {
        var beforeSpec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "any";
        var beforeIndex = beforeSpec ? findType(beforeSpec).index : typeList.length;
        var newTypes = [];
        for (var i = 0;i < types4.length; ++i) {
          if (!types4[i] || typeof types4[i].name !== "string" || typeof types4[i].test !== "function") {
            throw new TypeError("Object with properties {name: string, test: function} expected");
          }
          var typeName = types4[i].name;
          if (typeMap.has(typeName)) {
            throw new TypeError('Duplicate type name "' + typeName + '"');
          }
          newTypes.push(typeName);
          typeMap.set(typeName, {
            name: typeName,
            test: types4[i].test,
            isAny: types4[i].isAny,
            index: beforeIndex + i,
            conversionsTo: []
          });
        }
        var affectedTypes = typeList.slice(beforeIndex);
        typeList = typeList.slice(0, beforeIndex).concat(newTypes).concat(affectedTypes);
        for (var _i = beforeIndex + newTypes.length;_i < typeList.length; ++_i) {
          typeMap.get(typeList[_i]).index = _i;
        }
      }
      function clear() {
        typeMap = new Map;
        typeList = [];
        nConversions = 0;
        addTypes([anyType], false);
      }
      clear();
      addTypes(_types);
      function clearConversions() {
        var typeName;
        var _iterator2 = _createForOfIteratorHelper(typeList), _step2;
        try {
          for (_iterator2.s();!(_step2 = _iterator2.n()).done; ) {
            typeName = _step2.value;
            typeMap.get(typeName).conversionsTo = [];
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        nConversions = 0;
      }
      function findTypeNames(value) {
        var matches = typeList.filter(function(name) {
          var type = typeMap.get(name);
          return !type.isAny && type.test(value);
        });
        if (matches.length) {
          return matches;
        }
        return ["any"];
      }
      function isTypedFunction(entity) {
        return entity && typeof entity === "function" && "_typedFunctionData" in entity;
      }
      function findSignature(fn, signature, options) {
        if (!isTypedFunction(fn)) {
          throw new TypeError(NOT_TYPED_FUNCTION);
        }
        var exact = options && options.exact;
        var stringSignature = Array.isArray(signature) ? signature.join(",") : signature;
        var params = parseSignature(stringSignature);
        var canonicalSignature = stringifyParams(params);
        if (!exact || canonicalSignature in fn.signatures) {
          var match = fn._typedFunctionData.signatureMap.get(canonicalSignature);
          if (match) {
            return match;
          }
        }
        var nParams = params.length;
        var remainingSignatures;
        if (exact) {
          remainingSignatures = [];
          var name;
          for (name in fn.signatures) {
            remainingSignatures.push(fn._typedFunctionData.signatureMap.get(name));
          }
        } else {
          remainingSignatures = fn._typedFunctionData.signatures;
        }
        for (var i = 0;i < nParams; ++i) {
          var want = params[i];
          var filteredSignatures = [];
          var possibility = undefined;
          var _iterator3 = _createForOfIteratorHelper(remainingSignatures), _step3;
          try {
            for (_iterator3.s();!(_step3 = _iterator3.n()).done; ) {
              possibility = _step3.value;
              var have = getParamAtIndex(possibility.params, i);
              if (!have || want.restParam && !have.restParam) {
                continue;
              }
              if (!have.hasAny) {
                var _ret = function() {
                  var haveTypes = paramTypeSet(have);
                  if (want.types.some(function(wtype) {
                    return !haveTypes.has(wtype.name);
                  })) {
                    return "continue";
                  }
                }();
                if (_ret === "continue")
                  continue;
              }
              filteredSignatures.push(possibility);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          remainingSignatures = filteredSignatures;
          if (remainingSignatures.length === 0)
            break;
        }
        var candidate;
        var _iterator4 = _createForOfIteratorHelper(remainingSignatures), _step4;
        try {
          for (_iterator4.s();!(_step4 = _iterator4.n()).done; ) {
            candidate = _step4.value;
            if (candidate.params.length <= nParams) {
              return candidate;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        throw new TypeError("Signature not found (signature: " + (fn.name || "unnamed") + "(" + stringifyParams(params, ", ") + "))");
      }
      function find(fn, signature, options) {
        return findSignature(fn, signature, options).implementation;
      }
      function convert(value, typeName) {
        var type = findType(typeName);
        if (type.test(value)) {
          return value;
        }
        var conversions = type.conversionsTo;
        if (conversions.length === 0) {
          throw new Error("There are no conversions to " + typeName + " defined.");
        }
        for (var i = 0;i < conversions.length; i++) {
          var fromType = findType(conversions[i].from);
          if (fromType.test(value)) {
            return conversions[i].convert(value);
          }
        }
        throw new Error("Cannot convert " + value + " to " + typeName);
      }
      function stringifyParams(params) {
        var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ",";
        return params.map(function(p) {
          return p.name;
        }).join(separator);
      }
      function parseParam(param) {
        var restParam = param.indexOf("...") === 0;
        var types4 = !restParam ? param : param.length > 3 ? param.slice(3) : "any";
        var typeDefs = types4.split("|").map(function(s) {
          return findType(s.trim());
        });
        var hasAny = false;
        var paramName = restParam ? "..." : "";
        var exactTypes = typeDefs.map(function(type) {
          hasAny = type.isAny || hasAny;
          paramName += type.name + "|";
          return {
            name: type.name,
            typeIndex: type.index,
            test: type.test,
            isAny: type.isAny,
            conversion: null,
            conversionIndex: -1
          };
        });
        return {
          types: exactTypes,
          name: paramName.slice(0, -1),
          hasAny,
          hasConversion: false,
          restParam
        };
      }
      function expandParam(param) {
        var typeNames = param.types.map(function(t) {
          return t.name;
        });
        var matchingConversions = availableConversions(typeNames);
        var hasAny = param.hasAny;
        var newName = param.name;
        var convertibleTypes = matchingConversions.map(function(conversion) {
          var type = findType(conversion.from);
          hasAny = type.isAny || hasAny;
          newName += "|" + conversion.from;
          return {
            name: conversion.from,
            typeIndex: type.index,
            test: type.test,
            isAny: type.isAny,
            conversion,
            conversionIndex: conversion.index
          };
        });
        return {
          types: param.types.concat(convertibleTypes),
          name: newName,
          hasAny,
          hasConversion: convertibleTypes.length > 0,
          restParam: param.restParam
        };
      }
      function paramTypeSet(param) {
        if (!param.typeSet) {
          param.typeSet = new Set;
          param.types.forEach(function(type) {
            return param.typeSet.add(type.name);
          });
        }
        return param.typeSet;
      }
      function parseSignature(rawSignature) {
        var params = [];
        if (typeof rawSignature !== "string") {
          throw new TypeError("Signatures must be strings");
        }
        var signature = rawSignature.trim();
        if (signature === "") {
          return params;
        }
        var rawParams = signature.split(",");
        for (var i = 0;i < rawParams.length; ++i) {
          var parsedParam = parseParam(rawParams[i].trim());
          if (parsedParam.restParam && i !== rawParams.length - 1) {
            throw new SyntaxError('Unexpected rest parameter "' + rawParams[i] + '": ' + "only allowed for the last parameter");
          }
          if (parsedParam.types.length === 0) {
            return null;
          }
          params.push(parsedParam);
        }
        return params;
      }
      function hasRestParam(params) {
        var param = last(params);
        return param ? param.restParam : false;
      }
      function compileTest(param) {
        if (!param || param.types.length === 0) {
          return ok;
        } else if (param.types.length === 1) {
          return findType(param.types[0].name).test;
        } else if (param.types.length === 2) {
          var test0 = findType(param.types[0].name).test;
          var test1 = findType(param.types[1].name).test;
          return function or(x) {
            return test0(x) || test1(x);
          };
        } else {
          var tests = param.types.map(function(type) {
            return findType(type.name).test;
          });
          return function or(x) {
            for (var i = 0;i < tests.length; i++) {
              if (tests[i](x)) {
                return true;
              }
            }
            return false;
          };
        }
      }
      function compileTests(params) {
        var tests, test0, test1;
        if (hasRestParam(params)) {
          tests = initial(params).map(compileTest);
          var varIndex = tests.length;
          var lastTest = compileTest(last(params));
          var testRestParam = function testRestParam(args) {
            for (var i = varIndex;i < args.length; i++) {
              if (!lastTest(args[i])) {
                return false;
              }
            }
            return true;
          };
          return function testArgs(args) {
            for (var i = 0;i < tests.length; i++) {
              if (!tests[i](args[i])) {
                return false;
              }
            }
            return testRestParam(args) && args.length >= varIndex + 1;
          };
        } else {
          if (params.length === 0) {
            return function testArgs(args) {
              return args.length === 0;
            };
          } else if (params.length === 1) {
            test0 = compileTest(params[0]);
            return function testArgs(args) {
              return test0(args[0]) && args.length === 1;
            };
          } else if (params.length === 2) {
            test0 = compileTest(params[0]);
            test1 = compileTest(params[1]);
            return function testArgs(args) {
              return test0(args[0]) && test1(args[1]) && args.length === 2;
            };
          } else {
            tests = params.map(compileTest);
            return function testArgs(args) {
              for (var i = 0;i < tests.length; i++) {
                if (!tests[i](args[i])) {
                  return false;
                }
              }
              return args.length === tests.length;
            };
          }
        }
      }
      function getParamAtIndex(params, index) {
        return index < params.length ? params[index] : hasRestParam(params) ? last(params) : null;
      }
      function getTypeSetAtIndex(params, index) {
        var param = getParamAtIndex(params, index);
        if (!param) {
          return new Set;
        }
        return paramTypeSet(param);
      }
      function isExactType(type) {
        return type.conversion === null || type.conversion === undefined;
      }
      function mergeExpectedParams(signatures, index) {
        var typeSet = new Set;
        signatures.forEach(function(signature) {
          var paramSet = getTypeSetAtIndex(signature.params, index);
          var name;
          var _iterator5 = _createForOfIteratorHelper(paramSet), _step5;
          try {
            for (_iterator5.s();!(_step5 = _iterator5.n()).done; ) {
              name = _step5.value;
              typeSet.add(name);
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        });
        return typeSet.has("any") ? ["any"] : Array.from(typeSet);
      }
      function createError(name, args, signatures) {
        var err, expected;
        var _name = name || "unnamed";
        var matchingSignatures = signatures;
        var index;
        var _loop = function _loop() {
          var nextMatchingDefs = [];
          matchingSignatures.forEach(function(signature) {
            var param = getParamAtIndex(signature.params, index);
            var test = compileTest(param);
            if ((index < signature.params.length || hasRestParam(signature.params)) && test(args[index])) {
              nextMatchingDefs.push(signature);
            }
          });
          if (nextMatchingDefs.length === 0) {
            expected = mergeExpectedParams(matchingSignatures, index);
            if (expected.length > 0) {
              var actualTypes = findTypeNames(args[index]);
              err = new TypeError("Unexpected type of argument in function " + _name + " (expected: " + expected.join(" or ") + ", actual: " + actualTypes.join(" | ") + ", index: " + index + ")");
              err.data = {
                category: "wrongType",
                fn: _name,
                index,
                actual: actualTypes,
                expected
              };
              return {
                v: err
              };
            }
          } else {
            matchingSignatures = nextMatchingDefs;
          }
        };
        for (index = 0;index < args.length; index++) {
          var _ret2 = _loop();
          if (_typeof(_ret2) === "object")
            return _ret2.v;
        }
        var lengths = matchingSignatures.map(function(signature) {
          return hasRestParam(signature.params) ? Infinity : signature.params.length;
        });
        if (args.length < Math.min.apply(null, lengths)) {
          expected = mergeExpectedParams(matchingSignatures, index);
          err = new TypeError("Too few arguments in function " + _name + " (expected: " + expected.join(" or ") + ", index: " + args.length + ")");
          err.data = {
            category: "tooFewArgs",
            fn: _name,
            index: args.length,
            expected
          };
          return err;
        }
        var maxLength = Math.max.apply(null, lengths);
        if (args.length > maxLength) {
          err = new TypeError("Too many arguments in function " + _name + " (expected: " + maxLength + ", actual: " + args.length + ")");
          err.data = {
            category: "tooManyArgs",
            fn: _name,
            index: args.length,
            expectedLength: maxLength
          };
          return err;
        }
        var argTypes = [];
        for (var i = 0;i < args.length; ++i) {
          argTypes.push(findTypeNames(args[i]).join("|"));
        }
        err = new TypeError('Arguments of type "' + argTypes.join(", ") + '" do not match any of the defined signatures of function ' + _name + ".");
        err.data = {
          category: "mismatch",
          actual: argTypes
        };
        return err;
      }
      function getLowestTypeIndex(param) {
        var min = typeList.length + 1;
        for (var i = 0;i < param.types.length; i++) {
          if (isExactType(param.types[i])) {
            min = Math.min(min, param.types[i].typeIndex);
          }
        }
        return min;
      }
      function getLowestConversionIndex(param) {
        var min = nConversions + 1;
        for (var i = 0;i < param.types.length; i++) {
          if (!isExactType(param.types[i])) {
            min = Math.min(min, param.types[i].conversionIndex);
          }
        }
        return min;
      }
      function compareParams(param1, param2) {
        if (param1.hasAny) {
          if (!param2.hasAny) {
            return 1;
          }
        } else if (param2.hasAny) {
          return -1;
        }
        if (param1.restParam) {
          if (!param2.restParam) {
            return 1;
          }
        } else if (param2.restParam) {
          return -1;
        }
        if (param1.hasConversion) {
          if (!param2.hasConversion) {
            return 1;
          }
        } else if (param2.hasConversion) {
          return -1;
        }
        var typeDiff = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
        if (typeDiff < 0) {
          return -1;
        }
        if (typeDiff > 0) {
          return 1;
        }
        var convDiff = getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
        if (convDiff < 0) {
          return -1;
        }
        if (convDiff > 0) {
          return 1;
        }
        return 0;
      }
      function compareSignatures(signature1, signature2) {
        var pars1 = signature1.params;
        var pars2 = signature2.params;
        var last1 = last(pars1);
        var last2 = last(pars2);
        var hasRest1 = hasRestParam(pars1);
        var hasRest2 = hasRestParam(pars2);
        if (hasRest1 && last1.hasAny) {
          if (!hasRest2 || !last2.hasAny) {
            return 1;
          }
        } else if (hasRest2 && last2.hasAny) {
          return -1;
        }
        var any1 = 0;
        var conv1 = 0;
        var par;
        var _iterator6 = _createForOfIteratorHelper(pars1), _step6;
        try {
          for (_iterator6.s();!(_step6 = _iterator6.n()).done; ) {
            par = _step6.value;
            if (par.hasAny)
              ++any1;
            if (par.hasConversion)
              ++conv1;
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
        var any2 = 0;
        var conv2 = 0;
        var _iterator7 = _createForOfIteratorHelper(pars2), _step7;
        try {
          for (_iterator7.s();!(_step7 = _iterator7.n()).done; ) {
            par = _step7.value;
            if (par.hasAny)
              ++any2;
            if (par.hasConversion)
              ++conv2;
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
        if (any1 !== any2) {
          return any1 - any2;
        }
        if (hasRest1 && last1.hasConversion) {
          if (!hasRest2 || !last2.hasConversion) {
            return 1;
          }
        } else if (hasRest2 && last2.hasConversion) {
          return -1;
        }
        if (conv1 !== conv2) {
          return conv1 - conv2;
        }
        if (hasRest1) {
          if (!hasRest2) {
            return 1;
          }
        } else if (hasRest2) {
          return -1;
        }
        var lengthCriterion = (pars1.length - pars2.length) * (hasRest1 ? -1 : 1);
        if (lengthCriterion !== 0) {
          return lengthCriterion;
        }
        var comparisons = [];
        var tc = 0;
        for (var i = 0;i < pars1.length; ++i) {
          var thisComparison = compareParams(pars1[i], pars2[i]);
          comparisons.push(thisComparison);
          tc += thisComparison;
        }
        if (tc !== 0) {
          return tc;
        }
        var c;
        for (var _i2 = 0, _comparisons = comparisons;_i2 < _comparisons.length; _i2++) {
          c = _comparisons[_i2];
          if (c !== 0) {
            return c;
          }
        }
        return 0;
      }
      function availableConversions(typeNames) {
        if (typeNames.length === 0) {
          return [];
        }
        var types4 = typeNames.map(findType);
        if (typeNames.length > 1) {
          types4.sort(function(t1, t2) {
            return t1.index - t2.index;
          });
        }
        var matches = types4[0].conversionsTo;
        if (typeNames.length === 1) {
          return matches;
        }
        matches = matches.concat([]);
        var knownTypes = new Set(typeNames);
        for (var i = 1;i < types4.length; ++i) {
          var newMatch = undefined;
          var _iterator8 = _createForOfIteratorHelper(types4[i].conversionsTo), _step8;
          try {
            for (_iterator8.s();!(_step8 = _iterator8.n()).done; ) {
              newMatch = _step8.value;
              if (!knownTypes.has(newMatch.from)) {
                matches.push(newMatch);
                knownTypes.add(newMatch.from);
              }
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
        }
        return matches;
      }
      function compileArgsPreprocessing(params, fn) {
        var fnConvert = fn;
        if (params.some(function(p) {
          return p.hasConversion;
        })) {
          var restParam = hasRestParam(params);
          var compiledConversions = params.map(compileArgConversion);
          fnConvert = function convertArgs() {
            var args = [];
            var last2 = restParam ? arguments.length - 1 : arguments.length;
            for (var i = 0;i < last2; i++) {
              args[i] = compiledConversions[i](arguments[i]);
            }
            if (restParam) {
              args[last2] = arguments[last2].map(compiledConversions[last2]);
            }
            return fn.apply(this, args);
          };
        }
        var fnPreprocess = fnConvert;
        if (hasRestParam(params)) {
          var offset = params.length - 1;
          fnPreprocess = function preprocessRestParams() {
            return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));
          };
        }
        return fnPreprocess;
      }
      function compileArgConversion(param) {
        var test0, test1, conversion0, conversion1;
        var tests = [];
        var conversions = [];
        param.types.forEach(function(type) {
          if (type.conversion) {
            tests.push(findType(type.conversion.from).test);
            conversions.push(type.conversion.convert);
          }
        });
        switch (conversions.length) {
          case 0:
            return function convertArg(arg) {
              return arg;
            };
          case 1:
            test0 = tests[0];
            conversion0 = conversions[0];
            return function convertArg(arg) {
              if (test0(arg)) {
                return conversion0(arg);
              }
              return arg;
            };
          case 2:
            test0 = tests[0];
            test1 = tests[1];
            conversion0 = conversions[0];
            conversion1 = conversions[1];
            return function convertArg(arg) {
              if (test0(arg)) {
                return conversion0(arg);
              }
              if (test1(arg)) {
                return conversion1(arg);
              }
              return arg;
            };
          default:
            return function convertArg(arg) {
              for (var i = 0;i < conversions.length; i++) {
                if (tests[i](arg)) {
                  return conversions[i](arg);
                }
              }
              return arg;
            };
        }
      }
      function splitParams(params) {
        function _splitParams(params2, index, paramsSoFar) {
          if (index < params2.length) {
            var param = params2[index];
            var resultingParams = [];
            if (param.restParam) {
              var exactTypes = param.types.filter(isExactType);
              if (exactTypes.length < param.types.length) {
                resultingParams.push({
                  types: exactTypes,
                  name: "..." + exactTypes.map(function(t) {
                    return t.name;
                  }).join("|"),
                  hasAny: exactTypes.some(function(t) {
                    return t.isAny;
                  }),
                  hasConversion: false,
                  restParam: true
                });
              }
              resultingParams.push(param);
            } else {
              resultingParams = param.types.map(function(type) {
                return {
                  types: [type],
                  name: type.name,
                  hasAny: type.isAny,
                  hasConversion: type.conversion,
                  restParam: false
                };
              });
            }
            return flatMap(resultingParams, function(nextParam) {
              return _splitParams(params2, index + 1, paramsSoFar.concat([nextParam]));
            });
          } else {
            return [paramsSoFar];
          }
        }
        return _splitParams(params, 0, []);
      }
      function conflicting(params1, params2) {
        var ii = Math.max(params1.length, params2.length);
        for (var i = 0;i < ii; i++) {
          var typeSet1 = getTypeSetAtIndex(params1, i);
          var typeSet2 = getTypeSetAtIndex(params2, i);
          var overlap = false;
          var name = undefined;
          var _iterator9 = _createForOfIteratorHelper(typeSet2), _step9;
          try {
            for (_iterator9.s();!(_step9 = _iterator9.n()).done; ) {
              name = _step9.value;
              if (typeSet1.has(name)) {
                overlap = true;
                break;
              }
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
          if (!overlap) {
            return false;
          }
        }
        var len1 = params1.length;
        var len2 = params2.length;
        var restParam1 = hasRestParam(params1);
        var restParam2 = hasRestParam(params2);
        return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
      }
      function clearResolutions(functionList) {
        return functionList.map(function(fn) {
          if (isReferToSelf(fn)) {
            return referToSelf(fn.referToSelf.callback);
          }
          if (isReferTo(fn)) {
            return makeReferTo(fn.referTo.references, fn.referTo.callback);
          }
          return fn;
        });
      }
      function collectResolutions(references, functionList, signatureMap) {
        var resolvedReferences = [];
        var reference;
        var _iterator10 = _createForOfIteratorHelper(references), _step10;
        try {
          for (_iterator10.s();!(_step10 = _iterator10.n()).done; ) {
            reference = _step10.value;
            var resolution = signatureMap[reference];
            if (typeof resolution !== "number") {
              throw new TypeError('No definition for referenced signature "' + reference + '"');
            }
            resolution = functionList[resolution];
            if (typeof resolution !== "function") {
              return false;
            }
            resolvedReferences.push(resolution);
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }
        return resolvedReferences;
      }
      function resolveReferences(functionList, signatureMap, self2) {
        var resolvedFunctions = clearResolutions(functionList);
        var isResolved = new Array(resolvedFunctions.length).fill(false);
        var leftUnresolved = true;
        while (leftUnresolved) {
          leftUnresolved = false;
          var nothingResolved = true;
          for (var i = 0;i < resolvedFunctions.length; ++i) {
            if (isResolved[i])
              continue;
            var fn = resolvedFunctions[i];
            if (isReferToSelf(fn)) {
              resolvedFunctions[i] = fn.referToSelf.callback(self2);
              resolvedFunctions[i].referToSelf = fn.referToSelf;
              isResolved[i] = true;
              nothingResolved = false;
            } else if (isReferTo(fn)) {
              var resolvedReferences = collectResolutions(fn.referTo.references, resolvedFunctions, signatureMap);
              if (resolvedReferences) {
                resolvedFunctions[i] = fn.referTo.callback.apply(this, resolvedReferences);
                resolvedFunctions[i].referTo = fn.referTo;
                isResolved[i] = true;
                nothingResolved = false;
              } else {
                leftUnresolved = true;
              }
            }
          }
          if (nothingResolved && leftUnresolved) {
            throw new SyntaxError("Circular reference detected in resolving typed.referTo");
          }
        }
        return resolvedFunctions;
      }
      function validateDeprecatedThis(signaturesMap) {
        var deprecatedThisRegex = /\bthis(\(|\.signatures\b)/;
        Object.keys(signaturesMap).forEach(function(signature) {
          var fn = signaturesMap[signature];
          if (deprecatedThisRegex.test(fn.toString())) {
            throw new SyntaxError("Using `this` to self-reference a function " + "is deprecated since typed-function@3. " + "Use typed.referTo and typed.referToSelf instead.");
          }
        });
      }
      function createTypedFunction(name, rawSignaturesMap) {
        typed.createCount++;
        if (Object.keys(rawSignaturesMap).length === 0) {
          throw new SyntaxError("No signatures provided");
        }
        if (typed.warnAgainstDeprecatedThis) {
          validateDeprecatedThis(rawSignaturesMap);
        }
        var parsedParams = [];
        var originalFunctions = [];
        var signaturesMap = {};
        var preliminarySignatures = [];
        var signature;
        var _loop2 = function _loop2() {
          if (!Object.prototype.hasOwnProperty.call(rawSignaturesMap, signature)) {
            return "continue";
          }
          var params = parseSignature(signature);
          if (!params)
            return "continue";
          parsedParams.forEach(function(pp) {
            if (conflicting(pp, params)) {
              throw new TypeError('Conflicting signatures "' + stringifyParams(pp) + '" and "' + stringifyParams(params) + '".');
            }
          });
          parsedParams.push(params);
          var functionIndex = originalFunctions.length;
          originalFunctions.push(rawSignaturesMap[signature]);
          var conversionParams = params.map(expandParam);
          var sp = undefined;
          var _iterator11 = _createForOfIteratorHelper(splitParams(conversionParams)), _step11;
          try {
            for (_iterator11.s();!(_step11 = _iterator11.n()).done; ) {
              sp = _step11.value;
              var spName = stringifyParams(sp);
              preliminarySignatures.push({
                params: sp,
                name: spName,
                fn: functionIndex
              });
              if (sp.every(function(p) {
                return !p.hasConversion;
              })) {
                signaturesMap[spName] = functionIndex;
              }
            }
          } catch (err) {
            _iterator11.e(err);
          } finally {
            _iterator11.f();
          }
        };
        for (signature in rawSignaturesMap) {
          var _ret3 = _loop2();
          if (_ret3 === "continue")
            continue;
        }
        preliminarySignatures.sort(compareSignatures);
        var resolvedFunctions = resolveReferences(originalFunctions, signaturesMap, theTypedFn);
        var s;
        for (s in signaturesMap) {
          if (Object.prototype.hasOwnProperty.call(signaturesMap, s)) {
            signaturesMap[s] = resolvedFunctions[signaturesMap[s]];
          }
        }
        var signatures = [];
        var internalSignatureMap = new Map;
        for (var _i3 = 0, _preliminarySignature = preliminarySignatures;_i3 < _preliminarySignature.length; _i3++) {
          s = _preliminarySignature[_i3];
          if (!internalSignatureMap.has(s.name)) {
            s.fn = resolvedFunctions[s.fn];
            signatures.push(s);
            internalSignatureMap.set(s.name, s);
          }
        }
        var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
        var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
        var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
        var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
        var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
        var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
        var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;
        for (var i = 0;i < signatures.length; ++i) {
          signatures[i].test = compileTests(signatures[i].params);
        }
        var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
        var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
        var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
        var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
        var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
        var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
        var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
        var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
        var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
        var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
        var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
        var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;
        for (var _i4 = 0;_i4 < signatures.length; ++_i4) {
          signatures[_i4].implementation = compileArgsPreprocessing(signatures[_i4].params, signatures[_i4].fn);
        }
        var fn0 = ok0 ? signatures[0].implementation : undef;
        var fn1 = ok1 ? signatures[1].implementation : undef;
        var fn2 = ok2 ? signatures[2].implementation : undef;
        var fn3 = ok3 ? signatures[3].implementation : undef;
        var fn4 = ok4 ? signatures[4].implementation : undef;
        var fn5 = ok5 ? signatures[5].implementation : undef;
        var len0 = ok0 ? signatures[0].params.length : -1;
        var len1 = ok1 ? signatures[1].params.length : -1;
        var len2 = ok2 ? signatures[2].params.length : -1;
        var len3 = ok3 ? signatures[3].params.length : -1;
        var len4 = ok4 ? signatures[4].params.length : -1;
        var len5 = ok5 ? signatures[5].params.length : -1;
        var iStart = allOk ? 6 : 0;
        var iEnd = signatures.length;
        var tests = signatures.map(function(s2) {
          return s2.test;
        });
        var fns = signatures.map(function(s2) {
          return s2.implementation;
        });
        var generic = function generic() {
          for (var _i5 = iStart;_i5 < iEnd; _i5++) {
            if (tests[_i5](arguments)) {
              return fns[_i5].apply(this, arguments);
            }
          }
          return typed.onMismatch(name, arguments, signatures);
        };
        function theTypedFn(arg0, arg1) {
          if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
            return fn0.apply(this, arguments);
          }
          if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
            return fn1.apply(this, arguments);
          }
          if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
            return fn2.apply(this, arguments);
          }
          if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
            return fn3.apply(this, arguments);
          }
          if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
            return fn4.apply(this, arguments);
          }
          if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
            return fn5.apply(this, arguments);
          }
          return generic.apply(this, arguments);
        }
        try {
          Object.defineProperty(theTypedFn, "name", {
            value: name
          });
        } catch (err) {
        }
        theTypedFn.signatures = signaturesMap;
        theTypedFn._typedFunctionData = {
          signatures,
          signatureMap: internalSignatureMap
        };
        return theTypedFn;
      }
      function _onMismatch(name, args, signatures) {
        throw createError(name, args, signatures);
      }
      function initial(arr) {
        return slice(arr, 0, arr.length - 1);
      }
      function last(arr) {
        return arr[arr.length - 1];
      }
      function slice(arr, start, end) {
        return Array.prototype.slice.call(arr, start, end);
      }
      function findInArray(arr, test) {
        for (var i = 0;i < arr.length; i++) {
          if (test(arr[i])) {
            return arr[i];
          }
        }
        return;
      }
      function flatMap(arr, callback) {
        return Array.prototype.concat.apply([], arr.map(callback));
      }
      function referTo() {
        var references = initial(arguments).map(function(s) {
          return stringifyParams(parseSignature(s));
        });
        var callback = last(arguments);
        if (typeof callback !== "function") {
          throw new TypeError("Callback function expected as last argument");
        }
        return makeReferTo(references, callback);
      }
      function makeReferTo(references, callback) {
        return {
          referTo: {
            references,
            callback
          }
        };
      }
      function referToSelf(callback) {
        if (typeof callback !== "function") {
          throw new TypeError("Callback function expected as first argument");
        }
        return {
          referToSelf: {
            callback
          }
        };
      }
      function isReferTo(objectOrFn) {
        return objectOrFn && _typeof(objectOrFn.referTo) === "object" && Array.isArray(objectOrFn.referTo.references) && typeof objectOrFn.referTo.callback === "function";
      }
      function isReferToSelf(objectOrFn) {
        return objectOrFn && _typeof(objectOrFn.referToSelf) === "object" && typeof objectOrFn.referToSelf.callback === "function";
      }
      function checkName(nameSoFar, newName) {
        if (!nameSoFar) {
          return newName;
        }
        if (newName && newName !== nameSoFar) {
          var err = new Error("Function names do not match (expected: " + nameSoFar + ", actual: " + newName + ")");
          err.data = {
            actual: newName,
            expected: nameSoFar
          };
          throw err;
        }
        return nameSoFar;
      }
      function getObjectName(obj) {
        var name;
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key) && (isTypedFunction(obj[key]) || typeof obj[key].signature === "string")) {
            name = checkName(name, obj[key].name);
          }
        }
        return name;
      }
      function mergeSignatures(dest, source) {
        var key;
        for (key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            if (key in dest) {
              if (source[key] !== dest[key]) {
                var err = new Error('Signature "' + key + '" is defined twice');
                err.data = {
                  signature: key,
                  sourceFunction: source[key],
                  destFunction: dest[key]
                };
                throw err;
              }
            }
            dest[key] = source[key];
          }
        }
      }
      var saveTyped = typed;
      typed = function typed(maybeName) {
        var named = typeof maybeName === "string";
        var start = named ? 1 : 0;
        var name = named ? maybeName : "";
        var allSignatures = {};
        for (var i = start;i < arguments.length; ++i) {
          var item = arguments[i];
          var theseSignatures = {};
          var thisName = undefined;
          if (typeof item === "function") {
            thisName = item.name;
            if (typeof item.signature === "string") {
              theseSignatures[item.signature] = item;
            } else if (isTypedFunction(item)) {
              theseSignatures = item.signatures;
            }
          } else if (isPlainObject(item)) {
            theseSignatures = item;
            if (!named) {
              thisName = getObjectName(item);
            }
          }
          if (Object.keys(theseSignatures).length === 0) {
            var err = new TypeError("Argument to \'typed\' at index " + i + " is not a (typed) function, " + "nor an object with signatures as keys and functions as values.");
            err.data = {
              index: i,
              argument: item
            };
            throw err;
          }
          if (!named) {
            name = checkName(name, thisName);
          }
          mergeSignatures(allSignatures, theseSignatures);
        }
        return createTypedFunction(name || "", allSignatures);
      };
      typed.create = create;
      typed.createCount = saveTyped.createCount;
      typed.onMismatch = _onMismatch;
      typed.throwMismatchError = _onMismatch;
      typed.createError = createError;
      typed.clear = clear;
      typed.clearConversions = clearConversions;
      typed.addTypes = addTypes;
      typed._findType = findType;
      typed.referTo = referTo;
      typed.referToSelf = referToSelf;
      typed.convert = convert;
      typed.findSignature = findSignature;
      typed.find = find;
      typed.isTypedFunction = isTypedFunction;
      typed.warnAgainstDeprecatedThis = true;
      typed.addType = function(type, beforeObjectTest) {
        var before = "any";
        if (beforeObjectTest !== false && typeMap.has("Object")) {
          before = "Object";
        }
        typed.addTypes([type], before);
      };
      function _validateConversion(conversion) {
        if (!conversion || typeof conversion.from !== "string" || typeof conversion.to !== "string" || typeof conversion.convert !== "function") {
          throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
        }
        if (conversion.to === conversion.from) {
          throw new SyntaxError('Illegal to define conversion from "' + conversion.from + '" to itself.');
        }
      }
      typed.addConversion = function(conversion) {
        _validateConversion(conversion);
        var to = findType(conversion.to);
        if (to.conversionsTo.every(function(other) {
          return other.from !== conversion.from;
        })) {
          to.conversionsTo.push({
            from: conversion.from,
            convert: conversion.convert,
            index: nConversions++
          });
        } else {
          throw new Error('There is already a conversion from "' + conversion.from + '" to "' + to.name + '"');
        }
      };
      typed.addConversions = function(conversions) {
        conversions.forEach(typed.addConversion);
      };
      typed.removeConversion = function(conversion) {
        _validateConversion(conversion);
        var to = findType(conversion.to);
        var existingConversion = findInArray(to.conversionsTo, function(c) {
          return c.from === conversion.from;
        });
        if (!existingConversion) {
          throw new Error("Attempt to remove nonexistent conversion from " + conversion.from + " to " + conversion.to);
        }
        if (existingConversion.convert !== conversion.convert) {
          throw new Error("Conversion to remove does not match existing conversion");
        }
        var index = to.conversionsTo.indexOf(existingConversion);
        to.conversionsTo.splice(index, 1);
      };
      typed.resolve = function(tf, argList) {
        if (!isTypedFunction(tf)) {
          throw new TypeError(NOT_TYPED_FUNCTION);
        }
        var sigs = tf._typedFunctionData.signatures;
        for (var i = 0;i < sigs.length; ++i) {
          if (sigs[i].test(argList)) {
            return sigs[i];
          }
        }
        return null;
      };
      return typed;
    }
    var typedFunction = create();
    return typedFunction;
  });
});

// ../../node_modules/complex.js/complex.js
var require_complex = __commonJS((exports, module) => {
  (function(root) {
    var cosh3 = Math.cosh || function(x) {
      return Math.abs(x) < 0.000000001 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
    };
    var sinh3 = Math.sinh || function(x) {
      return Math.abs(x) < 0.000000001 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
    };
    var cosm1 = function(x) {
      var b = Math.PI / 4;
      if (-b > x || x > b) {
        return Math.cos(x) - 1;
      }
      var xx = x * x;
      return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888000 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
    };
    var hypot2 = function(x, y) {
      var a = Math.abs(x);
      var b = Math.abs(y);
      if (a < 3000 && b < 3000) {
        return Math.sqrt(a * a + b * b);
      }
      if (a < b) {
        a = b;
        b = x / y;
      } else {
        b = y / x;
      }
      return a * Math.sqrt(1 + b * b);
    };
    var parser_exit = function() {
      throw SyntaxError("Invalid Param");
    };
    function logHypot(a, b) {
      var _a = Math.abs(a);
      var _b = Math.abs(b);
      if (a === 0) {
        return Math.log(_b);
      }
      if (b === 0) {
        return Math.log(_a);
      }
      if (_a < 3000 && _b < 3000) {
        return Math.log(a * a + b * b) * 0.5;
      }
      a = a / 2;
      b = b / 2;
      return 0.5 * Math.log(a * a + b * b) + Math.LN2;
    }
    var parse = function(a, b) {
      var z2 = { re: 0, im: 0 };
      if (a === undefined || a === null) {
        z2["re"] = z2["im"] = 0;
      } else if (b !== undefined) {
        z2["re"] = a;
        z2["im"] = b;
      } else
        switch (typeof a) {
          case "object":
            if ("im" in a && "re" in a) {
              z2["re"] = a["re"];
              z2["im"] = a["im"];
            } else if ("abs" in a && "arg" in a) {
              if (!Number.isFinite(a["abs"]) && Number.isFinite(a["arg"])) {
                return Complex["INFINITY"];
              }
              z2["re"] = a["abs"] * Math.cos(a["arg"]);
              z2["im"] = a["abs"] * Math.sin(a["arg"]);
            } else if ("r" in a && "phi" in a) {
              if (!Number.isFinite(a["r"]) && Number.isFinite(a["phi"])) {
                return Complex["INFINITY"];
              }
              z2["re"] = a["r"] * Math.cos(a["phi"]);
              z2["im"] = a["r"] * Math.sin(a["phi"]);
            } else if (a.length === 2) {
              z2["re"] = a[0];
              z2["im"] = a[1];
            } else {
              parser_exit();
            }
            break;
          case "string":
            z2["im"] = z2["re"] = 0;
            var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
            var plus = 1;
            var minus = 0;
            if (tokens === null) {
              parser_exit();
            }
            for (var i = 0;i < tokens.length; i++) {
              var c = tokens[i];
              if (c === " " || c === "\t" || c === "\n") {
              } else if (c === "+") {
                plus++;
              } else if (c === "-") {
                minus++;
              } else if (c === "i" || c === "I") {
                if (plus + minus === 0) {
                  parser_exit();
                }
                if (tokens[i + 1] !== " " && !isNaN(tokens[i + 1])) {
                  z2["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i + 1]);
                  i++;
                } else {
                  z2["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
                }
                plus = minus = 0;
              } else {
                if (plus + minus === 0 || isNaN(c)) {
                  parser_exit();
                }
                if (tokens[i + 1] === "i" || tokens[i + 1] === "I") {
                  z2["im"] += parseFloat((minus % 2 ? "-" : "") + c);
                  i++;
                } else {
                  z2["re"] += parseFloat((minus % 2 ? "-" : "") + c);
                }
                plus = minus = 0;
              }
            }
            if (plus + minus > 0) {
              parser_exit();
            }
            break;
          case "number":
            z2["im"] = 0;
            z2["re"] = a;
            break;
          default:
            parser_exit();
        }
      if (isNaN(z2["re"]) || isNaN(z2["im"])) {
      }
      return z2;
    };
    function Complex(a, b) {
      if (!(this instanceof Complex)) {
        return new Complex(a, b);
      }
      var z2 = parse(a, b);
      this["re"] = z2["re"];
      this["im"] = z2["im"];
    }
    Complex.prototype = {
      re: 0,
      im: 0,
      sign: function() {
        var abs2 = this["abs"]();
        return new Complex(this["re"] / abs2, this["im"] / abs2);
      },
      add: function(a, b) {
        var z2 = new Complex(a, b);
        if (this["isInfinite"]() && z2["isInfinite"]()) {
          return Complex["NAN"];
        }
        if (this["isInfinite"]() || z2["isInfinite"]()) {
          return Complex["INFINITY"];
        }
        return new Complex(this["re"] + z2["re"], this["im"] + z2["im"]);
      },
      sub: function(a, b) {
        var z2 = new Complex(a, b);
        if (this["isInfinite"]() && z2["isInfinite"]()) {
          return Complex["NAN"];
        }
        if (this["isInfinite"]() || z2["isInfinite"]()) {
          return Complex["INFINITY"];
        }
        return new Complex(this["re"] - z2["re"], this["im"] - z2["im"]);
      },
      mul: function(a, b) {
        var z2 = new Complex(a, b);
        if (this["isInfinite"]() && z2["isZero"]() || this["isZero"]() && z2["isInfinite"]()) {
          return Complex["NAN"];
        }
        if (this["isInfinite"]() || z2["isInfinite"]()) {
          return Complex["INFINITY"];
        }
        if (z2["im"] === 0 && this["im"] === 0) {
          return new Complex(this["re"] * z2["re"], 0);
        }
        return new Complex(this["re"] * z2["re"] - this["im"] * z2["im"], this["re"] * z2["im"] + this["im"] * z2["re"]);
      },
      div: function(a, b) {
        var z2 = new Complex(a, b);
        if (this["isZero"]() && z2["isZero"]() || this["isInfinite"]() && z2["isInfinite"]()) {
          return Complex["NAN"];
        }
        if (this["isInfinite"]() || z2["isZero"]()) {
          return Complex["INFINITY"];
        }
        if (this["isZero"]() || z2["isInfinite"]()) {
          return Complex["ZERO"];
        }
        a = this["re"];
        b = this["im"];
        var c = z2["re"];
        var d = z2["im"];
        var t, x;
        if (d === 0) {
          return new Complex(a / c, b / c);
        }
        if (Math.abs(c) < Math.abs(d)) {
          x = c / d;
          t = c * x + d;
          return new Complex((a * x + b) / t, (b * x - a) / t);
        } else {
          x = d / c;
          t = d * x + c;
          return new Complex((a + b * x) / t, (b - a * x) / t);
        }
      },
      pow: function(a, b) {
        var z2 = new Complex(a, b);
        a = this["re"];
        b = this["im"];
        if (z2["isZero"]()) {
          return Complex["ONE"];
        }
        if (z2["im"] === 0) {
          if (b === 0 && a > 0) {
            return new Complex(Math.pow(a, z2["re"]), 0);
          } else if (a === 0) {
            switch ((z2["re"] % 4 + 4) % 4) {
              case 0:
                return new Complex(Math.pow(b, z2["re"]), 0);
              case 1:
                return new Complex(0, Math.pow(b, z2["re"]));
              case 2:
                return new Complex(-Math.pow(b, z2["re"]), 0);
              case 3:
                return new Complex(0, -Math.pow(b, z2["re"]));
            }
          }
        }
        if (a === 0 && b === 0 && z2["re"] > 0 && z2["im"] >= 0) {
          return Complex["ZERO"];
        }
        var arg = Math.atan2(b, a);
        var loh = logHypot(a, b);
        a = Math.exp(z2["re"] * loh - z2["im"] * arg);
        b = z2["im"] * loh + z2["re"] * arg;
        return new Complex(a * Math.cos(b), a * Math.sin(b));
      },
      sqrt: function() {
        var a = this["re"];
        var b = this["im"];
        var r = this["abs"]();
        var re, im;
        if (a >= 0) {
          if (b === 0) {
            return new Complex(Math.sqrt(a), 0);
          }
          re = 0.5 * Math.sqrt(2 * (r + a));
        } else {
          re = Math.abs(b) / Math.sqrt(2 * (r - a));
        }
        if (a <= 0) {
          im = 0.5 * Math.sqrt(2 * (r - a));
        } else {
          im = Math.abs(b) / Math.sqrt(2 * (r + a));
        }
        return new Complex(re, b < 0 ? -im : im);
      },
      exp: function() {
        var tmp = Math.exp(this["re"]);
        if (this["im"] === 0) {
        }
        return new Complex(tmp * Math.cos(this["im"]), tmp * Math.sin(this["im"]));
      },
      expm1: function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex(Math.expm1(a) * Math.cos(b) + cosm1(b), Math.exp(a) * Math.sin(b));
      },
      log: function() {
        var a = this["re"];
        var b = this["im"];
        if (b === 0 && a > 0) {
        }
        return new Complex(logHypot(a, b), Math.atan2(b, a));
      },
      abs: function() {
        return hypot2(this["re"], this["im"]);
      },
      arg: function() {
        return Math.atan2(this["im"], this["re"]);
      },
      sin: function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex(Math.sin(a) * cosh3(b), Math.cos(a) * sinh3(b));
      },
      cos: function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex(Math.cos(a) * cosh3(b), -Math.sin(a) * sinh3(b));
      },
      tan: function() {
        var a = 2 * this["re"];
        var b = 2 * this["im"];
        var d = Math.cos(a) + cosh3(b);
        return new Complex(Math.sin(a) / d, sinh3(b) / d);
      },
      cot: function() {
        var a = 2 * this["re"];
        var b = 2 * this["im"];
        var d = Math.cos(a) - cosh3(b);
        return new Complex(-Math.sin(a) / d, sinh3(b) / d);
      },
      sec: function() {
        var a = this["re"];
        var b = this["im"];
        var d = 0.5 * cosh3(2 * b) + 0.5 * Math.cos(2 * a);
        return new Complex(Math.cos(a) * cosh3(b) / d, Math.sin(a) * sinh3(b) / d);
      },
      csc: function() {
        var a = this["re"];
        var b = this["im"];
        var d = 0.5 * cosh3(2 * b) - 0.5 * Math.cos(2 * a);
        return new Complex(Math.sin(a) * cosh3(b) / d, -Math.cos(a) * sinh3(b) / d);
      },
      asin: function() {
        var a = this["re"];
        var b = this["im"];
        var t1 = new Complex(b * b - a * a + 1, -2 * a * b)["sqrt"]();
        var t2 = new Complex(t1["re"] - b, t1["im"] + a)["log"]();
        return new Complex(t2["im"], -t2["re"]);
      },
      acos: function() {
        var a = this["re"];
        var b = this["im"];
        var t1 = new Complex(b * b - a * a + 1, -2 * a * b)["sqrt"]();
        var t2 = new Complex(t1["re"] - b, t1["im"] + a)["log"]();
        return new Complex(Math.PI / 2 - t2["im"], t2["re"]);
      },
      atan: function() {
        var a = this["re"];
        var b = this["im"];
        if (a === 0) {
          if (b === 1) {
            return new Complex(0, Infinity);
          }
          if (b === -1) {
            return new Complex(0, -Infinity);
          }
        }
        var d = a * a + (1 - b) * (1 - b);
        var t1 = new Complex((1 - b * b - a * a) / d, -2 * a / d).log();
        return new Complex(-0.5 * t1["im"], 0.5 * t1["re"]);
      },
      acot: function() {
        var a = this["re"];
        var b = this["im"];
        if (b === 0) {
          return new Complex(Math.atan2(1, a), 0);
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex(a / d, -b / d).atan() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).atan();
      },
      asec: function() {
        var a = this["re"];
        var b = this["im"];
        if (a === 0 && b === 0) {
          return new Complex(0, Infinity);
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex(a / d, -b / d).acos() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).acos();
      },
      acsc: function() {
        var a = this["re"];
        var b = this["im"];
        if (a === 0 && b === 0) {
          return new Complex(Math.PI / 2, Infinity);
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex(a / d, -b / d).asin() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).asin();
      },
      sinh: function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex(sinh3(a) * Math.cos(b), cosh3(a) * Math.sin(b));
      },
      cosh: function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex(cosh3(a) * Math.cos(b), sinh3(a) * Math.sin(b));
      },
      tanh: function() {
        var a = 2 * this["re"];
        var b = 2 * this["im"];
        var d = cosh3(a) + Math.cos(b);
        return new Complex(sinh3(a) / d, Math.sin(b) / d);
      },
      coth: function() {
        var a = 2 * this["re"];
        var b = 2 * this["im"];
        var d = cosh3(a) - Math.cos(b);
        return new Complex(sinh3(a) / d, -Math.sin(b) / d);
      },
      csch: function() {
        var a = this["re"];
        var b = this["im"];
        var d = Math.cos(2 * b) - cosh3(2 * a);
        return new Complex(-2 * sinh3(a) * Math.cos(b) / d, 2 * cosh3(a) * Math.sin(b) / d);
      },
      sech: function() {
        var a = this["re"];
        var b = this["im"];
        var d = Math.cos(2 * b) + cosh3(2 * a);
        return new Complex(2 * cosh3(a) * Math.cos(b) / d, -2 * sinh3(a) * Math.sin(b) / d);
      },
      asinh: function() {
        var tmp = this["im"];
        this["im"] = -this["re"];
        this["re"] = tmp;
        var res = this["asin"]();
        this["re"] = -this["im"];
        this["im"] = tmp;
        tmp = res["re"];
        res["re"] = -res["im"];
        res["im"] = tmp;
        return res;
      },
      acosh: function() {
        var res = this["acos"]();
        if (res["im"] <= 0) {
          var tmp = res["re"];
          res["re"] = -res["im"];
          res["im"] = tmp;
        } else {
          var tmp = res["im"];
          res["im"] = -res["re"];
          res["re"] = tmp;
        }
        return res;
      },
      atanh: function() {
        var a = this["re"];
        var b = this["im"];
        var noIM = a > 1 && b === 0;
        var oneMinus = 1 - a;
        var onePlus = 1 + a;
        var d = oneMinus * oneMinus + b * b;
        var x = d !== 0 ? new Complex((onePlus * oneMinus - b * b) / d, (b * oneMinus + onePlus * b) / d) : new Complex(a !== -1 ? a / 0 : 0, b !== 0 ? b / 0 : 0);
        var temp = x["re"];
        x["re"] = logHypot(x["re"], x["im"]) / 2;
        x["im"] = Math.atan2(x["im"], temp) / 2;
        if (noIM) {
          x["im"] = -x["im"];
        }
        return x;
      },
      acoth: function() {
        var a = this["re"];
        var b = this["im"];
        if (a === 0 && b === 0) {
          return new Complex(0, Math.PI / 2);
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex(a / d, -b / d).atanh() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).atanh();
      },
      acsch: function() {
        var a = this["re"];
        var b = this["im"];
        if (b === 0) {
          return new Complex(a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity, 0);
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex(a / d, -b / d).asinh() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).asinh();
      },
      asech: function() {
        var a = this["re"];
        var b = this["im"];
        if (this["isZero"]()) {
          return Complex["INFINITY"];
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex(a / d, -b / d).acosh() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).acosh();
      },
      inverse: function() {
        if (this["isZero"]()) {
          return Complex["INFINITY"];
        }
        if (this["isInfinite"]()) {
          return Complex["ZERO"];
        }
        var a = this["re"];
        var b = this["im"];
        var d = a * a + b * b;
        return new Complex(a / d, -b / d);
      },
      conjugate: function() {
        return new Complex(this["re"], -this["im"]);
      },
      neg: function() {
        return new Complex(-this["re"], -this["im"]);
      },
      ceil: function(places) {
        places = Math.pow(10, places || 0);
        return new Complex(Math.ceil(this["re"] * places) / places, Math.ceil(this["im"] * places) / places);
      },
      floor: function(places) {
        places = Math.pow(10, places || 0);
        return new Complex(Math.floor(this["re"] * places) / places, Math.floor(this["im"] * places) / places);
      },
      round: function(places) {
        places = Math.pow(10, places || 0);
        return new Complex(Math.round(this["re"] * places) / places, Math.round(this["im"] * places) / places);
      },
      equals: function(a, b) {
        var z2 = new Complex(a, b);
        return Math.abs(z2["re"] - this["re"]) <= Complex["EPSILON"] && Math.abs(z2["im"] - this["im"]) <= Complex["EPSILON"];
      },
      clone: function() {
        return new Complex(this["re"], this["im"]);
      },
      toString: function() {
        var a = this["re"];
        var b = this["im"];
        var ret = "";
        if (this["isNaN"]()) {
          return "NaN";
        }
        if (this["isInfinite"]()) {
          return "Infinity";
        }
        if (Math.abs(a) < Complex["EPSILON"]) {
          a = 0;
        }
        if (Math.abs(b) < Complex["EPSILON"]) {
          b = 0;
        }
        if (b === 0) {
          return ret + a;
        }
        if (a !== 0) {
          ret += a;
          ret += " ";
          if (b < 0) {
            b = -b;
            ret += "-";
          } else {
            ret += "+";
          }
          ret += " ";
        } else if (b < 0) {
          b = -b;
          ret += "-";
        }
        if (b !== 1) {
          ret += b;
        }
        return ret + "i";
      },
      toVector: function() {
        return [this["re"], this["im"]];
      },
      valueOf: function() {
        if (this["im"] === 0) {
          return this["re"];
        }
        return null;
      },
      isNaN: function() {
        return isNaN(this["re"]) || isNaN(this["im"]);
      },
      isZero: function() {
        return this["im"] === 0 && this["re"] === 0;
      },
      isFinite: function() {
        return isFinite(this["re"]) && isFinite(this["im"]);
      },
      isInfinite: function() {
        return !(this["isNaN"]() || this["isFinite"]());
      }
    };
    Complex["ZERO"] = new Complex(0, 0);
    Complex["ONE"] = new Complex(1, 0);
    Complex["I"] = new Complex(0, 1);
    Complex["PI"] = new Complex(Math.PI, 0);
    Complex["E"] = new Complex(Math.E, 0);
    Complex["INFINITY"] = new Complex(Infinity, Infinity);
    Complex["NAN"] = new Complex(NaN, NaN);
    Complex["EPSILON"] = 0.000000000000001;
    if (typeof define === "function" && define["amd"]) {
      define([], function() {
        return Complex;
      });
    } else if (typeof exports === "object") {
      Object.defineProperty(Complex, "__esModule", { value: true });
      Complex["default"] = Complex;
      Complex["Complex"] = Complex;
      module["exports"] = Complex;
    } else {
      root["Complex"] = Complex;
    }
  })(exports);
});

// ../../node_modules/mathjs/node_modules/fraction.js/fraction.js
var require_fraction = __commonJS((exports, module) => {
  (function(root) {
    var MAX_CYCLE_LEN = 2000;
    var P2 = {
      s: 1,
      n: 0,
      d: 1
    };
    function assign2(n, s) {
      if (isNaN(n = parseInt(n, 10))) {
        throw Fraction["InvalidParameter"];
      }
      return n * s;
    }
    function newFraction(n, d) {
      if (d === 0) {
        throw Fraction["DivisionByZero"];
      }
      var f = Object.create(Fraction.prototype);
      f["s"] = n < 0 ? -1 : 1;
      n = n < 0 ? -n : n;
      var a = gcd(n, d);
      f["n"] = n / a;
      f["d"] = d / a;
      return f;
    }
    function factorize(num) {
      var factors = {};
      var n = num;
      var i = 2;
      var s = 4;
      while (s <= n) {
        while (n % i === 0) {
          n /= i;
          factors[i] = (factors[i] || 0) + 1;
        }
        s += 1 + 2 * i++;
      }
      if (n !== num) {
        if (n > 1)
          factors[n] = (factors[n] || 0) + 1;
      } else {
        factors[num] = (factors[num] || 0) + 1;
      }
      return factors;
    }
    var parse = function(p1, p2) {
      var n = 0, d = 1, s = 1;
      var v = 0, w = 0, x = 0, y = 1, z2 = 1;
      var A = 0, B = 1;
      var C = 1, D = 1;
      var N = 1e7;
      var M;
      if (p1 === undefined || p1 === null) {
      } else if (p2 !== undefined) {
        n = p1;
        d = p2;
        s = n * d;
        if (n % 1 !== 0 || d % 1 !== 0) {
          throw Fraction["NonIntegerParameter"];
        }
      } else
        switch (typeof p1) {
          case "object": {
            if ("d" in p1 && "n" in p1) {
              n = p1["n"];
              d = p1["d"];
              if ("s" in p1)
                n *= p1["s"];
            } else if (0 in p1) {
              n = p1[0];
              if (1 in p1)
                d = p1[1];
            } else {
              throw Fraction["InvalidParameter"];
            }
            s = n * d;
            break;
          }
          case "number": {
            if (p1 < 0) {
              s = p1;
              p1 = -p1;
            }
            if (p1 % 1 === 0) {
              n = p1;
            } else if (p1 > 0) {
              if (p1 >= 1) {
                z2 = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                p1 /= z2;
              }
              while (B <= N && D <= N) {
                M = (A + C) / (B + D);
                if (p1 === M) {
                  if (B + D <= N) {
                    n = A + C;
                    d = B + D;
                  } else if (D > B) {
                    n = C;
                    d = D;
                  } else {
                    n = A;
                    d = B;
                  }
                  break;
                } else {
                  if (p1 > M) {
                    A += C;
                    B += D;
                  } else {
                    C += A;
                    D += B;
                  }
                  if (B > N) {
                    n = C;
                    d = D;
                  } else {
                    n = A;
                    d = B;
                  }
                }
              }
              n *= z2;
            } else if (isNaN(p1) || isNaN(p2)) {
              d = n = NaN;
            }
            break;
          }
          case "string": {
            B = p1.match(/\d+|./g);
            if (B === null)
              throw Fraction["InvalidParameter"];
            if (B[A] === "-") {
              s = -1;
              A++;
            } else if (B[A] === "+") {
              A++;
            }
            if (B.length === A + 1) {
              w = assign2(B[A++], s);
            } else if (B[A + 1] === "." || B[A] === ".") {
              if (B[A] !== ".") {
                v = assign2(B[A++], s);
              }
              A++;
              if (A + 1 === B.length || B[A + 1] === "(" && B[A + 3] === ")" || B[A + 1] === "'" && B[A + 3] === "'") {
                w = assign2(B[A], s);
                y = Math.pow(10, B[A].length);
                A++;
              }
              if (B[A] === "(" && B[A + 2] === ")" || B[A] === "'" && B[A + 2] === "'") {
                x = assign2(B[A + 1], s);
                z2 = Math.pow(10, B[A + 1].length) - 1;
                A += 3;
              }
            } else if (B[A + 1] === "/" || B[A + 1] === ":") {
              w = assign2(B[A], s);
              y = assign2(B[A + 2], 1);
              A += 3;
            } else if (B[A + 3] === "/" && B[A + 1] === " ") {
              v = assign2(B[A], s);
              w = assign2(B[A + 2], s);
              y = assign2(B[A + 4], 1);
              A += 5;
            }
            if (B.length <= A) {
              d = y * z2;
              s = n = x + d * v + z2 * w;
              break;
            }
          }
          default:
            throw Fraction["InvalidParameter"];
        }
      if (d === 0) {
        throw Fraction["DivisionByZero"];
      }
      P2["s"] = s < 0 ? -1 : 1;
      P2["n"] = Math.abs(n);
      P2["d"] = Math.abs(d);
    };
    function modpow(b, e, m) {
      var r = 1;
      for (;e > 0; b = b * b % m, e >>= 1) {
        if (e & 1) {
          r = r * b % m;
        }
      }
      return r;
    }
    function cycleLen(n, d) {
      for (;d % 2 === 0; d /= 2) {
      }
      for (;d % 5 === 0; d /= 5) {
      }
      if (d === 1)
        return 0;
      var rem = 10 % d;
      var t = 1;
      for (;rem !== 1; t++) {
        rem = rem * 10 % d;
        if (t > MAX_CYCLE_LEN)
          return 0;
      }
      return t;
    }
    function cycleStart(n, d, len) {
      var rem1 = 1;
      var rem2 = modpow(10, len, d);
      for (var t = 0;t < 300; t++) {
        if (rem1 === rem2)
          return t;
        rem1 = rem1 * 10 % d;
        rem2 = rem2 * 10 % d;
      }
      return 0;
    }
    function gcd(a, b) {
      if (!a)
        return b;
      if (!b)
        return a;
      while (true) {
        a %= b;
        if (!a)
          return b;
        b %= a;
        if (!b)
          return a;
      }
    }
    function Fraction(a, b) {
      parse(a, b);
      if (this instanceof Fraction) {
        a = gcd(P2["d"], P2["n"]);
        this["s"] = P2["s"];
        this["n"] = P2["n"] / a;
        this["d"] = P2["d"] / a;
      } else {
        return newFraction(P2["s"] * P2["n"], P2["d"]);
      }
    }
    Fraction["DivisionByZero"] = new Error("Division by Zero");
    Fraction["InvalidParameter"] = new Error("Invalid argument");
    Fraction["NonIntegerParameter"] = new Error("Parameters must be integer");
    Fraction.prototype = {
      s: 1,
      n: 0,
      d: 1,
      abs: function() {
        return newFraction(this["n"], this["d"]);
      },
      neg: function() {
        return newFraction(-this["s"] * this["n"], this["d"]);
      },
      add: function(a, b) {
        parse(a, b);
        return newFraction(this["s"] * this["n"] * P2["d"] + P2["s"] * this["d"] * P2["n"], this["d"] * P2["d"]);
      },
      sub: function(a, b) {
        parse(a, b);
        return newFraction(this["s"] * this["n"] * P2["d"] - P2["s"] * this["d"] * P2["n"], this["d"] * P2["d"]);
      },
      mul: function(a, b) {
        parse(a, b);
        return newFraction(this["s"] * P2["s"] * this["n"] * P2["n"], this["d"] * P2["d"]);
      },
      div: function(a, b) {
        parse(a, b);
        return newFraction(this["s"] * P2["s"] * this["n"] * P2["d"], this["d"] * P2["n"]);
      },
      clone: function() {
        return newFraction(this["s"] * this["n"], this["d"]);
      },
      mod: function(a, b) {
        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return new Fraction(NaN);
        }
        if (a === undefined) {
          return newFraction(this["s"] * this["n"] % this["d"], 1);
        }
        parse(a, b);
        if (P2["n"] === 0 && this["d"] === 0) {
          throw Fraction["DivisionByZero"];
        }
        return newFraction(this["s"] * (P2["d"] * this["n"]) % (P2["n"] * this["d"]), P2["d"] * this["d"]);
      },
      gcd: function(a, b) {
        parse(a, b);
        return newFraction(gcd(P2["n"], this["n"]) * gcd(P2["d"], this["d"]), P2["d"] * this["d"]);
      },
      lcm: function(a, b) {
        parse(a, b);
        if (P2["n"] === 0 && this["n"] === 0) {
          return newFraction(0, 1);
        }
        return newFraction(P2["n"] * this["n"], gcd(P2["n"], this["n"]) * gcd(P2["d"], this["d"]));
      },
      ceil: function(places) {
        places = Math.pow(10, places || 0);
        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return new Fraction(NaN);
        }
        return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
      },
      floor: function(places) {
        places = Math.pow(10, places || 0);
        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return new Fraction(NaN);
        }
        return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
      },
      round: function(places) {
        places = Math.pow(10, places || 0);
        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return new Fraction(NaN);
        }
        return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
      },
      inverse: function() {
        return newFraction(this["s"] * this["d"], this["n"]);
      },
      pow: function(a, b) {
        parse(a, b);
        if (P2["d"] === 1) {
          if (P2["s"] < 0) {
            return newFraction(Math.pow(this["s"] * this["d"], P2["n"]), Math.pow(this["n"], P2["n"]));
          } else {
            return newFraction(Math.pow(this["s"] * this["n"], P2["n"]), Math.pow(this["d"], P2["n"]));
          }
        }
        if (this["s"] < 0)
          return null;
        var N = factorize(this["n"]);
        var D = factorize(this["d"]);
        var n = 1;
        var d = 1;
        for (var k in N) {
          if (k === "1")
            continue;
          if (k === "0") {
            n = 0;
            break;
          }
          N[k] *= P2["n"];
          if (N[k] % P2["d"] === 0) {
            N[k] /= P2["d"];
          } else
            return null;
          n *= Math.pow(k, N[k]);
        }
        for (var k in D) {
          if (k === "1")
            continue;
          D[k] *= P2["n"];
          if (D[k] % P2["d"] === 0) {
            D[k] /= P2["d"];
          } else
            return null;
          d *= Math.pow(k, D[k]);
        }
        if (P2["s"] < 0) {
          return newFraction(d, n);
        }
        return newFraction(n, d);
      },
      equals: function(a, b) {
        parse(a, b);
        return this["s"] * this["n"] * P2["d"] === P2["s"] * P2["n"] * this["d"];
      },
      compare: function(a, b) {
        parse(a, b);
        var t = this["s"] * this["n"] * P2["d"] - P2["s"] * P2["n"] * this["d"];
        return (0 < t) - (t < 0);
      },
      simplify: function(eps) {
        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return this;
        }
        eps = eps || 0.001;
        var thisABS = this["abs"]();
        var cont = thisABS["toContinued"]();
        for (var i = 1;i < cont.length; i++) {
          var s = newFraction(cont[i - 1], 1);
          for (var k = i - 2;k >= 0; k--) {
            s = s["inverse"]()["add"](cont[k]);
          }
          if (s["sub"](thisABS)["abs"]().valueOf() < eps) {
            return s["mul"](this["s"]);
          }
        }
        return this;
      },
      divisible: function(a, b) {
        parse(a, b);
        return !(!(P2["n"] * this["d"]) || this["n"] * P2["d"] % (P2["n"] * this["d"]));
      },
      valueOf: function() {
        return this["s"] * this["n"] / this["d"];
      },
      toFraction: function(excludeWhole) {
        var whole, str = "";
        var n = this["n"];
        var d = this["d"];
        if (this["s"] < 0) {
          str += "-";
        }
        if (d === 1) {
          str += n;
        } else {
          if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
            str += whole;
            str += " ";
            n %= d;
          }
          str += n;
          str += "/";
          str += d;
        }
        return str;
      },
      toLatex: function(excludeWhole) {
        var whole, str = "";
        var n = this["n"];
        var d = this["d"];
        if (this["s"] < 0) {
          str += "-";
        }
        if (d === 1) {
          str += n;
        } else {
          if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
            str += whole;
            n %= d;
          }
          str += "\\frac{";
          str += n;
          str += "}{";
          str += d;
          str += "}";
        }
        return str;
      },
      toContinued: function() {
        var t;
        var a = this["n"];
        var b = this["d"];
        var res = [];
        if (isNaN(a) || isNaN(b)) {
          return res;
        }
        do {
          res.push(Math.floor(a / b));
          t = a % b;
          a = b;
          b = t;
        } while (a !== 1);
        return res;
      },
      toString: function(dec) {
        var N = this["n"];
        var D = this["d"];
        if (isNaN(N) || isNaN(D)) {
          return "NaN";
        }
        dec = dec || 15;
        var cycLen = cycleLen(N, D);
        var cycOff = cycleStart(N, D, cycLen);
        var str = this["s"] < 0 ? "-" : "";
        str += N / D | 0;
        N %= D;
        N *= 10;
        if (N)
          str += ".";
        if (cycLen) {
          for (var i = cycOff;i--; ) {
            str += N / D | 0;
            N %= D;
            N *= 10;
          }
          str += "(";
          for (var i = cycLen;i--; ) {
            str += N / D | 0;
            N %= D;
            N *= 10;
          }
          str += ")";
        } else {
          for (var i = dec;N && i--; ) {
            str += N / D | 0;
            N %= D;
            N *= 10;
          }
        }
        return str;
      }
    };
    if (typeof define === "function" && define["amd"]) {
      define([], function() {
        return Fraction;
      });
    } else if (typeof exports === "object") {
      Object.defineProperty(Fraction, "__esModule", { value: true });
      Fraction["default"] = Fraction;
      Fraction["Fraction"] = Fraction;
      module["exports"] = Fraction;
    } else {
      root["Fraction"] = Fraction;
    }
  })(exports);
});

// ../../node_modules/javascript-natural-sort/naturalSort.js
var require_naturalSort = __commonJS((exports, module) => {
  module.exports = function naturalSort(a, b) {
    var re = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi, sre = /(^[ ]*|[ ]*$)/g, dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, hre = /^0x[0-9a-f]+$/i, ore = /^0/, i = function(s) {
      return naturalSort.insensitive && ("" + s).toLowerCase() || "" + s;
    }, x = i(a).replace(sre, "") || "", y = i(b).replace(sre, "") || "", xN = x.replace(re, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), yN = y.replace(re, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), xD = parseInt(x.match(hre), 16) || xN.length !== 1 && x.match(dre) && Date.parse(x), yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null, oFxNcL, oFyNcL;
    if (yD) {
      if (xD < yD) {
        return -1;
      } else if (xD > yD) {
        return 1;
      }
    }
    for (var cLoc = 0, numS = Math.max(xN.length, yN.length);cLoc < numS; cLoc++) {
      oFxNcL = !(xN[cLoc] || "").match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
      oFyNcL = !(yN[cLoc] || "").match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
      if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
        return isNaN(oFxNcL) ? 1 : -1;
      } else if (typeof oFxNcL !== typeof oFyNcL) {
        oFxNcL += "";
        oFyNcL += "";
      }
      if (oFxNcL < oFyNcL) {
        return -1;
      }
      if (oFxNcL > oFyNcL) {
        return 1;
      }
    }
    return 0;
  };
});

// ../../node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS((exports, module) => {
  var _typeof = function(obj) {
    "@babel/helpers - typeof";
    return module.exports = _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(obj);
  };
  module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// ../../node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS((exports, module) => {
  var _toPrimitive = function(input, hint) {
    if (_typeof(input) !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  };
  var _typeof = require_typeof()["default"];
  module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// ../../node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS((exports, module) => {
  var _toPropertyKey = function(arg) {
    var key = toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  };
  var _typeof = require_typeof()["default"];
  var toPrimitive = require_toPrimitive();
  module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// ../../node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS((exports, module) => {
  var _defineProperty = function(obj, key, value) {
    key = toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  };
  var toPropertyKey = require_toPropertyKey();
  module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// ../../node_modules/escape-latex/dist/index.js
var require_dist2 = __commonJS((exports, module) => {
  var _extends3 = Object.assign || function(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var defaultEscapes = {
    "{": "\\{",
    "}": "\\}",
    "\\": "\\textbackslash{}",
    "#": "\\#",
    $: "\\$",
    "%": "\\%",
    "&": "\\&",
    "^": "\\textasciicircum{}",
    _: "\\_",
    "~": "\\textasciitilde{}"
  };
  var formatEscapes = {
    "\u2013": "\\--",
    "\u2014": "\\---",
    " ": "~",
    "\t": "\\qquad{}",
    "\r\n": "\\newline{}",
    "\n": "\\newline{}"
  };
  var defaultEscapeMapFn = function defaultEscapeMapFn(defaultEscapes2, formatEscapes2) {
    return _extends3({}, defaultEscapes2, formatEscapes2);
  };
  module.exports = function(str) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$preserveFormatti = _ref.preserveFormatting, preserveFormatting = _ref$preserveFormatti === undefined ? false : _ref$preserveFormatti, _ref$escapeMapFn = _ref.escapeMapFn, escapeMapFn = _ref$escapeMapFn === undefined ? defaultEscapeMapFn : _ref$escapeMapFn;
    var runningStr = String(str);
    var result = "";
    var escapes = escapeMapFn(_extends3({}, defaultEscapes), preserveFormatting ? _extends3({}, formatEscapes) : {});
    var escapeKeys = Object.keys(escapes);
    var _loop = function _loop() {
      var specialCharFound = false;
      escapeKeys.forEach(function(key, index) {
        if (specialCharFound) {
          return;
        }
        if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {
          result += escapes[escapeKeys[index]];
          runningStr = runningStr.slice(key.length, runningStr.length);
          specialCharFound = true;
        }
      });
      if (!specialCharFound) {
        result += runningStr.slice(0, 1);
        runningStr = runningStr.slice(1, runningStr.length);
      }
    };
    while (runningStr) {
      _loop();
    }
    return result;
  };
});

// ../../node_modules/seedrandom/lib/alea.js
var require_alea = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function Alea(seed) {
      var me = this, mash = Mash();
      me.next = function() {
        var t = 2091639 * me.s0 + me.c * 0.00000000023283064365386963;
        me.s0 = me.s1;
        me.s1 = me.s2;
        return me.s2 = t - (me.c = t | 0);
      };
      me.c = 1;
      me.s0 = mash(" ");
      me.s1 = mash(" ");
      me.s2 = mash(" ");
      me.s0 -= mash(seed);
      if (me.s0 < 0) {
        me.s0 += 1;
      }
      me.s1 -= mash(seed);
      if (me.s1 < 0) {
        me.s1 += 1;
      }
      me.s2 -= mash(seed);
      if (me.s2 < 0) {
        me.s2 += 1;
      }
      mash = null;
    }
    function copy(f, t) {
      t.c = f.c;
      t.s0 = f.s0;
      t.s1 = f.s1;
      t.s2 = f.s2;
      return t;
    }
    function impl(seed, opts) {
      var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
      prng.int32 = function() {
        return xg.next() * 4294967296 | 0;
      };
      prng.double = function() {
        return prng() + (prng() * 2097152 | 0) * 0.00000000000000011102230246251565;
      };
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    function Mash() {
      var n = 4022871197;
      var mash = function(data) {
        data = String(data);
        for (var i2 = 0;i2 < data.length; i2++) {
          n += data.charCodeAt(i2);
          var h2 = 0.02519603282416938 * n;
          n = h2 >>> 0;
          h2 -= n;
          h2 *= n;
          n = h2 >>> 0;
          h2 -= n;
          n += h2 * 4294967296;
        }
        return (n >>> 0) * 0.00000000023283064365386963;
      };
      return mash;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.alea = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// ../../node_modules/seedrandom/lib/xor128.js
var require_xor128 = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.next = function() {
        var t = me.x ^ me.x << 11;
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
      };
      if (seed === (seed | 0)) {
        me.x = seed;
      } else {
        strseed += seed;
      }
      for (var k = 0;k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }
    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xor128 = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// ../../node_modules/seedrandom/lib/xorwow.js
var require_xorwow = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.next = function() {
        var t = me.x ^ me.x >>> 2;
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        me.w = me.v;
        return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
      };
      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.v = 0;
      if (seed === (seed | 0)) {
        me.x = seed;
      } else {
        strseed += seed;
      }
      for (var k = 0;k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        if (k == strseed.length) {
          me.d = me.x << 10 ^ me.x >>> 4;
        }
        me.next();
      }
    }
    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      t.v = f.v;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xorwow = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// ../../node_modules/seedrandom/lib/xorshift7.js
var require_xorshift7 = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this;
      me.next = function() {
        var { x: X, i: i2 } = me, t, v, w;
        t = X[i2];
        t ^= t >>> 7;
        v = t ^ t << 24;
        t = X[i2 + 1 & 7];
        v ^= t ^ t >>> 10;
        t = X[i2 + 3 & 7];
        v ^= t ^ t >>> 3;
        t = X[i2 + 4 & 7];
        v ^= t ^ t << 7;
        t = X[i2 + 7 & 7];
        t = t ^ t << 13;
        v ^= t ^ t << 9;
        X[i2] = v;
        me.i = i2 + 1 & 7;
        return v;
      };
      function init(me2, seed2) {
        var j, w, X = [];
        if (seed2 === (seed2 | 0)) {
          w = X[0] = seed2;
        } else {
          seed2 = "" + seed2;
          for (j = 0;j < seed2.length; ++j) {
            X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
          }
        }
        while (X.length < 8)
          X.push(0);
        for (j = 0;j < 8 && X[j] === 0; ++j)
          ;
        if (j == 8)
          w = X[7] = -1;
        else
          w = X[j];
        me2.x = X;
        me2.i = 0;
        for (j = 256;j > 0; --j) {
          me2.next();
        }
      }
      init(me, seed);
    }
    function copy(f, t) {
      t.x = f.x.slice();
      t.i = f.i;
      return t;
    }
    function impl(seed, opts) {
      if (seed == null)
        seed = +new Date;
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.x)
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xorshift7 = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// ../../node_modules/seedrandom/lib/xor4096.js
var require_xor4096 = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this;
      me.next = function() {
        var { w, X, i: i2 } = me, t, v;
        me.w = w = w + 1640531527 | 0;
        v = X[i2 + 34 & 127];
        t = X[i2 = i2 + 1 & 127];
        v ^= v << 13;
        t ^= t << 17;
        v ^= v >>> 15;
        t ^= t >>> 12;
        v = X[i2] = v ^ t;
        me.i = i2;
        return v + (w ^ w >>> 16) | 0;
      };
      function init(me2, seed2) {
        var t, v, i2, j, w, X = [], limit = 128;
        if (seed2 === (seed2 | 0)) {
          v = seed2;
          seed2 = null;
        } else {
          seed2 = seed2 + "\0";
          v = 0;
          limit = Math.max(limit, seed2.length);
        }
        for (i2 = 0, j = -32;j < limit; ++j) {
          if (seed2)
            v ^= seed2.charCodeAt((j + 32) % seed2.length);
          if (j === 0)
            w = v;
          v ^= v << 10;
          v ^= v >>> 15;
          v ^= v << 4;
          v ^= v >>> 13;
          if (j >= 0) {
            w = w + 1640531527 | 0;
            t = X[j & 127] ^= v + w;
            i2 = t == 0 ? i2 + 1 : 0;
          }
        }
        if (i2 >= 128) {
          X[(seed2 && seed2.length || 0) & 127] = -1;
        }
        i2 = 127;
        for (j = 4 * 128;j > 0; --j) {
          v = X[i2 + 34 & 127];
          t = X[i2 = i2 + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          X[i2] = v ^ t;
        }
        me2.w = w;
        me2.X = X;
        me2.i = i2;
      }
      init(me, seed);
    }
    function copy(f, t) {
      t.i = f.i;
      t.w = f.w;
      t.X = f.X.slice();
      return t;
    }
    function impl(seed, opts) {
      if (seed == null)
        seed = +new Date;
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.X)
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xor4096 = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// ../../node_modules/seedrandom/lib/tychei.js
var require_tychei = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.next = function() {
        var { b, c, d, a } = me;
        b = b << 25 ^ b >>> 7 ^ c;
        c = c - d | 0;
        d = d << 24 ^ d >>> 8 ^ a;
        a = a - b | 0;
        me.b = b = b << 20 ^ b >>> 12 ^ c;
        me.c = c = c - d | 0;
        me.d = d << 16 ^ c >>> 16 ^ a;
        return me.a = a - b | 0;
      };
      me.a = 0;
      me.b = 0;
      me.c = 2654435769 | 0;
      me.d = 1367130551;
      if (seed === Math.floor(seed)) {
        me.a = seed / 4294967296 | 0;
        me.b = seed | 0;
      } else {
        strseed += seed;
      }
      for (var k = 0;k < strseed.length + 20; k++) {
        me.b ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }
    function copy(f, t) {
      t.a = f.a;
      t.b = f.b;
      t.c = f.c;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.tychei = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// ../../node_modules/seedrandom/seedrandom.js
var require_seedrandom = __commonJS((exports, module) => {
  (function(global2, pool, math) {
    var width = 256, chunks = 6, digits2 = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits2), overflow = significance * 2, mask = width - 1, nodecrypto;
    function seedrandom(seed, options, callback) {
      var key = [];
      options = options == true ? { entropy: true } : options || {};
      var shortseed = mixkey(flatten3(options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed, 3), key);
      var arc4 = new ARC4(key);
      var prng = function() {
        var n = arc4.g(chunks), d = startdenom, x = 0;
        while (n < significance) {
          n = (n + x) * width;
          d *= width;
          x = arc4.g(1);
        }
        while (n >= overflow) {
          n /= 2;
          d /= 2;
          x >>>= 1;
        }
        return (n + x) / d;
      };
      prng.int32 = function() {
        return arc4.g(4) | 0;
      };
      prng.quick = function() {
        return arc4.g(4) / 4294967296;
      };
      prng.double = prng;
      mixkey(tostring(arc4.S), pool);
      return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
        if (state) {
          if (state.S) {
            copy(state, arc4);
          }
          prng2.state = function() {
            return copy(arc4, {});
          };
        }
        if (is_math_call) {
          math[rngname] = prng2;
          return seed2;
        } else
          return prng2;
      })(prng, shortseed, "globalThis" in options ? options.globalThis : this == math, options.state);
    }
    function ARC4(key) {
      var t, keylen = key.length, me = this, i2 = 0, j = me.i = me.j = 0, s = me.S = [];
      if (!keylen) {
        key = [keylen++];
      }
      while (i2 < width) {
        s[i2] = i2++;
      }
      for (i2 = 0;i2 < width; i2++) {
        s[i2] = s[j = mask & j + key[i2 % keylen] + (t = s[i2])];
        s[j] = t;
      }
      (me.g = function(count2) {
        var t2, r = 0, i3 = me.i, j2 = me.j, s2 = me.S;
        while (count2--) {
          t2 = s2[i3 = mask & i3 + 1];
          r = r * width + s2[mask & (s2[i3] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
        }
        me.i = i3;
        me.j = j2;
        return r;
      })(width);
    }
    function copy(f, t) {
      t.i = f.i;
      t.j = f.j;
      t.S = f.S.slice();
      return t;
    }
    function flatten3(obj, depth) {
      var result = [], typ = typeof obj, prop;
      if (depth && typ == "object") {
        for (prop in obj) {
          try {
            result.push(flatten3(obj[prop], depth - 1));
          } catch (e3) {
          }
        }
      }
      return result.length ? result : typ == "string" ? obj : obj + "\0";
    }
    function mixkey(seed, key) {
      var stringseed = seed + "", smear, j = 0;
      while (j < stringseed.length) {
        key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
      }
      return tostring(key);
    }
    function autoseed() {
      try {
        var out;
        if (nodecrypto && (out = nodecrypto.randomBytes)) {
          out = out(width);
        } else {
          out = new Uint8Array(width);
          (global2.crypto || global2.msCrypto).getRandomValues(out);
        }
        return tostring(out);
      } catch (e3) {
        var browser = global2.navigator, plugins = browser && browser.plugins;
        return [+new Date, global2, plugins, global2.screen, tostring(pool)];
      }
    }
    function tostring(a) {
      return String.fromCharCode.apply(0, a);
    }
    mixkey(math.random(), pool);
    if (typeof module == "object" && exports) {
      module.exports = seedrandom;
      try {
        nodecrypto = __require("crypto");
      } catch (ex) {
      }
    } else if (typeof define == "function" && define.amd) {
      define(function() {
        return seedrandom;
      });
    } else {
      math["seed" + rngname] = seedrandom;
    }
  })(typeof self !== "undefined" ? self : exports, [], Math);
});

// ../../node_modules/seedrandom/index.js
var require_seedrandom2 = __commonJS((exports, module) => {
  var alea = require_alea();
  var xor128 = require_xor128();
  var xorwow = require_xorwow();
  var xorshift7 = require_xorshift7();
  var xor4096 = require_xor4096();
  var tychei = require_tychei();
  var sr = require_seedrandom();
  sr.alea = alea;
  sr.xor128 = xor128;
  sr.xorwow = xorwow;
  sr.xorshift7 = xorshift7;
  sr.xor4096 = xor4096;
  sr.tychei = tychei;
  module.exports = sr;
});

// ../../node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS((exports) => {
  var flatten4 = function(items) {
    return items.reduce((collection47, item) => [].concat(collection47, item), []);
  };
  var splitWhen = function(items, predicate) {
    const result = [[]];
    let groupIndex = 0;
    for (const item of items) {
      if (predicate(item)) {
        groupIndex++;
        result[groupIndex] = [];
      } else {
        result[groupIndex].push(item);
      }
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.splitWhen = exports.flatten = undefined;
  exports.flatten = flatten4;
  exports.splitWhen = splitWhen;
});

// ../../node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS((exports) => {
  var isEnoentCodeError = function(error) {
    return error.code === "ENOENT";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isEnoentCodeError = undefined;
  exports.isEnoentCodeError = isEnoentCodeError;
});

// ../../node_modules/fast-glob/out/utils/fs.js
var require_fs = __commonJS((exports) => {
  var createDirentFromStats = function(name302, stats) {
    return new DirentFromStats(name302, stats);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDirentFromStats = undefined;

  class DirentFromStats {
    constructor(name302, stats) {
      this.name = name302;
      this.isBlockDevice = stats.isBlockDevice.bind(stats);
      this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
      this.isDirectory = stats.isDirectory.bind(stats);
      this.isFIFO = stats.isFIFO.bind(stats);
      this.isFile = stats.isFile.bind(stats);
      this.isSocket = stats.isSocket.bind(stats);
      this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
  }
  exports.createDirentFromStats = createDirentFromStats;
});

// ../../node_modules/fast-glob/out/utils/path.js
var require_path = __commonJS((exports) => {
  var unixify = function(filepath) {
    return filepath.replace(/\\/g, "/");
  };
  var makeAbsolute = function(cwd, filepath) {
    return path.resolve(cwd, filepath);
  };
  var removeLeadingDotSegment = function(entry) {
    if (entry.charAt(0) === ".") {
      const secondCharactery = entry.charAt(1);
      if (secondCharactery === "/" || secondCharactery === "\\") {
        return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
      }
    }
    return entry;
  };
  var escapeWindowsPath = function(pattern) {
    return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
  };
  var escapePosixPath = function(pattern) {
    return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
  };
  var convertWindowsPathToPattern = function(filepath) {
    return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, "//$1").replace(WINDOWS_BACKSLASHES_RE, "/");
  };
  var convertPosixPathToPattern = function(filepath) {
    return escapePosixPath(filepath);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.convertPosixPathToPattern = exports.convertWindowsPathToPattern = exports.convertPathToPattern = exports.escapePosixPath = exports.escapeWindowsPath = exports.escape = exports.removeLeadingDotSegment = exports.makeAbsolute = exports.unixify = undefined;
  var os = __require("os");
  var path = __require("path");
  var IS_WINDOWS_PLATFORM = os.platform() === "win32";
  var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
  var POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g;
  var WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([(){}]|^!|[!+@](?=\())/g;
  var DOS_DEVICE_PATH_RE = /^\\\\([.?])/;
  var WINDOWS_BACKSLASHES_RE = /\\(?![!()+@{}])/g;
  exports.unixify = unixify;
  exports.makeAbsolute = makeAbsolute;
  exports.removeLeadingDotSegment = removeLeadingDotSegment;
  exports.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
  exports.escapeWindowsPath = escapeWindowsPath;
  exports.escapePosixPath = escapePosixPath;
  exports.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
  exports.convertWindowsPathToPattern = convertWindowsPathToPattern;
  exports.convertPosixPathToPattern = convertPosixPathToPattern;
});

// ../../node_modules/is-extglob/index.js
var require_is_extglob = __commonJS((exports, module) => {
  /*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  module.exports = function isExtglob(str) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    var match;
    while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
      if (match[2])
        return true;
      str = str.slice(match.index + match[0].length);
    }
    return false;
  };
});

// ../../node_modules/is-glob/index.js
var require_is_glob = __commonJS((exports, module) => {
  /*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  var isExtglob = require_is_extglob();
  var chars = { "{": "}", "(": ")", "[": "]" };
  var strictCheck = function(str) {
    if (str[0] === "!") {
      return true;
    }
    var index2 = 0;
    var pipeIndex = -2;
    var closeSquareIndex = -2;
    var closeCurlyIndex = -2;
    var closeParenIndex = -2;
    var backSlashIndex = -2;
    while (index2 < str.length) {
      if (str[index2] === "*") {
        return true;
      }
      if (str[index2 + 1] === "?" && /[\].+)]/.test(str[index2])) {
        return true;
      }
      if (closeSquareIndex !== -1 && str[index2] === "[" && str[index2 + 1] !== "]") {
        if (closeSquareIndex < index2) {
          closeSquareIndex = str.indexOf("]", index2);
        }
        if (closeSquareIndex > index2) {
          if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
            return true;
          }
          backSlashIndex = str.indexOf("\\", index2);
          if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
            return true;
          }
        }
      }
      if (closeCurlyIndex !== -1 && str[index2] === "{" && str[index2 + 1] !== "}") {
        closeCurlyIndex = str.indexOf("}", index2);
        if (closeCurlyIndex > index2) {
          backSlashIndex = str.indexOf("\\", index2);
          if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
            return true;
          }
        }
      }
      if (closeParenIndex !== -1 && str[index2] === "(" && str[index2 + 1] === "?" && /[:!=]/.test(str[index2 + 2]) && str[index2 + 3] !== ")") {
        closeParenIndex = str.indexOf(")", index2);
        if (closeParenIndex > index2) {
          backSlashIndex = str.indexOf("\\", index2);
          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
      if (pipeIndex !== -1 && str[index2] === "(" && str[index2 + 1] !== "|") {
        if (pipeIndex < index2) {
          pipeIndex = str.indexOf("|", index2);
        }
        if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
          closeParenIndex = str.indexOf(")", pipeIndex);
          if (closeParenIndex > pipeIndex) {
            backSlashIndex = str.indexOf("\\", pipeIndex);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
      }
      if (str[index2] === "\\") {
        var open = str[index2 + 1];
        index2 += 2;
        var close = chars[open];
        if (close) {
          var n = str.indexOf(close, index2);
          if (n !== -1) {
            index2 = n + 1;
          }
        }
        if (str[index2] === "!") {
          return true;
        }
      } else {
        index2++;
      }
    }
    return false;
  };
  var relaxedCheck = function(str) {
    if (str[0] === "!") {
      return true;
    }
    var index2 = 0;
    while (index2 < str.length) {
      if (/[*?{}()[\]]/.test(str[index2])) {
        return true;
      }
      if (str[index2] === "\\") {
        var open = str[index2 + 1];
        index2 += 2;
        var close = chars[open];
        if (close) {
          var n = str.indexOf(close, index2);
          if (n !== -1) {
            index2 = n + 1;
          }
        }
        if (str[index2] === "!") {
          return true;
        }
      } else {
        index2++;
      }
    }
    return false;
  };
  module.exports = function isGlob(str, options) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    if (isExtglob(str)) {
      return true;
    }
    var check = strictCheck;
    if (options && options.strict === false) {
      check = relaxedCheck;
    }
    return check(str);
  };
});

// ../../node_modules/glob-parent/index.js
var require_glob_parent = __commonJS((exports, module) => {
  var isGlob = require_is_glob();
  var pathPosixDirname = __require("path").posix.dirname;
  var isWin32 = __require("os").platform() === "win32";
  var slash = "/";
  var backslash = /\\/g;
  var enclosure = /[\{\[].*[\}\]]$/;
  var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
  var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
  module.exports = function globParent(str, opts) {
    var options = Object.assign({ flipBackslashes: true }, opts);
    if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
      str = str.replace(backslash, slash);
    }
    if (enclosure.test(str)) {
      str += slash;
    }
    str += "a";
    do {
      str = pathPosixDirname(str);
    } while (isGlob(str) || globby.test(str));
    return str.replace(escaped, "$1");
  };
});

// ../../node_modules/braces/lib/utils.js
var require_utils = __commonJS((exports) => {
  exports.isInteger = (num) => {
    if (typeof num === "number") {
      return Number.isInteger(num);
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isInteger(Number(num));
    }
    return false;
  };
  exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
  exports.exceedsLimit = (min5, max5, step = 1, limit) => {
    if (limit === false)
      return false;
    if (!exports.isInteger(min5) || !exports.isInteger(max5))
      return false;
    return (Number(max5) - Number(min5)) / Number(step) >= limit;
  };
  exports.escapeNode = (block, n = 0, type) => {
    let node = block.nodes[n];
    if (!node)
      return;
    if (type && node.type === type || node.type === "open" || node.type === "close") {
      if (node.escaped !== true) {
        node.value = "\\" + node.value;
        node.escaped = true;
      }
    }
  };
  exports.encloseBrace = (node) => {
    if (node.type !== "brace")
      return false;
    if (node.commas >> 0 + node.ranges >> 0 === 0) {
      node.invalid = true;
      return true;
    }
    return false;
  };
  exports.isInvalidBrace = (block) => {
    if (block.type !== "brace")
      return false;
    if (block.invalid === true || block.dollar)
      return true;
    if (block.commas >> 0 + block.ranges >> 0 === 0) {
      block.invalid = true;
      return true;
    }
    if (block.open !== true || block.close !== true) {
      block.invalid = true;
      return true;
    }
    return false;
  };
  exports.isOpenOrClose = (node) => {
    if (node.type === "open" || node.type === "close") {
      return true;
    }
    return node.open === true || node.close === true;
  };
  exports.reduce = (nodes) => nodes.reduce((acc, node) => {
    if (node.type === "text")
      acc.push(node.value);
    if (node.type === "range")
      node.type = "text";
    return acc;
  }, []);
  exports.flatten = (...args) => {
    const result = [];
    const flat = (arr) => {
      for (let i3 = 0;i3 < arr.length; i3++) {
        let ele = arr[i3];
        Array.isArray(ele) ? flat(ele, result) : ele !== undefined && result.push(ele);
      }
      return result;
    };
    flat(args);
    return result;
  };
});

// ../../node_modules/braces/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var utils19 = require_utils();
  module.exports = (ast, options = {}) => {
    let stringify2 = (node, parent = {}) => {
      let invalidBlock = options.escapeInvalid && utils19.isInvalidBrace(parent);
      let invalidNode = node.invalid === true && options.escapeInvalid === true;
      let output = "";
      if (node.value) {
        if ((invalidBlock || invalidNode) && utils19.isOpenOrClose(node)) {
          return "\\" + node.value;
        }
        return node.value;
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes) {
        for (let child of node.nodes) {
          output += stringify2(child);
        }
      }
      return output;
    };
    return stringify2(ast);
  };
});

// ../../node_modules/is-number/index.js
var require_is_number = __commonJS((exports, module) => {
  /*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   */
  module.exports = function(num) {
    if (typeof num === "number") {
      return num - num === 0;
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
    }
    return false;
  };
});

// ../../node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS((exports, module) => {
  var collatePatterns = function(neg, pos, options) {
    let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
    let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
    let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join("|");
  };
  var splitToRanges = function(min5, max5) {
    let nines = 1;
    let zeros4 = 1;
    let stop = countNines(min5, nines);
    let stops = new Set([max5]);
    while (min5 <= stop && stop <= max5) {
      stops.add(stop);
      nines += 1;
      stop = countNines(min5, nines);
    }
    stop = countZeros(max5 + 1, zeros4) - 1;
    while (min5 < stop && stop <= max5) {
      stops.add(stop);
      zeros4 += 1;
      stop = countZeros(max5 + 1, zeros4) - 1;
    }
    stops = [...stops];
    stops.sort(compare3);
    return stops;
  };
  var rangeToPattern = function(start, stop, options) {
    if (start === stop) {
      return { pattern: start, count: [], digits: 0 };
    }
    let zipped = zip(start, stop);
    let digits2 = zipped.length;
    let pattern = "";
    let count3 = 0;
    for (let i3 = 0;i3 < digits2; i3++) {
      let [startDigit, stopDigit] = zipped[i3];
      if (startDigit === stopDigit) {
        pattern += startDigit;
      } else if (startDigit !== "0" || stopDigit !== "9") {
        pattern += toCharacterClass(startDigit, stopDigit, options);
      } else {
        count3++;
      }
    }
    if (count3) {
      pattern += options.shorthand === true ? "\\d" : "[0-9]";
    }
    return { pattern, count: [count3], digits: digits2 };
  };
  var splitToPatterns = function(min5, max5, tok, options) {
    let ranges = splitToRanges(min5, max5);
    let tokens = [];
    let start = min5;
    let prev;
    for (let i3 = 0;i3 < ranges.length; i3++) {
      let max6 = ranges[i3];
      let obj = rangeToPattern(String(start), String(max6), options);
      let zeros4 = "";
      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
        if (prev.count.length > 1) {
          prev.count.pop();
        }
        prev.count.push(obj.count[0]);
        prev.string = prev.pattern + toQuantifier(prev.count);
        start = max6 + 1;
        continue;
      }
      if (tok.isPadded) {
        zeros4 = padZeros(max6, tok, options);
      }
      obj.string = zeros4 + obj.pattern + toQuantifier(obj.count);
      tokens.push(obj);
      start = max6 + 1;
      prev = obj;
    }
    return tokens;
  };
  var filterPatterns = function(arr, comparison, prefix, intersection, options) {
    let result = [];
    for (let ele of arr) {
      let { string: string31 } = ele;
      if (!intersection && !contains(comparison, "string", string31)) {
        result.push(prefix + string31);
      }
      if (intersection && contains(comparison, "string", string31)) {
        result.push(prefix + string31);
      }
    }
    return result;
  };
  var zip = function(a, b) {
    let arr = [];
    for (let i3 = 0;i3 < a.length; i3++)
      arr.push([a[i3], b[i3]]);
    return arr;
  };
  var compare3 = function(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
  };
  var contains = function(arr, key, val) {
    return arr.some((ele) => ele[key] === val);
  };
  var countNines = function(min5, len) {
    return Number(String(min5).slice(0, -len) + "9".repeat(len));
  };
  var countZeros = function(integer2, zeros4) {
    return integer2 - integer2 % Math.pow(10, zeros4);
  };
  var toQuantifier = function(digits2) {
    let [start = 0, stop = ""] = digits2;
    if (stop || start > 1) {
      return `{${start + (stop ? "," + stop : "")}}`;
    }
    return "";
  };
  var toCharacterClass = function(a, b, options) {
    return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
  };
  var hasPadding = function(str) {
    return /^-?(0+)\d/.test(str);
  };
  var padZeros = function(value, tok, options) {
    if (!tok.isPadded) {
      return value;
    }
    let diff4 = Math.abs(tok.maxLen - String(value).length);
    let relax = options.relaxZeros !== false;
    switch (diff4) {
      case 0:
        return "";
      case 1:
        return relax ? "0?" : "0";
      case 2:
        return relax ? "0{0,2}" : "00";
      default: {
        return relax ? `0{0,${diff4}}` : `0{${diff4}}`;
      }
    }
  };
  /*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   */
  var isNumber2 = require_is_number();
  var toRegexRange = (min5, max5, options) => {
    if (isNumber2(min5) === false) {
      throw new TypeError("toRegexRange: expected the first argument to be a number");
    }
    if (max5 === undefined || min5 === max5) {
      return String(min5);
    }
    if (isNumber2(max5) === false) {
      throw new TypeError("toRegexRange: expected the second argument to be a number.");
    }
    let opts = { relaxZeros: true, ...options };
    if (typeof opts.strictZeros === "boolean") {
      opts.relaxZeros = opts.strictZeros === false;
    }
    let relax = String(opts.relaxZeros);
    let shorthand = String(opts.shorthand);
    let capture = String(opts.capture);
    let wrap = String(opts.wrap);
    let cacheKey = min5 + ":" + max5 + "=" + relax + shorthand + capture + wrap;
    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
      return toRegexRange.cache[cacheKey].result;
    }
    let a = Math.min(min5, max5);
    let b = Math.max(min5, max5);
    if (Math.abs(a - b) === 1) {
      let result = min5 + "|" + max5;
      if (opts.capture) {
        return `(${result})`;
      }
      if (opts.wrap === false) {
        return result;
      }
      return `(?:${result})`;
    }
    let isPadded = hasPadding(min5) || hasPadding(max5);
    let state3 = { min: min5, max: max5, a, b };
    let positives = [];
    let negatives = [];
    if (isPadded) {
      state3.isPadded = isPadded;
      state3.maxLen = String(state3.max).length;
    }
    if (a < 0) {
      let newMin = b < 0 ? Math.abs(b) : 1;
      negatives = splitToPatterns(newMin, Math.abs(a), state3, opts);
      a = state3.a = 0;
    }
    if (b >= 0) {
      positives = splitToPatterns(a, b, state3, opts);
    }
    state3.negatives = negatives;
    state3.positives = positives;
    state3.result = collatePatterns(negatives, positives, opts);
    if (opts.capture === true) {
      state3.result = `(${state3.result})`;
    } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
      state3.result = `(?:${state3.result})`;
    }
    toRegexRange.cache[cacheKey] = state3;
    return state3.result;
  };
  toRegexRange.cache = {};
  toRegexRange.clearCache = () => toRegexRange.cache = {};
  module.exports = toRegexRange;
});

// ../../node_modules/fill-range/index.js
var require_fill_range = __commonJS((exports, module) => {
  /*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  var util4 = __require("util");
  var toRegexRange = require_to_regex_range();
  var isObject2 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  var transform = (toNumber) => {
    return (value) => toNumber === true ? Number(value) : String(value);
  };
  var isValidValue = (value) => {
    return typeof value === "number" || typeof value === "string" && value !== "";
  };
  var isNumber2 = (num) => Number.isInteger(+num);
  var zeros4 = (input) => {
    let value = `${input}`;
    let index2 = -1;
    if (value[0] === "-")
      value = value.slice(1);
    if (value === "0")
      return false;
    while (value[++index2] === "0")
      ;
    return index2 > 0;
  };
  var stringify2 = (start, end, options) => {
    if (typeof start === "string" || typeof end === "string") {
      return true;
    }
    return options.stringify === true;
  };
  var pad = (input, maxLength, toNumber) => {
    if (maxLength > 0) {
      let dash = input[0] === "-" ? "-" : "";
      if (dash)
        input = input.slice(1);
      input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
    }
    if (toNumber === false) {
      return String(input);
    }
    return input;
  };
  var toMaxLen = (input, maxLength) => {
    let negative = input[0] === "-" ? "-" : "";
    if (negative) {
      input = input.slice(1);
      maxLength--;
    }
    while (input.length < maxLength)
      input = "0" + input;
    return negative ? "-" + input : input;
  };
  var toSequence = (parts, options) => {
    parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    let prefix = options.capture ? "" : "?:";
    let positives = "";
    let negatives = "";
    let result;
    if (parts.positives.length) {
      positives = parts.positives.join("|");
    }
    if (parts.negatives.length) {
      negatives = `-(${prefix}${parts.negatives.join("|")})`;
    }
    if (positives && negatives) {
      result = `${positives}|${negatives}`;
    } else {
      result = positives || negatives;
    }
    if (options.wrap) {
      return `(${prefix}${result})`;
    }
    return result;
  };
  var toRange = (a, b, isNumbers, options) => {
    if (isNumbers) {
      return toRegexRange(a, b, { wrap: false, ...options });
    }
    let start = String.fromCharCode(a);
    if (a === b)
      return start;
    let stop = String.fromCharCode(b);
    return `[${start}-${stop}]`;
  };
  var toRegex = (start, end, options) => {
    if (Array.isArray(start)) {
      let wrap = options.wrap === true;
      let prefix = options.capture ? "" : "?:";
      return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
    }
    return toRegexRange(start, end, options);
  };
  var rangeError = (...args) => {
    return new RangeError("Invalid range arguments: " + util4.inspect(...args));
  };
  var invalidRange = (start, end, options) => {
    if (options.strictRanges === true)
      throw rangeError([start, end]);
    return [];
  };
  var invalidStep = (step, options) => {
    if (options.strictRanges === true) {
      throw new TypeError(`Expected step "${step}" to be a number`);
    }
    return [];
  };
  var fillNumbers = (start, end, step = 1, options = {}) => {
    let a = Number(start);
    let b = Number(end);
    if (!Number.isInteger(a) || !Number.isInteger(b)) {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    }
    if (a === 0)
      a = 0;
    if (b === 0)
      b = 0;
    let descending = a > b;
    let startString = String(start);
    let endString = String(end);
    let stepString = String(step);
    step = Math.max(Math.abs(step), 1);
    let padded = zeros4(startString) || zeros4(endString) || zeros4(stepString);
    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
    let toNumber = padded === false && stringify2(start, end, options) === false;
    let format6 = options.transform || transform(toNumber);
    if (options.toRegex && step === 1) {
      return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
    }
    let parts = { negatives: [], positives: [] };
    let push2 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
    let range4 = [];
    let index2 = 0;
    while (descending ? a >= b : a <= b) {
      if (options.toRegex === true && step > 1) {
        push2(a);
      } else {
        range4.push(pad(format6(a, index2), maxLen, toNumber));
      }
      a = descending ? a - step : a + step;
      index2++;
    }
    if (options.toRegex === true) {
      return step > 1 ? toSequence(parts, options) : toRegex(range4, null, { wrap: false, ...options });
    }
    return range4;
  };
  var fillLetters = (start, end, step = 1, options = {}) => {
    if (!isNumber2(start) && start.length > 1 || !isNumber2(end) && end.length > 1) {
      return invalidRange(start, end, options);
    }
    let format6 = options.transform || ((val) => String.fromCharCode(val));
    let a = `${start}`.charCodeAt(0);
    let b = `${end}`.charCodeAt(0);
    let descending = a > b;
    let min5 = Math.min(a, b);
    let max5 = Math.max(a, b);
    if (options.toRegex && step === 1) {
      return toRange(min5, max5, false, options);
    }
    let range4 = [];
    let index2 = 0;
    while (descending ? a >= b : a <= b) {
      range4.push(format6(a, index2));
      a = descending ? a - step : a + step;
      index2++;
    }
    if (options.toRegex === true) {
      return toRegex(range4, null, { wrap: false, options });
    }
    return range4;
  };
  var fill = (start, end, step, options = {}) => {
    if (end == null && isValidValue(start)) {
      return [start];
    }
    if (!isValidValue(start) || !isValidValue(end)) {
      return invalidRange(start, end, options);
    }
    if (typeof step === "function") {
      return fill(start, end, 1, { transform: step });
    }
    if (isObject2(step)) {
      return fill(start, end, 0, step);
    }
    let opts = { ...options };
    if (opts.capture === true)
      opts.wrap = true;
    step = step || opts.step || 1;
    if (!isNumber2(step)) {
      if (step != null && !isObject2(step))
        return invalidStep(step, opts);
      return fill(start, end, 1, step);
    }
    if (isNumber2(start) && isNumber2(end)) {
      return fillNumbers(start, end, step, opts);
    }
    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
  };
  module.exports = fill;
});

// ../../node_modules/braces/lib/compile.js
var require_compile = __commonJS((exports, module) => {
  var fill = require_fill_range();
  var utils19 = require_utils();
  var compile2 = (ast, options = {}) => {
    let walk = (node, parent = {}) => {
      let invalidBlock = utils19.isInvalidBrace(parent);
      let invalidNode = node.invalid === true && options.escapeInvalid === true;
      let invalid = invalidBlock === true || invalidNode === true;
      let prefix = options.escapeInvalid === true ? "\\" : "";
      let output = "";
      if (node.isOpen === true) {
        return prefix + node.value;
      }
      if (node.isClose === true) {
        return prefix + node.value;
      }
      if (node.type === "open") {
        return invalid ? prefix + node.value : "(";
      }
      if (node.type === "close") {
        return invalid ? prefix + node.value : ")";
      }
      if (node.type === "comma") {
        return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes && node.ranges > 0) {
        let args = utils19.reduce(node.nodes);
        let range4 = fill(...args, { ...options, wrap: false, toRegex: true });
        if (range4.length !== 0) {
          return args.length > 1 && range4.length > 1 ? `(${range4})` : range4;
        }
      }
      if (node.nodes) {
        for (let child of node.nodes) {
          output += walk(child, node);
        }
      }
      return output;
    };
    return walk(ast);
  };
  module.exports = compile2;
});

// ../../node_modules/braces/lib/expand.js
var require_expand = __commonJS((exports, module) => {
  var fill = require_fill_range();
  var stringify2 = require_stringify();
  var utils19 = require_utils();
  var append = (queue = "", stash = "", enclose = false) => {
    let result = [];
    queue = [].concat(queue);
    stash = [].concat(stash);
    if (!stash.length)
      return queue;
    if (!queue.length) {
      return enclose ? utils19.flatten(stash).map((ele) => `{${ele}}`) : stash;
    }
    for (let item of queue) {
      if (Array.isArray(item)) {
        for (let value of item) {
          result.push(append(value, stash, enclose));
        }
      } else {
        for (let ele of stash) {
          if (enclose === true && typeof ele === "string")
            ele = `{${ele}}`;
          result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
        }
      }
    }
    return utils19.flatten(result);
  };
  var expand = (ast, options = {}) => {
    let rangeLimit = options.rangeLimit === undefined ? 1000 : options.rangeLimit;
    let walk = (node, parent = {}) => {
      node.queue = [];
      let p = parent;
      let q = parent.queue;
      while (p.type !== "brace" && p.type !== "root" && p.parent) {
        p = p.parent;
        q = p.queue;
      }
      if (node.invalid || node.dollar) {
        q.push(append(q.pop(), stringify2(node, options)));
        return;
      }
      if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
        q.push(append(q.pop(), ["{}"]));
        return;
      }
      if (node.nodes && node.ranges > 0) {
        let args = utils19.reduce(node.nodes);
        if (utils19.exceedsLimit(...args, options.step, rangeLimit)) {
          throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
        }
        let range4 = fill(...args, options);
        if (range4.length === 0) {
          range4 = stringify2(node, options);
        }
        q.push(append(q.pop(), range4));
        node.nodes = [];
        return;
      }
      let enclose = utils19.encloseBrace(node);
      let queue = node.queue;
      let block = node;
      while (block.type !== "brace" && block.type !== "root" && block.parent) {
        block = block.parent;
        queue = block.queue;
      }
      for (let i3 = 0;i3 < node.nodes.length; i3++) {
        let child = node.nodes[i3];
        if (child.type === "comma" && node.type === "brace") {
          if (i3 === 1)
            queue.push("");
          queue.push("");
          continue;
        }
        if (child.type === "close") {
          q.push(append(q.pop(), queue, enclose));
          continue;
        }
        if (child.value && child.type !== "open") {
          queue.push(append(queue.pop(), child.value));
          continue;
        }
        if (child.nodes) {
          walk(child, node);
        }
      }
      return queue;
    };
    return utils19.flatten(walk(ast));
  };
  module.exports = expand;
});

// ../../node_modules/braces/lib/constants.js
var require_constants2 = __commonJS((exports, module) => {
  module.exports = {
    MAX_LENGTH: 1024 * 64,
    CHAR_0: "0",
    CHAR_9: "9",
    CHAR_UPPERCASE_A: "A",
    CHAR_LOWERCASE_A: "a",
    CHAR_UPPERCASE_Z: "Z",
    CHAR_LOWERCASE_Z: "z",
    CHAR_LEFT_PARENTHESES: "(",
    CHAR_RIGHT_PARENTHESES: ")",
    CHAR_ASTERISK: "*",
    CHAR_AMPERSAND: "&",
    CHAR_AT: "@",
    CHAR_BACKSLASH: "\\",
    CHAR_BACKTICK: "`",
    CHAR_CARRIAGE_RETURN: "\r",
    CHAR_CIRCUMFLEX_ACCENT: "^",
    CHAR_COLON: ":",
    CHAR_COMMA: ",",
    CHAR_DOLLAR: "$",
    CHAR_DOT: ".",
    CHAR_DOUBLE_QUOTE: '"',
    CHAR_EQUAL: "=",
    CHAR_EXCLAMATION_MARK: "!",
    CHAR_FORM_FEED: "\f",
    CHAR_FORWARD_SLASH: "/",
    CHAR_HASH: "#",
    CHAR_HYPHEN_MINUS: "-",
    CHAR_LEFT_ANGLE_BRACKET: "<",
    CHAR_LEFT_CURLY_BRACE: "{",
    CHAR_LEFT_SQUARE_BRACKET: "[",
    CHAR_LINE_FEED: "\n",
    CHAR_NO_BREAK_SPACE: "\xA0",
    CHAR_PERCENT: "%",
    CHAR_PLUS: "+",
    CHAR_QUESTION_MARK: "?",
    CHAR_RIGHT_ANGLE_BRACKET: ">",
    CHAR_RIGHT_CURLY_BRACE: "}",
    CHAR_RIGHT_SQUARE_BRACKET: "]",
    CHAR_SEMICOLON: ";",
    CHAR_SINGLE_QUOTE: "\'",
    CHAR_SPACE: " ",
    CHAR_TAB: "\t",
    CHAR_UNDERSCORE: "_",
    CHAR_VERTICAL_LINE: "|",
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
  };
});

// ../../node_modules/braces/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var stringify2 = require_stringify();
  var {
    MAX_LENGTH,
    CHAR_BACKSLASH,
    CHAR_BACKTICK,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_LEFT_PARENTHESES,
    CHAR_RIGHT_PARENTHESES,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_RIGHT_SQUARE_BRACKET,
    CHAR_DOUBLE_QUOTE,
    CHAR_SINGLE_QUOTE,
    CHAR_NO_BREAK_SPACE,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE
  } = require_constants2();
  var parse4 = (input, options = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    let opts = options || {};
    let max5 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    if (input.length > max5) {
      throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max5})`);
    }
    let ast = { type: "root", input, nodes: [] };
    let stack = [ast];
    let block = ast;
    let prev = ast;
    let brackets = 0;
    let length = input.length;
    let index2 = 0;
    let depth = 0;
    let value;
    let memo = {};
    const advance = () => input[index2++];
    const push2 = (node) => {
      if (node.type === "text" && prev.type === "dot") {
        prev.type = "text";
      }
      if (prev && prev.type === "text" && node.type === "text") {
        prev.value += node.value;
        return;
      }
      block.nodes.push(node);
      node.parent = block;
      node.prev = prev;
      prev = node;
      return node;
    };
    push2({ type: "bos" });
    while (index2 < length) {
      block = stack[stack.length - 1];
      value = advance();
      if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
        continue;
      }
      if (value === CHAR_BACKSLASH) {
        push2({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
        continue;
      }
      if (value === CHAR_RIGHT_SQUARE_BRACKET) {
        push2({ type: "text", value: "\\" + value });
        continue;
      }
      if (value === CHAR_LEFT_SQUARE_BRACKET) {
        brackets++;
        let closed = true;
        let next;
        while (index2 < length && (next = advance())) {
          value += next;
          if (next === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            continue;
          }
          if (next === CHAR_BACKSLASH) {
            value += advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            brackets--;
            if (brackets === 0) {
              break;
            }
          }
        }
        push2({ type: "text", value });
        continue;
      }
      if (value === CHAR_LEFT_PARENTHESES) {
        block = push2({ type: "paren", nodes: [] });
        stack.push(block);
        push2({ type: "text", value });
        continue;
      }
      if (value === CHAR_RIGHT_PARENTHESES) {
        if (block.type !== "paren") {
          push2({ type: "text", value });
          continue;
        }
        block = stack.pop();
        push2({ type: "text", value });
        block = stack[stack.length - 1];
        continue;
      }
      if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
        let open = value;
        let next;
        if (options.keepQuotes !== true) {
          value = "";
        }
        while (index2 < length && (next = advance())) {
          if (next === CHAR_BACKSLASH) {
            value += next + advance();
            continue;
          }
          if (next === open) {
            if (options.keepQuotes === true)
              value += next;
            break;
          }
          value += next;
        }
        push2({ type: "text", value });
        continue;
      }
      if (value === CHAR_LEFT_CURLY_BRACE) {
        depth++;
        let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
        let brace = {
          type: "brace",
          open: true,
          close: false,
          dollar,
          depth,
          commas: 0,
          ranges: 0,
          nodes: []
        };
        block = push2(brace);
        stack.push(block);
        push2({ type: "open", value });
        continue;
      }
      if (value === CHAR_RIGHT_CURLY_BRACE) {
        if (block.type !== "brace") {
          push2({ type: "text", value });
          continue;
        }
        let type = "close";
        block = stack.pop();
        block.close = true;
        push2({ type, value });
        depth--;
        block = stack[stack.length - 1];
        continue;
      }
      if (value === CHAR_COMMA && depth > 0) {
        if (block.ranges > 0) {
          block.ranges = 0;
          let open = block.nodes.shift();
          block.nodes = [open, { type: "text", value: stringify2(block) }];
        }
        push2({ type: "comma", value });
        block.commas++;
        continue;
      }
      if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
        let siblings = block.nodes;
        if (depth === 0 || siblings.length === 0) {
          push2({ type: "text", value });
          continue;
        }
        if (prev.type === "dot") {
          block.range = [];
          prev.value += value;
          prev.type = "range";
          if (block.nodes.length !== 3 && block.nodes.length !== 5) {
            block.invalid = true;
            block.ranges = 0;
            prev.type = "text";
            continue;
          }
          block.ranges++;
          block.args = [];
          continue;
        }
        if (prev.type === "range") {
          siblings.pop();
          let before = siblings[siblings.length - 1];
          before.value += prev.value + value;
          prev = before;
          block.ranges--;
          continue;
        }
        push2({ type: "dot", value });
        continue;
      }
      push2({ type: "text", value });
    }
    do {
      block = stack.pop();
      if (block.type !== "root") {
        block.nodes.forEach((node) => {
          if (!node.nodes) {
            if (node.type === "open")
              node.isOpen = true;
            if (node.type === "close")
              node.isClose = true;
            if (!node.nodes)
              node.type = "text";
            node.invalid = true;
          }
        });
        let parent = stack[stack.length - 1];
        let index3 = parent.nodes.indexOf(block);
        parent.nodes.splice(index3, 1, ...block.nodes);
      }
    } while (stack.length > 0);
    push2({ type: "eos" });
    return ast;
  };
  module.exports = parse4;
});

// ../../node_modules/braces/index.js
var require_braces = __commonJS((exports, module) => {
  var stringify2 = require_stringify();
  var compile2 = require_compile();
  var expand = require_expand();
  var parse4 = require_parse();
  var braces = (input, options = {}) => {
    let output = [];
    if (Array.isArray(input)) {
      for (let pattern of input) {
        let result = braces.create(pattern, options);
        if (Array.isArray(result)) {
          output.push(...result);
        } else {
          output.push(result);
        }
      }
    } else {
      output = [].concat(braces.create(input, options));
    }
    if (options && options.expand === true && options.nodupes === true) {
      output = [...new Set(output)];
    }
    return output;
  };
  braces.parse = (input, options = {}) => parse4(input, options);
  braces.stringify = (input, options = {}) => {
    if (typeof input === "string") {
      return stringify2(braces.parse(input, options), options);
    }
    return stringify2(input, options);
  };
  braces.compile = (input, options = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options);
    }
    return compile2(input, options);
  };
  braces.expand = (input, options = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options);
    }
    let result = expand(input, options);
    if (options.noempty === true) {
      result = result.filter(Boolean);
    }
    if (options.nodupes === true) {
      result = [...new Set(result)];
    }
    return result;
  };
  braces.create = (input, options = {}) => {
    if (input === "" || input.length < 3) {
      return [input];
    }
    return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
  };
  module.exports = braces;
});

// ../../node_modules/picomatch/lib/constants.js
var require_constants3 = __commonJS((exports, module) => {
  var path = __require("path");
  var WIN_SLASH = "\\\\/";
  var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
  var DOT_LITERAL = "\\.";
  var PLUS_LITERAL = "\\+";
  var QMARK_LITERAL = "\\?";
  var SLASH_LITERAL = "\\/";
  var ONE_CHAR = "(?=.)";
  var QMARK = "[^/]";
  var END_ANCHOR = `(?:${SLASH_LITERAL}|\$)`;
  var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
  var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
  var NO_DOT = `(?!${DOT_LITERAL})`;
  var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
  var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
  var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
  var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
  var STAR = `${QMARK}*?`;
  var POSIX_CHARS = {
    DOT_LITERAL,
    PLUS_LITERAL,
    QMARK_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    QMARK,
    END_ANCHOR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  };
  var WINDOWS_CHARS = {
    ...POSIX_CHARS,
    SLASH_LITERAL: `[${WIN_SLASH}]`,
    QMARK: WIN_NO_SLASH,
    STAR: `${WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|\$)`,
    NO_DOT: `(?!${DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|\$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|\$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|\$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
    END_ANCHOR: `(?:[${WIN_SLASH}]|\$)`
  };
  var POSIX_REGEX_SOURCE = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  module.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE,
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    CHAR_0: 48,
    CHAR_9: 57,
    CHAR_UPPERCASE_A: 65,
    CHAR_LOWERCASE_A: 97,
    CHAR_UPPERCASE_Z: 90,
    CHAR_LOWERCASE_Z: 122,
    CHAR_LEFT_PARENTHESES: 40,
    CHAR_RIGHT_PARENTHESES: 41,
    CHAR_ASTERISK: 42,
    CHAR_AMPERSAND: 38,
    CHAR_AT: 64,
    CHAR_BACKWARD_SLASH: 92,
    CHAR_CARRIAGE_RETURN: 13,
    CHAR_CIRCUMFLEX_ACCENT: 94,
    CHAR_COLON: 58,
    CHAR_COMMA: 44,
    CHAR_DOT: 46,
    CHAR_DOUBLE_QUOTE: 34,
    CHAR_EQUAL: 61,
    CHAR_EXCLAMATION_MARK: 33,
    CHAR_FORM_FEED: 12,
    CHAR_FORWARD_SLASH: 47,
    CHAR_GRAVE_ACCENT: 96,
    CHAR_HASH: 35,
    CHAR_HYPHEN_MINUS: 45,
    CHAR_LEFT_ANGLE_BRACKET: 60,
    CHAR_LEFT_CURLY_BRACE: 123,
    CHAR_LEFT_SQUARE_BRACKET: 91,
    CHAR_LINE_FEED: 10,
    CHAR_NO_BREAK_SPACE: 160,
    CHAR_PERCENT: 37,
    CHAR_PLUS: 43,
    CHAR_QUESTION_MARK: 63,
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    CHAR_RIGHT_CURLY_BRACE: 125,
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    CHAR_SEMICOLON: 59,
    CHAR_SINGLE_QUOTE: 39,
    CHAR_SPACE: 32,
    CHAR_TAB: 9,
    CHAR_UNDERSCORE: 95,
    CHAR_VERTICAL_LINE: 124,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    SEP: path.sep,
    extglobChars(chars) {
      return {
        "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
        "?": { type: "qmark", open: "(?:", close: ")?" },
        "+": { type: "plus", open: "(?:", close: ")+" },
        "*": { type: "star", open: "(?:", close: ")*" },
        "@": { type: "at", open: "(?:", close: ")" }
      };
    },
    globChars(win32) {
      return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
    }
  };
});

// ../../node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS((exports) => {
  var path = __require("path");
  var win32 = process.platform === "win32";
  var {
    REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL
  } = require_constants3();
  exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
  exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
  exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
  exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
  exports.removeBackslashes = (str) => {
    return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
      return match === "\\" ? "" : match;
    });
  };
  exports.supportsLookbehinds = () => {
    const segs = process.version.slice(1).split(".").map(Number);
    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
      return true;
    }
    return false;
  };
  exports.isWindows = (options) => {
    if (options && typeof options.windows === "boolean") {
      return options.windows;
    }
    return win32 === true || path.sep === "\\";
  };
  exports.escapeLast = (input, char, lastIdx) => {
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1)
      return input;
    if (input[idx - 1] === "\\")
      return exports.escapeLast(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
  };
  exports.removePrefix = (input, state3 = {}) => {
    let output = input;
    if (output.startsWith("./")) {
      output = output.slice(2);
      state3.prefix = "./";
    }
    return output;
  };
  exports.wrapOutput = (input, state3 = {}, options = {}) => {
    const prepend = options.contains ? "" : "^";
    const append = options.contains ? "" : "$";
    let output = `${prepend}(?:${input})${append}`;
    if (state3.negated === true) {
      output = `(?:^(?!${output}).*\$)`;
    }
    return output;
  };
});

// ../../node_modules/picomatch/lib/scan.js
var require_scan = __commonJS((exports, module) => {
  var utils19 = require_utils2();
  var {
    CHAR_ASTERISK,
    CHAR_AT,
    CHAR_BACKWARD_SLASH,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_EXCLAMATION_MARK,
    CHAR_FORWARD_SLASH,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_LEFT_PARENTHESES,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_PLUS,
    CHAR_QUESTION_MARK,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_RIGHT_PARENTHESES,
    CHAR_RIGHT_SQUARE_BRACKET
  } = require_constants3();
  var isPathSeparator = (code) => {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  };
  var depth = (token) => {
    if (token.isPrefix !== true) {
      token.depth = token.isGlobstar ? Infinity : 1;
    }
  };
  var scan2 = (input, options) => {
    const opts = options || {};
    const length = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index2 = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob = false;
    let isExtglob = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let negatedExtglob = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = { value: "", depth: 0, isGlob: false };
    const eos2 = () => index2 >= length;
    const peek = () => str.charCodeAt(index2 + 1);
    const advance = () => {
      prev = code;
      return str.charCodeAt(++index2);
    };
    while (index2 < length) {
      code = advance();
      let next;
      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = token.backslashes = true;
        code = advance();
        if (code === CHAR_LEFT_CURLY_BRACE) {
          braceEscaped = true;
        }
        continue;
      }
      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
        braces++;
        while (eos2() !== true && (code = advance())) {
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            continue;
          }
          if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (braceEscaped !== true && code === CHAR_COMMA) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_RIGHT_CURLY_BRACE) {
            braces--;
            if (braces === 0) {
              braceEscaped = false;
              isBrace = token.isBrace = true;
              finished = true;
              break;
            }
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_FORWARD_SLASH) {
        slashes.push(index2);
        tokens.push(token);
        token = { value: "", depth: 0, isGlob: false };
        if (finished === true)
          continue;
        if (prev === CHAR_DOT && index2 === start + 1) {
          start += 2;
          continue;
        }
        lastIndex = index2 + 1;
        continue;
      }
      if (opts.noext !== true) {
        const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
        if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          isExtglob = token.isExtglob = true;
          finished = true;
          if (code === CHAR_EXCLAMATION_MARK && index2 === start) {
            negatedExtglob = true;
          }
          if (scanToEnd === true) {
            while (eos2() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
      }
      if (code === CHAR_ASTERISK) {
        if (prev === CHAR_ASTERISK)
          isGlobstar = token.isGlobstar = true;
        isGlob = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_QUESTION_MARK) {
        isGlob = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_LEFT_SQUARE_BRACKET) {
        while (eos2() !== true && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            isBracket = token.isBracket = true;
            isGlob = token.isGlob = true;
            finished = true;
            break;
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index2 === start) {
        negated = token.negated = true;
        start++;
        continue;
      }
      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        if (scanToEnd === true) {
          while (eos2() !== true && (code = advance())) {
            if (code === CHAR_LEFT_PARENTHESES) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }
            if (code === CHAR_RIGHT_PARENTHESES) {
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (isGlob === true) {
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
    }
    if (opts.noext === true) {
      isExtglob = false;
      isGlob = false;
    }
    let base15 = str;
    let prefix = "";
    let glob = "";
    if (start > 0) {
      prefix = str.slice(0, start);
      str = str.slice(start);
      lastIndex -= start;
    }
    if (base15 && isGlob === true && lastIndex > 0) {
      base15 = str.slice(0, lastIndex);
      glob = str.slice(lastIndex);
    } else if (isGlob === true) {
      base15 = "";
      glob = str;
    } else {
      base15 = str;
    }
    if (base15 && base15 !== "" && base15 !== "/" && base15 !== str) {
      if (isPathSeparator(base15.charCodeAt(base15.length - 1))) {
        base15 = base15.slice(0, -1);
      }
    }
    if (opts.unescape === true) {
      if (glob)
        glob = utils19.removeBackslashes(glob);
      if (base15 && backslashes === true) {
        base15 = utils19.removeBackslashes(base15);
      }
    }
    const state3 = {
      prefix,
      input,
      start,
      base: base15,
      glob,
      isBrace,
      isBracket,
      isGlob,
      isExtglob,
      isGlobstar,
      negated,
      negatedExtglob
    };
    if (opts.tokens === true) {
      state3.maxDepth = 0;
      if (!isPathSeparator(code)) {
        tokens.push(token);
      }
      state3.tokens = tokens;
    }
    if (opts.parts === true || opts.tokens === true) {
      let prevIndex;
      for (let idx = 0;idx < slashes.length; idx++) {
        const n = prevIndex ? prevIndex + 1 : start;
        const i3 = slashes[idx];
        const value = input.slice(n, i3);
        if (opts.tokens) {
          if (idx === 0 && start !== 0) {
            tokens[idx].isPrefix = true;
            tokens[idx].value = prefix;
          } else {
            tokens[idx].value = value;
          }
          depth(tokens[idx]);
          state3.maxDepth += tokens[idx].depth;
        }
        if (idx !== 0 || value !== "") {
          parts.push(value);
        }
        prevIndex = i3;
      }
      if (prevIndex && prevIndex + 1 < input.length) {
        const value = input.slice(prevIndex + 1);
        parts.push(value);
        if (opts.tokens) {
          tokens[tokens.length - 1].value = value;
          depth(tokens[tokens.length - 1]);
          state3.maxDepth += tokens[tokens.length - 1].depth;
        }
      }
      state3.slashes = slashes;
      state3.parts = parts;
    }
    return state3;
  };
  module.exports = scan2;
});

// ../../node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var constants3 = require_constants3();
  var utils19 = require_utils2();
  var {
    MAX_LENGTH,
    POSIX_REGEX_SOURCE,
    REGEX_NON_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_BACKREF,
    REPLACEMENTS
  } = constants3;
  var expandRange = (args, options) => {
    if (typeof options.expandRange === "function") {
      return options.expandRange(...args, options);
    }
    args.sort();
    const value = `[${args.join("-")}]`;
    try {
      new RegExp(value);
    } catch (ex) {
      return args.map((v) => utils19.escapeRegex(v)).join("..");
    }
    return value;
  };
  var syntaxError = (type, char) => {
    return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
  };
  var parse4 = (input, options) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    input = REPLACEMENTS[input] || input;
    const opts = { ...options };
    const max5 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input.length;
    if (len > max5) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max5}`);
    }
    const bos = { type: "bos", value: "", output: opts.prepend || "" };
    const tokens = [bos];
    const capture = opts.capture ? "" : "?:";
    const win32 = utils19.isWindows(options);
    const PLATFORM_CHARS = constants3.globChars(win32);
    const EXTGLOB_CHARS = constants3.extglobChars(PLATFORM_CHARS);
    const {
      DOT_LITERAL,
      PLUS_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    } = PLATFORM_CHARS;
    const globstar = (opts2) => {
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const nodot = opts.dot ? "" : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    if (typeof opts.noext === "boolean") {
      opts.noextglob = opts.noext;
    }
    const state3 = {
      input,
      index: -1,
      start: 0,
      dot: opts.dot === true,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: false,
      negated: false,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: false,
      tokens
    };
    input = utils19.removePrefix(input, state3);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value;
    const eos2 = () => state3.index === len - 1;
    const peek = state3.peek = (n = 1) => input[state3.index + n];
    const advance = state3.advance = () => input[++state3.index] || "";
    const remaining = () => input.slice(state3.index + 1);
    const consume = (value2 = "", num = 0) => {
      state3.consumed += value2;
      state3.index += num;
    };
    const append = (token) => {
      state3.output += token.output != null ? token.output : token.value;
      consume(token.value);
    };
    const negate = () => {
      let count3 = 1;
      while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
        advance();
        state3.start++;
        count3++;
      }
      if (count3 % 2 === 0) {
        return false;
      }
      state3.negated = true;
      state3.start++;
      return true;
    };
    const increment = (type) => {
      state3[type]++;
      stack.push(type);
    };
    const decrement = (type) => {
      state3[type]--;
      stack.pop();
    };
    const push2 = (tok) => {
      if (prev.type === "globstar") {
        const isBrace = state3.braces > 0 && (tok.type === "comma" || tok.type === "brace");
        const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
        if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
          state3.output = state3.output.slice(0, -prev.output.length);
          prev.type = "star";
          prev.value = "*";
          prev.output = star;
          state3.output += prev.output;
        }
      }
      if (extglobs.length && tok.type !== "paren") {
        extglobs[extglobs.length - 1].inner += tok.value;
      }
      if (tok.value || tok.output)
        append(tok);
      if (prev && prev.type === "text" && tok.type === "text") {
        prev.value += tok.value;
        prev.output = (prev.output || "") + tok.value;
        return;
      }
      tok.prev = prev;
      tokens.push(tok);
      prev = tok;
    };
    const extglobOpen = (type, value2) => {
      const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
      token.prev = prev;
      token.parens = state3.parens;
      token.output = state3.output;
      const output = (opts.capture ? "(" : "") + token.open;
      increment("parens");
      push2({ type, value: value2, output: state3.output ? "" : ONE_CHAR });
      push2({ type: "paren", extglob: true, value: advance(), output });
      extglobs.push(token);
    };
    const extglobClose = (token) => {
      let output = token.close + (opts.capture ? ")" : "");
      let rest;
      if (token.type === "negate") {
        let extglobStar = star;
        if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
          extglobStar = globstar(opts);
        }
        if (extglobStar !== star || eos2() || /^\)+$/.test(remaining())) {
          output = token.close = `)\$))${extglobStar}`;
        }
        if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
          const expression = parse4(rest, { ...options, fastpaths: false }).output;
          output = token.close = `)${expression})${extglobStar})`;
        }
        if (token.prev.type === "bos") {
          state3.negatedExtglob = true;
        }
      }
      push2({ type: "paren", extglob: true, value, output });
      decrement("parens");
    };
    if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
      let backslashes = false;
      let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index2) => {
        if (first === "\\") {
          backslashes = true;
          return m;
        }
        if (first === "?") {
          if (esc) {
            return esc + first + (rest ? QMARK.repeat(rest.length) : "");
          }
          if (index2 === 0) {
            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
          }
          return QMARK.repeat(chars.length);
        }
        if (first === ".") {
          return DOT_LITERAL.repeat(chars.length);
        }
        if (first === "*") {
          if (esc) {
            return esc + first + (rest ? star : "");
          }
          return star;
        }
        return esc ? m : `\\${m}`;
      });
      if (backslashes === true) {
        if (opts.unescape === true) {
          output = output.replace(/\\/g, "");
        } else {
          output = output.replace(/\\+/g, (m) => {
            return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
          });
        }
      }
      if (output === input && opts.contains === true) {
        state3.output = input;
        return state3;
      }
      state3.output = utils19.wrapOutput(output, state3, options);
      return state3;
    }
    while (!eos2()) {
      value = advance();
      if (value === "\0") {
        continue;
      }
      if (value === "\\") {
        const next = peek();
        if (next === "/" && opts.bash !== true) {
          continue;
        }
        if (next === "." || next === ";") {
          continue;
        }
        if (!next) {
          value += "\\";
          push2({ type: "text", value });
          continue;
        }
        const match = /^\\+/.exec(remaining());
        let slashes = 0;
        if (match && match[0].length > 2) {
          slashes = match[0].length;
          state3.index += slashes;
          if (slashes % 2 !== 0) {
            value += "\\";
          }
        }
        if (opts.unescape === true) {
          value = advance();
        } else {
          value += advance();
        }
        if (state3.brackets === 0) {
          push2({ type: "text", value });
          continue;
        }
      }
      if (state3.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
        if (opts.posix !== false && value === ":") {
          const inner = prev.value.slice(1);
          if (inner.includes("[")) {
            prev.posix = true;
            if (inner.includes(":")) {
              const idx = prev.value.lastIndexOf("[");
              const pre = prev.value.slice(0, idx);
              const rest2 = prev.value.slice(idx + 2);
              const posix = POSIX_REGEX_SOURCE[rest2];
              if (posix) {
                prev.value = pre + posix;
                state3.backtrack = true;
                advance();
                if (!bos.output && tokens.indexOf(prev) === 1) {
                  bos.output = ONE_CHAR;
                }
                continue;
              }
            }
          }
        }
        if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
          value = `\\${value}`;
        }
        if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
          value = `\\${value}`;
        }
        if (opts.posix === true && value === "!" && prev.value === "[") {
          value = "^";
        }
        prev.value += value;
        append({ value });
        continue;
      }
      if (state3.quotes === 1 && value !== '"') {
        value = utils19.escapeRegex(value);
        prev.value += value;
        append({ value });
        continue;
      }
      if (value === '"') {
        state3.quotes = state3.quotes === 1 ? 0 : 1;
        if (opts.keepQuotes === true) {
          push2({ type: "text", value });
        }
        continue;
      }
      if (value === "(") {
        increment("parens");
        push2({ type: "paren", value });
        continue;
      }
      if (value === ")") {
        if (state3.parens === 0 && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError("opening", "("));
        }
        const extglob = extglobs[extglobs.length - 1];
        if (extglob && state3.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }
        push2({ type: "paren", value, output: state3.parens ? ")" : "\\)" });
        decrement("parens");
        continue;
      }
      if (value === "[") {
        if (opts.nobracket === true || !remaining().includes("]")) {
          if (opts.nobracket !== true && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("closing", "]"));
          }
          value = `\\${value}`;
        } else {
          increment("brackets");
        }
        push2({ type: "bracket", value });
        continue;
      }
      if (value === "]") {
        if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
          push2({ type: "text", value, output: `\\${value}` });
          continue;
        }
        if (state3.brackets === 0) {
          if (opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "["));
          }
          push2({ type: "text", value, output: `\\${value}` });
          continue;
        }
        decrement("brackets");
        const prevValue = prev.value.slice(1);
        if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
          value = `/${value}`;
        }
        prev.value += value;
        append({ value });
        if (opts.literalBrackets === false || utils19.hasRegexChars(prevValue)) {
          continue;
        }
        const escaped = utils19.escapeRegex(prev.value);
        state3.output = state3.output.slice(0, -prev.value.length);
        if (opts.literalBrackets === true) {
          state3.output += escaped;
          prev.value = escaped;
          continue;
        }
        prev.value = `(${capture}${escaped}|${prev.value})`;
        state3.output += prev.value;
        continue;
      }
      if (value === "{" && opts.nobrace !== true) {
        increment("braces");
        const open = {
          type: "brace",
          value,
          output: "(",
          outputIndex: state3.output.length,
          tokensIndex: state3.tokens.length
        };
        braces.push(open);
        push2(open);
        continue;
      }
      if (value === "}") {
        const brace = braces[braces.length - 1];
        if (opts.nobrace === true || !brace) {
          push2({ type: "text", value, output: value });
          continue;
        }
        let output = ")";
        if (brace.dots === true) {
          const arr = tokens.slice();
          const range4 = [];
          for (let i3 = arr.length - 1;i3 >= 0; i3--) {
            tokens.pop();
            if (arr[i3].type === "brace") {
              break;
            }
            if (arr[i3].type !== "dots") {
              range4.unshift(arr[i3].value);
            }
          }
          output = expandRange(range4, opts);
          state3.backtrack = true;
        }
        if (brace.comma !== true && brace.dots !== true) {
          const out = state3.output.slice(0, brace.outputIndex);
          const toks = state3.tokens.slice(brace.tokensIndex);
          brace.value = brace.output = "\\{";
          value = output = "\\}";
          state3.output = out;
          for (const t of toks) {
            state3.output += t.output || t.value;
          }
        }
        push2({ type: "brace", value, output });
        decrement("braces");
        braces.pop();
        continue;
      }
      if (value === "|") {
        if (extglobs.length > 0) {
          extglobs[extglobs.length - 1].conditions++;
        }
        push2({ type: "text", value });
        continue;
      }
      if (value === ",") {
        let output = value;
        const brace = braces[braces.length - 1];
        if (brace && stack[stack.length - 1] === "braces") {
          brace.comma = true;
          output = "|";
        }
        push2({ type: "comma", value, output });
        continue;
      }
      if (value === "/") {
        if (prev.type === "dot" && state3.index === state3.start + 1) {
          state3.start = state3.index + 1;
          state3.consumed = "";
          state3.output = "";
          tokens.pop();
          prev = bos;
          continue;
        }
        push2({ type: "slash", value, output: SLASH_LITERAL });
        continue;
      }
      if (value === ".") {
        if (state3.braces > 0 && prev.type === "dot") {
          if (prev.value === ".")
            prev.output = DOT_LITERAL;
          const brace = braces[braces.length - 1];
          prev.type = "dots";
          prev.output += value;
          prev.value += value;
          brace.dots = true;
          continue;
        }
        if (state3.braces + state3.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
          push2({ type: "text", value, output: DOT_LITERAL });
          continue;
        }
        push2({ type: "dot", value, output: DOT_LITERAL });
        continue;
      }
      if (value === "?") {
        const isGroup = prev && prev.value === "(";
        if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("qmark", value);
          continue;
        }
        if (prev && prev.type === "paren") {
          const next = peek();
          let output = value;
          if (next === "<" && !utils19.supportsLookbehinds()) {
            throw new Error("Node.js v10 or higher is required for regex lookbehinds");
          }
          if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
            output = `\\${value}`;
          }
          push2({ type: "text", value, output });
          continue;
        }
        if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
          push2({ type: "qmark", value, output: QMARK_NO_DOT });
          continue;
        }
        push2({ type: "qmark", value, output: QMARK });
        continue;
      }
      if (value === "!") {
        if (opts.noextglob !== true && peek() === "(") {
          if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
            extglobOpen("negate", value);
            continue;
          }
        }
        if (opts.nonegate !== true && state3.index === 0) {
          negate();
          continue;
        }
      }
      if (value === "+") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("plus", value);
          continue;
        }
        if (prev && prev.value === "(" || opts.regex === false) {
          push2({ type: "plus", value, output: PLUS_LITERAL });
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state3.parens > 0) {
          push2({ type: "plus", value });
          continue;
        }
        push2({ type: "plus", value: PLUS_LITERAL });
        continue;
      }
      if (value === "@") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          push2({ type: "at", extglob: true, value, output: "" });
          continue;
        }
        push2({ type: "text", value });
        continue;
      }
      if (value !== "*") {
        if (value === "$" || value === "^") {
          value = `\\${value}`;
        }
        const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
        if (match) {
          value += match[0];
          state3.index += match[0].length;
        }
        push2({ type: "text", value });
        continue;
      }
      if (prev && (prev.type === "globstar" || prev.star === true)) {
        prev.type = "star";
        prev.star = true;
        prev.value += value;
        prev.output = star;
        state3.backtrack = true;
        state3.globstar = true;
        consume(value);
        continue;
      }
      let rest = remaining();
      if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
        extglobOpen("star", value);
        continue;
      }
      if (prev.type === "star") {
        if (opts.noglobstar === true) {
          consume(value);
          continue;
        }
        const prior = prev.prev;
        const before = prior.prev;
        const isStart = prior.type === "slash" || prior.type === "bos";
        const afterStar = before && (before.type === "star" || before.type === "globstar");
        if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
          push2({ type: "star", value, output: "" });
          continue;
        }
        const isBrace = state3.braces > 0 && (prior.type === "comma" || prior.type === "brace");
        const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
        if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
          push2({ type: "star", value, output: "" });
          continue;
        }
        while (rest.slice(0, 3) === "/**") {
          const after = input[state3.index + 4];
          if (after && after !== "/") {
            break;
          }
          rest = rest.slice(3);
          consume("/**", 3);
        }
        if (prior.type === "bos" && eos2()) {
          prev.type = "globstar";
          prev.value += value;
          prev.output = globstar(opts);
          state3.output = prev.output;
          state3.globstar = true;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos2()) {
          state3.output = state3.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
          prev.value += value;
          state3.globstar = true;
          state3.output += prior.output + prev.output;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
          const end = rest[1] !== undefined ? "|$" : "";
          state3.output = state3.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
          prev.value += value;
          state3.output += prior.output + prev.output;
          state3.globstar = true;
          consume(value + advance());
          push2({ type: "slash", value: "/", output: "" });
          continue;
        }
        if (prior.type === "bos" && rest[0] === "/") {
          prev.type = "globstar";
          prev.value += value;
          prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
          state3.output = prev.output;
          state3.globstar = true;
          consume(value + advance());
          push2({ type: "slash", value: "/", output: "" });
          continue;
        }
        state3.output = state3.output.slice(0, -prev.output.length);
        prev.type = "globstar";
        prev.output = globstar(opts);
        prev.value += value;
        state3.output += prev.output;
        state3.globstar = true;
        consume(value);
        continue;
      }
      const token = { type: "star", value, output: star };
      if (opts.bash === true) {
        token.output = ".*?";
        if (prev.type === "bos" || prev.type === "slash") {
          token.output = nodot + token.output;
        }
        push2(token);
        continue;
      }
      if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
        token.output = value;
        push2(token);
        continue;
      }
      if (state3.index === state3.start || prev.type === "slash" || prev.type === "dot") {
        if (prev.type === "dot") {
          state3.output += NO_DOT_SLASH;
          prev.output += NO_DOT_SLASH;
        } else if (opts.dot === true) {
          state3.output += NO_DOTS_SLASH;
          prev.output += NO_DOTS_SLASH;
        } else {
          state3.output += nodot;
          prev.output += nodot;
        }
        if (peek() !== "*") {
          state3.output += ONE_CHAR;
          prev.output += ONE_CHAR;
        }
      }
      push2(token);
    }
    while (state3.brackets > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "]"));
      state3.output = utils19.escapeLast(state3.output, "[");
      decrement("brackets");
    }
    while (state3.parens > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", ")"));
      state3.output = utils19.escapeLast(state3.output, "(");
      decrement("parens");
    }
    while (state3.braces > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "}"));
      state3.output = utils19.escapeLast(state3.output, "{");
      decrement("braces");
    }
    if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
      push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
    }
    if (state3.backtrack === true) {
      state3.output = "";
      for (const token of state3.tokens) {
        state3.output += token.output != null ? token.output : token.value;
        if (token.suffix) {
          state3.output += token.suffix;
        }
      }
    }
    return state3;
  };
  parse4.fastpaths = (input, options) => {
    const opts = { ...options };
    const max5 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    const len = input.length;
    if (len > max5) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max5}`);
    }
    input = REPLACEMENTS[input] || input;
    const win32 = utils19.isWindows(options);
    const {
      DOT_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOTS_SLASH,
      STAR,
      START_ANCHOR
    } = constants3.globChars(win32);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? "" : "?:";
    const state3 = { negated: false, prefix: "" };
    let star = opts.bash === true ? ".*?" : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    const globstar = (opts2) => {
      if (opts2.noglobstar === true)
        return star;
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const create2 = (str) => {
      switch (str) {
        case "*":
          return `${nodot}${ONE_CHAR}${star}`;
        case ".*":
          return `${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*.*":
          return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*/*":
          return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
        case "**":
          return nodot + globstar(opts);
        case "**/*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
        case "**/*.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "**/.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
        default: {
          const match = /^(.*?)\.(\w+)$/.exec(str);
          if (!match)
            return;
          const source2 = create2(match[1]);
          if (!source2)
            return;
          return source2 + DOT_LITERAL + match[2];
        }
      }
    };
    const output = utils19.removePrefix(input, state3);
    let source = create2(output);
    if (source && opts.strictSlashes !== true) {
      source += `${SLASH_LITERAL}?`;
    }
    return source;
  };
  module.exports = parse4;
});

// ../../node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS((exports, module) => {
  var path = __require("path");
  var scan2 = require_scan();
  var parse4 = require_parse2();
  var utils19 = require_utils2();
  var constants3 = require_constants3();
  var isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
  var picomatch = (glob, options, returnState = false) => {
    if (Array.isArray(glob)) {
      const fns = glob.map((input) => picomatch(input, options, returnState));
      const arrayMatcher = (str) => {
        for (const isMatch2 of fns) {
          const state4 = isMatch2(str);
          if (state4)
            return state4;
        }
        return false;
      };
      return arrayMatcher;
    }
    const isState = isObject2(glob) && glob.tokens && glob.input;
    if (glob === "" || typeof glob !== "string" && !isState) {
      throw new TypeError("Expected pattern to be a non-empty string");
    }
    const opts = options || {};
    const posix = utils19.isWindows(options);
    const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
    const state3 = regex.state;
    delete regex.state;
    let isIgnored = () => false;
    if (opts.ignore) {
      const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
      isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input, returnObject = false) => {
      const { isMatch: isMatch2, match, output } = picomatch.test(input, regex, options, { glob, posix });
      const result = { glob, state: state3, regex, posix, input, output, match, isMatch: isMatch2 };
      if (typeof opts.onResult === "function") {
        opts.onResult(result);
      }
      if (isMatch2 === false) {
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (isIgnored(input)) {
        if (typeof opts.onIgnore === "function") {
          opts.onIgnore(result);
        }
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (typeof opts.onMatch === "function") {
        opts.onMatch(result);
      }
      return returnObject ? result : true;
    };
    if (returnState) {
      matcher.state = state3;
    }
    return matcher;
  };
  picomatch.test = (input, regex, options, { glob, posix } = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected input to be a string");
    }
    if (input === "") {
      return { isMatch: false, output: "" };
    }
    const opts = options || {};
    const format6 = opts.format || (posix ? utils19.toPosixSlashes : null);
    let match = input === glob;
    let output = match && format6 ? format6(input) : input;
    if (match === false) {
      output = format6 ? format6(input) : input;
      match = output === glob;
    }
    if (match === false || opts.capture === true) {
      if (opts.matchBase === true || opts.basename === true) {
        match = picomatch.matchBase(input, regex, options, posix);
      } else {
        match = regex.exec(output);
      }
    }
    return { isMatch: Boolean(match), match, output };
  };
  picomatch.matchBase = (input, glob, options, posix = utils19.isWindows(options)) => {
    const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
    return regex.test(path.basename(input));
  };
  picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
  picomatch.parse = (pattern, options) => {
    if (Array.isArray(pattern))
      return pattern.map((p) => picomatch.parse(p, options));
    return parse4(pattern, { ...options, fastpaths: false });
  };
  picomatch.scan = (input, options) => scan2(input, options);
  picomatch.compileRe = (state3, options, returnOutput = false, returnState = false) => {
    if (returnOutput === true) {
      return state3.output;
    }
    const opts = options || {};
    const prepend = opts.contains ? "" : "^";
    const append = opts.contains ? "" : "$";
    let source = `${prepend}(?:${state3.output})${append}`;
    if (state3 && state3.negated === true) {
      source = `^(?!${source}).*\$`;
    }
    const regex = picomatch.toRegex(source, options);
    if (returnState === true) {
      regex.state = state3;
    }
    return regex;
  };
  picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
    if (!input || typeof input !== "string") {
      throw new TypeError("Expected a non-empty string");
    }
    let parsed = { negated: false, fastpaths: true };
    if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
      parsed.output = parse4.fastpaths(input, options);
    }
    if (!parsed.output) {
      parsed = parse4(input, options);
    }
    return picomatch.compileRe(parsed, options, returnOutput, returnState);
  };
  picomatch.toRegex = (source, options) => {
    try {
      const opts = options || {};
      return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
    } catch (err) {
      if (options && options.debug === true)
        throw err;
      return /$^/;
    }
  };
  picomatch.constants = constants3;
  module.exports = picomatch;
});

// ../../node_modules/micromatch/index.js
var require_micromatch = __commonJS((exports, module) => {
  var util4 = __require("util");
  var braces = require_braces();
  var picomatch = require_picomatch();
  var utils19 = require_utils2();
  var isEmptyString = (val) => val === "" || val === "./";
  var micromatch = (list3, patterns, options) => {
    patterns = [].concat(patterns);
    list3 = [].concat(list3);
    let omit = new Set;
    let keep = new Set;
    let items = new Set;
    let negatives = 0;
    let onResult = (state3) => {
      items.add(state3.output);
      if (options && options.onResult) {
        options.onResult(state3);
      }
    };
    for (let i3 = 0;i3 < patterns.length; i3++) {
      let isMatch2 = picomatch(String(patterns[i3]), { ...options, onResult }, true);
      let negated = isMatch2.state.negated || isMatch2.state.negatedExtglob;
      if (negated)
        negatives++;
      for (let item of list3) {
        let matched = isMatch2(item, true);
        let match = negated ? !matched.isMatch : matched.isMatch;
        if (!match)
          continue;
        if (negated) {
          omit.add(matched.output);
        } else {
          omit.delete(matched.output);
          keep.add(matched.output);
        }
      }
    }
    let result = negatives === patterns.length ? [...items] : [...keep];
    let matches = result.filter((item) => !omit.has(item));
    if (options && matches.length === 0) {
      if (options.failglob === true) {
        throw new Error(`No matches found for "${patterns.join(", ")}"`);
      }
      if (options.nonull === true || options.nullglob === true) {
        return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
      }
    }
    return matches;
  };
  micromatch.match = micromatch;
  micromatch.matcher = (pattern, options) => picomatch(pattern, options);
  micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
  micromatch.any = micromatch.isMatch;
  micromatch.not = (list3, patterns, options = {}) => {
    patterns = [].concat(patterns).map(String);
    let result = new Set;
    let items = [];
    let onResult = (state3) => {
      if (options.onResult)
        options.onResult(state3);
      items.push(state3.output);
    };
    let matches = new Set(micromatch(list3, patterns, { ...options, onResult }));
    for (let item of items) {
      if (!matches.has(item)) {
        result.add(item);
      }
    }
    return [...result];
  };
  micromatch.contains = (str, pattern, options) => {
    if (typeof str !== "string") {
      throw new TypeError(`Expected a string: "${util4.inspect(str)}"`);
    }
    if (Array.isArray(pattern)) {
      return pattern.some((p) => micromatch.contains(str, p, options));
    }
    if (typeof pattern === "string") {
      if (isEmptyString(str) || isEmptyString(pattern)) {
        return false;
      }
      if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
        return true;
      }
    }
    return micromatch.isMatch(str, pattern, { ...options, contains: true });
  };
  micromatch.matchKeys = (obj, patterns, options) => {
    if (!utils19.isObject(obj)) {
      throw new TypeError("Expected the first argument to be an object");
    }
    let keys = micromatch(Object.keys(obj), patterns, options);
    let res = {};
    for (let key of keys)
      res[key] = obj[key];
    return res;
  };
  micromatch.some = (list3, patterns, options) => {
    let items = [].concat(list3);
    for (let pattern of [].concat(patterns)) {
      let isMatch2 = picomatch(String(pattern), options);
      if (items.some((item) => isMatch2(item))) {
        return true;
      }
    }
    return false;
  };
  micromatch.every = (list3, patterns, options) => {
    let items = [].concat(list3);
    for (let pattern of [].concat(patterns)) {
      let isMatch2 = picomatch(String(pattern), options);
      if (!items.every((item) => isMatch2(item))) {
        return false;
      }
    }
    return true;
  };
  micromatch.all = (str, patterns, options) => {
    if (typeof str !== "string") {
      throw new TypeError(`Expected a string: "${util4.inspect(str)}"`);
    }
    return [].concat(patterns).every((p) => picomatch(p, options)(str));
  };
  micromatch.capture = (glob, input, options) => {
    let posix = utils19.isWindows(options);
    let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
    let match = regex.exec(posix ? utils19.toPosixSlashes(input) : input);
    if (match) {
      return match.slice(1).map((v) => v === undefined ? "" : v);
    }
  };
  micromatch.makeRe = (...args) => picomatch.makeRe(...args);
  micromatch.scan = (...args) => picomatch.scan(...args);
  micromatch.parse = (patterns, options) => {
    let res = [];
    for (let pattern of [].concat(patterns || [])) {
      for (let str of braces(String(pattern), options)) {
        res.push(picomatch.parse(str, options));
      }
    }
    return res;
  };
  micromatch.braces = (pattern, options) => {
    if (typeof pattern !== "string")
      throw new TypeError("Expected a string");
    if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
      return [pattern];
    }
    return braces(pattern, options);
  };
  micromatch.braceExpand = (pattern, options) => {
    if (typeof pattern !== "string")
      throw new TypeError("Expected a string");
    return micromatch.braces(pattern, { ...options, expand: true });
  };
  module.exports = micromatch;
});

// ../../node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS((exports) => {
  var isStaticPattern = function(pattern, options = {}) {
    return !isDynamicPattern(pattern, options);
  };
  var isDynamicPattern = function(pattern, options = {}) {
    if (pattern === "") {
      return false;
    }
    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
      return true;
    }
    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
      return true;
    }
    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
      return true;
    }
    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
      return true;
    }
    return false;
  };
  var hasBraceExpansion = function(pattern) {
    const openingBraceIndex = pattern.indexOf("{");
    if (openingBraceIndex === -1) {
      return false;
    }
    const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
    if (closingBraceIndex === -1) {
      return false;
    }
    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
  };
  var convertToPositivePattern = function(pattern) {
    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
  };
  var convertToNegativePattern = function(pattern) {
    return "!" + pattern;
  };
  var isNegativePattern = function(pattern) {
    return pattern.startsWith("!") && pattern[1] !== "(";
  };
  var isPositivePattern = function(pattern) {
    return !isNegativePattern(pattern);
  };
  var getNegativePatterns = function(patterns) {
    return patterns.filter(isNegativePattern);
  };
  var getPositivePatterns = function(patterns) {
    return patterns.filter(isPositivePattern);
  };
  var getPatternsInsideCurrentDirectory = function(patterns) {
    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
  };
  var getPatternsOutsideCurrentDirectory = function(patterns) {
    return patterns.filter(isPatternRelatedToParentDirectory);
  };
  var isPatternRelatedToParentDirectory = function(pattern) {
    return pattern.startsWith("..") || pattern.startsWith("./..");
  };
  var getBaseDirectory = function(pattern) {
    return globParent(pattern, { flipBackslashes: false });
  };
  var hasGlobStar = function(pattern) {
    return pattern.includes(GLOBSTAR);
  };
  var endsWithSlashGlobStar = function(pattern) {
    return pattern.endsWith("/" + GLOBSTAR);
  };
  var isAffectDepthOfReadingPattern = function(pattern) {
    const basename = path.basename(pattern);
    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
  };
  var expandPatternsWithBraceExpansion = function(patterns) {
    return patterns.reduce((collection47, pattern) => {
      return collection47.concat(expandBraceExpansion(pattern));
    }, []);
  };
  var expandBraceExpansion = function(pattern) {
    const patterns = micromatch.braces(pattern, { expand: true, nodupes: true });
    patterns.sort((a, b) => a.length - b.length);
    return patterns.filter((pattern2) => pattern2 !== "");
  };
  var getPatternParts = function(pattern, options) {
    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
    if (parts.length === 0) {
      parts = [pattern];
    }
    if (parts[0].startsWith("/")) {
      parts[0] = parts[0].slice(1);
      parts.unshift("");
    }
    return parts;
  };
  var makeRe = function(pattern, options) {
    return micromatch.makeRe(pattern, options);
  };
  var convertPatternsToRe = function(patterns, options) {
    return patterns.map((pattern) => makeRe(pattern, options));
  };
  var matchAny = function(entry, patternsRe) {
    return patternsRe.some((patternRe) => patternRe.test(entry));
  };
  var removeDuplicateSlashes = function(pattern) {
    return pattern.replace(DOUBLE_SLASH_RE, "/");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = undefined;
  var path = __require("path");
  var globParent = require_glob_parent();
  var micromatch = require_micromatch();
  var GLOBSTAR = "**";
  var ESCAPE_SYMBOL = "\\";
  var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
  var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
  var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
  var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
  var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
  var DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
  exports.isStaticPattern = isStaticPattern;
  exports.isDynamicPattern = isDynamicPattern;
  exports.convertToPositivePattern = convertToPositivePattern;
  exports.convertToNegativePattern = convertToNegativePattern;
  exports.isNegativePattern = isNegativePattern;
  exports.isPositivePattern = isPositivePattern;
  exports.getNegativePatterns = getNegativePatterns;
  exports.getPositivePatterns = getPositivePatterns;
  exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
  exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
  exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
  exports.getBaseDirectory = getBaseDirectory;
  exports.hasGlobStar = hasGlobStar;
  exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
  exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
  exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
  exports.expandBraceExpansion = expandBraceExpansion;
  exports.getPatternParts = getPatternParts;
  exports.makeRe = makeRe;
  exports.convertPatternsToRe = convertPatternsToRe;
  exports.matchAny = matchAny;
  exports.removeDuplicateSlashes = removeDuplicateSlashes;
});

// ../../node_modules/merge2/index.js
var require_merge2 = __commonJS((exports, module) => {
  var merge2 = function() {
    const streamsQueue = [];
    const args = slice.call(arguments);
    let merging = false;
    let options = args[args.length - 1];
    if (options && !Array.isArray(options) && options.pipe == null) {
      args.pop();
    } else {
      options = {};
    }
    const doEnd = options.end !== false;
    const doPipeError = options.pipeError === true;
    if (options.objectMode == null) {
      options.objectMode = true;
    }
    if (options.highWaterMark == null) {
      options.highWaterMark = 64 * 1024;
    }
    const mergedStream = PassThrough(options);
    function addStream() {
      for (let i3 = 0, len = arguments.length;i3 < len; i3++) {
        streamsQueue.push(pauseStreams(arguments[i3], options));
      }
      mergeStream();
      return this;
    }
    function mergeStream() {
      if (merging) {
        return;
      }
      merging = true;
      let streams = streamsQueue.shift();
      if (!streams) {
        process.nextTick(endStream);
        return;
      }
      if (!Array.isArray(streams)) {
        streams = [streams];
      }
      let pipesCount = streams.length + 1;
      function next() {
        if (--pipesCount > 0) {
          return;
        }
        merging = false;
        mergeStream();
      }
      function pipe(stream2) {
        function onend() {
          stream2.removeListener("merge2UnpipeEnd", onend);
          stream2.removeListener("end", onend);
          if (doPipeError) {
            stream2.removeListener("error", onerror);
          }
          next();
        }
        function onerror(err) {
          mergedStream.emit("error", err);
        }
        if (stream2._readableState.endEmitted) {
          return next();
        }
        stream2.on("merge2UnpipeEnd", onend);
        stream2.on("end", onend);
        if (doPipeError) {
          stream2.on("error", onerror);
        }
        stream2.pipe(mergedStream, { end: false });
        stream2.resume();
      }
      for (let i3 = 0;i3 < streams.length; i3++) {
        pipe(streams[i3]);
      }
      next();
    }
    function endStream() {
      merging = false;
      mergedStream.emit("queueDrain");
      if (doEnd) {
        mergedStream.end();
      }
    }
    mergedStream.setMaxListeners(0);
    mergedStream.add = addStream;
    mergedStream.on("unpipe", function(stream2) {
      stream2.emit("merge2UnpipeEnd");
    });
    if (args.length) {
      addStream.apply(null, args);
    }
    return mergedStream;
  };
  var pauseStreams = function(streams, options) {
    if (!Array.isArray(streams)) {
      if (!streams._readableState && streams.pipe) {
        streams = streams.pipe(PassThrough(options));
      }
      if (!streams._readableState || !streams.pause || !streams.pipe) {
        throw new Error("Only readable stream can be merged.");
      }
      streams.pause();
    } else {
      for (let i3 = 0, len = streams.length;i3 < len; i3++) {
        streams[i3] = pauseStreams(streams[i3], options);
      }
    }
    return streams;
  };
  var Stream = __require("stream");
  var PassThrough = Stream.PassThrough;
  var slice = Array.prototype.slice;
  module.exports = merge2;
});

// ../../node_modules/fast-glob/out/utils/stream.js
var require_stream2 = __commonJS((exports) => {
  var merge = function(streams) {
    const mergedStream = merge2(streams);
    streams.forEach((stream2) => {
      stream2.once("error", (error) => mergedStream.emit("error", error));
    });
    mergedStream.once("close", () => propagateCloseEventToSources(streams));
    mergedStream.once("end", () => propagateCloseEventToSources(streams));
    return mergedStream;
  };
  var propagateCloseEventToSources = function(streams) {
    streams.forEach((stream2) => stream2.emit("close"));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = undefined;
  var merge2 = require_merge2();
  exports.merge = merge;
});

// ../../node_modules/fast-glob/out/utils/string.js
var require_string = __commonJS((exports) => {
  var isString2 = function(input) {
    return typeof input === "string";
  };
  var isEmpty = function(input) {
    return input === "";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isEmpty = exports.isString = undefined;
  exports.isString = isString2;
  exports.isEmpty = isEmpty;
});

// ../../node_modules/fast-glob/out/utils/index.js
var require_utils3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = undefined;
  var array59 = require_array();
  exports.array = array59;
  var errno = require_errno();
  exports.errno = errno;
  var fs = require_fs();
  exports.fs = fs;
  var path = require_path();
  exports.path = path;
  var pattern = require_pattern();
  exports.pattern = pattern;
  var stream2 = require_stream2();
  exports.stream = stream2;
  var string31 = require_string();
  exports.string = string31;
});

// ../../node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS((exports) => {
  var generate = function(input, settings) {
    const patterns = processPatterns(input, settings);
    const ignore = processPatterns(settings.ignore, settings);
    const positivePatterns = getPositivePatterns(patterns);
    const negativePatterns = getNegativePatternsAsPositive(patterns, ignore);
    const staticPatterns = positivePatterns.filter((pattern) => utils19.pattern.isStaticPattern(pattern, settings));
    const dynamicPatterns = positivePatterns.filter((pattern) => utils19.pattern.isDynamicPattern(pattern, settings));
    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
    return staticTasks.concat(dynamicTasks);
  };
  var processPatterns = function(input, settings) {
    let patterns = input;
    if (settings.braceExpansion) {
      patterns = utils19.pattern.expandPatternsWithBraceExpansion(patterns);
    }
    if (settings.baseNameMatch) {
      patterns = patterns.map((pattern) => pattern.includes("/") ? pattern : `**/${pattern}`);
    }
    return patterns.map((pattern) => utils19.pattern.removeDuplicateSlashes(pattern));
  };
  var convertPatternsToTasks = function(positive, negative, dynamic) {
    const tasks = [];
    const patternsOutsideCurrentDirectory = utils19.pattern.getPatternsOutsideCurrentDirectory(positive);
    const patternsInsideCurrentDirectory = utils19.pattern.getPatternsInsideCurrentDirectory(positive);
    const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
    const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
    tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
    if ("." in insideCurrentDirectoryGroup) {
      tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
    } else {
      tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
    }
    return tasks;
  };
  var getPositivePatterns = function(patterns) {
    return utils19.pattern.getPositivePatterns(patterns);
  };
  var getNegativePatternsAsPositive = function(patterns, ignore) {
    const negative = utils19.pattern.getNegativePatterns(patterns).concat(ignore);
    const positive = negative.map(utils19.pattern.convertToPositivePattern);
    return positive;
  };
  var groupPatternsByBaseDirectory = function(patterns) {
    const group = {};
    return patterns.reduce((collection47, pattern) => {
      const base15 = utils19.pattern.getBaseDirectory(pattern);
      if (base15 in collection47) {
        collection47[base15].push(pattern);
      } else {
        collection47[base15] = [pattern];
      }
      return collection47;
    }, group);
  };
  var convertPatternGroupsToTasks = function(positive, negative, dynamic) {
    return Object.keys(positive).map((base15) => {
      return convertPatternGroupToTask(base15, positive[base15], negative, dynamic);
    });
  };
  var convertPatternGroupToTask = function(base15, positive, negative, dynamic) {
    return {
      dynamic,
      positive,
      negative,
      base: base15,
      patterns: [].concat(positive, negative.map(utils19.pattern.convertToNegativePattern))
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = undefined;
  var utils19 = require_utils3();
  exports.generate = generate;
  exports.convertPatternsToTasks = convertPatternsToTasks;
  exports.getPositivePatterns = getPositivePatterns;
  exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
  exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
  exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
  exports.convertPatternGroupToTask = convertPatternGroupToTask;
});

// ../../node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS((exports) => {
  var read = function(path, settings, callback) {
    settings.fs.lstat(path, (lstatError, lstat) => {
      if (lstatError !== null) {
        callFailureCallback(callback, lstatError);
        return;
      }
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        callSuccessCallback(callback, lstat);
        return;
      }
      settings.fs.stat(path, (statError, stat) => {
        if (statError !== null) {
          if (settings.throwErrorOnBrokenSymbolicLink) {
            callFailureCallback(callback, statError);
            return;
          }
          callSuccessCallback(callback, lstat);
          return;
        }
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        callSuccessCallback(callback, stat);
      });
    });
  };
  var callFailureCallback = function(callback, error) {
    callback(error);
  };
  var callSuccessCallback = function(callback, result) {
    callback(null, result);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.read = undefined;
  exports.read = read;
});

// ../../node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS((exports) => {
  var read = function(path, settings) {
    const lstat = settings.fs.lstatSync(path);
    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
      return lstat;
    }
    try {
      const stat = settings.fs.statSync(path);
      if (settings.markSymbolicLink) {
        stat.isSymbolicLink = () => true;
      }
      return stat;
    } catch (error) {
      if (!settings.throwErrorOnBrokenSymbolicLink) {
        return lstat;
      }
      throw error;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.read = undefined;
  exports.read = read;
});

// ../../node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs2 = __commonJS((exports) => {
  var createFileSystemAdapter = function(fsMethods) {
    if (fsMethods === undefined) {
      return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = undefined;
  var fs = __require("fs");
  exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync
  };
  exports.createFileSystemAdapter = createFileSystemAdapter;
});

// ../../node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var fs = require_fs2();

  class Settings {
    constructor(_options = {}) {
      this._options = _options;
      this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
      this.fs = fs.createFileSystemAdapter(this._options.fs);
      this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    }
    _getValue(option, value) {
      return option !== null && option !== undefined ? option : value;
    }
  }
  exports.default = Settings;
});

// ../../node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS((exports) => {
  var stat = function(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === "function") {
      async.read(path, getSettings(), optionsOrSettingsOrCallback);
      return;
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
  };
  var statSync = function(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
  };
  var getSettings = function(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
      return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.statSync = exports.stat = exports.Settings = undefined;
  var async = require_async();
  var sync = require_sync();
  var settings_1 = require_settings();
  exports.Settings = settings_1.default;
  exports.stat = stat;
  exports.statSync = statSync;
});

// ../../node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS((exports, module) => {
  /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var promise;
  module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : globalThis) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
    throw err;
  }, 0));
});

// ../../node_modules/run-parallel/index.js
var require_run_parallel = __commonJS((exports, module) => {
  var runParallel = function(tasks, cb) {
    let results, pending, keys;
    let isSync = true;
    if (Array.isArray(tasks)) {
      results = [];
      pending = tasks.length;
    } else {
      keys = Object.keys(tasks);
      results = {};
      pending = keys.length;
    }
    function done(err) {
      function end() {
        if (cb)
          cb(err, results);
        cb = null;
      }
      if (isSync)
        queueMicrotask2(end);
      else
        end();
    }
    function each(i3, err, result) {
      results[i3] = result;
      if (--pending === 0 || err) {
        done(err);
      }
    }
    if (!pending) {
      done(null);
    } else if (keys) {
      keys.forEach(function(key) {
        tasks[key](function(err, result) {
          each(key, err, result);
        });
      });
    } else {
      tasks.forEach(function(task, i3) {
        task(function(err, result) {
          each(i3, err, result);
        });
      });
    }
    isSync = false;
  };
  /*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  module.exports = runParallel;
  var queueMicrotask2 = require_queue_microtask();
});

// ../../node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = undefined;
  var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
  if (NODE_PROCESS_VERSION_PARTS[0] === undefined || NODE_PROCESS_VERSION_PARTS[1] === undefined) {
    throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
  }
  var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
  var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
  var SUPPORTED_MAJOR_VERSION = 10;
  var SUPPORTED_MINOR_VERSION = 10;
  var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
  var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
  exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
});

// ../../node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs3 = __commonJS((exports) => {
  var createDirentFromStats = function(name302, stats) {
    return new DirentFromStats(name302, stats);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDirentFromStats = undefined;

  class DirentFromStats {
    constructor(name302, stats) {
      this.name = name302;
      this.isBlockDevice = stats.isBlockDevice.bind(stats);
      this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
      this.isDirectory = stats.isDirectory.bind(stats);
      this.isFIFO = stats.isFIFO.bind(stats);
      this.isFile = stats.isFile.bind(stats);
      this.isSocket = stats.isSocket.bind(stats);
      this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
  }
  exports.createDirentFromStats = createDirentFromStats;
});

// ../../node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fs = undefined;
  var fs = require_fs3();
  exports.fs = fs;
});

// ../../node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common = __commonJS((exports) => {
  var joinPathSegments = function(a, b, separator) {
    if (a.endsWith(separator)) {
      return a + b;
    }
    return a + separator + b;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.joinPathSegments = undefined;
  exports.joinPathSegments = joinPathSegments;
});

// ../../node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS((exports) => {
  var read = function(directory, settings, callback) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
      readdirWithFileTypes(directory, settings, callback);
      return;
    }
    readdir(directory, settings, callback);
  };
  var readdirWithFileTypes = function(directory, settings, callback) {
    settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
      if (readdirError !== null) {
        callFailureCallback(callback, readdirError);
        return;
      }
      const entries = dirents.map((dirent) => ({
        dirent,
        name: dirent.name,
        path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
      }));
      if (!settings.followSymbolicLinks) {
        callSuccessCallback(callback, entries);
        return;
      }
      const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
      rpl(tasks, (rplError, rplEntries) => {
        if (rplError !== null) {
          callFailureCallback(callback, rplError);
          return;
        }
        callSuccessCallback(callback, rplEntries);
      });
    });
  };
  var makeRplTaskEntry = function(entry, settings) {
    return (done) => {
      if (!entry.dirent.isSymbolicLink()) {
        done(null, entry);
        return;
      }
      settings.fs.stat(entry.path, (statError, stats) => {
        if (statError !== null) {
          if (settings.throwErrorOnBrokenSymbolicLink) {
            done(statError);
            return;
          }
          done(null, entry);
          return;
        }
        entry.dirent = utils19.fs.createDirentFromStats(entry.name, stats);
        done(null, entry);
      });
    };
  };
  var readdir = function(directory, settings, callback) {
    settings.fs.readdir(directory, (readdirError, names) => {
      if (readdirError !== null) {
        callFailureCallback(callback, readdirError);
        return;
      }
      const tasks = names.map((name302) => {
        const path = common.joinPathSegments(directory, name302, settings.pathSegmentSeparator);
        return (done) => {
          fsStat.stat(path, settings.fsStatSettings, (error, stats) => {
            if (error !== null) {
              done(error);
              return;
            }
            const entry = {
              name: name302,
              path,
              dirent: utils19.fs.createDirentFromStats(name302, stats)
            };
            if (settings.stats) {
              entry.stats = stats;
            }
            done(null, entry);
          });
        };
      });
      rpl(tasks, (rplError, entries) => {
        if (rplError !== null) {
          callFailureCallback(callback, rplError);
          return;
        }
        callSuccessCallback(callback, entries);
      });
    });
  };
  var callFailureCallback = function(callback, error) {
    callback(error);
  };
  var callSuccessCallback = function(callback, result) {
    callback(null, result);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readdir = exports.readdirWithFileTypes = exports.read = undefined;
  var fsStat = require_out();
  var rpl = require_run_parallel();
  var constants_1 = require_constants4();
  var utils19 = require_utils4();
  var common = require_common();
  exports.read = read;
  exports.readdirWithFileTypes = readdirWithFileTypes;
  exports.readdir = readdir;
});

// ../../node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS((exports) => {
  var read = function(directory, settings) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
      return readdirWithFileTypes(directory, settings);
    }
    return readdir(directory, settings);
  };
  var readdirWithFileTypes = function(directory, settings) {
    const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
    return dirents.map((dirent) => {
      const entry = {
        dirent,
        name: dirent.name,
        path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
      };
      if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
        try {
          const stats = settings.fs.statSync(entry.path);
          entry.dirent = utils19.fs.createDirentFromStats(entry.name, stats);
        } catch (error) {
          if (settings.throwErrorOnBrokenSymbolicLink) {
            throw error;
          }
        }
      }
      return entry;
    });
  };
  var readdir = function(directory, settings) {
    const names = settings.fs.readdirSync(directory);
    return names.map((name302) => {
      const entryPath = common.joinPathSegments(directory, name302, settings.pathSegmentSeparator);
      const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
      const entry = {
        name: name302,
        path: entryPath,
        dirent: utils19.fs.createDirentFromStats(name302, stats)
      };
      if (settings.stats) {
        entry.stats = stats;
      }
      return entry;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readdir = exports.readdirWithFileTypes = exports.read = undefined;
  var fsStat = require_out();
  var constants_1 = require_constants4();
  var utils19 = require_utils4();
  var common = require_common();
  exports.read = read;
  exports.readdirWithFileTypes = readdirWithFileTypes;
  exports.readdir = readdir;
});

// ../../node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs4 = __commonJS((exports) => {
  var createFileSystemAdapter = function(fsMethods) {
    if (fsMethods === undefined) {
      return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = undefined;
  var fs = __require("fs");
  exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
  };
  exports.createFileSystemAdapter = createFileSystemAdapter;
});

// ../../node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var path = __require("path");
  var fsStat = require_out();
  var fs = require_fs4();

  class Settings {
    constructor(_options = {}) {
      this._options = _options;
      this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
      this.fs = fs.createFileSystemAdapter(this._options.fs);
      this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
      this.stats = this._getValue(this._options.stats, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      this.fsStatSettings = new fsStat.Settings({
        followSymbolicLink: this.followSymbolicLinks,
        fs: this.fs,
        throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
      });
    }
    _getValue(option, value) {
      return option !== null && option !== undefined ? option : value;
    }
  }
  exports.default = Settings;
});

// ../../node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS((exports) => {
  var scandir = function(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === "function") {
      async.read(path, getSettings(), optionsOrSettingsOrCallback);
      return;
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
  };
  var scandirSync = function(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
  };
  var getSettings = function(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
      return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Settings = exports.scandirSync = exports.scandir = undefined;
  var async = require_async2();
  var sync = require_sync2();
  var settings_1 = require_settings2();
  exports.Settings = settings_1.default;
  exports.scandir = scandir;
  exports.scandirSync = scandirSync;
});

// ../../node_modules/reusify/reusify.js
var require_reusify = __commonJS((exports, module) => {
  var reusify = function(Constructor) {
    var head = new Constructor;
    var tail = head;
    function get() {
      var current = head;
      if (current.next) {
        head = current.next;
      } else {
        head = new Constructor;
        tail = head;
      }
      current.next = null;
      return current;
    }
    function release(obj) {
      tail.next = obj;
      tail = obj;
    }
    return {
      get,
      release
    };
  };
  module.exports = reusify;
});

// ../../node_modules/fastq/queue.js
var require_queue = __commonJS((exports, module) => {
  var fastqueue = function(context2, worker, concurrency) {
    if (typeof context2 === "function") {
      concurrency = worker;
      worker = context2;
      context2 = null;
    }
    if (concurrency < 1) {
      throw new Error("fastqueue concurrency must be greater than 1");
    }
    var cache = reusify(Task);
    var queueHead = null;
    var queueTail = null;
    var _running = 0;
    var errorHandler = null;
    var self2 = {
      push: push2,
      drain: noop5,
      saturated: noop5,
      pause,
      paused: false,
      concurrency,
      running,
      resume,
      idle,
      length,
      getQueue,
      unshift,
      empty: noop5,
      kill,
      killAndDrain,
      error
    };
    return self2;
    function running() {
      return _running;
    }
    function pause() {
      self2.paused = true;
    }
    function length() {
      var current = queueHead;
      var counter = 0;
      while (current) {
        current = current.next;
        counter++;
      }
      return counter;
    }
    function getQueue() {
      var current = queueHead;
      var tasks = [];
      while (current) {
        tasks.push(current.value);
        current = current.next;
      }
      return tasks;
    }
    function resume() {
      if (!self2.paused)
        return;
      self2.paused = false;
      for (var i3 = 0;i3 < self2.concurrency; i3++) {
        _running++;
        release();
      }
    }
    function idle() {
      return _running === 0 && self2.length() === 0;
    }
    function push2(value, done) {
      var current = cache.get();
      current.context = context2;
      current.release = release;
      current.value = value;
      current.callback = done || noop5;
      current.errorHandler = errorHandler;
      if (_running === self2.concurrency || self2.paused) {
        if (queueTail) {
          queueTail.next = current;
          queueTail = current;
        } else {
          queueHead = current;
          queueTail = current;
          self2.saturated();
        }
      } else {
        _running++;
        worker.call(context2, current.value, current.worked);
      }
    }
    function unshift(value, done) {
      var current = cache.get();
      current.context = context2;
      current.release = release;
      current.value = value;
      current.callback = done || noop5;
      if (_running === self2.concurrency || self2.paused) {
        if (queueHead) {
          current.next = queueHead;
          queueHead = current;
        } else {
          queueHead = current;
          queueTail = current;
          self2.saturated();
        }
      } else {
        _running++;
        worker.call(context2, current.value, current.worked);
      }
    }
    function release(holder) {
      if (holder) {
        cache.release(holder);
      }
      var next = queueHead;
      if (next) {
        if (!self2.paused) {
          if (queueTail === queueHead) {
            queueTail = null;
          }
          queueHead = next.next;
          next.next = null;
          worker.call(context2, next.value, next.worked);
          if (queueTail === null) {
            self2.empty();
          }
        } else {
          _running--;
        }
      } else if (--_running === 0) {
        self2.drain();
      }
    }
    function kill() {
      queueHead = null;
      queueTail = null;
      self2.drain = noop5;
    }
    function killAndDrain() {
      queueHead = null;
      queueTail = null;
      self2.drain();
      self2.drain = noop5;
    }
    function error(handler) {
      errorHandler = handler;
    }
  };
  var noop5 = function() {
  };
  var Task = function() {
    this.value = null;
    this.callback = noop5;
    this.next = null;
    this.release = noop5;
    this.context = null;
    this.errorHandler = null;
    var self2 = this;
    this.worked = function worked(err, result) {
      var callback = self2.callback;
      var errorHandler = self2.errorHandler;
      var val = self2.value;
      self2.value = null;
      self2.callback = noop5;
      if (self2.errorHandler) {
        errorHandler(err, val);
      }
      callback.call(self2.context, err, result);
      self2.release(self2);
    };
  };
  var queueAsPromised = function(context2, worker, concurrency) {
    if (typeof context2 === "function") {
      concurrency = worker;
      worker = context2;
      context2 = null;
    }
    function asyncWrapper(arg3, cb) {
      worker.call(this, arg3).then(function(res) {
        cb(null, res);
      }, cb);
    }
    var queue = fastqueue(context2, asyncWrapper, concurrency);
    var pushCb = queue.push;
    var unshiftCb = queue.unshift;
    queue.push = push2;
    queue.unshift = unshift;
    queue.drained = drained;
    return queue;
    function push2(value) {
      var p = new Promise(function(resolve4, reject2) {
        pushCb(value, function(err, result) {
          if (err) {
            reject2(err);
            return;
          }
          resolve4(result);
        });
      });
      p.catch(noop5);
      return p;
    }
    function unshift(value) {
      var p = new Promise(function(resolve4, reject2) {
        unshiftCb(value, function(err, result) {
          if (err) {
            reject2(err);
            return;
          }
          resolve4(result);
        });
      });
      p.catch(noop5);
      return p;
    }
    function drained() {
      var previousDrain = queue.drain;
      var p = new Promise(function(resolve4) {
        queue.drain = function() {
          previousDrain();
          resolve4();
        };
      });
      return p;
    }
  };
  var reusify = require_reusify();
  module.exports = fastqueue;
  module.exports.promise = queueAsPromised;
});

// ../../node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common2 = __commonJS((exports) => {
  var isFatalError = function(settings, error) {
    if (settings.errorFilter === null) {
      return true;
    }
    return !settings.errorFilter(error);
  };
  var isAppliedFilter = function(filter4, value) {
    return filter4 === null || filter4(value);
  };
  var replacePathSegmentSeparator = function(filepath, separator) {
    return filepath.split(/[/\\]/).join(separator);
  };
  var joinPathSegments = function(a, b, separator) {
    if (a === "") {
      return b;
    }
    if (a.endsWith(separator)) {
      return a + b;
    }
    return a + separator + b;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = undefined;
  exports.isFatalError = isFatalError;
  exports.isAppliedFilter = isAppliedFilter;
  exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
  exports.joinPathSegments = joinPathSegments;
});

// ../../node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var common = require_common2();

  class Reader {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
    }
  }
  exports.default = Reader;
});

// ../../node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var events_1 = __require("events");
  var fsScandir = require_out2();
  var fastq = require_queue();
  var common = require_common2();
  var reader_1 = require_reader();

  class AsyncReader extends reader_1.default {
    constructor(_root, _settings) {
      super(_root, _settings);
      this._settings = _settings;
      this._scandir = fsScandir.scandir;
      this._emitter = new events_1.EventEmitter;
      this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
      this._isFatalError = false;
      this._isDestroyed = false;
      this._queue.drain = () => {
        if (!this._isFatalError) {
          this._emitter.emit("end");
        }
      };
    }
    read() {
      this._isFatalError = false;
      this._isDestroyed = false;
      setImmediate(() => {
        this._pushToQueue(this._root, this._settings.basePath);
      });
      return this._emitter;
    }
    get isDestroyed() {
      return this._isDestroyed;
    }
    destroy() {
      if (this._isDestroyed) {
        throw new Error("The reader is already destroyed");
      }
      this._isDestroyed = true;
      this._queue.killAndDrain();
    }
    onEntry(callback) {
      this._emitter.on("entry", callback);
    }
    onError(callback) {
      this._emitter.once("error", callback);
    }
    onEnd(callback) {
      this._emitter.once("end", callback);
    }
    _pushToQueue(directory, base15) {
      const queueItem = { directory, base: base15 };
      this._queue.push(queueItem, (error) => {
        if (error !== null) {
          this._handleError(error);
        }
      });
    }
    _worker(item, done) {
      this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
        if (error !== null) {
          done(error, undefined);
          return;
        }
        for (const entry of entries) {
          this._handleEntry(entry, item.base);
        }
        done(null, undefined);
      });
    }
    _handleError(error) {
      if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
        return;
      }
      this._isFatalError = true;
      this._isDestroyed = true;
      this._emitter.emit("error", error);
    }
    _handleEntry(entry, base15) {
      if (this._isDestroyed || this._isFatalError) {
        return;
      }
      const fullpath = entry.path;
      if (base15 !== undefined) {
        entry.path = common.joinPathSegments(base15, entry.name, this._settings.pathSegmentSeparator);
      }
      if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
        this._emitEntry(entry);
      }
      if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
        this._pushToQueue(fullpath, base15 === undefined ? undefined : entry.path);
      }
    }
    _emitEntry(entry) {
      this._emitter.emit("entry", entry);
    }
  }
  exports.default = AsyncReader;
});

// ../../node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS((exports) => {
  var callFailureCallback = function(callback, error) {
    callback(error);
  };
  var callSuccessCallback = function(callback, entries) {
    callback(null, entries);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var async_1 = require_async3();

  class AsyncProvider {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._reader = new async_1.default(this._root, this._settings);
      this._storage = [];
    }
    read(callback) {
      this._reader.onError((error) => {
        callFailureCallback(callback, error);
      });
      this._reader.onEntry((entry) => {
        this._storage.push(entry);
      });
      this._reader.onEnd(() => {
        callSuccessCallback(callback, this._storage);
      });
      this._reader.read();
    }
  }
  exports.default = AsyncProvider;
});

// ../../node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream_1 = __require("stream");
  var async_1 = require_async3();

  class StreamProvider {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._reader = new async_1.default(this._root, this._settings);
      this._stream = new stream_1.Readable({
        objectMode: true,
        read: () => {
        },
        destroy: () => {
          if (!this._reader.isDestroyed) {
            this._reader.destroy();
          }
        }
      });
    }
    read() {
      this._reader.onError((error) => {
        this._stream.emit("error", error);
      });
      this._reader.onEntry((entry) => {
        this._stream.push(entry);
      });
      this._reader.onEnd(() => {
        this._stream.push(null);
      });
      this._reader.read();
      return this._stream;
    }
  }
  exports.default = StreamProvider;
});

// ../../node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var fsScandir = require_out2();
  var common = require_common2();
  var reader_1 = require_reader();

  class SyncReader extends reader_1.default {
    constructor() {
      super(...arguments);
      this._scandir = fsScandir.scandirSync;
      this._storage = [];
      this._queue = new Set;
    }
    read() {
      this._pushToQueue(this._root, this._settings.basePath);
      this._handleQueue();
      return this._storage;
    }
    _pushToQueue(directory, base15) {
      this._queue.add({ directory, base: base15 });
    }
    _handleQueue() {
      for (const item of this._queue.values()) {
        this._handleDirectory(item.directory, item.base);
      }
    }
    _handleDirectory(directory, base15) {
      try {
        const entries = this._scandir(directory, this._settings.fsScandirSettings);
        for (const entry of entries) {
          this._handleEntry(entry, base15);
        }
      } catch (error) {
        this._handleError(error);
      }
    }
    _handleError(error) {
      if (!common.isFatalError(this._settings, error)) {
        return;
      }
      throw error;
    }
    _handleEntry(entry, base15) {
      const fullpath = entry.path;
      if (base15 !== undefined) {
        entry.path = common.joinPathSegments(base15, entry.name, this._settings.pathSegmentSeparator);
      }
      if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
        this._pushToStorage(entry);
      }
      if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
        this._pushToQueue(fullpath, base15 === undefined ? undefined : entry.path);
      }
    }
    _pushToStorage(entry) {
      this._storage.push(entry);
    }
  }
  exports.default = SyncReader;
});

// ../../node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var sync_1 = require_sync3();

  class SyncProvider {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._reader = new sync_1.default(this._root, this._settings);
    }
    read() {
      return this._reader.read();
    }
  }
  exports.default = SyncProvider;
});

// ../../node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var path = __require("path");
  var fsScandir = require_out2();

  class Settings {
    constructor(_options = {}) {
      this._options = _options;
      this.basePath = this._getValue(this._options.basePath, undefined);
      this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
      this.deepFilter = this._getValue(this._options.deepFilter, null);
      this.entryFilter = this._getValue(this._options.entryFilter, null);
      this.errorFilter = this._getValue(this._options.errorFilter, null);
      this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
      this.fsScandirSettings = new fsScandir.Settings({
        followSymbolicLinks: this._options.followSymbolicLinks,
        fs: this._options.fs,
        pathSegmentSeparator: this._options.pathSegmentSeparator,
        stats: this._options.stats,
        throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
      });
    }
    _getValue(option, value) {
      return option !== null && option !== undefined ? option : value;
    }
  }
  exports.default = Settings;
});

// ../../node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS((exports) => {
  var walk = function(directory, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === "function") {
      new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
      return;
    }
    new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
  };
  var walkSync = function(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new sync_1.default(directory, settings);
    return provider.read();
  };
  var walkStream = function(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new stream_1.default(directory, settings);
    return provider.read();
  };
  var getSettings = function(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
      return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Settings = exports.walkStream = exports.walkSync = exports.walk = undefined;
  var async_1 = require_async4();
  var stream_1 = require_stream3();
  var sync_1 = require_sync4();
  var settings_1 = require_settings3();
  exports.Settings = settings_1.default;
  exports.walk = walk;
  exports.walkSync = walkSync;
  exports.walkStream = walkStream;
});

// ../../node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var path = __require("path");
  var fsStat = require_out();
  var utils19 = require_utils3();

  class Reader {
    constructor(_settings) {
      this._settings = _settings;
      this._fsStatSettings = new fsStat.Settings({
        followSymbolicLink: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
      });
    }
    _getFullEntryPath(filepath) {
      return path.resolve(this._settings.cwd, filepath);
    }
    _makeEntry(stats, pattern) {
      const entry = {
        name: pattern,
        path: pattern,
        dirent: utils19.fs.createDirentFromStats(pattern, stats)
      };
      if (this._settings.stats) {
        entry.stats = stats;
      }
      return entry;
    }
    _isFatalError(error) {
      return !utils19.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
    }
  }
  exports.default = Reader;
});

// ../../node_modules/fast-glob/out/readers/stream.js
var require_stream4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream_1 = __require("stream");
  var fsStat = require_out();
  var fsWalk = require_out3();
  var reader_1 = require_reader2();

  class ReaderStream extends reader_1.default {
    constructor() {
      super(...arguments);
      this._walkStream = fsWalk.walkStream;
      this._stat = fsStat.stat;
    }
    dynamic(root, options) {
      return this._walkStream(root, options);
    }
    static(patterns, options) {
      const filepaths = patterns.map(this._getFullEntryPath, this);
      const stream2 = new stream_1.PassThrough({ objectMode: true });
      stream2._write = (index2, _enc, done) => {
        return this._getEntry(filepaths[index2], patterns[index2], options).then((entry) => {
          if (entry !== null && options.entryFilter(entry)) {
            stream2.push(entry);
          }
          if (index2 === filepaths.length - 1) {
            stream2.end();
          }
          done();
        }).catch(done);
      };
      for (let i3 = 0;i3 < filepaths.length; i3++) {
        stream2.write(i3);
      }
      return stream2;
    }
    _getEntry(filepath, pattern, options) {
      return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
        if (options.errorFilter(error)) {
          return null;
        }
        throw error;
      });
    }
    _getStat(filepath) {
      return new Promise((resolve4, reject2) => {
        this._stat(filepath, this._fsStatSettings, (error, stats) => {
          return error === null ? resolve4(stats) : reject2(error);
        });
      });
    }
  }
  exports.default = ReaderStream;
});

// ../../node_modules/fast-glob/out/readers/async.js
var require_async5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var fsWalk = require_out3();
  var reader_1 = require_reader2();
  var stream_1 = require_stream4();

  class ReaderAsync extends reader_1.default {
    constructor() {
      super(...arguments);
      this._walkAsync = fsWalk.walk;
      this._readerStream = new stream_1.default(this._settings);
    }
    dynamic(root, options) {
      return new Promise((resolve4, reject2) => {
        this._walkAsync(root, options, (error, entries) => {
          if (error === null) {
            resolve4(entries);
          } else {
            reject2(error);
          }
        });
      });
    }
    async static(patterns, options) {
      const entries = [];
      const stream2 = this._readerStream.static(patterns, options);
      return new Promise((resolve4, reject2) => {
        stream2.once("error", reject2);
        stream2.on("data", (entry) => entries.push(entry));
        stream2.once("end", () => resolve4(entries));
      });
    }
  }
  exports.default = ReaderAsync;
});

// ../../node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils19 = require_utils3();

  class Matcher {
    constructor(_patterns, _settings, _micromatchOptions) {
      this._patterns = _patterns;
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
      this._storage = [];
      this._fillStorage();
    }
    _fillStorage() {
      for (const pattern of this._patterns) {
        const segments = this._getPatternSegments(pattern);
        const sections = this._splitSegmentsIntoSections(segments);
        this._storage.push({
          complete: sections.length <= 1,
          pattern,
          segments,
          sections
        });
      }
    }
    _getPatternSegments(pattern) {
      const parts = utils19.pattern.getPatternParts(pattern, this._micromatchOptions);
      return parts.map((part) => {
        const dynamic = utils19.pattern.isDynamicPattern(part, this._settings);
        if (!dynamic) {
          return {
            dynamic: false,
            pattern: part
          };
        }
        return {
          dynamic: true,
          pattern: part,
          patternRe: utils19.pattern.makeRe(part, this._micromatchOptions)
        };
      });
    }
    _splitSegmentsIntoSections(segments) {
      return utils19.array.splitWhen(segments, (segment2) => segment2.dynamic && utils19.pattern.hasGlobStar(segment2.pattern));
    }
  }
  exports.default = Matcher;
});

// ../../node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var matcher_1 = require_matcher();

  class PartialMatcher extends matcher_1.default {
    match(filepath) {
      const parts = filepath.split("/");
      const levels = parts.length;
      const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
      for (const pattern of patterns) {
        const section = pattern.sections[0];
        if (!pattern.complete && levels > section.length) {
          return true;
        }
        const match = parts.every((part, index2) => {
          const segment2 = pattern.segments[index2];
          if (segment2.dynamic && segment2.patternRe.test(part)) {
            return true;
          }
          if (!segment2.dynamic && segment2.pattern === part) {
            return true;
          }
          return false;
        });
        if (match) {
          return true;
        }
      }
      return false;
    }
  }
  exports.default = PartialMatcher;
});

// ../../node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils19 = require_utils3();
  var partial_1 = require_partial();

  class DeepFilter {
    constructor(_settings, _micromatchOptions) {
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
    }
    getFilter(basePath, positive, negative) {
      const matcher = this._getMatcher(positive);
      const negativeRe = this._getNegativePatternsRe(negative);
      return (entry) => this._filter(basePath, entry, matcher, negativeRe);
    }
    _getMatcher(patterns) {
      return new partial_1.default(patterns, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(patterns) {
      const affectDepthOfReadingPatterns = patterns.filter(utils19.pattern.isAffectDepthOfReadingPattern);
      return utils19.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
    }
    _filter(basePath, entry, matcher, negativeRe) {
      if (this._isSkippedByDeep(basePath, entry.path)) {
        return false;
      }
      if (this._isSkippedSymbolicLink(entry)) {
        return false;
      }
      const filepath = utils19.path.removeLeadingDotSegment(entry.path);
      if (this._isSkippedByPositivePatterns(filepath, matcher)) {
        return false;
      }
      return this._isSkippedByNegativePatterns(filepath, negativeRe);
    }
    _isSkippedByDeep(basePath, entryPath) {
      if (this._settings.deep === Infinity) {
        return false;
      }
      return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
    }
    _getEntryLevel(basePath, entryPath) {
      const entryPathDepth = entryPath.split("/").length;
      if (basePath === "") {
        return entryPathDepth;
      }
      const basePathDepth = basePath.split("/").length;
      return entryPathDepth - basePathDepth;
    }
    _isSkippedSymbolicLink(entry) {
      return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
    }
    _isSkippedByPositivePatterns(entryPath, matcher) {
      return !this._settings.baseNameMatch && !matcher.match(entryPath);
    }
    _isSkippedByNegativePatterns(entryPath, patternsRe) {
      return !utils19.pattern.matchAny(entryPath, patternsRe);
    }
  }
  exports.default = DeepFilter;
});

// ../../node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils19 = require_utils3();

  class EntryFilter {
    constructor(_settings, _micromatchOptions) {
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
      this.index = new Map;
    }
    getFilter(positive, negative) {
      const positiveRe = utils19.pattern.convertPatternsToRe(positive, this._micromatchOptions);
      const negativeRe = utils19.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true }));
      return (entry) => this._filter(entry, positiveRe, negativeRe);
    }
    _filter(entry, positiveRe, negativeRe) {
      const filepath = utils19.path.removeLeadingDotSegment(entry.path);
      if (this._settings.unique && this._isDuplicateEntry(filepath)) {
        return false;
      }
      if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
        return false;
      }
      if (this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe)) {
        return false;
      }
      const isDirectory = entry.dirent.isDirectory();
      const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory);
      if (this._settings.unique && isMatched) {
        this._createIndexRecord(filepath);
      }
      return isMatched;
    }
    _isDuplicateEntry(filepath) {
      return this.index.has(filepath);
    }
    _createIndexRecord(filepath) {
      this.index.set(filepath, undefined);
    }
    _onlyFileFilter(entry) {
      return this._settings.onlyFiles && !entry.dirent.isFile();
    }
    _onlyDirectoryFilter(entry) {
      return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    }
    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
      if (!this._settings.absolute) {
        return false;
      }
      const fullpath = utils19.path.makeAbsolute(this._settings.cwd, entryPath);
      return utils19.pattern.matchAny(fullpath, patternsRe);
    }
    _isMatchToPatterns(filepath, patternsRe, isDirectory) {
      const isMatched = utils19.pattern.matchAny(filepath, patternsRe);
      if (!isMatched && isDirectory) {
        return utils19.pattern.matchAny(filepath + "/", patternsRe);
      }
      return isMatched;
    }
  }
  exports.default = EntryFilter;
});

// ../../node_modules/fast-glob/out/providers/filters/error.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils19 = require_utils3();

  class ErrorFilter {
    constructor(_settings) {
      this._settings = _settings;
    }
    getFilter() {
      return (error) => this._isNonFatalError(error);
    }
    _isNonFatalError(error) {
      return utils19.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
    }
  }
  exports.default = ErrorFilter;
});

// ../../node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils19 = require_utils3();

  class EntryTransformer {
    constructor(_settings) {
      this._settings = _settings;
    }
    getTransformer() {
      return (entry) => this._transform(entry);
    }
    _transform(entry) {
      let filepath = entry.path;
      if (this._settings.absolute) {
        filepath = utils19.path.makeAbsolute(this._settings.cwd, filepath);
        filepath = utils19.path.unixify(filepath);
      }
      if (this._settings.markDirectories && entry.dirent.isDirectory()) {
        filepath += "/";
      }
      if (!this._settings.objectMode) {
        return filepath;
      }
      return Object.assign(Object.assign({}, entry), { path: filepath });
    }
  }
  exports.default = EntryTransformer;
});

// ../../node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var path = __require("path");
  var deep_1 = require_deep();
  var entry_1 = require_entry();
  var error_1 = require_error();
  var entry_2 = require_entry2();

  class Provider {
    constructor(_settings) {
      this._settings = _settings;
      this.errorFilter = new error_1.default(this._settings);
      this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
      this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
      this.entryTransformer = new entry_2.default(this._settings);
    }
    _getRootDirectory(task) {
      return path.resolve(this._settings.cwd, task.base);
    }
    _getReaderOptions(task) {
      const basePath = task.base === "." ? "" : task.base;
      return {
        basePath,
        pathSegmentSeparator: "/",
        concurrency: this._settings.concurrency,
        deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
        entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
        errorFilter: this.errorFilter.getFilter(),
        followSymbolicLinks: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        stats: this._settings.stats,
        throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
        transform: this.entryTransformer.getTransformer()
      };
    }
    _getMicromatchOptions() {
      return {
        dot: this._settings.dot,
        matchBase: this._settings.baseNameMatch,
        nobrace: !this._settings.braceExpansion,
        nocase: !this._settings.caseSensitiveMatch,
        noext: !this._settings.extglob,
        noglobstar: !this._settings.globstar,
        posix: true,
        strictSlashes: false
      };
    }
  }
  exports.default = Provider;
});

// ../../node_modules/fast-glob/out/providers/async.js
var require_async6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var async_1 = require_async5();
  var provider_1 = require_provider();

  class ProviderAsync extends provider_1.default {
    constructor() {
      super(...arguments);
      this._reader = new async_1.default(this._settings);
    }
    async read(task) {
      const root = this._getRootDirectory(task);
      const options = this._getReaderOptions(task);
      const entries = await this.api(root, task, options);
      return entries.map((entry) => options.transform(entry));
    }
    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }
      return this._reader.static(task.patterns, options);
    }
  }
  exports.default = ProviderAsync;
});

// ../../node_modules/fast-glob/out/providers/stream.js
var require_stream5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream_1 = __require("stream");
  var stream_2 = require_stream4();
  var provider_1 = require_provider();

  class ProviderStream extends provider_1.default {
    constructor() {
      super(...arguments);
      this._reader = new stream_2.default(this._settings);
    }
    read(task) {
      const root = this._getRootDirectory(task);
      const options = this._getReaderOptions(task);
      const source = this.api(root, task, options);
      const destination = new stream_1.Readable({ objectMode: true, read: () => {
      } });
      source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
      destination.once("close", () => source.destroy());
      return destination;
    }
    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }
      return this._reader.static(task.patterns, options);
    }
  }
  exports.default = ProviderStream;
});

// ../../node_modules/fast-glob/out/readers/sync.js
var require_sync5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var fsStat = require_out();
  var fsWalk = require_out3();
  var reader_1 = require_reader2();

  class ReaderSync extends reader_1.default {
    constructor() {
      super(...arguments);
      this._walkSync = fsWalk.walkSync;
      this._statSync = fsStat.statSync;
    }
    dynamic(root, options) {
      return this._walkSync(root, options);
    }
    static(patterns, options) {
      const entries = [];
      for (const pattern of patterns) {
        const filepath = this._getFullEntryPath(pattern);
        const entry = this._getEntry(filepath, pattern, options);
        if (entry === null || !options.entryFilter(entry)) {
          continue;
        }
        entries.push(entry);
      }
      return entries;
    }
    _getEntry(filepath, pattern, options) {
      try {
        const stats = this._getStat(filepath);
        return this._makeEntry(stats, pattern);
      } catch (error) {
        if (options.errorFilter(error)) {
          return null;
        }
        throw error;
      }
    }
    _getStat(filepath) {
      return this._statSync(filepath, this._fsStatSettings);
    }
  }
  exports.default = ReaderSync;
});

// ../../node_modules/fast-glob/out/providers/sync.js
var require_sync6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var sync_1 = require_sync5();
  var provider_1 = require_provider();

  class ProviderSync extends provider_1.default {
    constructor() {
      super(...arguments);
      this._reader = new sync_1.default(this._settings);
    }
    read(task) {
      const root = this._getRootDirectory(task);
      const options = this._getReaderOptions(task);
      const entries = this.api(root, task, options);
      return entries.map(options.transform);
    }
    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }
      return this._reader.static(task.patterns, options);
    }
  }
  exports.default = ProviderSync;
});

// ../../node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_FILE_SYSTEM_ADAPTER = undefined;
  var fs = __require("fs");
  var os = __require("os");
  var CPU_COUNT = Math.max(os.cpus().length, 1);
  exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    lstatSync: fs.lstatSync,
    stat: fs.stat,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
  };

  class Settings {
    constructor(_options = {}) {
      this._options = _options;
      this.absolute = this._getValue(this._options.absolute, false);
      this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
      this.braceExpansion = this._getValue(this._options.braceExpansion, true);
      this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
      this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
      this.cwd = this._getValue(this._options.cwd, process.cwd());
      this.deep = this._getValue(this._options.deep, Infinity);
      this.dot = this._getValue(this._options.dot, false);
      this.extglob = this._getValue(this._options.extglob, true);
      this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
      this.fs = this._getFileSystemMethods(this._options.fs);
      this.globstar = this._getValue(this._options.globstar, true);
      this.ignore = this._getValue(this._options.ignore, []);
      this.markDirectories = this._getValue(this._options.markDirectories, false);
      this.objectMode = this._getValue(this._options.objectMode, false);
      this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
      this.onlyFiles = this._getValue(this._options.onlyFiles, true);
      this.stats = this._getValue(this._options.stats, false);
      this.suppressErrors = this._getValue(this._options.suppressErrors, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
      this.unique = this._getValue(this._options.unique, true);
      if (this.onlyDirectories) {
        this.onlyFiles = false;
      }
      if (this.stats) {
        this.objectMode = true;
      }
      this.ignore = [].concat(this.ignore);
    }
    _getValue(option, value) {
      return option === undefined ? value : option;
    }
    _getFileSystemMethods(methods = {}) {
      return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }
  }
  exports.default = Settings;
});

// ../../node_modules/fast-glob/out/index.js
var require_out4 = __commonJS((exports, module) => {
  async function FastGlob(source, options) {
    assertPatternsInput(source);
    const works = getWorks(source, async_1.default, options);
    const result = await Promise.all(works);
    return utils19.array.flatten(result);
  }
  var getWorks = function(source, _Provider, options) {
    const patterns = [].concat(source);
    const settings = new settings_1.default(options);
    const tasks = taskManager.generate(patterns, settings);
    const provider = new _Provider(settings);
    return tasks.map(provider.read, provider);
  };
  var assertPatternsInput = function(input) {
    const source = [].concat(input);
    const isValidSource = source.every((item) => utils19.string.isString(item) && !utils19.string.isEmpty(item));
    if (!isValidSource) {
      throw new TypeError("Patterns must be a string (non empty) or an array of strings");
    }
  };
  var taskManager = require_tasks();
  var async_1 = require_async6();
  var stream_1 = require_stream5();
  var sync_1 = require_sync6();
  var settings_1 = require_settings4();
  var utils19 = require_utils3();
  (function(FastGlob2) {
    FastGlob2.glob = FastGlob2;
    FastGlob2.globSync = sync;
    FastGlob2.globStream = stream2;
    FastGlob2.async = FastGlob2;
    function sync(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, sync_1.default, options);
      return utils19.array.flatten(works);
    }
    FastGlob2.sync = sync;
    function stream2(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, stream_1.default, options);
      return utils19.stream.merge(works);
    }
    FastGlob2.stream = stream2;
    function generateTasks(source, options) {
      assertPatternsInput(source);
      const patterns = [].concat(source);
      const settings = new settings_1.default(options);
      return taskManager.generate(patterns, settings);
    }
    FastGlob2.generateTasks = generateTasks;
    function isDynamicPattern(source, options) {
      assertPatternsInput(source);
      const settings = new settings_1.default(options);
      return utils19.pattern.isDynamicPattern(source, settings);
    }
    FastGlob2.isDynamicPattern = isDynamicPattern;
    function escapePath(source) {
      assertPatternsInput(source);
      return utils19.path.escape(source);
    }
    FastGlob2.escapePath = escapePath;
    function convertPathToPattern(source) {
      assertPatternsInput(source);
      return utils19.path.convertPathToPattern(source);
    }
    FastGlob2.convertPathToPattern = convertPathToPattern;
    let posix;
    (function(posix2) {
      function escapePath2(source) {
        assertPatternsInput(source);
        return utils19.path.escapePosixPath(source);
      }
      posix2.escapePath = escapePath2;
      function convertPathToPattern2(source) {
        assertPatternsInput(source);
        return utils19.path.convertPosixPathToPattern(source);
      }
      posix2.convertPathToPattern = convertPathToPattern2;
    })(posix = FastGlob2.posix || (FastGlob2.posix = {}));
    let win32;
    (function(win322) {
      function escapePath2(source) {
        assertPatternsInput(source);
        return utils19.path.escapeWindowsPath(source);
      }
      win322.escapePath = escapePath2;
      function convertPathToPattern2(source) {
        assertPatternsInput(source);
        return utils19.path.convertWindowsPathToPattern(source);
      }
      win322.convertPathToPattern = convertPathToPattern2;
    })(win32 = FastGlob2.win32 || (FastGlob2.win32 = {}));
  })(FastGlob || (FastGlob = {}));
  module.exports = FastGlob;
});

// ../../node_modules/webidl-conversions/lib/index.js
var require_lib18 = __commonJS((exports, module) => {
  var sign5 = function(x) {
    return x < 0 ? -1 : 1;
  };
  var evenRound = function(x) {
    if (x % 1 === 0.5 && (x & 1) === 0) {
      return Math.floor(x);
    } else {
      return Math.round(x);
    }
  };
  var createNumberConversion = function(bitLength, typeOpts) {
    if (!typeOpts.unsigned) {
      --bitLength;
    }
    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
    const upperBound = Math.pow(2, bitLength) - 1;
    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
    return function(V, opts) {
      if (!opts)
        opts = {};
      let x = +V;
      if (opts.enforceRange) {
        if (!Number.isFinite(x)) {
          throw new TypeError("Argument is not a finite number");
        }
        x = sign5(x) * Math.floor(Math.abs(x));
        if (x < lowerBound || x > upperBound) {
          throw new TypeError("Argument is not in byte range");
        }
        return x;
      }
      if (!isNaN(x) && opts.clamp) {
        x = evenRound(x);
        if (x < lowerBound)
          x = lowerBound;
        if (x > upperBound)
          x = upperBound;
        return x;
      }
      if (!Number.isFinite(x) || x === 0) {
        return 0;
      }
      x = sign5(x) * Math.floor(Math.abs(x));
      x = x % moduloVal;
      if (!typeOpts.unsigned && x >= moduloBound) {
        return x - moduloVal;
      } else if (typeOpts.unsigned) {
        if (x < 0) {
          x += moduloVal;
        } else if (x === -0) {
          return 0;
        }
      }
      return x;
    };
  };
  var conversions = {};
  module.exports = conversions;
  conversions["void"] = function() {
    return;
  };
  conversions["boolean"] = function(val) {
    return !!val;
  };
  conversions["byte"] = createNumberConversion(8, { unsigned: false });
  conversions["octet"] = createNumberConversion(8, { unsigned: true });
  conversions["short"] = createNumberConversion(16, { unsigned: false });
  conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
  conversions["long"] = createNumberConversion(32, { unsigned: false });
  conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
  conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
  conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
  conversions["double"] = function(V) {
    const x = +V;
    if (!Number.isFinite(x)) {
      throw new TypeError("Argument is not a finite floating-point value");
    }
    return x;
  };
  conversions["unrestricted double"] = function(V) {
    const x = +V;
    if (isNaN(x)) {
      throw new TypeError("Argument is NaN");
    }
    return x;
  };
  conversions["float"] = conversions["double"];
  conversions["unrestricted float"] = conversions["unrestricted double"];
  conversions["DOMString"] = function(V, opts) {
    if (!opts)
      opts = {};
    if (opts.treatNullAsEmptyString && V === null) {
      return "";
    }
    return String(V);
  };
  conversions["ByteString"] = function(V, opts) {
    const x = String(V);
    let c = undefined;
    for (let i3 = 0;(c = x.codePointAt(i3)) !== undefined; ++i3) {
      if (c > 255) {
        throw new TypeError("Argument is not a valid bytestring");
      }
    }
    return x;
  };
  conversions["USVString"] = function(V) {
    const S = String(V);
    const n = S.length;
    const U = [];
    for (let i3 = 0;i3 < n; ++i3) {
      const c = S.charCodeAt(i3);
      if (c < 55296 || c > 57343) {
        U.push(String.fromCodePoint(c));
      } else if (56320 <= c && c <= 57343) {
        U.push(String.fromCodePoint(65533));
      } else {
        if (i3 === n - 1) {
          U.push(String.fromCodePoint(65533));
        } else {
          const d = S.charCodeAt(i3 + 1);
          if (56320 <= d && d <= 57343) {
            const a = c & 1023;
            const b = d & 1023;
            U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
            ++i3;
          } else {
            U.push(String.fromCodePoint(65533));
          }
        }
      }
    }
    return U.join("");
  };
  conversions["Date"] = function(V, opts) {
    if (!(V instanceof Date)) {
      throw new TypeError("Argument is not a Date object");
    }
    if (isNaN(V)) {
      return;
    }
    return V;
  };
  conversions["RegExp"] = function(V, opts) {
    if (!(V instanceof RegExp)) {
      V = new RegExp(V);
    }
    return V;
  };
});

// ../../node_modules/whatwg-url/lib/utils.js
var require_utils5 = __commonJS((exports, module) => {
  exports.mixin = function mixin(target, source) {
    const keys = Object.getOwnPropertyNames(source);
    for (let i3 = 0;i3 < keys.length; ++i3) {
      Object.defineProperty(target, keys[i3], Object.getOwnPropertyDescriptor(source, keys[i3]));
    }
  };
  exports.wrapperSymbol = Symbol("wrapper");
  exports.implSymbol = Symbol("impl");
  exports.wrapperForImpl = function(impl) {
    return impl[exports.wrapperSymbol];
  };
  exports.implForWrapper = function(wrapper) {
    return wrapper[exports.implSymbol];
  };
});

// ../../node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS((exports, module) => {
  module.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1000, 1000], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6000], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8000, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8000]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9000], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [30000]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13000, 13000], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43000, 43000], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64000, 64000], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66000, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[120000, 120000], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128000, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23000]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149000]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32000]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195000, 195000], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [40000]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918000, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
});

// ../../node_modules/tr46/index.js
var require_tr46 = __commonJS((exports, module) => {
  var normalize = function(str) {
    return str.split("\0").map(function(s) {
      return s.normalize("NFC");
    }).join("\0");
  };
  var findStatus = function(val) {
    var start = 0;
    var end = mappingTable.length - 1;
    while (start <= end) {
      var mid = Math.floor((start + end) / 2);
      var target = mappingTable[mid];
      if (target[0][0] <= val && target[0][1] >= val) {
        return target;
      } else if (target[0][0] > val) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    }
    return null;
  };
  var countSymbols = function(string31) {
    return string31.replace(regexAstralSymbols, "_").length;
  };
  var mapChars = function(domain_name, useSTD3, processing_option) {
    var hasError = false;
    var processed = "";
    var len = countSymbols(domain_name);
    for (var i3 = 0;i3 < len; ++i3) {
      var codePoint = domain_name.codePointAt(i3);
      var status = findStatus(codePoint);
      switch (status[1]) {
        case "disallowed":
          hasError = true;
          processed += String.fromCodePoint(codePoint);
          break;
        case "ignored":
          break;
        case "mapped":
          processed += String.fromCodePoint.apply(String, status[2]);
          break;
        case "deviation":
          if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
            processed += String.fromCodePoint.apply(String, status[2]);
          } else {
            processed += String.fromCodePoint(codePoint);
          }
          break;
        case "valid":
          processed += String.fromCodePoint(codePoint);
          break;
        case "disallowed_STD3_mapped":
          if (useSTD3) {
            hasError = true;
            processed += String.fromCodePoint(codePoint);
          } else {
            processed += String.fromCodePoint.apply(String, status[2]);
          }
          break;
        case "disallowed_STD3_valid":
          if (useSTD3) {
            hasError = true;
          }
          processed += String.fromCodePoint(codePoint);
          break;
      }
    }
    return {
      string: processed,
      error: hasError
    };
  };
  var validateLabel = function(label, processing_option) {
    if (label.substr(0, 4) === "xn--") {
      label = punycode.toUnicode(label);
      processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
    }
    var error = false;
    if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
      error = true;
    }
    var len = countSymbols(label);
    for (var i3 = 0;i3 < len; ++i3) {
      var status = findStatus(label.codePointAt(i3));
      if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
        error = true;
        break;
      }
    }
    return {
      label,
      error
    };
  };
  var processing = function(domain_name, useSTD3, processing_option) {
    var result = mapChars(domain_name, useSTD3, processing_option);
    result.string = normalize(result.string);
    var labels = result.string.split(".");
    for (var i3 = 0;i3 < labels.length; ++i3) {
      try {
        var validation = validateLabel(labels[i3]);
        labels[i3] = validation.label;
        result.error = result.error || validation.error;
      } catch (e4) {
        result.error = true;
      }
    }
    return {
      string: labels.join("."),
      error: result.error
    };
  };
  var punycode = __require("punycode");
  var mappingTable = require_mappingTable();
  var PROCESSING_OPTIONS = {
    TRANSITIONAL: 0,
    NONTRANSITIONAL: 1
  };
  var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
  exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
    var result = processing(domain_name, useSTD3, processing_option);
    var labels = result.string.split(".");
    labels = labels.map(function(l) {
      try {
        return punycode.toASCII(l);
      } catch (e4) {
        result.error = true;
        return l;
      }
    });
    if (verifyDnsLength) {
      var total = labels.slice(0, labels.length - 1).join(".").length;
      if (total.length > 253 || total.length === 0) {
        result.error = true;
      }
      for (var i3 = 0;i3 < labels.length; ++i3) {
        if (labels.length > 63 || labels.length === 0) {
          result.error = true;
          break;
        }
      }
    }
    if (result.error)
      return null;
    return labels.join(".");
  };
  exports.toUnicode = function(domain_name, useSTD3) {
    var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
    return {
      domain: result.string,
      error: result.error
    };
  };
  exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
});

// ../../node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS((exports, module) => {
  var countSymbols = function(str) {
    return punycode.ucs2.decode(str).length;
  };
  var at2 = function(input, idx) {
    const c = input[idx];
    return isNaN(c) ? undefined : String.fromCodePoint(c);
  };
  var isASCIIDigit = function(c) {
    return c >= 48 && c <= 57;
  };
  var isASCIIAlpha = function(c) {
    return c >= 65 && c <= 90 || c >= 97 && c <= 122;
  };
  var isASCIIAlphanumeric = function(c) {
    return isASCIIAlpha(c) || isASCIIDigit(c);
  };
  var isASCIIHex = function(c) {
    return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
  };
  var isSingleDot = function(buffer) {
    return buffer === "." || buffer.toLowerCase() === "%2e";
  };
  var isDoubleDot = function(buffer) {
    buffer = buffer.toLowerCase();
    return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
  };
  var isWindowsDriveLetterCodePoints = function(cp1, cp2) {
    return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
  };
  var isWindowsDriveLetterString = function(string31) {
    return string31.length === 2 && isASCIIAlpha(string31.codePointAt(0)) && (string31[1] === ":" || string31[1] === "|");
  };
  var isNormalizedWindowsDriveLetterString = function(string31) {
    return string31.length === 2 && isASCIIAlpha(string31.codePointAt(0)) && string31[1] === ":";
  };
  var containsForbiddenHostCodePoint = function(string31) {
    return string31.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
  };
  var containsForbiddenHostCodePointExcludingPercent = function(string31) {
    return string31.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
  };
  var isSpecialScheme = function(scheme) {
    return specialSchemes[scheme] !== undefined;
  };
  var isSpecial = function(url) {
    return isSpecialScheme(url.scheme);
  };
  var defaultPort = function(scheme) {
    return specialSchemes[scheme];
  };
  var percentEncode = function(c) {
    let hex4 = c.toString(16).toUpperCase();
    if (hex4.length === 1) {
      hex4 = "0" + hex4;
    }
    return "%" + hex4;
  };
  var utf8PercentEncode = function(c) {
    const buf = new Buffer(c);
    let str = "";
    for (let i3 = 0;i3 < buf.length; ++i3) {
      str += percentEncode(buf[i3]);
    }
    return str;
  };
  var utf8PercentDecode = function(str) {
    const input = new Buffer(str);
    const output = [];
    for (let i3 = 0;i3 < input.length; ++i3) {
      if (input[i3] !== 37) {
        output.push(input[i3]);
      } else if (input[i3] === 37 && isASCIIHex(input[i3 + 1]) && isASCIIHex(input[i3 + 2])) {
        output.push(parseInt(input.slice(i3 + 1, i3 + 3).toString(), 16));
        i3 += 2;
      } else {
        output.push(input[i3]);
      }
    }
    return new Buffer(output).toString();
  };
  var isC0ControlPercentEncode = function(c) {
    return c <= 31 || c > 126;
  };
  var isPathPercentEncode = function(c) {
    return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
  };
  var isUserinfoPercentEncode = function(c) {
    return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
  };
  var percentEncodeChar = function(c, encodeSetPredicate) {
    const cStr = String.fromCodePoint(c);
    if (encodeSetPredicate(c)) {
      return utf8PercentEncode(cStr);
    }
    return cStr;
  };
  var parseIPv4Number = function(input) {
    let R = 10;
    if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
      input = input.substring(2);
      R = 16;
    } else if (input.length >= 2 && input.charAt(0) === "0") {
      input = input.substring(1);
      R = 8;
    }
    if (input === "") {
      return 0;
    }
    const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
    if (regex.test(input)) {
      return failure;
    }
    return parseInt(input, R);
  };
  var parseIPv4 = function(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length > 1) {
        parts.pop();
      }
    }
    if (parts.length > 4) {
      return input;
    }
    const numbers = [];
    for (const part of parts) {
      if (part === "") {
        return input;
      }
      const n = parseIPv4Number(part);
      if (n === failure) {
        return input;
      }
      numbers.push(n);
    }
    for (let i3 = 0;i3 < numbers.length - 1; ++i3) {
      if (numbers[i3] > 255) {
        return failure;
      }
    }
    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
      return failure;
    }
    let ipv4 = numbers.pop();
    let counter = 0;
    for (const n of numbers) {
      ipv4 += n * Math.pow(256, 3 - counter);
      ++counter;
    }
    return ipv4;
  };
  var serializeIPv4 = function(address) {
    let output = "";
    let n = address;
    for (let i3 = 1;i3 <= 4; ++i3) {
      output = String(n % 256) + output;
      if (i3 !== 4) {
        output = "." + output;
      }
      n = Math.floor(n / 256);
    }
    return output;
  };
  var parseIPv6 = function(input) {
    const address = [0, 0, 0, 0, 0, 0, 0, 0];
    let pieceIndex = 0;
    let compress = null;
    let pointer = 0;
    input = punycode.ucs2.decode(input);
    if (input[pointer] === 58) {
      if (input[pointer + 1] !== 58) {
        return failure;
      }
      pointer += 2;
      ++pieceIndex;
      compress = pieceIndex;
    }
    while (pointer < input.length) {
      if (pieceIndex === 8) {
        return failure;
      }
      if (input[pointer] === 58) {
        if (compress !== null) {
          return failure;
        }
        ++pointer;
        ++pieceIndex;
        compress = pieceIndex;
        continue;
      }
      let value = 0;
      let length = 0;
      while (length < 4 && isASCIIHex(input[pointer])) {
        value = value * 16 + parseInt(at2(input, pointer), 16);
        ++pointer;
        ++length;
      }
      if (input[pointer] === 46) {
        if (length === 0) {
          return failure;
        }
        pointer -= length;
        if (pieceIndex > 6) {
          return failure;
        }
        let numbersSeen = 0;
        while (input[pointer] !== undefined) {
          let ipv4Piece = null;
          if (numbersSeen > 0) {
            if (input[pointer] === 46 && numbersSeen < 4) {
              ++pointer;
            } else {
              return failure;
            }
          }
          if (!isASCIIDigit(input[pointer])) {
            return failure;
          }
          while (isASCIIDigit(input[pointer])) {
            const number102 = parseInt(at2(input, pointer));
            if (ipv4Piece === null) {
              ipv4Piece = number102;
            } else if (ipv4Piece === 0) {
              return failure;
            } else {
              ipv4Piece = ipv4Piece * 10 + number102;
            }
            if (ipv4Piece > 255) {
              return failure;
            }
            ++pointer;
          }
          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          ++numbersSeen;
          if (numbersSeen === 2 || numbersSeen === 4) {
            ++pieceIndex;
          }
        }
        if (numbersSeen !== 4) {
          return failure;
        }
        break;
      } else if (input[pointer] === 58) {
        ++pointer;
        if (input[pointer] === undefined) {
          return failure;
        }
      } else if (input[pointer] !== undefined) {
        return failure;
      }
      address[pieceIndex] = value;
      ++pieceIndex;
    }
    if (compress !== null) {
      let swaps = pieceIndex - compress;
      pieceIndex = 7;
      while (pieceIndex !== 0 && swaps > 0) {
        const temp = address[compress + swaps - 1];
        address[compress + swaps - 1] = address[pieceIndex];
        address[pieceIndex] = temp;
        --pieceIndex;
        --swaps;
      }
    } else if (compress === null && pieceIndex !== 8) {
      return failure;
    }
    return address;
  };
  var serializeIPv6 = function(address) {
    let output = "";
    const seqResult = findLongestZeroSequence(address);
    const compress = seqResult.idx;
    let ignore0 = false;
    for (let pieceIndex = 0;pieceIndex <= 7; ++pieceIndex) {
      if (ignore0 && address[pieceIndex] === 0) {
        continue;
      } else if (ignore0) {
        ignore0 = false;
      }
      if (compress === pieceIndex) {
        const separator = pieceIndex === 0 ? "::" : ":";
        output += separator;
        ignore0 = true;
        continue;
      }
      output += address[pieceIndex].toString(16);
      if (pieceIndex !== 7) {
        output += ":";
      }
    }
    return output;
  };
  var parseHost = function(input, isSpecialArg) {
    if (input[0] === "[") {
      if (input[input.length - 1] !== "]") {
        return failure;
      }
      return parseIPv6(input.substring(1, input.length - 1));
    }
    if (!isSpecialArg) {
      return parseOpaqueHost(input);
    }
    const domain = utf8PercentDecode(input);
    const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
    if (asciiDomain === null) {
      return failure;
    }
    if (containsForbiddenHostCodePoint(asciiDomain)) {
      return failure;
    }
    const ipv4Host = parseIPv4(asciiDomain);
    if (typeof ipv4Host === "number" || ipv4Host === failure) {
      return ipv4Host;
    }
    return asciiDomain;
  };
  var parseOpaqueHost = function(input) {
    if (containsForbiddenHostCodePointExcludingPercent(input)) {
      return failure;
    }
    let output = "";
    const decoded = punycode.ucs2.decode(input);
    for (let i3 = 0;i3 < decoded.length; ++i3) {
      output += percentEncodeChar(decoded[i3], isC0ControlPercentEncode);
    }
    return output;
  };
  var findLongestZeroSequence = function(arr) {
    let maxIdx = null;
    let maxLen = 1;
    let currStart = null;
    let currLen = 0;
    for (let i3 = 0;i3 < arr.length; ++i3) {
      if (arr[i3] !== 0) {
        if (currLen > maxLen) {
          maxIdx = currStart;
          maxLen = currLen;
        }
        currStart = null;
        currLen = 0;
      } else {
        if (currStart === null) {
          currStart = i3;
        }
        ++currLen;
      }
    }
    if (currLen > maxLen) {
      maxIdx = currStart;
      maxLen = currLen;
    }
    return {
      idx: maxIdx,
      len: maxLen
    };
  };
  var serializeHost = function(host) {
    if (typeof host === "number") {
      return serializeIPv4(host);
    }
    if (host instanceof Array) {
      return "[" + serializeIPv6(host) + "]";
    }
    return host;
  };
  var trimControlChars = function(url) {
    return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
  };
  var trimTabAndNewline = function(url) {
    return url.replace(/\u0009|\u000A|\u000D/g, "");
  };
  var shortenPath = function(url) {
    const path = url.path;
    if (path.length === 0) {
      return;
    }
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
      return;
    }
    path.pop();
  };
  var includesCredentials = function(url) {
    return url.username !== "" || url.password !== "";
  };
  var cannotHaveAUsernamePasswordPort = function(url) {
    return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
  };
  var isNormalizedWindowsDriveLetter = function(string31) {
    return /^[A-Za-z]:$/.test(string31);
  };
  var URLStateMachine = function(input, base15, encodingOverride, url, stateOverride) {
    this.pointer = 0;
    this.input = input;
    this.base = base15 || null;
    this.encodingOverride = encodingOverride || "utf-8";
    this.stateOverride = stateOverride;
    this.url = url;
    this.failure = false;
    this.parseError = false;
    if (!this.url) {
      this.url = {
        scheme: "",
        username: "",
        password: "",
        host: null,
        port: null,
        path: [],
        query: null,
        fragment: null,
        cannotBeABaseURL: false
      };
      const res2 = trimControlChars(this.input);
      if (res2 !== this.input) {
        this.parseError = true;
      }
      this.input = res2;
    }
    const res = trimTabAndNewline(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
    this.state = stateOverride || "scheme start";
    this.buffer = "";
    this.atFlag = false;
    this.arrFlag = false;
    this.passwordTokenSeenFlag = false;
    this.input = punycode.ucs2.decode(this.input);
    for (;this.pointer <= this.input.length; ++this.pointer) {
      const c = this.input[this.pointer];
      const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);
      const ret = this["parse " + this.state](c, cStr);
      if (!ret) {
        break;
      } else if (ret === failure) {
        this.failure = true;
        break;
      }
    }
  };
  var serializeURL = function(url, excludeFragment) {
    let output = url.scheme + ":";
    if (url.host !== null) {
      output += "//";
      if (url.username !== "" || url.password !== "") {
        output += url.username;
        if (url.password !== "") {
          output += ":" + url.password;
        }
        output += "@";
      }
      output += serializeHost(url.host);
      if (url.port !== null) {
        output += ":" + url.port;
      }
    } else if (url.host === null && url.scheme === "file") {
      output += "//";
    }
    if (url.cannotBeABaseURL) {
      output += url.path[0];
    } else {
      for (const string31 of url.path) {
        output += "/" + string31;
      }
    }
    if (url.query !== null) {
      output += "?" + url.query;
    }
    if (!excludeFragment && url.fragment !== null) {
      output += "#" + url.fragment;
    }
    return output;
  };
  var serializeOrigin = function(tuple) {
    let result = tuple.scheme + "://";
    result += serializeHost(tuple.host);
    if (tuple.port !== null) {
      result += ":" + tuple.port;
    }
    return result;
  };
  var punycode = __require("punycode");
  var tr46 = require_tr46();
  var specialSchemes = {
    ftp: 21,
    file: null,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var failure = Symbol("failure");
  var extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
  var extraUserinfoPercentEncodeSet = new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
  URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
    if (isASCIIAlpha(c)) {
      this.buffer += cStr.toLowerCase();
      this.state = "scheme";
    } else if (!this.stateOverride) {
      this.state = "no scheme";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
    if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
      this.buffer += cStr.toLowerCase();
    } else if (c === 58) {
      if (this.stateOverride) {
        if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
          return false;
        }
        if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
          return false;
        }
        if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
          return false;
        }
        if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
          return false;
        }
      }
      this.url.scheme = this.buffer;
      this.buffer = "";
      if (this.stateOverride) {
        return false;
      }
      if (this.url.scheme === "file") {
        if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
          this.parseError = true;
        }
        this.state = "file";
      } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
        this.state = "special relative or authority";
      } else if (isSpecial(this.url)) {
        this.state = "special authority slashes";
      } else if (this.input[this.pointer + 1] === 47) {
        this.state = "path or authority";
        ++this.pointer;
      } else {
        this.url.cannotBeABaseURL = true;
        this.url.path.push("");
        this.state = "cannot-be-a-base-URL path";
      }
    } else if (!this.stateOverride) {
      this.buffer = "";
      this.state = "no scheme";
      this.pointer = -1;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
    if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
      return failure;
    } else if (this.base.cannotBeABaseURL && c === 35) {
      this.url.scheme = this.base.scheme;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.url.cannotBeABaseURL = true;
      this.state = "fragment";
    } else if (this.base.scheme === "file") {
      this.state = "file";
      --this.pointer;
    } else {
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
    if (c === 47) {
      this.state = "authority";
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
    this.url.scheme = this.base.scheme;
    if (isNaN(c)) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
    } else if (c === 47) {
      this.state = "relative slash";
    } else if (c === 63) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = "";
      this.state = "query";
    } else if (c === 35) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    } else if (isSpecial(this.url) && c === 92) {
      this.parseError = true;
      this.state = "relative slash";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice(0, this.base.path.length - 1);
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
    if (isSpecial(this.url) && (c === 47 || c === 92)) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "special authority ignore slashes";
    } else if (c === 47) {
      this.state = "authority";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "special authority ignore slashes";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
    if (c !== 47 && c !== 92) {
      this.state = "authority";
      --this.pointer;
    } else {
      this.parseError = true;
    }
    return true;
  };
  URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
    if (c === 64) {
      this.parseError = true;
      if (this.atFlag) {
        this.buffer = "%40" + this.buffer;
      }
      this.atFlag = true;
      const len = countSymbols(this.buffer);
      for (let pointer = 0;pointer < len; ++pointer) {
        const codePoint = this.buffer.codePointAt(pointer);
        if (codePoint === 58 && !this.passwordTokenSeenFlag) {
          this.passwordTokenSeenFlag = true;
          continue;
        }
        const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
        if (this.passwordTokenSeenFlag) {
          this.url.password += encodedCodePoints;
        } else {
          this.url.username += encodedCodePoints;
        }
      }
      this.buffer = "";
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
      if (this.atFlag && this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      this.pointer -= countSymbols(this.buffer) + 1;
      this.buffer = "";
      this.state = "host";
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
    if (this.stateOverride && this.url.scheme === "file") {
      --this.pointer;
      this.state = "file host";
    } else if (c === 58 && !this.arrFlag) {
      if (this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      const host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "port";
      if (this.stateOverride === "hostname") {
        return false;
      }
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
      --this.pointer;
      if (isSpecial(this.url) && this.buffer === "") {
        this.parseError = true;
        return failure;
      } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
        this.parseError = true;
        return false;
      }
      const host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "path start";
      if (this.stateOverride) {
        return false;
      }
    } else {
      if (c === 91) {
        this.arrFlag = true;
      } else if (c === 93) {
        this.arrFlag = false;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
    if (isASCIIDigit(c)) {
      this.buffer += cStr;
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
      if (this.buffer !== "") {
        const port = parseInt(this.buffer);
        if (port > Math.pow(2, 16) - 1) {
          this.parseError = true;
          return failure;
        }
        this.url.port = port === defaultPort(this.url.scheme) ? null : port;
        this.buffer = "";
      }
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  var fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);
  URLStateMachine.prototype["parse file"] = function parseFile(c) {
    this.url.scheme = "file";
    if (c === 47 || c === 92) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "file slash";
    } else if (this.base !== null && this.base.scheme === "file") {
      if (isNaN(c)) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 63) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (this.input.length - this.pointer - 1 === 0 || !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          shortenPath(this.url);
        } else {
          this.parseError = true;
        }
        this.state = "path";
        --this.pointer;
      }
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
    if (c === 47 || c === 92) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "file host";
    } else {
      if (this.base !== null && this.base.scheme === "file") {
        if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
          this.url.path.push(this.base.path[0]);
        } else {
          this.url.host = this.base.host;
        }
      }
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
    if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
      --this.pointer;
      if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
        this.parseError = true;
        this.state = "path";
      } else if (this.buffer === "") {
        this.url.host = "";
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
      } else {
        let host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        if (host === "localhost") {
          host = "";
        }
        this.url.host = host;
        if (this.stateOverride) {
          return false;
        }
        this.buffer = "";
        this.state = "path start";
      }
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
    if (isSpecial(this.url)) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "path";
      if (c !== 47 && c !== 92) {
        --this.pointer;
      }
    } else if (!this.stateOverride && c === 63) {
      this.url.query = "";
      this.state = "query";
    } else if (!this.stateOverride && c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    } else if (c !== undefined) {
      this.state = "path";
      if (c !== 47) {
        --this.pointer;
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse path"] = function parsePath(c) {
    if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
      if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
      }
      if (isDoubleDot(this.buffer)) {
        shortenPath(this.url);
        if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        }
      } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
        this.url.path.push("");
      } else if (!isSingleDot(this.buffer)) {
        if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
          if (this.url.host !== "" && this.url.host !== null) {
            this.parseError = true;
            this.url.host = "";
          }
          this.buffer = this.buffer[0] + ":";
        }
        this.url.path.push(this.buffer);
      }
      this.buffer = "";
      if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
        while (this.url.path.length > 1 && this.url.path[0] === "") {
          this.parseError = true;
          this.url.path.shift();
        }
      }
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      }
      if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += percentEncodeChar(c, isPathPercentEncode);
    }
    return true;
  };
  URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
    if (c === 63) {
      this.url.query = "";
      this.state = "query";
    } else if (c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    } else {
      if (!isNaN(c) && c !== 37) {
        this.parseError = true;
      }
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      if (!isNaN(c)) {
        this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
    if (isNaN(c) || !this.stateOverride && c === 35) {
      if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
        this.encodingOverride = "utf-8";
      }
      const buffer = new Buffer(this.buffer);
      for (let i3 = 0;i3 < buffer.length; ++i3) {
        if (buffer[i3] < 33 || buffer[i3] > 126 || buffer[i3] === 34 || buffer[i3] === 35 || buffer[i3] === 60 || buffer[i3] === 62) {
          this.url.query += percentEncode(buffer[i3]);
        } else {
          this.url.query += String.fromCodePoint(buffer[i3]);
        }
      }
      this.buffer = "";
      if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
    if (isNaN(c)) {
    } else if (c === 0) {
      this.parseError = true;
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
    }
    return true;
  };
  exports.serializeURL = serializeURL;
  exports.serializeURLOrigin = function(url) {
    switch (url.scheme) {
      case "blob":
        try {
          return exports.serializeURLOrigin(exports.parseURL(url.path[0]));
        } catch (e4) {
          return "null";
        }
      case "ftp":
      case "gopher":
      case "http":
      case "https":
      case "ws":
      case "wss":
        return serializeOrigin({
          scheme: url.scheme,
          host: url.host,
          port: url.port
        });
      case "file":
        return "file://";
      default:
        return "null";
    }
  };
  exports.basicURLParse = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
    if (usm.failure) {
      return "failure";
    }
    return usm.url;
  };
  exports.setTheUsername = function(url, username) {
    url.username = "";
    const decoded = punycode.ucs2.decode(username);
    for (let i3 = 0;i3 < decoded.length; ++i3) {
      url.username += percentEncodeChar(decoded[i3], isUserinfoPercentEncode);
    }
  };
  exports.setThePassword = function(url, password) {
    url.password = "";
    const decoded = punycode.ucs2.decode(password);
    for (let i3 = 0;i3 < decoded.length; ++i3) {
      url.password += percentEncodeChar(decoded[i3], isUserinfoPercentEncode);
    }
  };
  exports.serializeHost = serializeHost;
  exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
  exports.serializeInteger = function(integer2) {
    return String(integer2);
  };
  exports.parseURL = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
  };
});

// ../../node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS((exports) => {
  var usm = require_url_state_machine();
  exports.implementation = class URLImpl {
    constructor(constructorArgs) {
      const url = constructorArgs[0];
      const base15 = constructorArgs[1];
      let parsedBase = null;
      if (base15 !== undefined) {
        parsedBase = usm.basicURLParse(base15);
        if (parsedBase === "failure") {
          throw new TypeError("Invalid base URL");
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === "failure") {
        throw new TypeError("Invalid URL");
      }
      this._url = parsedURL;
    }
    get href() {
      return usm.serializeURL(this._url);
    }
    set href(v) {
      const parsedURL = usm.basicURLParse(v);
      if (parsedURL === "failure") {
        throw new TypeError("Invalid URL");
      }
      this._url = parsedURL;
    }
    get origin() {
      return usm.serializeURLOrigin(this._url);
    }
    get protocol() {
      return this._url.scheme + ":";
    }
    set protocol(v) {
      usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
    }
    get username() {
      return this._url.username;
    }
    set username(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setTheUsername(this._url, v);
    }
    get password() {
      return this._url.password;
    }
    set password(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setThePassword(this._url, v);
    }
    get host() {
      const url = this._url;
      if (url.host === null) {
        return "";
      }
      if (url.port === null) {
        return usm.serializeHost(url.host);
      }
      return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
    }
    set host(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
    }
    get hostname() {
      if (this._url.host === null) {
        return "";
      }
      return usm.serializeHost(this._url.host);
    }
    set hostname(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
    }
    get port() {
      if (this._url.port === null) {
        return "";
      }
      return usm.serializeInteger(this._url.port);
    }
    set port(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      if (v === "") {
        this._url.port = null;
      } else {
        usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
      }
    }
    get pathname() {
      if (this._url.cannotBeABaseURL) {
        return this._url.path[0];
      }
      if (this._url.path.length === 0) {
        return "";
      }
      return "/" + this._url.path.join("/");
    }
    set pathname(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      this._url.path = [];
      usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
    }
    get search() {
      if (this._url.query === null || this._url.query === "") {
        return "";
      }
      return "?" + this._url.query;
    }
    set search(v) {
      const url = this._url;
      if (v === "") {
        url.query = null;
        return;
      }
      const input = v[0] === "?" ? v.substring(1) : v;
      url.query = "";
      usm.basicURLParse(input, { url, stateOverride: "query" });
    }
    get hash() {
      if (this._url.fragment === null || this._url.fragment === "") {
        return "";
      }
      return "#" + this._url.fragment;
    }
    set hash(v) {
      if (v === "") {
        this._url.fragment = null;
        return;
      }
      const input = v[0] === "#" ? v.substring(1) : v;
      this._url.fragment = "";
      usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
    }
    toJSON() {
      return this.href;
    }
  };
});

// ../../node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS((exports, module) => {
  var URL2 = function(url) {
    if (!this || this[impl] || !(this instanceof URL2)) {
      throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
    }
    if (arguments.length < 1) {
      throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
    }
    const args = [];
    for (let i3 = 0;i3 < arguments.length && i3 < 2; ++i3) {
      args[i3] = arguments[i3];
    }
    args[0] = conversions["USVString"](args[0]);
    if (args[1] !== undefined) {
      args[1] = conversions["USVString"](args[1]);
    }
    exports.setup(this, args);
  };
  var conversions = require_lib18();
  var utils19 = require_utils5();
  var Impl = require_URL_impl();
  var impl = utils19.implSymbol;
  URL2.prototype.toJSON = function toJSON() {
    if (!this || !exports.is(this)) {
      throw new TypeError("Illegal invocation");
    }
    const args = [];
    for (let i3 = 0;i3 < arguments.length && i3 < 0; ++i3) {
      args[i3] = arguments[i3];
    }
    return this[impl].toJSON.apply(this[impl], args);
  };
  Object.defineProperty(URL2.prototype, "href", {
    get() {
      return this[impl].href;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].href = V;
    },
    enumerable: true,
    configurable: true
  });
  URL2.prototype.toString = function() {
    if (!this || !exports.is(this)) {
      throw new TypeError("Illegal invocation");
    }
    return this.href;
  };
  Object.defineProperty(URL2.prototype, "origin", {
    get() {
      return this[impl].origin;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "protocol", {
    get() {
      return this[impl].protocol;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].protocol = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "username", {
    get() {
      return this[impl].username;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].username = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "password", {
    get() {
      return this[impl].password;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].password = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "host", {
    get() {
      return this[impl].host;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].host = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "hostname", {
    get() {
      return this[impl].hostname;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].hostname = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "port", {
    get() {
      return this[impl].port;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].port = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "pathname", {
    get() {
      return this[impl].pathname;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].pathname = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "search", {
    get() {
      return this[impl].search;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].search = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "hash", {
    get() {
      return this[impl].hash;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].hash = V;
    },
    enumerable: true,
    configurable: true
  });
  module.exports = {
    is(obj) {
      return !!obj && obj[impl] instanceof Impl.implementation;
    },
    create(constructorArgs, privateData) {
      let obj = Object.create(URL2.prototype);
      this.setup(obj, constructorArgs, privateData);
      return obj;
    },
    setup(obj, constructorArgs, privateData) {
      if (!privateData)
        privateData = {};
      privateData.wrapper = obj;
      obj[impl] = new Impl.implementation(constructorArgs, privateData);
      obj[impl][utils19.wrapperSymbol] = obj;
    },
    interface: URL2,
    expose: {
      Window: { URL: URL2 },
      Worker: { URL: URL2 }
    }
  };
});

// ../../node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS((exports) => {
  exports.URL = require_URL().interface;
  exports.serializeURL = require_url_state_machine().serializeURL;
  exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
  exports.basicURLParse = require_url_state_machine().basicURLParse;
  exports.setTheUsername = require_url_state_machine().setTheUsername;
  exports.setThePassword = require_url_state_machine().setThePassword;
  exports.serializeHost = require_url_state_machine().serializeHost;
  exports.serializeInteger = require_url_state_machine().serializeInteger;
  exports.parseURL = require_url_state_machine().parseURL;
});

// ../../node_modules/node-fetch/lib/index.js
var require_lib19 = __commonJS((exports, module) => {
  var _interopDefault = function(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  };
  var FetchError = function(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  };
  var Body = function(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;
    let size3 = _ref$size === undefined ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (isURLSearchParams(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof Stream)
      ;
    else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size3;
    this.timeout = timeout;
    if (body instanceof Stream) {
      body.on("error", function(err) {
        const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
        _this[INTERNALS].error = error;
      });
    }
  };
  var consumeBody = function() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    if (body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (isBlob(body)) {
      body = body.stream();
    }
    if (Buffer.isBuffer(body)) {
      return Body.Promise.resolve(body);
    }
    if (!(body instanceof Stream)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve4, reject2) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject2(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      body.on("error", function(err) {
        if (err.name === "AbortError") {
          abort = true;
          reject2(err);
        } else {
          reject2(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
        }
      });
      body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject2(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve4(Buffer.concat(accum, accumBytes));
        } catch (err) {
          reject2(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      });
    });
  };
  var convertBody = function(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (!res) {
        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
        if (res) {
          res.pop();
        }
      }
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  };
  var isURLSearchParams = function(obj) {
    if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
      return false;
    }
    return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
  };
  var isBlob = function(obj) {
    return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
  };
  var clone5 = function(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof Stream && typeof body.getBoundary !== "function") {
      p1 = new PassThrough;
      p2 = new PassThrough;
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  };
  var extractContentType = function(body) {
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob(body)) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (ArrayBuffer.isView(body)) {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof Stream) {
      return null;
    } else {
      return "text/plain;charset=UTF-8";
    }
  };
  var getTotalBytes = function(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (isBlob(body)) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  };
  var writeToStream = function(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (isBlob(body)) {
      body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else {
      body.pipe(dest);
    }
  };
  var validateName = function(name302) {
    name302 = `${name302}`;
    if (invalidTokenRegex.test(name302) || name302 === "") {
      throw new TypeError(`${name302} is not a legal HTTP header name`);
    }
  };
  var validateValue = function(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  };
  var find = function(map11, name302) {
    name302 = name302.toLowerCase();
    for (const key in map11) {
      if (key.toLowerCase() === name302) {
        return key;
      }
    }
    return;
  };
  var getHeaders = function(headers) {
    let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "key+value";
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === "key" ? function(k) {
      return k.toLowerCase();
    } : kind === "value" ? function(k) {
      return headers[MAP][k].join(", ");
    } : function(k) {
      return [k.toLowerCase(), headers[MAP][k].join(", ")];
    });
  };
  var createHeadersIterator = function(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind,
      index: 0
    };
    return iterator;
  };
  var exportNodeCompatibleHeaders = function(headers) {
    const obj = Object.assign({ __proto__: null }, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== undefined) {
      obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
  };
  var createHeadersLenient = function(obj) {
    const headers = new Headers2;
    for (const name302 of Object.keys(obj)) {
      if (invalidTokenRegex.test(name302)) {
        continue;
      }
      if (Array.isArray(obj[name302])) {
        for (const val of obj[name302]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name302] === undefined) {
            headers[MAP][name302] = [val];
          } else {
            headers[MAP][name302].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj[name302])) {
        headers[MAP][name302] = [obj[name302]];
      }
    }
    return headers;
  };
  var parseURL = function(urlStr) {
    if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
      urlStr = new URL2(urlStr).toString();
    }
    return parse_url(urlStr);
  };
  var isRequest = function(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  };
  var isAbortSignal = function(signal) {
    const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === "AbortSignal");
  };
  var getNodeRequestOptions = function(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers2(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
      throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress && !headers.has("Accept-Encoding")) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    let agent = request.agent;
    if (typeof agent === "function") {
      agent = agent(parsedURL);
    }
    if (!headers.has("Connection") && !agent) {
      headers.set("Connection", "close");
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent
    });
  };
  var AbortError = function(message) {
    Error.call(this, message);
    this.type = "aborted";
    this.message = message;
    Error.captureStackTrace(this, this.constructor);
  };
  var fetch2 = function(url, opts) {
    if (!fetch2.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch2.Promise;
    return new fetch2.Promise(function(resolve4, reject2) {
      const request = new Request(url, opts);
      const options = getNodeRequestOptions(request);
      const send = (options.protocol === "https:" ? https : http).request;
      const signal = request.signal;
      let response = null;
      const abort = function abort() {
        let error = new AbortError("The user aborted a request.");
        reject2(error);
        if (request.body && request.body instanceof Stream.Readable) {
          request.body.destroy(error);
        }
        if (!response || !response.body)
          return;
        response.body.emit("error", error);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = function abortAndFinalize() {
        abort();
        finalize();
      };
      const req = send(options);
      let reqTimeout;
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      function finalize() {
        req.abort();
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject2(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req.on("error", function(err) {
        reject2(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        finalize();
      });
      req.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch2.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          let locationURL = null;
          try {
            locationURL = location === null ? null : new URL$1(location, request.url).toString();
          } catch (err) {
            if (request.redirect !== "manual") {
              reject2(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
              finalize();
              return;
            }
          }
          switch (request.redirect) {
            case "error":
              reject2(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                try {
                  headers.set("Location", locationURL);
                } catch (err) {
                  reject2(err);
                }
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject2(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers2(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body,
                signal: request.signal,
                timeout: request.timeout,
                size: request.size
              };
              if (!isDomainOrSubdomain(request.url, locationURL)) {
                for (const name302 of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                  requestOpts.headers.delete(name302);
                }
              }
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject2(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = undefined;
                requestOpts.headers.delete("content-length");
              }
              resolve4(fetch2(new Request(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        res.once("end", function() {
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
        });
        let body = res.pipe(new PassThrough$1);
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout,
          counter: request.counter
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          response = new Response(body, response_options);
          resolve4(response);
          return;
        }
        const zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(zlib.createGunzip(zlibOptions));
          response = new Response(body, response_options);
          resolve4(response);
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1);
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(zlib.createInflate());
            } else {
              body = body.pipe(zlib.createInflateRaw());
            }
            response = new Response(body, response_options);
            resolve4(response);
          });
          return;
        }
        if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
          body = body.pipe(zlib.createBrotliDecompress());
          response = new Response(body, response_options);
          resolve4(response);
          return;
        }
        response = new Response(body, response_options);
        resolve4(response);
      });
      writeToStream(req, request);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Stream = _interopDefault(__require("stream"));
  var http = _interopDefault(__require("http"));
  var Url = _interopDefault(__require("url"));
  var whatwgUrl = _interopDefault(require_public_api());
  var https = _interopDefault(__require("https"));
  var zlib = _interopDefault(__require("zlib"));
  var Readable = Stream.Readable;
  var BUFFER = Symbol("buffer");
  var TYPE = Symbol("type");

  class Blob2 {
    constructor() {
      this[TYPE] = "";
      const blobParts = arguments[0];
      const options = arguments[1];
      const buffers = [];
      let size3 = 0;
      if (blobParts) {
        const a = blobParts;
        const length = Number(a.length);
        for (let i3 = 0;i3 < length; i3++) {
          const element = a[i3];
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob2) {
            buffer = element[BUFFER];
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size3 += buffer.length;
          buffers.push(buffer);
        }
      }
      this[BUFFER] = Buffer.concat(buffers);
      let type = options && options.type !== undefined && String(options.type).toLowerCase();
      if (type && !/[^\u0020-\u007E]/.test(type)) {
        this[TYPE] = type;
      }
    }
    get size() {
      return this[BUFFER].length;
    }
    get type() {
      return this[TYPE];
    }
    text() {
      return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
      const buf = this[BUFFER];
      const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      return Promise.resolve(ab);
    }
    stream() {
      const readable = new Readable;
      readable._read = function() {
      };
      readable.push(this[BUFFER]);
      readable.push(null);
      return readable;
    }
    toString() {
      return "[object Blob]";
    }
    slice() {
      const size3 = this.size;
      const start = arguments[0];
      const end = arguments[1];
      let relativeStart, relativeEnd;
      if (start === undefined) {
        relativeStart = 0;
      } else if (start < 0) {
        relativeStart = Math.max(size3 + start, 0);
      } else {
        relativeStart = Math.min(start, size3);
      }
      if (end === undefined) {
        relativeEnd = size3;
      } else if (end < 0) {
        relativeEnd = Math.max(size3 + end, 0);
      } else {
        relativeEnd = Math.min(end, size3);
      }
      const span = Math.max(relativeEnd - relativeStart, 0);
      const buffer = this[BUFFER];
      const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      const blob = new Blob2([], { type: arguments[2] });
      blob[BUFFER] = slicedBuffer;
      return blob;
    }
  }
  Object.defineProperties(Blob2.prototype, {
    size: { enumerable: true },
    type: { enumerable: true },
    slice: { enumerable: true }
  });
  Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
    value: "Blob",
    writable: false,
    enumerable: false,
    configurable: true
  });
  FetchError.prototype = Object.create(Error.prototype);
  FetchError.prototype.constructor = FetchError;
  FetchError.prototype.name = "FetchError";
  var convert;
  try {
    convert = (()=>{throw new Error(`Cannot require module "encoding"`);})().convert;
  } catch (e4) {
  }
  var INTERNALS = Symbol("Body internals");
  var PassThrough = Stream.PassThrough;
  Body.prototype = {
    get body() {
      return this[INTERNALS].body;
    },
    get bodyUsed() {
      return this[INTERNALS].disturbed;
    },
    arrayBuffer() {
      return consumeBody.call(this).then(function(buf) {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      });
    },
    blob() {
      let ct = this.headers && this.headers.get("content-type") || "";
      return consumeBody.call(this).then(function(buf) {
        return Object.assign(new Blob2([], {
          type: ct.toLowerCase()
        }), {
          [BUFFER]: buf
        });
      });
    },
    json() {
      var _this2 = this;
      return consumeBody.call(this).then(function(buffer) {
        try {
          return JSON.parse(buffer.toString());
        } catch (err) {
          return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
        }
      });
    },
    text() {
      return consumeBody.call(this).then(function(buffer) {
        return buffer.toString();
      });
    },
    buffer() {
      return consumeBody.call(this);
    },
    textConverted() {
      var _this3 = this;
      return consumeBody.call(this).then(function(buffer) {
        return convertBody(buffer, _this3.headers);
      });
    }
  };
  Object.defineProperties(Body.prototype, {
    body: { enumerable: true },
    bodyUsed: { enumerable: true },
    arrayBuffer: { enumerable: true },
    blob: { enumerable: true },
    json: { enumerable: true },
    text: { enumerable: true }
  });
  Body.mixIn = function(proto) {
    for (const name302 of Object.getOwnPropertyNames(Body.prototype)) {
      if (!(name302 in proto)) {
        const desc = Object.getOwnPropertyDescriptor(Body.prototype, name302);
        Object.defineProperty(proto, name302, desc);
      }
    }
  };
  Body.Promise = globalThis.Promise;
  var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  var MAP = Symbol("map");

  class Headers2 {
    constructor() {
      let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      this[MAP] = Object.create(null);
      if (init instanceof Headers2) {
        const rawHeaders = init.raw();
        const headerNames = Object.keys(rawHeaders);
        for (const headerName of headerNames) {
          for (const value of rawHeaders[headerName]) {
            this.append(headerName, value);
          }
        }
        return;
      }
      if (init == null)
        ;
      else if (typeof init === "object") {
        const method = init[Symbol.iterator];
        if (method != null) {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }
          const pairs = [];
          for (const pair of init) {
            if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
              throw new TypeError("Each header pair must be iterable");
            }
            pairs.push(Array.from(pair));
          }
          for (const pair of pairs) {
            if (pair.length !== 2) {
              throw new TypeError("Each header pair must be a name/value tuple");
            }
            this.append(pair[0], pair[1]);
          }
        } else {
          for (const key of Object.keys(init)) {
            const value = init[key];
            this.append(key, value);
          }
        }
      } else {
        throw new TypeError("Provided initializer must be an object");
      }
    }
    get(name302) {
      name302 = `${name302}`;
      validateName(name302);
      const key = find(this[MAP], name302);
      if (key === undefined) {
        return null;
      }
      return this[MAP][key].join(", ");
    }
    forEach(callback) {
      let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      let pairs = getHeaders(this);
      let i3 = 0;
      while (i3 < pairs.length) {
        var _pairs$i = pairs[i3];
        const name302 = _pairs$i[0], value = _pairs$i[1];
        callback.call(thisArg, value, name302, this);
        pairs = getHeaders(this);
        i3++;
      }
    }
    set(name302, value) {
      name302 = `${name302}`;
      value = `${value}`;
      validateName(name302);
      validateValue(value);
      const key = find(this[MAP], name302);
      this[MAP][key !== undefined ? key : name302] = [value];
    }
    append(name302, value) {
      name302 = `${name302}`;
      value = `${value}`;
      validateName(name302);
      validateValue(value);
      const key = find(this[MAP], name302);
      if (key !== undefined) {
        this[MAP][key].push(value);
      } else {
        this[MAP][name302] = [value];
      }
    }
    has(name302) {
      name302 = `${name302}`;
      validateName(name302);
      return find(this[MAP], name302) !== undefined;
    }
    delete(name302) {
      name302 = `${name302}`;
      validateName(name302);
      const key = find(this[MAP], name302);
      if (key !== undefined) {
        delete this[MAP][key];
      }
    }
    raw() {
      return this[MAP];
    }
    keys() {
      return createHeadersIterator(this, "key");
    }
    values() {
      return createHeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
      return createHeadersIterator(this, "key+value");
    }
  }
  Headers2.prototype.entries = Headers2.prototype[Symbol.iterator];
  Object.defineProperty(Headers2.prototype, Symbol.toStringTag, {
    value: "Headers",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Headers2.prototype, {
    get: { enumerable: true },
    forEach: { enumerable: true },
    set: { enumerable: true },
    append: { enumerable: true },
    has: { enumerable: true },
    delete: { enumerable: true },
    keys: { enumerable: true },
    values: { enumerable: true },
    entries: { enumerable: true }
  });
  var INTERNAL = Symbol("internal");
  var HeadersIteratorPrototype = Object.setPrototypeOf({
    next() {
      if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
        throw new TypeError("Value of `this` is not a HeadersIterator");
      }
      var _INTERNAL = this[INTERNAL];
      const { target, kind, index: index2 } = _INTERNAL;
      const values = getHeaders(target, kind);
      const len = values.length;
      if (index2 >= len) {
        return {
          value: undefined,
          done: true
        };
      }
      this[INTERNAL].index = index2 + 1;
      return {
        value: values[index2],
        done: false
      };
    }
  }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
  Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: "HeadersIterator",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var INTERNALS$1 = Symbol("Response internals");
  var STATUS_CODES = http.STATUS_CODES;

  class Response {
    constructor() {
      let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      Body.call(this, body, opts);
      const status = opts.status || 200;
      const headers = new Headers2(opts.headers);
      if (body != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(body);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      this[INTERNALS$1] = {
        url: opts.url,
        status,
        statusText: opts.statusText || STATUS_CODES[status],
        headers,
        counter: opts.counter
      };
    }
    get url() {
      return this[INTERNALS$1].url || "";
    }
    get status() {
      return this[INTERNALS$1].status;
    }
    get ok() {
      return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
      return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
      return this[INTERNALS$1].statusText;
    }
    get headers() {
      return this[INTERNALS$1].headers;
    }
    clone() {
      return new Response(clone5(this), {
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok,
        redirected: this.redirected
      });
    }
  }
  Body.mixIn(Response.prototype);
  Object.defineProperties(Response.prototype, {
    url: { enumerable: true },
    status: { enumerable: true },
    ok: { enumerable: true },
    redirected: { enumerable: true },
    statusText: { enumerable: true },
    headers: { enumerable: true },
    clone: { enumerable: true }
  });
  Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: "Response",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var INTERNALS$2 = Symbol("Request internals");
  var URL2 = Url.URL || whatwgUrl.URL;
  var parse_url = Url.parse;
  var format_url = Url.format;
  var streamDestructionSupported = "destroy" in Stream.Readable.prototype;

  class Request {
    constructor(input) {
      let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      let parsedURL;
      if (!isRequest(input)) {
        if (input && input.href) {
          parsedURL = parseURL(input.href);
        } else {
          parsedURL = parseURL(`${input}`);
        }
        input = {};
      } else {
        parsedURL = parseURL(input.url);
      }
      let method = init.method || input.method || "GET";
      method = method.toUpperCase();
      if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }
      let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone5(input) : null;
      Body.call(this, inputBody, {
        timeout: init.timeout || input.timeout || 0,
        size: init.size || input.size || 0
      });
      const headers = new Headers2(init.headers || input.headers || {});
      if (inputBody != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(inputBody);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      let signal = isRequest(input) ? input.signal : null;
      if ("signal" in init)
        signal = init.signal;
      if (signal != null && !isAbortSignal(signal)) {
        throw new TypeError("Expected signal to be an instanceof AbortSignal");
      }
      this[INTERNALS$2] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL,
        signal
      };
      this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
      this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
    }
    get method() {
      return this[INTERNALS$2].method;
    }
    get url() {
      return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
      return this[INTERNALS$2].headers;
    }
    get redirect() {
      return this[INTERNALS$2].redirect;
    }
    get signal() {
      return this[INTERNALS$2].signal;
    }
    clone() {
      return new Request(this);
    }
  }
  Body.mixIn(Request.prototype);
  Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: "Request",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Request.prototype, {
    method: { enumerable: true },
    url: { enumerable: true },
    headers: { enumerable: true },
    redirect: { enumerable: true },
    clone: { enumerable: true },
    signal: { enumerable: true }
  });
  AbortError.prototype = Object.create(Error.prototype);
  AbortError.prototype.constructor = AbortError;
  AbortError.prototype.name = "AbortError";
  var URL$1 = Url.URL || whatwgUrl.URL;
  var PassThrough$1 = Stream.PassThrough;
  var isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
    const orig = new URL$1(original).hostname;
    const dest = new URL$1(destination).hostname;
    return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
  };
  fetch2.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  };
  fetch2.Promise = globalThis.Promise;
  module.exports = exports = fetch2;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = exports;
  exports.Headers = Headers2;
  exports.Request = Request;
  exports.Response = Response;
  exports.FetchError = FetchError;
});

// ../../node_modules/lodash/lodash.js
var require_lodash = __commonJS((exports, module) => {
  (function() {
    var undefined2;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991, MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types4 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types4) {
          return types4;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e4) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply3(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array59, setter, iteratee, accumulator) {
      var index2 = -1, length = array59 == null ? 0 : array59.length;
      while (++index2 < length) {
        var value = array59[index2];
        setter(accumulator, value, iteratee(value), array59);
      }
      return accumulator;
    }
    function arrayEach(array59, iteratee) {
      var index2 = -1, length = array59 == null ? 0 : array59.length;
      while (++index2 < length) {
        if (iteratee(array59[index2], index2, array59) === false) {
          break;
        }
      }
      return array59;
    }
    function arrayEachRight(array59, iteratee) {
      var length = array59 == null ? 0 : array59.length;
      while (length--) {
        if (iteratee(array59[length], length, array59) === false) {
          break;
        }
      }
      return array59;
    }
    function arrayEvery(array59, predicate) {
      var index2 = -1, length = array59 == null ? 0 : array59.length;
      while (++index2 < length) {
        if (!predicate(array59[index2], index2, array59)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array59, predicate) {
      var index2 = -1, length = array59 == null ? 0 : array59.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array59[index2];
        if (predicate(value, index2, array59)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array59, value) {
      var length = array59 == null ? 0 : array59.length;
      return !!length && baseIndexOf(array59, value, 0) > -1;
    }
    function arrayIncludesWith(array59, value, comparator) {
      var index2 = -1, length = array59 == null ? 0 : array59.length;
      while (++index2 < length) {
        if (comparator(value, array59[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array59, iteratee) {
      var index2 = -1, length = array59 == null ? 0 : array59.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array59[index2], index2, array59);
      }
      return result;
    }
    function arrayPush(array59, values) {
      var index2 = -1, length = values.length, offset = array59.length;
      while (++index2 < length) {
        array59[offset + index2] = values[index2];
      }
      return array59;
    }
    function arrayReduce(array59, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array59 == null ? 0 : array59.length;
      if (initAccum && length) {
        accumulator = array59[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array59[index2], index2, array59);
      }
      return accumulator;
    }
    function arrayReduceRight(array59, iteratee, accumulator, initAccum) {
      var length = array59 == null ? 0 : array59.length;
      if (initAccum && length) {
        accumulator = array59[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array59[length], length, array59);
      }
      return accumulator;
    }
    function arraySome(array59, predicate) {
      var index2 = -1, length = array59 == null ? 0 : array59.length;
      while (++index2 < length) {
        if (predicate(array59[index2], index2, array59)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string31) {
      return string31.split("");
    }
    function asciiWords(string31) {
      return string31.match(reAsciiWord) || [];
    }
    function baseFindKey(collection47, predicate, eachFunc) {
      var result;
      eachFunc(collection47, function(value, key, collection48) {
        if (predicate(value, key, collection48)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array59, predicate, fromIndex, fromRight) {
      var length = array59.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array59[index2], index2, array59)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array59, value, fromIndex) {
      return value === value ? strictIndexOf(array59, value, fromIndex) : baseFindIndex(array59, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array59, value, fromIndex, comparator) {
      var index2 = fromIndex - 1, length = array59.length;
      while (++index2 < length) {
        if (comparator(array59[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array59, iteratee) {
      var length = array59 == null ? 0 : array59.length;
      return length ? baseSum(array59, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object36) {
        return object36 == null ? undefined2 : object36[key];
      };
    }
    function basePropertyOf(object36) {
      return function(key) {
        return object36 == null ? undefined2 : object36[key];
      };
    }
    function baseReduce(collection47, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection47, function(value, index2, collection48) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection48);
      });
      return accumulator;
    }
    function baseSortBy(array59, comparer) {
      var length = array59.length;
      array59.sort(comparer);
      while (length--) {
        array59[length] = array59[length].value;
      }
      return array59;
    }
    function baseSum(array59, iteratee) {
      var result, index2 = -1, length = array59.length;
      while (++index2 < length) {
        var current = iteratee(array59[index2]);
        if (current !== undefined2) {
          result = result === undefined2 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object36, props) {
      return arrayMap(props, function(key) {
        return [key, object36[key]];
      });
    }
    function baseTrim(string31) {
      return string31 ? string31.slice(0, trimmedEndIndex(string31) + 1).replace(reTrimStart, "") : string31;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object36, props) {
      return arrayMap(props, function(key) {
        return object36[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array59, placeholder) {
      var length = array59.length, result = 0;
      while (length--) {
        if (array59[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object36, key) {
      return object36 == null ? undefined2 : object36[key];
    }
    function hasUnicode(string31) {
      return reHasUnicode.test(string31);
    }
    function hasUnicodeWord(string31) {
      return reHasUnicodeWord.test(string31);
    }
    function iteratorToArray(iterator) {
      var data2, result = [];
      while (!(data2 = iterator.next()).done) {
        result.push(data2.value);
      }
      return result;
    }
    function mapToArray(map11) {
      var index2 = -1, result = Array(map11.size);
      map11.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg3) {
        return func(transform(arg3));
      };
    }
    function replaceHolders(array59, placeholder) {
      var index2 = -1, length = array59.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array59[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array59[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array59, value, fromIndex) {
      var index2 = fromIndex - 1, length = array59.length;
      while (++index2 < length) {
        if (array59[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array59, value, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array59[index2] === value) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string31) {
      return hasUnicode(string31) ? unicodeSize(string31) : asciiSize(string31);
    }
    function stringToArray(string31) {
      return hasUnicode(string31) ? unicodeToArray(string31) : asciiToArray(string31);
    }
    function trimmedEndIndex(string31) {
      var index2 = string31.length;
      while (index2-- && reWhitespace.test(string31.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string31) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string31)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string31) {
      return string31.match(reUnicode) || [];
    }
    function unicodeWords(string31) {
      return string31.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext(context2) {
      context2 = context2 == null ? root : _.defaults(root.Object(), context2, _.pick(root, contextProps));
      var { Array: Array2, Date: Date2, Error: Error2, Function: Function2, Math: Math2, Object: Object2, RegExp: RegExp2, String: String2, TypeError: TypeError2 } = context2;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context2["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty3 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context2.Buffer : undefined2, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
      var defineProperty17 = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e4) {
        }
      }();
      var ctxClearTimeout = context2.clearTimeout !== root.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root.setTimeout && context2.setTimeout;
      var { ceil: nativeCeil, floor: nativeFloor } = Math2, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context2, "DataView"), Map2 = getNative(context2, "Map"), Promise2 = getNative(context2, "Promise"), Set2 = getNative(context2, "Set"), WeakMap2 = getNative(context2, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2;
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
      function lodash(value) {
        if (isObjectLike(value) && !isArray3(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty3.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object36() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object36.prototype = proto;
          var result2 = new object36;
          object36.prototype = undefined2;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined2;
      }
      lodash.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: "",
        imports: {
          _: lodash
        }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array59 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray3(array59), isRight = dir < 0, arrLength = isArr ? array59.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array59, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array59[index2];
            while (++iterIndex < iterLength) {
              var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data2 = this.__data__;
        if (nativeCreate) {
          var result2 = data2[key];
          return result2 === HASH_UNDEFINED ? undefined2 : result2;
        }
        return hasOwnProperty3.call(data2, key) ? data2[key] : undefined2;
      }
      function hashHas(key) {
        var data2 = this.__data__;
        return nativeCreate ? data2[key] !== undefined2 : hasOwnProperty3.call(data2, key);
      }
      function hashSet(key, value) {
        var data2 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data2[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index2 == lastIndex) {
          data2.pop();
        } else {
          splice.call(data2, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key);
        return index2 < 0 ? undefined2 : data2[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key);
        if (index2 < 0) {
          ++this.size;
          data2.push([key, value]);
        } else {
          data2[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          hash: new Hash,
          map: new (Map2 || ListCache),
          string: new Hash
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data2 = getMapData(this, key), size4 = data2.size;
        data2.set(key, value);
        this.size += data2.size == size4 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index2 = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache;
        while (++index2 < length) {
          this.add(values2[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data2 = this.__data__ = new ListCache(entries);
        this.size = data2.size;
      }
      function stackClear() {
        this.__data__ = new ListCache;
        this.size = 0;
      }
      function stackDelete(key) {
        var data2 = this.__data__, result2 = data2["delete"](key);
        this.size = data2.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data2 = this.__data__;
        if (data2 instanceof ListCache) {
          var pairs = data2.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data2.size;
            return this;
          }
          data2 = this.__data__ = new MapCache(pairs);
        }
        data2.set(key, value);
        this.size = data2.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray3(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex2(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array59) {
        var length = array59.length;
        return length ? array59[baseRandom(0, length - 1)] : undefined2;
      }
      function arraySampleSize(array59, n) {
        return shuffleSelf(copyArray(array59), baseClamp(n, 0, array59.length));
      }
      function arrayShuffle(array59) {
        return shuffleSelf(copyArray(array59));
      }
      function assignMergeValue(object36, key, value) {
        if (value !== undefined2 && !eq(object36[key], value) || value === undefined2 && !(key in object36)) {
          baseAssignValue(object36, key, value);
        }
      }
      function assignValue(object36, key, value) {
        var objValue = object36[key];
        if (!(hasOwnProperty3.call(object36, key) && eq(objValue, value)) || value === undefined2 && !(key in object36)) {
          baseAssignValue(object36, key, value);
        }
      }
      function assocIndexOf(array59, key) {
        var length = array59.length;
        while (length--) {
          if (eq(array59[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection47, setter, iteratee2, accumulator) {
        baseEach(collection47, function(value, key, collection48) {
          setter(accumulator, value, iteratee2(value), collection48);
        });
        return accumulator;
      }
      function baseAssign(object36, source) {
        return object36 && copyObject(source, keys(source), object36);
      }
      function baseAssignIn(object36, source) {
        return object36 && copyObject(source, keysIn(source), object36);
      }
      function baseAssignValue(object36, key, value) {
        if (key == "__proto__" && defineProperty17) {
          defineProperty17(object36, key, {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        } else {
          object36[key] = value;
        }
      }
      function baseAt(object36, paths) {
        var index2 = -1, length = paths.length, result2 = Array2(length), skip = object36 == null;
        while (++index2 < length) {
          result2[index2] = skip ? undefined2 : get(object36, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number102, lower, upper) {
        if (number102 === number102) {
          if (upper !== undefined2) {
            number102 = number102 <= upper ? number102 : upper;
          }
          if (lower !== undefined2) {
            number102 = number102 >= lower ? number102 : lower;
          }
        }
        return number102;
      }
      function baseClone(value, bitmask2, customizer, key, object36, stack) {
        var result2, isDeep = bitmask2 & CLONE_DEEP_FLAG, isFlat = bitmask2 & CLONE_FLAT_FLAG, isFull = bitmask2 & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object36 ? customizer(value, key, object36, stack) : customizer(value);
        }
        if (result2 !== undefined2) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray3(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag2 = getTag(value), isFunc = tag2 == funcTag || tag2 == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag2 == objectTag || tag2 == argsTag || isFunc && !object36) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag2]) {
              return object36 ? value : {};
            }
            result2 = initCloneByTag(value, tag2, isDeep);
          }
        }
        stack || (stack = new Stack);
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask2, customizer, subValue, value, stack));
          });
        } else if (isMap2(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask2, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined2 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask2, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object36) {
          return baseConformsTo(object36, source, props);
        };
      }
      function baseConformsTo(object36, source, props) {
        var length = props.length;
        if (object36 == null) {
          return !length;
        }
        object36 = Object2(object36);
        while (length--) {
          var key = props[length], predicate = source[key], value = object36[key];
          if (value === undefined2 && !(key in object36) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined2, args);
        }, wait);
      }
      function baseDifference(array59, values2, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array59.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index2 < length) {
            var value = array59[index2], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection47, predicate) {
        var result2 = true;
        baseEach(collection47, function(value, index2, collection48) {
          result2 = !!predicate(value, index2, collection48);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array59, iteratee2, comparator) {
        var index2 = -1, length = array59.length;
        while (++index2 < length) {
          var value = array59[index2], current = iteratee2(value);
          if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array59, value, start, end) {
        var length = array59.length;
        start = toInteger2(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined2 || end > length ? length : toInteger2(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array59[start++] = value;
        }
        return array59;
      }
      function baseFilter(collection47, predicate) {
        var result2 = [];
        baseEach(collection47, function(value, index2, collection48) {
          if (predicate(value, index2, collection48)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array59, depth, predicate, isStrict, result2) {
        var index2 = -1, length = array59.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value = array59[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object36, iteratee2) {
        return object36 && baseFor(object36, iteratee2, keys);
      }
      function baseForOwnRight(object36, iteratee2) {
        return object36 && baseForRight(object36, iteratee2, keys);
      }
      function baseFunctions(object36, props) {
        return arrayFilter(props, function(key) {
          return isFunction3(object36[key]);
        });
      }
      function baseGet(object36, path2) {
        path2 = castPath(path2, object36);
        var index2 = 0, length = path2.length;
        while (object36 != null && index2 < length) {
          object36 = object36[toKey(path2[index2++])];
        }
        return index2 && index2 == length ? object36 : undefined2;
      }
      function baseGetAllKeys(object36, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object36);
        return isArray3(object36) ? result2 : arrayPush(result2, symbolsFunc(object36));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined2 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString2(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object36, key) {
        return object36 != null && hasOwnProperty3.call(object36, key);
      }
      function baseHasIn(object36, key) {
        return object36 != null && key in Object2(object36);
      }
      function baseInRange(number102, start, end) {
        return number102 >= nativeMin(start, end) && number102 < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array59 = arrays[othIndex];
          if (othIndex && iteratee2) {
            array59 = arrayMap(array59, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array59.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array59.length >= 120) ? new SetCache(othIndex && array59) : undefined2;
        }
        array59 = arrays[0];
        var index2 = -1, seen = caches[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value = array59[index2], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object36, setter, iteratee2, accumulator) {
        baseForOwn(object36, function(value, key, object37) {
          setter(accumulator, iteratee2(value), key, object37);
        });
        return accumulator;
      }
      function baseInvoke(object36, path2, args) {
        path2 = castPath(path2, object36);
        object36 = parent(object36, path2);
        var func = object36 == null ? object36 : object36[toKey(last(path2))];
        return func == null ? undefined2 : apply3(func, object36, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask2, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask2, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object36, other, bitmask2, customizer, equalFunc, stack) {
        var objIsArr = isArray3(object36), othIsArr = isArray3(other), objTag = objIsArr ? arrayTag : getTag(object36), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object36)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack);
          return objIsArr || isTypedArray(object36) ? equalArrays(object36, other, bitmask2, customizer, equalFunc, stack) : equalByTag(object36, other, objTag, bitmask2, customizer, equalFunc, stack);
        }
        if (!(bitmask2 & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty3.call(object36, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty3.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object36.value() : object36, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask2, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack);
        return equalObjects(object36, other, bitmask2, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object36, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object36 == null) {
          return !length;
        }
        object36 = Object2(object36);
        while (index2--) {
          var data2 = matchData[index2];
          if (noCustomizer && data2[2] ? data2[1] !== object36[data2[0]] : !(data2[0] in object36)) {
            return false;
          }
        }
        while (++index2 < length) {
          data2 = matchData[index2];
          var key = data2[0], objValue = object36[key], srcValue = data2[1];
          if (noCustomizer && data2[2]) {
            if (objValue === undefined2 && !(key in object36)) {
              return false;
            }
          } else {
            var stack = new Stack;
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object36, source, stack);
            }
            if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction3(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity3;
        }
        if (typeof value == "object") {
          return isArray3(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object36) {
        if (!isPrototype(object36)) {
          return nativeKeys(object36);
        }
        var result2 = [];
        for (var key in Object2(object36)) {
          if (hasOwnProperty3.call(object36, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object36) {
        if (!isObject2(object36)) {
          return nativeKeysIn(object36);
        }
        var isProto = isPrototype(object36), result2 = [];
        for (var key in object36) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty3.call(object36, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection47, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection47) ? Array2(collection47.length) : [];
        baseEach(collection47, function(value, key, collection48) {
          result2[++index2] = iteratee2(value, key, collection48);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object36) {
          return object36 === source || baseIsMatch(object36, source, matchData);
        };
      }
      function baseMatchesProperty(path2, srcValue) {
        if (isKey(path2) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path2), srcValue);
        }
        return function(object36) {
          var objValue = get(object36, path2);
          return objValue === undefined2 && objValue === srcValue ? hasIn(object36, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object36, source, srcIndex, customizer, stack) {
        if (object36 === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack);
          if (isObject2(srcValue)) {
            baseMergeDeep(object36, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object36, key), srcValue, key + "", object36, source, stack) : undefined2;
            if (newValue === undefined2) {
              newValue = srcValue;
            }
            assignMergeValue(object36, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object36, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object36, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object36, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object36, source, stack) : undefined2;
        var isCommon = newValue === undefined2;
        if (isCommon) {
          var isArr = isArray3(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray3(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction3(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object36, key, newValue);
      }
      function baseNth(array59, n) {
        var length = array59.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex2(n, length) ? array59[n] : undefined2;
      }
      function baseOrderBy(collection47, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray3(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity3];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection47, function(value, key, collection48) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { criteria, index: ++index2, value };
        });
        return baseSortBy(result2, function(object36, other) {
          return compareMultiple(object36, other, orders);
        });
      }
      function basePick(object36, paths) {
        return basePickBy(object36, paths, function(value, path2) {
          return hasIn(object36, path2);
        });
      }
      function basePickBy(object36, paths, predicate) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path2 = paths[index2], value = baseGet(object36, path2);
          if (predicate(value, path2)) {
            baseSet(result2, castPath(path2, object36), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path2) {
        return function(object36) {
          return baseGet(object36, path2);
        };
      }
      function basePullAll(array59, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array59;
        if (array59 === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array59, baseUnary(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array59) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array59, fromIndex, 1);
          }
        }
        return array59;
      }
      function basePullAt(array59, indexes) {
        var length = array59 ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex2(index2)) {
              splice.call(array59, index2, 1);
            } else {
              baseUnset(array59, index2);
            }
          }
        }
        return array59;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string31, n) {
        var result2 = "";
        if (!string31 || n < 1 || n > MAX_SAFE_INTEGER2) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string31;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string31 += string31;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity3), func + "");
      }
      function baseSample(collection47) {
        return arraySample(values(collection47));
      }
      function baseSampleSize(collection47, n) {
        var array59 = values(collection47);
        return shuffleSelf(array59, baseClamp(n, 0, array59.length));
      }
      function baseSet(object36, path2, value, customizer) {
        if (!isObject2(object36)) {
          return object36;
        }
        path2 = castPath(path2, object36);
        var index2 = -1, length = path2.length, lastIndex = length - 1, nested = object36;
        while (nested != null && ++index2 < length) {
          var key = toKey(path2[index2]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object36;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined2;
            if (newValue === undefined2) {
              newValue = isObject2(objValue) ? objValue : isIndex2(path2[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object36;
      }
      var baseSetData = !metaMap ? identity3 : function(func, data2) {
        metaMap.set(func, data2);
        return func;
      };
      var baseSetToString = !defineProperty17 ? identity3 : function(func, string31) {
        return defineProperty17(func, "toString", {
          configurable: true,
          enumerable: false,
          value: constant(string31),
          writable: true
        });
      };
      function baseShuffle(collection47) {
        return shuffleSelf(values(collection47));
      }
      function baseSlice(array59, start, end) {
        var index2 = -1, length = array59.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index2 < length) {
          result2[index2] = array59[index2 + start];
        }
        return result2;
      }
      function baseSome(collection47, predicate) {
        var result2;
        baseEach(collection47, function(value, index2, collection48) {
          result2 = predicate(value, index2, collection48);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array59, value, retHighest) {
        var low = 0, high = array59 == null ? low : array59.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array59[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array59, value, identity3, retHighest);
      }
      function baseSortedIndexBy(array59, value, iteratee2, retHighest) {
        var low = 0, high = array59 == null ? 0 : array59.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array59[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array59, iteratee2) {
        var index2 = -1, length = array59.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array59[index2], computed = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray3(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array59, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, length = array59.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array59);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache;
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value = array59[index2], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object36, path2) {
        path2 = castPath(path2, object36);
        object36 = parent(object36, path2);
        return object36 == null || delete object36[toKey(last(path2))];
      }
      function baseUpdate(object36, path2, updater, customizer) {
        return baseSet(object36, path2, updater(baseGet(object36, path2)), customizer);
      }
      function baseWhile(array59, predicate, isDrop, fromRight) {
        var length = array59.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array59[index2], index2, array59)) {
        }
        return isDrop ? baseSlice(array59, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array59, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length);
        while (++index2 < length) {
          var array59 = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array59, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index2 < length) {
          var value = index2 < valsLength ? values2[index2] : undefined2;
          assignFunc(result2, props[index2], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity3;
      }
      function castPath(value, object36) {
        if (isArray3(value)) {
          return value;
        }
        return isKey(value, object36) ? [value] : stringToPath(toString(value));
      }
      var castRest = baseRest;
      function castSlice(array59, start, end) {
        var length = array59.length;
        end = end === undefined2 ? length : end;
        return !start && end >= length ? array59 : baseSlice(array59, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object36, other, orders) {
        var index2 = -1, objCriteria = object36.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order = orders[index2];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object36.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array59) {
        var index2 = -1, length = source.length;
        array59 || (array59 = Array2(length));
        while (++index2 < length) {
          array59[index2] = source[index2];
        }
        return array59;
      }
      function copyObject(source, props, object36, customizer) {
        var isNew = !object36;
        object36 || (object36 = {});
        var index2 = -1, length = props.length;
        while (++index2 < length) {
          var key = props[index2];
          var newValue = customizer ? customizer(object36[key], source[key], key, object36, source) : undefined2;
          if (newValue === undefined2) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object36, key, newValue);
          } else {
            assignValue(object36, key, newValue);
          }
        }
        return object36;
      }
      function copySymbols(source, object36) {
        return copyObject(source, getSymbols(source), object36);
      }
      function copySymbolsIn(source, object36) {
        return copyObject(source, getSymbolsIn(source), object36);
      }
      function createAggregator(setter, initializer) {
        return function(collection47, iteratee2) {
          var func = isArray3(collection47) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection47, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object36, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined2 : customizer;
            length = 1;
          }
          object36 = Object2(object36);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object36, source, index2, customizer);
            }
          }
          return object36;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection47, iteratee2) {
          if (collection47 == null) {
            return collection47;
          }
          if (!isArrayLike(collection47)) {
            return eachFunc(collection47, iteratee2);
          }
          var length = collection47.length, index2 = fromRight ? length : -1, iterable = Object2(collection47);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection47;
        };
      }
      function createBaseFor(fromRight) {
        return function(object36, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object36), props = keysFunc(object36), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object36;
        };
      }
      function createBind(func, bitmask2, thisArg) {
        var isBind = bitmask2 & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string31) {
          string31 = toString(string31);
          var strSymbols = hasUnicode(string31) ? stringToArray(string31) : undefined2;
          var chr = strSymbols ? strSymbols[0] : string31.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string31.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string31) {
          return arrayReduce(words(deburr(string31).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor;
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask2, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask2, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply3(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection47, predicate, fromIndex) {
          var iterable = Object2(collection47);
          if (!isArrayLike(collection47)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection47 = keys(collection47);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index2 = findIndexFunc(collection47, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection47[index2] : index2] : undefined2;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func = funcs[index2];
            var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData(func) : undefined2;
            if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
              wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray3(value)) {
              return wrapper.plant(value).value();
            }
            var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
            while (++index3 < length) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask2, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask2 & WRAP_ARY_FLAG, isBind = bitmask2 & WRAP_BIND_FLAG, isBindKey = bitmask2 & WRAP_BIND_KEY_FLAG, isCurried = bitmask2 & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask2 & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask2, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object36, iteratee2) {
          return baseInverter(object36, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined2 && other === undefined2) {
            return defaultValue;
          }
          if (value !== undefined2) {
            result2 = value;
          }
          if (other !== undefined2) {
            if (result2 === undefined2) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply3(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined2 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask2, thisArg, partials) {
        var isBind = bitmask2 & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply3(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange2(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined2;
          }
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask2, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask2 & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
        bitmask2 |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask2 &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask2 & WRAP_CURRY_BOUND_FLAG)) {
          bitmask2 &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask2,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined2, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask2);
      }
      function createRound2(methodName) {
        var func = Math2[methodName];
        return function(number102, precision) {
          number102 = toNumber(number102);
          precision = precision == null ? 0 : nativeMin(toInteger2(precision), 292);
          if (precision && nativeIsFinite(number102)) {
            var pair = (toString(number102) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number102);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop5 : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object36) {
          var tag2 = getTag(object36);
          if (tag2 == mapTag) {
            return mapToArray(object36);
          }
          if (tag2 == setTag) {
            return setToPairs(object36);
          }
          return baseToPairs(object36, keysFunc(object36));
        };
      }
      function createWrap(func, bitmask2, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask2 & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask2 &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined2;
        }
        ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger2(ary2), 0);
        arity = arity === undefined2 ? arity : toInteger2(arity);
        length -= holders ? holders.length : 0;
        if (bitmask2 & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined2;
        }
        var data2 = isBindKey ? undefined2 : getData(func);
        var newData = [
          func,
          bitmask2,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data2) {
          mergeData(newData, data2);
        }
        func = newData[0];
        bitmask2 = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask2 & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask2 &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask2 || bitmask2 == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask2, thisArg);
        } else if (bitmask2 == WRAP_CURRY_FLAG || bitmask2 == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask2, arity);
        } else if ((bitmask2 == WRAP_PARTIAL_FLAG || bitmask2 == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask2, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined2, newData);
        }
        var setter = data2 ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask2);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object36) {
        if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty3.call(object36, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object36, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject2(value) ? undefined2 : value;
      }
      function equalArrays(array59, other, bitmask2, customizer, equalFunc, stack) {
        var isPartial = bitmask2 & COMPARE_PARTIAL_FLAG, arrLength = array59.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array59);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array59;
        }
        var index2 = -1, result2 = true, seen = bitmask2 & COMPARE_UNORDERED_FLAG ? new SetCache : undefined2;
        stack.set(array59, other);
        stack.set(other, array59);
        while (++index2 < arrLength) {
          var arrValue = array59[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array59, stack) : customizer(arrValue, othValue, index2, array59, other, stack);
          }
          if (compared !== undefined2) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask2, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask2, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array59);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object36, other, tag2, bitmask2, customizer, equalFunc, stack) {
        switch (tag2) {
          case dataViewTag:
            if (object36.byteLength != other.byteLength || object36.byteOffset != other.byteOffset) {
              return false;
            }
            object36 = object36.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object36.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object36), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object36, +other);
          case errorTag:
            return object36.name == other.name && object36.message == other.message;
          case regexpTag:
          case stringTag:
            return object36 == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask2 & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object36.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object36);
            if (stacked) {
              return stacked == other;
            }
            bitmask2 |= COMPARE_UNORDERED_FLAG;
            stack.set(object36, other);
            var result2 = equalArrays(convert(object36), convert(other), bitmask2, customizer, equalFunc, stack);
            stack["delete"](object36);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object36) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object36, other, bitmask2, customizer, equalFunc, stack) {
        var isPartial = bitmask2 & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object36), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty3.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object36);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object36;
        }
        var result2 = true;
        stack.set(object36, other);
        stack.set(other, object36);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object36[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object36, stack) : customizer(objValue, othValue, key, object36, other, stack);
          }
          if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask2, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object36.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && (("constructor" in object36) && ("constructor" in other)) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object36);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined2, flatten4), func + "");
      }
      function getAllKeys(object36) {
        return baseGetAllKeys(object36, keys, getSymbols);
      }
      function getAllKeysIn(object36) {
        return baseGetAllKeys(object36, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop5 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array59 = realNames[result2], length = hasOwnProperty3.call(realNames, result2) ? array59.length : 0;
        while (length--) {
          var data2 = array59[length], otherFunc = data2.func;
          if (otherFunc == null || otherFunc == func) {
            return data2.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object36 = hasOwnProperty3.call(lodash, "placeholder") ? lodash : func;
        return object36.placeholder;
      }
      function getIteratee() {
        var result2 = lodash.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map12, key) {
        var data2 = map12.__data__;
        return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
      }
      function getMatchData(object36) {
        var result2 = keys(object36), length = result2.length;
        while (length--) {
          var key = result2[length], value = object36[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object36, key) {
        var value = getValue(object36, key);
        return baseIsNative(value) ? value : undefined2;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty3.call(value, symToStringTag), tag2 = value[symToStringTag];
        try {
          value[symToStringTag] = undefined2;
          var unmasked = true;
        } catch (e4) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag2;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object36) {
        if (object36 == null) {
          return [];
        }
        object36 = Object2(object36);
        return arrayFilter(nativeGetSymbols(object36), function(symbol) {
          return propertyIsEnumerable.call(object36, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object36) {
        var result2 = [];
        while (object36) {
          arrayPush(result2, getSymbols(object36));
          object36 = getPrototype(object36);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2) != setTag || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data2 = transforms[index2], size4 = data2.size;
          switch (data2.type) {
            case "drop":
              start += size4;
              break;
            case "dropRight":
              end -= size4;
              break;
            case "take":
              end = nativeMin(end, start + size4);
              break;
            case "takeRight":
              start = nativeMax(start, end - size4);
              break;
          }
        }
        return { start, end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object36, path2, hasFunc) {
        path2 = castPath(path2, object36);
        var index2 = -1, length = path2.length, result2 = false;
        while (++index2 < length) {
          var key = toKey(path2[index2]);
          if (!(result2 = object36 != null && hasFunc(object36, key))) {
            break;
          }
          object36 = object36[key];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object36 == null ? 0 : object36.length;
        return !!length && isLength(length) && isIndex2(key, length) && (isArray3(object36) || isArguments(object36));
      }
      function initCloneArray(array59) {
        var length = array59.length, result2 = new array59.constructor(length);
        if (length && typeof array59[0] == "string" && hasOwnProperty3.call(array59, "index")) {
          result2.index = array59.index;
          result2.input = array59.input;
        }
        return result2;
      }
      function initCloneObject(object36) {
        return typeof object36.constructor == "function" && !isPrototype(object36) ? baseCreate(getPrototype(object36)) : {};
      }
      function initCloneByTag(object36, tag2, isDeep) {
        var Ctor = object36.constructor;
        switch (tag2) {
          case arrayBufferTag:
            return cloneArrayBuffer(object36);
          case boolTag:
          case dateTag:
            return new Ctor(+object36);
          case dataViewTag:
            return cloneDataView(object36, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object36, isDeep);
          case mapTag:
            return new Ctor;
          case numberTag:
          case stringTag:
            return new Ctor(object36);
          case regexpTag:
            return cloneRegExp(object36);
          case setTag:
            return new Ctor;
          case symbolTag:
            return cloneSymbol(object36);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray3(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex2(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER2 : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index2, object36) {
        if (!isObject2(object36)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object36) && isIndex2(index2, object36.length) : type == "string" && (index2 in object36)) {
          return eq(object36[index2], value);
        }
        return false;
      }
      function isKey(value, object36) {
        if (isArray3(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object36 != null && value in Object2(object36);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data2 = getData(other);
        return !!data2 && func === data2[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction3 : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object36) {
          if (object36 == null) {
            return false;
          }
          return object36[key] === srcValue && (srcValue !== undefined2 || (key in Object2(object36)));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize2(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data2, source) {
        var bitmask2 = data2[1], srcBitmask = source[1], newBitmask = bitmask2 | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask2 == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask2 == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask2 == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data2;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data2[2] = source[2];
          newBitmask |= bitmask2 & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data2[3];
          data2[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data2[5];
          data2[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data2[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data2[8] = data2[8] == null ? source[8] : nativeMin(data2[8], source[8]);
        }
        if (data2[9] == null) {
          data2[9] = source[9];
        }
        data2[0] = source[0];
        data2[1] = newBitmask;
        return data2;
      }
      function nativeKeysIn(object36) {
        var result2 = [];
        if (object36 != null) {
          for (var key in Object2(object36)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString2(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array59 = Array2(length);
          while (++index2 < length) {
            array59[index2] = args[start + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start + 1);
          while (++index2 < start) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start] = transform2(array59);
          return apply3(func, this, otherArgs);
        };
      }
      function parent(object36, path2) {
        return path2.length < 2 ? object36 : baseGet(object36, baseSlice(path2, 0, -1));
      }
      function reorder(array59, indexes) {
        var arrLength = array59.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array59);
        while (length--) {
          var index2 = indexes[length];
          array59[length] = isIndex2(index2, arrLength) ? oldArray[index2] : undefined2;
        }
        return array59;
      }
      function safeGet(object36, key) {
        if (key === "constructor" && typeof object36[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object36[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask2) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask2)));
      }
      function shortOut(func) {
        var count3 = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count3 >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count3 = 0;
          }
          return func.apply(undefined2, arguments);
        };
      }
      function shuffleSelf(array59, size4) {
        var index2 = -1, length = array59.length, lastIndex = length - 1;
        size4 = size4 === undefined2 ? length : size4;
        while (++index2 < size4) {
          var rand = baseRandom(index2, lastIndex), value = array59[rand];
          array59[rand] = array59[index2];
          array59[index2] = value;
        }
        array59.length = size4;
        return array59;
      }
      var stringToPath = memoizeCapped(function(string31) {
        var result2 = [];
        if (string31.charCodeAt(0) === 46) {
          result2.push("");
        }
        string31.replace(rePropName, function(match, number102, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number102 || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e4) {
          }
          try {
            return func + "";
          } catch (e4) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask2) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask2 & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array59, size4, guard) {
        if (guard ? isIterateeCall(array59, size4, guard) : size4 === undefined2) {
          size4 = 1;
        } else {
          size4 = nativeMax(toInteger2(size4), 0);
        }
        var length = array59 == null ? 0 : array59.length;
        if (!length || size4 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size4));
        while (index2 < length) {
          result2[resIndex++] = baseSlice(array59, index2, index2 += size4);
        }
        return result2;
      }
      function compact(array59) {
        var index2 = -1, length = array59 == null ? 0 : array59.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array59[index2];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat4() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array59 = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray3(array59) ? copyArray(array59) : [array59], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array59, values2) {
        return isArrayLikeObject(array59) ? baseDifference(array59, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array59, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return isArrayLikeObject(array59) ? baseDifference(array59, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array59, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined2;
        }
        return isArrayLikeObject(array59) ? baseDifference(array59, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
      });
      function drop(array59, n, guard) {
        var length = array59 == null ? 0 : array59.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger2(n);
        return baseSlice(array59, n < 0 ? 0 : n, length);
      }
      function dropRight(array59, n, guard) {
        var length = array59 == null ? 0 : array59.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger2(n);
        n = length - n;
        return baseSlice(array59, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array59, predicate) {
        return array59 && array59.length ? baseWhile(array59, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array59, predicate) {
        return array59 && array59.length ? baseWhile(array59, getIteratee(predicate, 3), true) : [];
      }
      function fill(array59, value, start, end) {
        var length = array59 == null ? 0 : array59.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array59, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array59, value, start, end);
      }
      function findIndex(array59, predicate, fromIndex) {
        var length = array59 == null ? 0 : array59.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseFindIndex(array59, getIteratee(predicate, 3), index2);
      }
      function findLastIndex(array59, predicate, fromIndex) {
        var length = array59 == null ? 0 : array59.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined2) {
          index2 = toInteger2(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return baseFindIndex(array59, getIteratee(predicate, 3), index2, true);
      }
      function flatten4(array59) {
        var length = array59 == null ? 0 : array59.length;
        return length ? baseFlatten(array59, 1) : [];
      }
      function flattenDeep(array59) {
        var length = array59 == null ? 0 : array59.length;
        return length ? baseFlatten(array59, INFINITY) : [];
      }
      function flattenDepth(array59, depth) {
        var length = array59 == null ? 0 : array59.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined2 ? 1 : toInteger2(depth);
        return baseFlatten(array59, depth);
      }
      function fromPairs(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array59) {
        return array59 && array59.length ? array59[0] : undefined2;
      }
      function indexOf(array59, value, fromIndex) {
        var length = array59 == null ? 0 : array59.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseIndexOf(array59, value, index2);
      }
      function initial(array59) {
        var length = array59 == null ? 0 : array59.length;
        return length ? baseSlice(array59, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined2;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
      });
      function join2(array59, separator) {
        return array59 == null ? "" : nativeJoin.call(array59, separator);
      }
      function last(array59) {
        var length = array59 == null ? 0 : array59.length;
        return length ? array59[length - 1] : undefined2;
      }
      function lastIndexOf(array59, value, fromIndex) {
        var length = array59 == null ? 0 : array59.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined2) {
          index2 = toInteger2(fromIndex);
          index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return value === value ? strictLastIndexOf(array59, value, index2) : baseFindIndex(array59, baseIsNaN, index2, true);
      }
      function nth(array59, n) {
        return array59 && array59.length ? baseNth(array59, toInteger2(n)) : undefined2;
      }
      var pull = baseRest(pullAll);
      function pullAll(array59, values2) {
        return array59 && array59.length && values2 && values2.length ? basePullAll(array59, values2) : array59;
      }
      function pullAllBy(array59, values2, iteratee2) {
        return array59 && array59.length && values2 && values2.length ? basePullAll(array59, values2, getIteratee(iteratee2, 2)) : array59;
      }
      function pullAllWith(array59, values2, comparator) {
        return array59 && array59.length && values2 && values2.length ? basePullAll(array59, values2, undefined2, comparator) : array59;
      }
      var pullAt = flatRest(function(array59, indexes) {
        var length = array59 == null ? 0 : array59.length, result2 = baseAt(array59, indexes);
        basePullAt(array59, arrayMap(indexes, function(index2) {
          return isIndex2(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array59, predicate) {
        var result2 = [];
        if (!(array59 && array59.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array59.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length) {
          var value = array59[index2];
          if (predicate(value, index2, array59)) {
            result2.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array59, indexes);
        return result2;
      }
      function reverse(array59) {
        return array59 == null ? array59 : nativeReverse.call(array59);
      }
      function slice(array59, start, end) {
        var length = array59 == null ? 0 : array59.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array59, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger2(start);
          end = end === undefined2 ? length : toInteger2(end);
        }
        return baseSlice(array59, start, end);
      }
      function sortedIndex(array59, value) {
        return baseSortedIndex(array59, value);
      }
      function sortedIndexBy(array59, value, iteratee2) {
        return baseSortedIndexBy(array59, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array59, value) {
        var length = array59 == null ? 0 : array59.length;
        if (length) {
          var index2 = baseSortedIndex(array59, value);
          if (index2 < length && eq(array59[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array59, value) {
        return baseSortedIndex(array59, value, true);
      }
      function sortedLastIndexBy(array59, value, iteratee2) {
        return baseSortedIndexBy(array59, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array59, value) {
        var length = array59 == null ? 0 : array59.length;
        if (length) {
          var index2 = baseSortedIndex(array59, value, true) - 1;
          if (eq(array59[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array59) {
        return array59 && array59.length ? baseSortedUniq(array59) : [];
      }
      function sortedUniqBy(array59, iteratee2) {
        return array59 && array59.length ? baseSortedUniq(array59, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array59) {
        var length = array59 == null ? 0 : array59.length;
        return length ? baseSlice(array59, 1, length) : [];
      }
      function take(array59, n, guard) {
        if (!(array59 && array59.length)) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger2(n);
        return baseSlice(array59, 0, n < 0 ? 0 : n);
      }
      function takeRight(array59, n, guard) {
        var length = array59 == null ? 0 : array59.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger2(n);
        n = length - n;
        return baseSlice(array59, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array59, predicate) {
        return array59 && array59.length ? baseWhile(array59, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array59, predicate) {
        return array59 && array59.length ? baseWhile(array59, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
      });
      function uniq(array59) {
        return array59 && array59.length ? baseUniq(array59) : [];
      }
      function uniqBy(array59, iteratee2) {
        return array59 && array59.length ? baseUniq(array59, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array59, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return array59 && array59.length ? baseUniq(array59, undefined2, comparator) : [];
      }
      function unzip(array59) {
        if (!(array59 && array59.length)) {
          return [];
        }
        var length = 0;
        array59 = arrayFilter(array59, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index2) {
          return arrayMap(array59, baseProperty(index2));
        });
      }
      function unzipWith(array59, iteratee2) {
        if (!(array59 && array59.length)) {
          return [];
        }
        var result2 = unzip(array59);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply3(iteratee2, undefined2, group);
        });
      }
      var without = baseRest(function(array59, values2) {
        return isArrayLikeObject(array59) ? baseDifference(array59, values2) : [];
      });
      var xor3 = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
        return unzipWith(arrays, iteratee2);
      });
      function chain2(value) {
        var result2 = lodash(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object36) {
          return baseAt(object36, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex2(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined2
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array59) {
          if (length && !array59.length) {
            array59.push(undefined2);
          }
          return array59;
        });
      });
      function wrapperChain() {
        return chain2(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined2) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
        return { done, value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone6 = wrapperClone(parent2);
          clone6.__index__ = 0;
          clone6.__values__ = undefined2;
          if (result2) {
            previous.__wrapped__ = clone6;
          } else {
            result2 = clone6;
          }
          var previous = clone6;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined2
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty3.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection47, predicate, guard) {
        var func = isArray3(collection47) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection47, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection47, getIteratee(predicate, 3));
      }
      function filter4(collection47, predicate) {
        var func = isArray3(collection47) ? arrayFilter : baseFilter;
        return func(collection47, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection47, iteratee2) {
        return baseFlatten(map11(collection47, iteratee2), 1);
      }
      function flatMapDeep(collection47, iteratee2) {
        return baseFlatten(map11(collection47, iteratee2), INFINITY);
      }
      function flatMapDepth(collection47, iteratee2, depth) {
        depth = depth === undefined2 ? 1 : toInteger2(depth);
        return baseFlatten(map11(collection47, iteratee2), depth);
      }
      function forEach4(collection47, iteratee2) {
        var func = isArray3(collection47) ? arrayEach : baseEach;
        return func(collection47, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection47, iteratee2) {
        var func = isArray3(collection47) ? arrayEachRight : baseEachRight;
        return func(collection47, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty3.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection47, value, fromIndex, guard) {
        collection47 = isArrayLike(collection47) ? collection47 : values(collection47);
        fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
        var length = collection47.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString2(collection47) ? fromIndex <= length && collection47.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection47, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection47, path2, args) {
        var index2 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike(collection47) ? Array2(collection47.length) : [];
        baseEach(collection47, function(value) {
          result2[++index2] = isFunc ? apply3(path2, value, args) : baseInvoke(value, path2, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map11(collection47, iteratee2) {
        var func = isArray3(collection47) ? arrayMap : baseMap;
        return func(collection47, getIteratee(iteratee2, 3));
      }
      function orderBy(collection47, iteratees, orders, guard) {
        if (collection47 == null) {
          return [];
        }
        if (!isArray3(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined2 : orders;
        if (!isArray3(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection47, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce2(collection47, iteratee2, accumulator) {
        var func = isArray3(collection47) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection47, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection47, iteratee2, accumulator) {
        var func = isArray3(collection47) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection47, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject2(collection47, predicate) {
        var func = isArray3(collection47) ? arrayFilter : baseFilter;
        return func(collection47, negate(getIteratee(predicate, 3)));
      }
      function sample2(collection47) {
        var func = isArray3(collection47) ? arraySample : baseSample;
        return func(collection47);
      }
      function sampleSize(collection47, n, guard) {
        if (guard ? isIterateeCall(collection47, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger2(n);
        }
        var func = isArray3(collection47) ? arraySampleSize : baseSampleSize;
        return func(collection47, n);
      }
      function shuffle2(collection47) {
        var func = isArray3(collection47) ? arrayShuffle : baseShuffle;
        return func(collection47);
      }
      function size3(collection47) {
        if (collection47 == null) {
          return 0;
        }
        if (isArrayLike(collection47)) {
          return isString2(collection47) ? stringSize(collection47) : collection47.length;
        }
        var tag2 = getTag(collection47);
        if (tag2 == mapTag || tag2 == setTag) {
          return collection47.size;
        }
        return baseKeys(collection47).length;
      }
      function some(collection47, predicate, guard) {
        var func = isArray3(collection47) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection47, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection47, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection47, iteratees) {
        if (collection47 == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection47, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection47, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger2(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined2 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger2(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined2;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask2 = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask2 |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask2, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object36, key, partials) {
        var bitmask2 = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask2 |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask2, object36, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined2;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined2;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined2;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined2) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined2;
        }
        function flush() {
          return timerId === undefined2 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined2) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined2) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize2(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize2.Cache || MapCache);
        return memoized;
      }
      memoize2.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray3(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length = nativeMin(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply3(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined2 ? start : toInteger2(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger2(start), 0);
        return baseRest(function(args) {
          var array59 = args[start], otherArgs = castSlice(args, 0, start);
          if (array59) {
            arrayPush(otherArgs, array59);
          }
          return apply3(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray3(value) ? value : [value];
      }
      function clone5(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object36, source) {
        return source == null || baseConformsTo(object36, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray3 = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction3(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean2(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray3(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag2 = getTag(value);
        if (tag2 == mapTag || tag2 == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty3.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        var result2 = customizer ? customizer(value, other) : undefined2;
        return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag2 = baseGetTag(value);
        return tag2 == errorTag || tag2 == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction3(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag2 = baseGetTag(value);
        return tag2 == funcTag || tag2 == genTag || tag2 == asyncTag || tag2 == proxyTag;
      }
      function isInteger4(value) {
        return typeof value == "number" && value == toInteger2(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
      }
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch2(object36, source) {
        return object36 === source || baseIsMatch(object36, source, getMatchData(source));
      }
      function isMatchWith(object36, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseIsMatch(object36, source, getMatchData(source), customizer);
      }
      function isNaN4(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull2(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject2(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty3.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger4(value) && value >= -MAX_SAFE_INTEGER2 && value <= MAX_SAFE_INTEGER2;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value) {
        return typeof value == "string" || !isArray3(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined2(value) {
        return value === undefined2;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString2(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag2 = getTag(value), func = tag2 == mapTag ? mapToArray : tag2 == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign5 = value < 0 ? -1 : 1;
          return sign5 * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger2(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger2(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary2 = reIsBinary.test(value);
        return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger2(value), -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2) : value === 0 ? value : 0;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign3 = createAssigner(function(object36, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object36);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty3.call(source, key)) {
            assignValue(object36, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object36, source) {
        copyObject(source, keysIn(source), object36);
      });
      var assignInWith = createAssigner(function(object36, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object36, customizer);
      });
      var assignWith = createAssigner(function(object36, source, srcIndex, customizer) {
        copyObject(source, keys(source), object36, customizer);
      });
      var at2 = flatRest(baseAt);
      function create2(prototype, properties2) {
        var result2 = baseCreate(prototype);
        return properties2 == null ? result2 : baseAssign(result2, properties2);
      }
      var defaults = baseRest(function(object36, sources) {
        object36 = Object2(object36);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined2;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object36[key];
            if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty3.call(object36, key)) {
              object36[key] = source[key];
            }
          }
        }
        return object36;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined2, customDefaultsMerge);
        return apply3(mergeWith, undefined2, args);
      });
      function findKey(object36, predicate) {
        return baseFindKey(object36, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object36, predicate) {
        return baseFindKey(object36, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object36, iteratee2) {
        return object36 == null ? object36 : baseFor(object36, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object36, iteratee2) {
        return object36 == null ? object36 : baseForRight(object36, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object36, iteratee2) {
        return object36 && baseForOwn(object36, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object36, iteratee2) {
        return object36 && baseForOwnRight(object36, getIteratee(iteratee2, 3));
      }
      function functions(object36) {
        return object36 == null ? [] : baseFunctions(object36, keys(object36));
      }
      function functionsIn(object36) {
        return object36 == null ? [] : baseFunctions(object36, keysIn(object36));
      }
      function get(object36, path2, defaultValue) {
        var result2 = object36 == null ? undefined2 : baseGet(object36, path2);
        return result2 === undefined2 ? defaultValue : result2;
      }
      function has(object36, path2) {
        return object36 != null && hasPath(object36, path2, baseHas);
      }
      function hasIn(object36, path2) {
        return object36 != null && hasPath(object36, path2, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity3));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty3.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object36) {
        return isArrayLike(object36) ? arrayLikeKeys(object36) : baseKeys(object36);
      }
      function keysIn(object36) {
        return isArrayLike(object36) ? arrayLikeKeys(object36, true) : baseKeysIn(object36);
      }
      function mapKeys(object36, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object36, function(value, key, object37) {
          baseAssignValue(result2, iteratee2(value, key, object37), value);
        });
        return result2;
      }
      function mapValues(object36, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object36, function(value, key, object37) {
          baseAssignValue(result2, key, iteratee2(value, key, object37));
        });
        return result2;
      }
      var merge = createAssigner(function(object36, source, srcIndex) {
        baseMerge(object36, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object36, source, srcIndex, customizer) {
        baseMerge(object36, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object36, paths) {
        var result2 = {};
        if (object36 == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path2) {
          path2 = castPath(path2, object36);
          isDeep || (isDeep = path2.length > 1);
          return path2;
        });
        copyObject(object36, getAllKeysIn(object36), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object36, predicate) {
        return pickBy(object36, negate(getIteratee(predicate)));
      }
      var pick2 = flatRest(function(object36, paths) {
        return object36 == null ? {} : basePick(object36, paths);
      });
      function pickBy(object36, predicate) {
        if (object36 == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object36), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object36, props, function(value, path2) {
          return predicate(value, path2[0]);
        });
      }
      function result(object36, path2, defaultValue) {
        path2 = castPath(path2, object36);
        var index2 = -1, length = path2.length;
        if (!length) {
          length = 1;
          object36 = undefined2;
        }
        while (++index2 < length) {
          var value = object36 == null ? undefined2 : object36[toKey(path2[index2])];
          if (value === undefined2) {
            index2 = length;
            value = defaultValue;
          }
          object36 = isFunction3(value) ? value.call(object36) : value;
        }
        return object36;
      }
      function set(object36, path2, value) {
        return object36 == null ? object36 : baseSet(object36, path2, value);
      }
      function setWith(object36, path2, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object36 == null ? object36 : baseSet(object36, path2, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object36, iteratee2, accumulator) {
        var isArr = isArray3(object36), isArrLike = isArr || isBuffer(object36) || isTypedArray(object36);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object36 && object36.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor : [];
          } else if (isObject2(object36)) {
            accumulator = isFunction3(Ctor) ? baseCreate(getPrototype(object36)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object36, function(value, index2, object37) {
          return iteratee2(accumulator, value, index2, object37);
        });
        return accumulator;
      }
      function unset(object36, path2) {
        return object36 == null ? true : baseUnset(object36, path2);
      }
      function update(object36, path2, updater) {
        return object36 == null ? object36 : baseUpdate(object36, path2, castFunction(updater));
      }
      function updateWith(object36, path2, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object36 == null ? object36 : baseUpdate(object36, path2, castFunction(updater), customizer);
      }
      function values(object36) {
        return object36 == null ? [] : baseValues(object36, keys(object36));
      }
      function valuesIn(object36) {
        return object36 == null ? [] : baseValues(object36, keysIn(object36));
      }
      function clamp4(number102, lower, upper) {
        if (upper === undefined2) {
          upper = lower;
          lower = undefined2;
        }
        if (upper !== undefined2) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined2) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number102), lower, upper);
      }
      function inRange(number102, start, end) {
        start = toFinite(start);
        if (end === undefined2) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number102 = toNumber(number102);
        return baseInRange(number102, start, end);
      }
      function random4(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined2;
        }
        if (floating === undefined2) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined2;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined2;
          }
        }
        if (lower === undefined2 && upper === undefined2) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined2) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize(word) : word);
      });
      function capitalize(string31) {
        return upperFirst(toString(string31).toLowerCase());
      }
      function deburr(string31) {
        string31 = toString(string31);
        return string31 && string31.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith2(string31, target, position) {
        string31 = toString(string31);
        target = baseToString(target);
        var length = string31.length;
        position = position === undefined2 ? length : baseClamp(toInteger2(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string31.slice(position, end) == target;
      }
      function escape2(string31) {
        string31 = toString(string31);
        return string31 && reHasUnescapedHtml.test(string31) ? string31.replace(reUnescapedHtml, escapeHtmlChar) : string31;
      }
      function escapeRegExp2(string31) {
        string31 = toString(string31);
        return string31 && reHasRegExpChar.test(string31) ? string31.replace(reRegExpChar, "\\$&") : string31;
      }
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string31, length, chars) {
        string31 = toString(string31);
        length = toInteger2(length);
        var strLength = length ? stringSize(string31) : 0;
        if (!length || strLength >= length) {
          return string31;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string31 + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string31, length, chars) {
        string31 = toString(string31);
        length = toInteger2(length);
        var strLength = length ? stringSize(string31) : 0;
        return length && strLength < length ? string31 + createPadding(length - strLength, chars) : string31;
      }
      function padStart(string31, length, chars) {
        string31 = toString(string31);
        length = toInteger2(length);
        var strLength = length ? stringSize(string31) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string31 : string31;
      }
      function parseInt2(string31, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string31).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string31, n, guard) {
        if (guard ? isIterateeCall(string31, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger2(n);
        }
        return baseRepeat(toString(string31), n);
      }
      function replace() {
        var args = arguments, string31 = toString(args[0]);
        return args.length < 3 ? string31 : string31.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split(string31, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string31, separator, limit)) {
          separator = limit = undefined2;
        }
        limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string31 = toString(string31);
        if (string31 && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string31)) {
            return castSlice(stringToArray(string31), 0, limit);
          }
        }
        return string31.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith(string31, target, position) {
        string31 = toString(string31);
        position = position == null ? 0 : baseClamp(toInteger2(position), 0, string31.length);
        target = baseToString(target);
        return string31.slice(position, position + target.length) == target;
      }
      function template(string31, options, guard) {
        var settings = lodash.templateSettings;
        if (guard && isIterateeCall(string31, options, guard)) {
          options = undefined2;
        }
        string31 = toString(string31);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty3.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string31.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string31.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty3.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      function trim(string31, chars, guard) {
        string31 = toString(string31);
        if (string31 && (guard || chars === undefined2)) {
          return baseTrim(string31);
        }
        if (!string31 || !(chars = baseToString(chars))) {
          return string31;
        }
        var strSymbols = stringToArray(string31), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string31, chars, guard) {
        string31 = toString(string31);
        if (string31 && (guard || chars === undefined2)) {
          return string31.slice(0, trimmedEndIndex(string31) + 1);
        }
        if (!string31 || !(chars = baseToString(chars))) {
          return string31;
        }
        var strSymbols = stringToArray(string31), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string31, chars, guard) {
        string31 = toString(string31);
        if (string31 && (guard || chars === undefined2)) {
          return string31.replace(reTrimStart, "");
        }
        if (!string31 || !(chars = baseToString(chars))) {
          return string31;
        }
        var strSymbols = stringToArray(string31), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate2(string31, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger2(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string31 = toString(string31);
        var strLength = string31.length;
        if (hasUnicode(string31)) {
          var strSymbols = stringToArray(string31);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string31;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string31.slice(0, end);
        if (separator === undefined2) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp2(separator)) {
          if (string31.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.globalThis) {
              separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
          }
        } else if (string31.indexOf(baseToString(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape(string31) {
        string31 = toString(string31);
        return string31 && reHasEscapedHtml.test(string31) ? string31.replace(reEscapedHtml, unescapeHtmlChar) : string31;
      }
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string31, pattern, guard) {
        string31 = toString(string31);
        pattern = guard ? undefined2 : pattern;
        if (pattern === undefined2) {
          return hasUnicodeWord(string31) ? unicodeWords(string31) : asciiWords(string31);
        }
        return string31.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply3(func, undefined2, args);
        } catch (e4) {
          return isError(e4) ? e4 : new Error2(e4);
        }
      });
      var bindAll = flatRest(function(object36, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object36, key, bind(object36[key], object36));
        });
        return object36;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply3(pair[0], this, args)) {
              return apply3(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity3(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path2, srcValue) {
        return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path2, args) {
        return function(object36) {
          return baseInvoke(object36, path2, args);
        };
      });
      var methodOf = baseRest(function(object36, args) {
        return function(path2) {
          return baseInvoke(object36, path2, args);
        };
      });
      function mixin(object36, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object36;
          object36 = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain3 = !(isObject2(options) && ("chain" in options)) || !!options.chain, isFunc = isFunction3(object36);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object36[methodName] = func;
          if (isFunc) {
            object36.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain3 || chainAll) {
                var result2 = object36(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ func, args: arguments, thisArg: object36 });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object36, arrayPush([this.value()], arguments));
            };
          }
        });
        return object36;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop5() {
      }
      function nthArg(n) {
        n = toInteger2(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path2) {
        return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
      }
      function propertyOf(object36) {
        return function(path2) {
          return object36 == null ? undefined2 : baseGet(object36, path2);
        };
      }
      var range4 = createRange2();
      var rangeRight = createRange2(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger2(n);
        if (n < 1 || n > MAX_SAFE_INTEGER2) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index2 < n) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray3(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add5 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil4 = createRound2("ceil");
      var divide4 = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor4 = createRound2("floor");
      function max5(array59) {
        return array59 && array59.length ? baseExtremum(array59, identity3, baseGt) : undefined2;
      }
      function maxBy(array59, iteratee2) {
        return array59 && array59.length ? baseExtremum(array59, getIteratee(iteratee2, 2), baseGt) : undefined2;
      }
      function mean4(array59) {
        return baseMean(array59, identity3);
      }
      function meanBy(array59, iteratee2) {
        return baseMean(array59, getIteratee(iteratee2, 2));
      }
      function min5(array59) {
        return array59 && array59.length ? baseExtremum(array59, identity3, baseLt) : undefined2;
      }
      function minBy(array59, iteratee2) {
        return array59 && array59.length ? baseExtremum(array59, getIteratee(iteratee2, 2), baseLt) : undefined2;
      }
      var multiply4 = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round4 = createRound2("round");
      var subtract3 = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum5(array59) {
        return array59 && array59.length ? baseSum(array59, identity3) : 0;
      }
      function sumBy(array59, iteratee2) {
        return array59 && array59.length ? baseSum(array59, getIteratee(iteratee2, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign3;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at2;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain2;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat4;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create2;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter4;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten4;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map11;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize2;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick2;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range4;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject2;
      lodash.remove = remove;
      lodash.rest = rest;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle2;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.unary = unary;
      lodash.union = union;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor3;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add5;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize;
      lodash.ceil = ceil4;
      lodash.clamp = clamp4;
      lodash.clone = clone5;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide4;
      lodash.endsWith = endsWith2;
      lodash.eq = eq;
      lodash.escape = escape2;
      lodash.escapeRegExp = escapeRegExp2;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor4;
      lodash.forEach = forEach4;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity3;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray3;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean2;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate2;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite2;
      lodash.isFunction = isFunction3;
      lodash.isInteger = isInteger4;
      lodash.isLength = isLength;
      lodash.isMap = isMap2;
      lodash.isMatch = isMatch2;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN4;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull2;
      lodash.isNumber = isNumber2;
      lodash.isObject = isObject2;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject2;
      lodash.isRegExp = isRegExp2;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString2;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined2;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join2;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max5;
      lodash.maxBy = maxBy;
      lodash.mean = mean4;
      lodash.meanBy = meanBy;
      lodash.min = min5;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply4;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop5;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt2;
      lodash.random = random4;
      lodash.reduce = reduce2;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round4;
      lodash.runInContext = runInContext;
      lodash.sample = sample2;
      lodash.size = size3;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract3;
      lodash.sum = sum5;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger2;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate2;
      lodash.unescape = unescape;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach4;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!hasOwnProperty3.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { chain: false });
      lodash.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined2 ? 1 : nativeMax(toInteger2(n), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              size: nativeMin(n, MAX_ARRAY_LENGTH),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity3);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
        if (typeof path2 == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path2, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger2(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined2) {
          end = toInteger2(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray3(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ func: thru, args: [interceptor], thisArg: undefined2 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray3(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray3(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty3.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ name: methodName, func: lodashFunc });
        }
      });
      realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined2
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    };
    var _ = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      root._ = _;
      define(function() {
        return _;
      });
    } else if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }).call(exports);
});

// ../../node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS((exports, module) => {
  var DelayedStream = function() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
  };
  var Stream = __require("stream").Stream;
  var util4 = __require("util");
  module.exports = DelayedStream;
  util4.inherits(DelayedStream, Stream);
  DelayedStream.create = function(source, options) {
    var delayedStream = new this;
    options = options || {};
    for (var option in options) {
      delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
      delayedStream._handleEmit(arguments);
      return realEmit.apply(source, arguments);
    };
    source.on("error", function() {
    });
    if (delayedStream.pauseStream) {
      source.pause();
    }
    return delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: true,
    enumerable: true,
    get: function() {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function() {
    if (!this._released) {
      this.release();
    }
    this.source.resume();
  };
  DelayedStream.prototype.pause = function() {
    this.source.pause();
  };
  DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach(function(args) {
      this.emit.apply(this, args);
    }.bind(this));
    this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
  };
  DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    if (args[0] === "data") {
      this.dataSize += args[1].length;
      this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
      return;
    }
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    this._maxDataSizeExceeded = true;
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(message));
  };
});

// ../../node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS((exports, module) => {
  var CombinedStream = function() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
  };
  var util4 = __require("util");
  var Stream = __require("stream").Stream;
  var DelayedStream = require_delayed_stream();
  module.exports = CombinedStream;
  util4.inherits(CombinedStream, Stream);
  CombinedStream.create = function(options) {
    var combinedStream = new this;
    options = options || {};
    for (var option in options) {
      combinedStream[option] = options[option];
    }
    return combinedStream;
  };
  CombinedStream.isStreamLike = function(stream3) {
    return typeof stream3 !== "function" && typeof stream3 !== "string" && typeof stream3 !== "boolean" && typeof stream3 !== "number" && !Buffer.isBuffer(stream3);
  };
  CombinedStream.prototype.append = function(stream3) {
    var isStreamLike = CombinedStream.isStreamLike(stream3);
    if (isStreamLike) {
      if (!(stream3 instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream3, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams
        });
        stream3.on("data", this._checkDataSize.bind(this));
        stream3 = newStream;
      }
      this._handleErrors(stream3);
      if (this.pauseStreams) {
        stream3.pause();
      }
    }
    this._streams.push(stream3);
    return this;
  };
  CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
  };
  CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
      this._pendingNext = true;
      return;
    }
    this._insideLoop = true;
    try {
      do {
        this._pendingNext = false;
        this._realGetNext();
      } while (this._pendingNext);
    } finally {
      this._insideLoop = false;
    }
  };
  CombinedStream.prototype._realGetNext = function() {
    var stream3 = this._streams.shift();
    if (typeof stream3 == "undefined") {
      this.end();
      return;
    }
    if (typeof stream3 !== "function") {
      this._pipeNext(stream3);
      return;
    }
    var getStream = stream3;
    getStream(function(stream4) {
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        stream4.on("data", this._checkDataSize.bind(this));
        this._handleErrors(stream4);
      }
      this._pipeNext(stream4);
    }.bind(this));
  };
  CombinedStream.prototype._pipeNext = function(stream3) {
    this._currentStream = stream3;
    var isStreamLike = CombinedStream.isStreamLike(stream3);
    if (isStreamLike) {
      stream3.on("end", this._getNext.bind(this));
      stream3.pipe(this, { end: false });
      return;
    }
    var value = stream3;
    this.write(value);
    this._getNext();
  };
  CombinedStream.prototype._handleErrors = function(stream3) {
    var self2 = this;
    stream3.on("error", function(err) {
      self2._emitError(err);
    });
  };
  CombinedStream.prototype.write = function(data2) {
    this.emit("data", data2);
  };
  CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
      return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
      this._currentStream.pause();
    this.emit("pause");
  };
  CombinedStream.prototype.resume = function() {
    if (!this._released) {
      this._released = true;
      this.writable = true;
      this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
      this._currentStream.resume();
    this.emit("resume");
  };
  CombinedStream.prototype.end = function() {
    this._reset();
    this.emit("end");
  };
  CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit("close");
  };
  CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(message));
  };
  CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self2 = this;
    this._streams.forEach(function(stream3) {
      if (!stream3.dataSize) {
        return;
      }
      self2.dataSize += stream3.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
      this.dataSize += this._currentStream.dataSize;
    }
  };
  CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit("error", err);
  };
});

// ../../node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports) => {
  var charset = function(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  };
  var contentType = function(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  };
  var extension = function(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  };
  var lookup4 = function(path3) {
    if (!path3 || typeof path3 !== "string") {
      return false;
    }
    var extension2 = extname("x." + path3).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  };
  var populateMaps = function(extensions, types5) {
    var preference = ["nginx", "apache", undefined, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i3 = 0;i3 < exts.length; i3++) {
        var extension2 = exts[i3];
        if (types5[extension2]) {
          var from = preference.indexOf(db[types5[extension2]].source);
          var to3 = preference.indexOf(mime.source);
          if (types5[extension2] !== "application/octet-stream" && (from > to3 || from === to3 && types5[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types5[extension2] = type;
      }
    });
  };
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db = require_mime_db();
  var extname = __require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = Object.create(null);
  exports.lookup = lookup4;
  exports.types = Object.create(null);
  populateMaps(exports.extensions, exports.types);
});

// ../../node_modules/asynckit/lib/defer.js
var require_defer = __commonJS((exports, module) => {
  var defer = function(fn) {
    var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    if (nextTick) {
      nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  };
  module.exports = defer;
});

// ../../node_modules/asynckit/lib/async.js
var require_async7 = __commonJS((exports, module) => {
  var async = function(callback) {
    var isAsync = false;
    defer(function() {
      isAsync = true;
    });
    return function async_callback(err, result) {
      if (isAsync) {
        callback(err, result);
      } else {
        defer(function nextTick_callback() {
          callback(err, result);
        });
      }
    };
  };
  var defer = require_defer();
  module.exports = async;
});

// ../../node_modules/asynckit/lib/abort.js
var require_abort = __commonJS((exports, module) => {
  var abort = function(state3) {
    Object.keys(state3.jobs).forEach(clean.bind(state3));
    state3.jobs = {};
  };
  var clean = function(key) {
    if (typeof this.jobs[key] == "function") {
      this.jobs[key]();
    }
  };
  module.exports = abort;
});

// ../../node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS((exports, module) => {
  var iterate = function(list3, iterator, state3, callback) {
    var key = state3["keyedList"] ? state3["keyedList"][state3.index] : state3.index;
    state3.jobs[key] = runJob(iterator, key, list3[key], function(error, output) {
      if (!(key in state3.jobs)) {
        return;
      }
      delete state3.jobs[key];
      if (error) {
        abort(state3);
      } else {
        state3.results[key] = output;
      }
      callback(error, state3.results);
    });
  };
  var runJob = function(iterator, key, item, callback) {
    var aborter;
    if (iterator.length == 2) {
      aborter = iterator(item, async(callback));
    } else {
      aborter = iterator(item, key, async(callback));
    }
    return aborter;
  };
  var async = require_async7();
  var abort = require_abort();
  module.exports = iterate;
});

// ../../node_modules/asynckit/lib/state.js
var require_state = __commonJS((exports, module) => {
  var state3 = function(list3, sortMethod) {
    var isNamedList = !Array.isArray(list3), initState = {
      index: 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list3) : null,
      jobs: {},
      results: isNamedList ? {} : [],
      size: isNamedList ? Object.keys(list3).length : list3.length
    };
    if (sortMethod) {
      initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
        return sortMethod(list3[a], list3[b]);
      });
    }
    return initState;
  };
  module.exports = state3;
});

// ../../node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS((exports, module) => {
  var terminator = function(callback) {
    if (!Object.keys(this.jobs).length) {
      return;
    }
    this.index = this.size;
    abort(this);
    async(callback)(null, this.results);
  };
  var abort = require_abort();
  var async = require_async7();
  module.exports = terminator;
});

// ../../node_modules/asynckit/parallel.js
var require_parallel = __commonJS((exports, module) => {
  var parallel = function(list3, iterator, callback) {
    var state3 = initState(list3);
    while (state3.index < (state3["keyedList"] || list3).length) {
      iterate(list3, iterator, state3, function(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        if (Object.keys(state3.jobs).length === 0) {
          callback(null, state3.results);
          return;
        }
      });
      state3.index++;
    }
    return terminator.bind(state3, callback);
  };
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module.exports = parallel;
});

// ../../node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS((exports, module) => {
  var serialOrdered = function(list3, iterator, sortMethod, callback) {
    var state3 = initState(list3, sortMethod);
    iterate(list3, iterator, state3, function iteratorHandler(error, result) {
      if (error) {
        callback(error, result);
        return;
      }
      state3.index++;
      if (state3.index < (state3["keyedList"] || list3).length) {
        iterate(list3, iterator, state3, iteratorHandler);
        return;
      }
      callback(null, state3.results);
    });
    return terminator.bind(state3, callback);
  };
  var ascending = function(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  };
  var descending = function(a, b) {
    return -1 * ascending(a, b);
  };
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module.exports = serialOrdered;
  module.exports.ascending = ascending;
  module.exports.descending = descending;
});

// ../../node_modules/asynckit/serial.js
var require_serial = __commonJS((exports, module) => {
  var serial = function(list3, iterator, callback) {
    return serialOrdered(list3, iterator, null, callback);
  };
  var serialOrdered = require_serialOrdered();
  module.exports = serial;
});

// ../../node_modules/asynckit/index.js
var require_asynckit = __commonJS((exports, module) => {
  module.exports = {
    parallel: require_parallel(),
    serial: require_serial(),
    serialOrdered: require_serialOrdered()
  };
});

// ../../node_modules/form-data/lib/populate.js
var require_populate = __commonJS((exports, module) => {
  module.exports = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
      dst[prop] = dst[prop] || src[prop];
    });
    return dst;
  };
});

// ../../node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS((exports, module) => {
  var FormData2 = function(options) {
    if (!(this instanceof FormData2)) {
      return new FormData2(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for (var option in options) {
      this[option] = options[option];
    }
  };
  var CombinedStream = require_combined_stream();
  var util4 = __require("util");
  var path3 = __require("path");
  var http = __require("http");
  var https = __require("https");
  var parseUrl = __require("url").parse;
  var fs5 = __require("fs");
  var Stream = __require("stream").Stream;
  var mime = require_mime_types();
  var asynckit = require_asynckit();
  var populate = require_populate();
  module.exports = FormData2;
  util4.inherits(FormData2, CombinedStream);
  FormData2.LINE_BREAK = "\r\n";
  FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData2.prototype.append = function(field, value, options) {
    options = options || {};
    if (typeof options == "string") {
      options = { filename: options };
    }
    var append = CombinedStream.prototype.append.bind(this);
    if (typeof value == "number") {
      value = "" + value;
    }
    if (util4.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    this._trackLength(header, value, options);
  };
  FormData2.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    if (options.knownLength != null) {
      valueLength += +options.knownLength;
    } else if (Buffer.isBuffer(value)) {
      valueLength = value.length;
    } else if (typeof value === "string") {
      valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
    if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
      return;
    }
    if (!options.knownLength) {
      this._valuesToMeasure.push(value);
    }
  };
  FormData2.prototype._lengthRetriever = function(value, callback) {
    if (value.hasOwnProperty("fd")) {
      if (value.end != null && value.end != Infinity && value.start != null) {
        callback(null, value.end + 1 - (value.start ? value.start : 0));
      } else {
        fs5.stat(value.path, function(err, stat) {
          var fileSize;
          if (err) {
            callback(err);
            return;
          }
          fileSize = stat.size - (value.start ? value.start : 0);
          callback(null, fileSize);
        });
      }
    } else if (value.hasOwnProperty("httpVersion")) {
      callback(null, +value.headers["content-length"]);
    } else if (value.hasOwnProperty("httpModule")) {
      value.on("response", function(response) {
        value.pause();
        callback(null, +response.headers["content-length"]);
      });
      value.resume();
    } else {
      callback("Unknown stream");
    }
  };
  FormData2.prototype._multiPartHeader = function(field, value, options) {
    if (typeof options.header == "string") {
      return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = "";
    var headers = {
      "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
      "Content-Type": [].concat(contentType || [])
    };
    if (typeof options.header == "object") {
      populate(headers, options.header);
    }
    var header;
    for (var prop in headers) {
      if (!headers.hasOwnProperty(prop))
        continue;
      header = headers[prop];
      if (header == null) {
        continue;
      }
      if (!Array.isArray(header)) {
        header = [header];
      }
      if (header.length) {
        contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
      }
    }
    return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
  };
  FormData2.prototype._getContentDisposition = function(value, options) {
    var filename, contentDisposition;
    if (typeof options.filepath === "string") {
      filename = path3.normalize(options.filepath).replace(/\\/g, "/");
    } else if (options.filename || value.name || value.path) {
      filename = path3.basename(options.filename || value.name || value.path);
    } else if (value.readable && value.hasOwnProperty("httpVersion")) {
      filename = path3.basename(value.client._httpMessage.path || "");
    }
    if (filename) {
      contentDisposition = 'filename="' + filename + '"';
    }
    return contentDisposition;
  };
  FormData2.prototype._getContentType = function(value, options) {
    var contentType = options.contentType;
    if (!contentType && value.name) {
      contentType = mime.lookup(value.name);
    }
    if (!contentType && value.path) {
      contentType = mime.lookup(value.path);
    }
    if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
      contentType = value.headers["content-type"];
    }
    if (!contentType && (options.filepath || options.filename)) {
      contentType = mime.lookup(options.filepath || options.filename);
    }
    if (!contentType && typeof value == "object") {
      contentType = FormData2.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
  };
  FormData2.prototype._multiPartFooter = function() {
    return function(next) {
      var footer = FormData2.LINE_BREAK;
      var lastPart = this._streams.length === 0;
      if (lastPart) {
        footer += this._lastBoundary();
      }
      next(footer);
    }.bind(this);
  };
  FormData2.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
  };
  FormData2.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
      "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders) {
      if (userHeaders.hasOwnProperty(header)) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    }
    return formHeaders;
  };
  FormData2.prototype.setBoundary = function(boundary) {
    this._boundary = boundary;
  };
  FormData2.prototype.getBoundary = function() {
    if (!this._boundary) {
      this._generateBoundary();
    }
    return this._boundary;
  };
  FormData2.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0);
    var boundary = this.getBoundary();
    for (var i3 = 0, len = this._streams.length;i3 < len; i3++) {
      if (typeof this._streams[i3] !== "function") {
        if (Buffer.isBuffer(this._streams[i3])) {
          dataBuffer = Buffer.concat([dataBuffer, this._streams[i3]]);
        } else {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i3])]);
        }
        if (typeof this._streams[i3] !== "string" || this._streams[i3].substring(2, boundary.length + 2) !== boundary) {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
        }
      }
    }
    return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
  };
  FormData2.prototype._generateBoundary = function() {
    var boundary = "--------------------------";
    for (var i3 = 0;i3 < 24; i3++) {
      boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
  };
  FormData2.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this.hasKnownLength()) {
      this._error(new Error("Cannot calculate proper length in synchronous way."));
    }
    return knownLength;
  };
  FormData2.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
      hasKnownLength = false;
    }
    return hasKnownLength;
  };
  FormData2.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
      if (err) {
        cb(err);
        return;
      }
      values.forEach(function(length) {
        knownLength += length;
      });
      cb(null, knownLength);
    });
  };
  FormData2.prototype.submit = function(params, cb) {
    var request, options, defaults = { method: "post" };
    if (typeof params == "string") {
      params = parseUrl(params);
      options = populate({
        port: params.port,
        path: params.pathname,
        host: params.hostname,
        protocol: params.protocol
      }, defaults);
    } else {
      options = populate(params, defaults);
      if (!options.port) {
        options.port = options.protocol == "https:" ? 443 : 80;
      }
    }
    options.headers = this.getHeaders(params.headers);
    if (options.protocol == "https:") {
      request = https.request(options);
    } else {
      request = http.request(options);
    }
    this.getLength(function(err, length) {
      if (err && err !== "Unknown stream") {
        this._error(err);
        return;
      }
      if (length) {
        request.setHeader("Content-Length", length);
      }
      this.pipe(request);
      if (cb) {
        var onResponse;
        var callback = function(error, responce) {
          request.removeListener("error", callback);
          request.removeListener("response", onResponse);
          return cb.call(this, error, responce);
        };
        onResponse = callback.bind(this, null);
        request.on("error", callback);
        request.on("response", onResponse);
      }
    }.bind(this));
    return request;
  };
  FormData2.prototype._error = function(err) {
    if (!this.error) {
      this.error = err;
      this.pause();
      this.emit("error", err);
    }
  };
  FormData2.prototype.toString = function() {
    return "[object FormData]";
  };
});

// ../../node_modules/logform/format.js
var require_format = __commonJS((exports, module) => {
  class InvalidFormatError extends Error {
    constructor(formatFn) {
      super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split("\n")[0]}\n`);
      Error.captureStackTrace(this, InvalidFormatError);
    }
  }
  module.exports = (formatFn) => {
    if (formatFn.length > 2) {
      throw new InvalidFormatError(formatFn);
    }
    function Format(options = {}) {
      this.options = options;
    }
    Format.prototype.transform = formatFn;
    function createFormatWrap(opts) {
      return new Format(opts);
    }
    createFormatWrap.Format = Format;
    return createFormatWrap;
  };
});

// ../../node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS((exports, module) => {
  var styles = {};
  module["exports"] = styles;
  var codes = {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    grey: [90, 39],
    brightRed: [91, 39],
    brightGreen: [92, 39],
    brightYellow: [93, 39],
    brightBlue: [94, 39],
    brightMagenta: [95, 39],
    brightCyan: [96, 39],
    brightWhite: [97, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgBrightRed: [101, 49],
    bgBrightGreen: [102, 49],
    bgBrightYellow: [103, 49],
    bgBrightBlue: [104, 49],
    bgBrightMagenta: [105, 49],
    bgBrightCyan: [106, 49],
    bgBrightWhite: [107, 49],
    blackBG: [40, 49],
    redBG: [41, 49],
    greenBG: [42, 49],
    yellowBG: [43, 49],
    blueBG: [44, 49],
    magentaBG: [45, 49],
    cyanBG: [46, 49],
    whiteBG: [47, 49]
  };
  Object.keys(codes).forEach(function(key) {
    var val = codes[key];
    var style = styles[key] = [];
    style.open = "\x1B[" + val[0] + "m";
    style.close = "\x1B[" + val[1] + "m";
  });
});

// ../../node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag2 = __commonJS((exports, module) => {
  module.exports = function(flag, argv) {
    argv = argv || process.argv || [];
    var terminatorPos = argv.indexOf("--");
    var prefix = /^-{1,2}/.test(flag) ? "" : "--";
    var pos = argv.indexOf(prefix + flag);
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// ../../node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS((exports, module) => {
  var translateLevel = function(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  };
  var supportsColor = function(stream3) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream3 && !stream3.isTTY && forceColor !== true) {
      return 0;
    }
    var min5 = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      var osRelease = os.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign5) {
        return sign5 in env;
      }) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min5;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if ("TERM_PROGRAM" in env) {
      var version9 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version9 >= 3 ? 3 : 2;
        case "Hyper":
          return 3;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    if (env.TERM === "dumb") {
      return min5;
    }
    return min5;
  };
  var getSupportLevel = function(stream3) {
    var level = supportsColor(stream3);
    return translateLevel(level);
  };
  var os = __require("os");
  var hasFlag = require_has_flag2();
  var env = process.env;
  var forceColor = undefined;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env) {
    forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// ../../node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS((exports, module) => {
  module["exports"] = function runTheTrap(text, options) {
    var result = "";
    text = text || "Run the trap, drop the bass";
    text = text.split("");
    var trap = {
      a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
      b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
      c: ["\xA9", "\u023B", "\u03FE"],
      d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
      e: [
        "\xCB",
        "\u0115",
        "\u018E",
        "\u0258",
        "\u03A3",
        "\u03BE",
        "\u04BC",
        "\u0A6C"
      ],
      f: ["\u04FA"],
      g: ["\u0262"],
      h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
      i: ["\u0F0F"],
      j: ["\u0134"],
      k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
      l: ["\u0139"],
      m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
      n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
      o: [
        "\xD8",
        "\xF5",
        "\xF8",
        "\u01FE",
        "\u0298",
        "\u047A",
        "\u05DD",
        "\u06DD",
        "\u0E4F"
      ],
      p: ["\u01F7", "\u048E"],
      q: ["\u09CD"],
      r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
      s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
      t: ["\u0141", "\u0166", "\u0373"],
      u: ["\u01B1", "\u054D"],
      v: ["\u05D8"],
      w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
      x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
      y: ["\xA5", "\u04B0", "\u04CB"],
      z: ["\u01B5", "\u0240"]
    };
    text.forEach(function(c) {
      c = c.toLowerCase();
      var chars = trap[c] || [" "];
      var rand = Math.floor(Math.random() * chars.length);
      if (typeof trap[c] !== "undefined") {
        result += trap[c][rand];
      } else {
        result += c;
      }
    });
    return result;
  };
});

// ../../node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS((exports, module) => {
  module["exports"] = function zalgo(text, options) {
    text = text || "   he is here   ";
    var soul = {
      up: [
        "\u030D",
        "\u030E",
        "\u0304",
        "\u0305",
        "\u033F",
        "\u0311",
        "\u0306",
        "\u0310",
        "\u0352",
        "\u0357",
        "\u0351",
        "\u0307",
        "\u0308",
        "\u030A",
        "\u0342",
        "\u0313",
        "\u0308",
        "\u034A",
        "\u034B",
        "\u034C",
        "\u0303",
        "\u0302",
        "\u030C",
        "\u0350",
        "\u0300",
        "\u0301",
        "\u030B",
        "\u030F",
        "\u0312",
        "\u0313",
        "\u0314",
        "\u033D",
        "\u0309",
        "\u0363",
        "\u0364",
        "\u0365",
        "\u0366",
        "\u0367",
        "\u0368",
        "\u0369",
        "\u036A",
        "\u036B",
        "\u036C",
        "\u036D",
        "\u036E",
        "\u036F",
        "\u033E",
        "\u035B",
        "\u0346",
        "\u031A"
      ],
      down: [
        "\u0316",
        "\u0317",
        "\u0318",
        "\u0319",
        "\u031C",
        "\u031D",
        "\u031E",
        "\u031F",
        "\u0320",
        "\u0324",
        "\u0325",
        "\u0326",
        "\u0329",
        "\u032A",
        "\u032B",
        "\u032C",
        "\u032D",
        "\u032E",
        "\u032F",
        "\u0330",
        "\u0331",
        "\u0332",
        "\u0333",
        "\u0339",
        "\u033A",
        "\u033B",
        "\u033C",
        "\u0345",
        "\u0347",
        "\u0348",
        "\u0349",
        "\u034D",
        "\u034E",
        "\u0353",
        "\u0354",
        "\u0355",
        "\u0356",
        "\u0359",
        "\u035A",
        "\u0323"
      ],
      mid: [
        "\u0315",
        "\u031B",
        "\u0300",
        "\u0301",
        "\u0358",
        "\u0321",
        "\u0322",
        "\u0327",
        "\u0328",
        "\u0334",
        "\u0335",
        "\u0336",
        "\u035C",
        "\u035D",
        "\u035E",
        "\u035F",
        "\u0360",
        "\u0362",
        "\u0338",
        "\u0337",
        "\u0361",
        " \u0489"
      ]
    };
    var all = [].concat(soul.up, soul.down, soul.mid);
    function randomNumber(range4) {
      var r = Math.floor(Math.random() * range4);
      return r;
    }
    function isChar(character) {
      var bool2 = false;
      all.filter(function(i3) {
        bool2 = i3 === character;
      });
      return bool2;
    }
    function heComes(text2, options2) {
      var result = "";
      var counts;
      var l;
      options2 = options2 || {};
      options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
      options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
      options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
      options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
      text2 = text2.split("");
      for (l in text2) {
        if (isChar(l)) {
          continue;
        }
        result = result + text2[l];
        counts = { up: 0, down: 0, mid: 0 };
        switch (options2.size) {
          case "mini":
            counts.up = randomNumber(8);
            counts.mid = randomNumber(2);
            counts.down = randomNumber(8);
            break;
          case "maxi":
            counts.up = randomNumber(16) + 3;
            counts.mid = randomNumber(4) + 1;
            counts.down = randomNumber(64) + 3;
            break;
          default:
            counts.up = randomNumber(8) + 1;
            counts.mid = randomNumber(6) / 2;
            counts.down = randomNumber(8) + 1;
            break;
        }
        var arr = ["up", "mid", "down"];
        for (var d in arr) {
          var index2 = arr[d];
          for (var i3 = 0;i3 <= counts[index2]; i3++) {
            if (options2[index2]) {
              result = result + soul[index2][randomNumber(soul[index2].length)];
            }
          }
        }
      }
      return result;
    }
    return heComes(text, options);
  };
});

// ../../node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    return function(letter, i3, exploded) {
      if (letter === " ")
        return letter;
      switch (i3 % 3) {
        case 0:
          return colors.red(letter);
        case 1:
          return colors.white(letter);
        case 2:
          return colors.blue(letter);
      }
    };
  };
});

// ../../node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    return function(letter, i3, exploded) {
      return i3 % 2 === 0 ? letter : colors.inverse(letter);
    };
  };
});

// ../../node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
    return function(letter, i3, exploded) {
      if (letter === " ") {
        return letter;
      } else {
        return colors[rainbowColors[i3++ % rainbowColors.length]](letter);
      }
    };
  };
});

// ../../node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    var available = [
      "underline",
      "inverse",
      "grey",
      "yellow",
      "red",
      "green",
      "blue",
      "white",
      "cyan",
      "magenta",
      "brightYellow",
      "brightRed",
      "brightGreen",
      "brightBlue",
      "brightWhite",
      "brightCyan",
      "brightMagenta"
    ];
    return function(letter, i3, exploded) {
      return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
    };
  };
});

// ../../node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS((exports, module) => {
  var build = function(_styles) {
    var builder = function builder() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder.__proto__ = proto;
    return builder;
  };
  var applyStyle = function() {
    var args = Array.prototype.slice.call(arguments);
    var str = args.map(function(arg3) {
      if (arg3 != null && arg3.constructor === String) {
        return arg3;
      } else {
        return util4.inspect(arg3);
      }
    }).join(" ");
    if (!colors.enabled || !str) {
      return str;
    }
    var newLinesPresent = str.indexOf("\n") != -1;
    var nestedStyles = this._styles;
    var i3 = nestedStyles.length;
    while (i3--) {
      var code = ansiStyles[nestedStyles[i3]];
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      if (newLinesPresent) {
        str = str.replace(newLineRegex, function(match) {
          return code.close + match + code.open;
        });
      }
    }
    return str;
  };
  var init = function() {
    var ret = {};
    Object.keys(styles).forEach(function(name302) {
      ret[name302] = {
        get: function() {
          return build([name302]);
        }
      };
    });
    return ret;
  };
  var colors = {};
  module["exports"] = colors;
  colors.themes = {};
  var util4 = __require("util");
  var ansiStyles = colors.styles = require_styles();
  var defineProps = Object.defineProperties;
  var newLineRegex = new RegExp(/[\r\n]+/g);
  colors.supportsColor = require_supports_colors().supportsColor;
  if (typeof colors.enabled === "undefined") {
    colors.enabled = colors.supportsColor() !== false;
  }
  colors.enable = function() {
    colors.enabled = true;
  };
  colors.disable = function() {
    colors.enabled = false;
  };
  colors.stripColors = colors.strip = function(str) {
    return ("" + str).replace(/\x1B\[\d+m/g, "");
  };
  var stylize = colors.stylize = function stylize(str, style) {
    if (!colors.enabled) {
      return str + "";
    }
    var styleMap = ansiStyles[style];
    if (!styleMap && style in colors) {
      return colors[style](str);
    }
    return styleMap.open + str + styleMap.close;
  };
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  var escapeStringRegexp = function(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
  };
  var styles = function() {
    var ret = {};
    ansiStyles.grey = ansiStyles.gray;
    Object.keys(ansiStyles).forEach(function(key) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      ret[key] = {
        get: function() {
          return build(this._styles.concat(key));
        }
      };
    });
    return ret;
  }();
  var proto = defineProps(function colors() {
  }, styles);
  colors.setTheme = function(theme) {
    if (typeof theme === "string") {
      console.log("colors.setTheme now only accepts an object, not a string.  " + "If you are trying to set a theme from a file, it is now your (the " + "caller\'s) responsibility to require the file.  The old syntax " + "looked like colors.setTheme(__dirname + " + "\'/../themes/generic-logging.js\'); The new syntax looks like " + "colors.setTheme(require(__dirname + " + "\'/../themes/generic-logging.js\'));");
      return;
    }
    for (var style in theme) {
      (function(style2) {
        colors[style2] = function(str) {
          if (typeof theme[style2] === "object") {
            var out = str;
            for (var i3 in theme[style2]) {
              out = colors[theme[style2][i3]](out);
            }
            return out;
          }
          return colors[theme[style2]](str);
        };
      })(style);
    }
  };
  var sequencer = function sequencer(map12, str) {
    var exploded = str.split("");
    exploded = exploded.map(map12);
    return exploded.join("");
  };
  colors.trap = require_trap();
  colors.zalgo = require_zalgo();
  colors.maps = {};
  colors.maps.america = require_america()(colors);
  colors.maps.zebra = require_zebra()(colors);
  colors.maps.rainbow = require_rainbow()(colors);
  colors.maps.random = require_random()(colors);
  for (map11 in colors.maps) {
    (function(map12) {
      colors[map12] = function(str) {
        return sequencer(colors.maps[map12], str);
      };
    })(map11);
  }
  var map11;
  defineProps(colors, init());
});

// ../../node_modules/@colors/colors/safe.js
var require_safe = __commonJS((exports, module) => {
  var colors = require_colors();
  module["exports"] = colors;
});

// ../../node_modules/triple-beam/config/cli.js
var require_cli = __commonJS((exports) => {
  exports.levels = {
    error: 0,
    warn: 1,
    help: 2,
    data: 3,
    info: 4,
    debug: 5,
    prompt: 6,
    verbose: 7,
    input: 8,
    silly: 9
  };
  exports.colors = {
    error: "red",
    warn: "yellow",
    help: "cyan",
    data: "grey",
    info: "green",
    debug: "blue",
    prompt: "grey",
    verbose: "cyan",
    input: "grey",
    silly: "magenta"
  };
});

// ../../node_modules/triple-beam/config/npm.js
var require_npm = __commonJS((exports) => {
  exports.levels = {
    error: 0,
    warn: 1,
    info: 2,
    http: 3,
    verbose: 4,
    debug: 5,
    silly: 6
  };
  exports.colors = {
    error: "red",
    warn: "yellow",
    info: "green",
    http: "green",
    verbose: "cyan",
    debug: "blue",
    silly: "magenta"
  };
});

// ../../node_modules/triple-beam/config/syslog.js
var require_syslog = __commonJS((exports) => {
  exports.levels = {
    emerg: 0,
    alert: 1,
    crit: 2,
    error: 3,
    warning: 4,
    notice: 5,
    info: 6,
    debug: 7
  };
  exports.colors = {
    emerg: "red",
    alert: "yellow",
    crit: "red",
    error: "red",
    warning: "red",
    notice: "yellow",
    info: "green",
    debug: "blue"
  };
});

// ../../node_modules/triple-beam/config/index.js
var require_config = __commonJS((exports) => {
  Object.defineProperty(exports, "cli", {
    value: require_cli()
  });
  Object.defineProperty(exports, "npm", {
    value: require_npm()
  });
  Object.defineProperty(exports, "syslog", {
    value: require_syslog()
  });
});

// ../../node_modules/triple-beam/index.js
var require_triple_beam = __commonJS((exports) => {
  Object.defineProperty(exports, "LEVEL", {
    value: Symbol.for("level")
  });
  Object.defineProperty(exports, "MESSAGE", {
    value: Symbol.for("message")
  });
  Object.defineProperty(exports, "SPLAT", {
    value: Symbol.for("splat")
  });
  Object.defineProperty(exports, "configs", {
    value: require_config()
  });
});

// ../../node_modules/logform/colorize.js
var require_colorize = __commonJS((exports, module) => {
  var colors = require_safe();
  var { LEVEL, MESSAGE } = require_triple_beam();
  colors.enabled = true;
  var hasSpace = /\s+/;

  class Colorizer {
    constructor(opts = {}) {
      if (opts.colors) {
        this.addColors(opts.colors);
      }
      this.options = opts;
    }
    static addColors(clrs) {
      const nextColors = Object.keys(clrs).reduce((acc, level) => {
        acc[level] = hasSpace.test(clrs[level]) ? clrs[level].split(hasSpace) : clrs[level];
        return acc;
      }, {});
      Colorizer.allColors = Object.assign({}, Colorizer.allColors || {}, nextColors);
      return Colorizer.allColors;
    }
    addColors(clrs) {
      return Colorizer.addColors(clrs);
    }
    colorize(lookup4, level, message) {
      if (typeof message === "undefined") {
        message = level;
      }
      if (!Array.isArray(Colorizer.allColors[lookup4])) {
        return colors[Colorizer.allColors[lookup4]](message);
      }
      for (let i3 = 0, len = Colorizer.allColors[lookup4].length;i3 < len; i3++) {
        message = colors[Colorizer.allColors[lookup4][i3]](message);
      }
      return message;
    }
    transform(info, opts) {
      if (opts.all && typeof info[MESSAGE] === "string") {
        info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
      }
      if (opts.level || opts.all || !opts.message) {
        info.level = this.colorize(info[LEVEL], info.level);
      }
      if (opts.all || opts.message) {
        info.message = this.colorize(info[LEVEL], info.level, info.message);
      }
      return info;
    }
  }
  module.exports = (opts) => new Colorizer(opts);
  module.exports.Colorizer = module.exports.Format = Colorizer;
});

// ../../node_modules/logform/levels.js
var require_levels = __commonJS((exports, module) => {
  var { Colorizer } = require_colorize();
  module.exports = (config8) => {
    Colorizer.addColors(config8.colors || config8);
    return config8;
  };
});

// ../../node_modules/logform/align.js
var require_align = __commonJS((exports, module) => {
  var format6 = require_format();
  module.exports = format6((info) => {
    info.message = `\t${info.message}`;
    return info;
  });
});

// ../../node_modules/logform/errors.js
var require_errors = __commonJS((exports, module) => {
  var format6 = require_format();
  var { LEVEL, MESSAGE } = require_triple_beam();
  module.exports = format6((einfo, { stack, cause }) => {
    if (einfo instanceof Error) {
      const info = Object.assign({}, einfo, {
        level: einfo.level,
        [LEVEL]: einfo[LEVEL] || einfo.level,
        message: einfo.message,
        [MESSAGE]: einfo[MESSAGE] || einfo.message
      });
      if (stack)
        info.stack = einfo.stack;
      if (cause)
        info.cause = einfo.cause;
      return info;
    }
    if (!(einfo.message instanceof Error))
      return einfo;
    const err = einfo.message;
    Object.assign(einfo, err);
    einfo.message = err.message;
    einfo[MESSAGE] = err.message;
    if (stack)
      einfo.stack = err.stack;
    if (cause)
      einfo.cause = err.cause;
    return einfo;
  });
});

// ../../node_modules/logform/pad-levels.js
var require_pad_levels = __commonJS((exports, module) => {
  var { configs, LEVEL, MESSAGE } = require_triple_beam();

  class Padder {
    constructor(opts = { levels: configs.npm.levels }) {
      this.paddings = Padder.paddingForLevels(opts.levels, opts.filler);
      this.options = opts;
    }
    static getLongestLevel(levels) {
      const lvls = Object.keys(levels).map((level) => level.length);
      return Math.max(...lvls);
    }
    static paddingForLevel(level, filler, maxLength) {
      const targetLen = maxLength + 1 - level.length;
      const rep = Math.floor(targetLen / filler.length);
      const padding = `${filler}${filler.repeat(rep)}`;
      return padding.slice(0, targetLen);
    }
    static paddingForLevels(levels, filler = " ") {
      const maxLength = Padder.getLongestLevel(levels);
      return Object.keys(levels).reduce((acc, level) => {
        acc[level] = Padder.paddingForLevel(level, filler, maxLength);
        return acc;
      }, {});
    }
    transform(info, opts) {
      info.message = `${this.paddings[info[LEVEL]]}${info.message}`;
      if (info[MESSAGE]) {
        info[MESSAGE] = `${this.paddings[info[LEVEL]]}${info[MESSAGE]}`;
      }
      return info;
    }
  }
  module.exports = (opts) => new Padder(opts);
  module.exports.Padder = module.exports.Format = Padder;
});

// ../../node_modules/logform/cli.js
var require_cli2 = __commonJS((exports, module) => {
  var { Colorizer } = require_colorize();
  var { Padder } = require_pad_levels();
  var { configs, MESSAGE } = require_triple_beam();

  class CliFormat {
    constructor(opts = {}) {
      if (!opts.levels) {
        opts.levels = configs.cli.levels;
      }
      this.colorizer = new Colorizer(opts);
      this.padder = new Padder(opts);
      this.options = opts;
    }
    transform(info, opts) {
      this.colorizer.transform(this.padder.transform(info, opts), opts);
      info[MESSAGE] = `${info.level}:${info.message}`;
      return info;
    }
  }
  module.exports = (opts) => new CliFormat(opts);
  module.exports.Format = CliFormat;
});

// ../../node_modules/logform/combine.js
var require_combine = __commonJS((exports, module) => {
  var cascade = function(formats) {
    if (!formats.every(isValidFormat)) {
      return;
    }
    return (info) => {
      let obj = info;
      for (let i3 = 0;i3 < formats.length; i3++) {
        obj = formats[i3].transform(obj, formats[i3].options);
        if (!obj) {
          return false;
        }
      }
      return obj;
    };
  };
  var isValidFormat = function(fmt) {
    if (typeof fmt.transform !== "function") {
      throw new Error([
        "No transform function found on format. Did you create a format instance?",
        "const myFormat = format(formatFn);",
        "const instance = myFormat();"
      ].join("\n"));
    }
    return true;
  };
  var format6 = require_format();
  module.exports = (...formats) => {
    const combinedFormat = format6(cascade(formats));
    const instance = combinedFormat();
    instance.Format = combinedFormat.Format;
    return instance;
  };
  module.exports.cascade = cascade;
});

// ../../node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS((exports, module) => {
  var strEscape = function(str) {
    if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
      return `"${str}"`;
    }
    return JSON.stringify(str);
  };
  var insertSort = function(array59) {
    if (array59.length > 200) {
      return array59.sort();
    }
    for (let i3 = 1;i3 < array59.length; i3++) {
      const currentValue = array59[i3];
      let position = i3;
      while (position !== 0 && array59[position - 1] > currentValue) {
        array59[position] = array59[position - 1];
        position--;
      }
      array59[position] = currentValue;
    }
    return array59;
  };
  var isTypedArrayWithEntries = function(value) {
    return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0;
  };
  var stringifyTypedArray = function(array59, separator, maximumBreadth) {
    if (array59.length < maximumBreadth) {
      maximumBreadth = array59.length;
    }
    const whitespace = separator === "," ? "" : " ";
    let res = `"0":${whitespace}${array59[0]}`;
    for (let i3 = 1;i3 < maximumBreadth; i3++) {
      res += `${separator}"${i3}":${whitespace}${array59[i3]}`;
    }
    return res;
  };
  var getCircularValueOption = function(options) {
    if (hasOwnProperty3.call(options, "circularValue")) {
      const circularValue = options.circularValue;
      if (typeof circularValue === "string") {
        return `"${circularValue}"`;
      }
      if (circularValue == null) {
        return circularValue;
      }
      if (circularValue === Error || circularValue === TypeError) {
        return {
          toString() {
            throw new TypeError("Converting circular structure to JSON");
          }
        };
      }
      throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
    }
    return '"[Circular]"';
  };
  var getBooleanOption = function(options, key) {
    let value;
    if (hasOwnProperty3.call(options, key)) {
      value = options[key];
      if (typeof value !== "boolean") {
        throw new TypeError(`The "${key}" argument must be of type boolean`);
      }
    }
    return value === undefined ? true : value;
  };
  var getPositiveIntegerOption = function(options, key) {
    let value;
    if (hasOwnProperty3.call(options, key)) {
      value = options[key];
      if (typeof value !== "number") {
        throw new TypeError(`The "${key}" argument must be of type number`);
      }
      if (!Number.isInteger(value)) {
        throw new TypeError(`The "${key}" argument must be an integer`);
      }
      if (value < 1) {
        throw new RangeError(`The "${key}" argument must be >= 1`);
      }
    }
    return value === undefined ? Infinity : value;
  };
  var getItemCount = function(number102) {
    if (number102 === 1) {
      return "1 item";
    }
    return `${number102} items`;
  };
  var getUniqueReplacerSet = function(replacerArray) {
    const replacerSet = new Set;
    for (const value of replacerArray) {
      if (typeof value === "string" || typeof value === "number") {
        replacerSet.add(String(value));
      }
    }
    return replacerSet;
  };
  var getStrictOption = function(options) {
    if (hasOwnProperty3.call(options, "strict")) {
      const value = options.strict;
      if (typeof value !== "boolean") {
        throw new TypeError('The "strict" argument must be of type boolean');
      }
      if (value) {
        return (value2) => {
          let message = `Object can not safely be stringified. Received type ${typeof value2}`;
          if (typeof value2 !== "function")
            message += ` (${value2.toString()})`;
          throw new Error(message);
        };
      }
    }
  };
  var configure = function(options) {
    options = { ...options };
    const fail = getStrictOption(options);
    if (fail) {
      if (options.bigint === undefined) {
        options.bigint = false;
      }
      if (!("circularValue" in options)) {
        options.circularValue = Error;
      }
    }
    const circularValue = getCircularValueOption(options);
    const bigint = getBooleanOption(options, "bigint");
    const deterministic = getBooleanOption(options, "deterministic");
    const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
    const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
    function stringifyFnReplacer(key, parent, stack, replacer2, spacer, indentation) {
      let value = parent[key];
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      value = replacer2.call(parent, key, value);
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          let res = "";
          let join2 = ",";
          const originalIndentation = indentation;
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            if (spacer !== "") {
              indentation += spacer;
              res += `\n${indentation}`;
              join2 = `,\n${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i3 = 0;
            for (;i3 < maximumValuesToStringify - 1; i3++) {
              const tmp2 = stringifyFnReplacer(String(i3), value, stack, replacer2, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join2;
            }
            const tmp = stringifyFnReplacer(String(i3), value, stack, replacer2, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `\n${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let whitespace = "";
          let separator = "";
          if (spacer !== "") {
            indentation += spacer;
            join2 = `,\n${indentation}`;
            whitespace = " ";
          }
          const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (deterministic && !isTypedArrayWithEntries(value)) {
            keys = insertSort(keys);
          }
          stack.push(value);
          for (let i3 = 0;i3 < maximumPropertiesToStringify; i3++) {
            const key2 = keys[i3];
            const tmp = stringifyFnReplacer(key2, value, stack, replacer2, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join2;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
            separator = join2;
          }
          if (spacer !== "" && separator.length > 1) {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifyArrayReplacer(key, value, stack, replacer2, spacer, indentation) {
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          let res = "";
          let join2 = ",";
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            if (spacer !== "") {
              indentation += spacer;
              res += `\n${indentation}`;
              join2 = `,\n${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i3 = 0;
            for (;i3 < maximumValuesToStringify - 1; i3++) {
              const tmp2 = stringifyArrayReplacer(String(i3), value[i3], stack, replacer2, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join2;
            }
            const tmp = stringifyArrayReplacer(String(i3), value[i3], stack, replacer2, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `\n${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          stack.push(value);
          let whitespace = "";
          if (spacer !== "") {
            indentation += spacer;
            join2 = `,\n${indentation}`;
            whitespace = " ";
          }
          let separator = "";
          for (const key2 of replacer2) {
            const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer2, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join2;
            }
          }
          if (spacer !== "" && separator.length > 1) {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifyIndent(key, value, stack, spacer, indentation) {
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
            if (typeof value !== "object") {
              return stringifyIndent(key, value, stack, spacer, indentation);
            }
            if (value === null) {
              return "null";
            }
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            indentation += spacer;
            let res2 = `\n${indentation}`;
            const join3 = `,\n${indentation}`;
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i3 = 0;
            for (;i3 < maximumValuesToStringify - 1; i3++) {
              const tmp2 = stringifyIndent(String(i3), value[i3], stack, spacer, indentation);
              res2 += tmp2 !== undefined ? tmp2 : "null";
              res2 += join3;
            }
            const tmp = stringifyIndent(String(i3), value[i3], stack, spacer, indentation);
            res2 += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res2 += `${join3}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            res2 += `\n${originalIndentation}`;
            stack.pop();
            return `[${res2}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          indentation += spacer;
          const join2 = `,\n${indentation}`;
          let res = "";
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (isTypedArrayWithEntries(value)) {
            res += stringifyTypedArray(value, join2, maximumBreadth);
            keys = keys.slice(value.length);
            maximumPropertiesToStringify -= value.length;
            separator = join2;
          }
          if (deterministic) {
            keys = insertSort(keys);
          }
          stack.push(value);
          for (let i3 = 0;i3 < maximumPropertiesToStringify; i3++) {
            const key2 = keys[i3];
            const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}: ${tmp}`;
              separator = join2;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
            separator = join2;
          }
          if (separator !== "") {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifySimple(key, value, stack) {
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
            if (typeof value !== "object") {
              return stringifySimple(key, value, stack);
            }
            if (value === null) {
              return "null";
            }
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          let res = "";
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i3 = 0;
            for (;i3 < maximumValuesToStringify - 1; i3++) {
              const tmp2 = stringifySimple(String(i3), value[i3], stack);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += ",";
            }
            const tmp = stringifySimple(String(i3), value[i3], stack);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `,"... ${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (isTypedArrayWithEntries(value)) {
            res += stringifyTypedArray(value, ",", maximumBreadth);
            keys = keys.slice(value.length);
            maximumPropertiesToStringify -= value.length;
            separator = ",";
          }
          if (deterministic) {
            keys = insertSort(keys);
          }
          stack.push(value);
          for (let i3 = 0;i3 < maximumPropertiesToStringify; i3++) {
            const key2 = keys[i3];
            const tmp = stringifySimple(key2, value[key2], stack);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${tmp}`;
              separator = ",";
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringify3(value, replacer2, space) {
      if (arguments.length > 1) {
        let spacer = "";
        if (typeof space === "number") {
          spacer = " ".repeat(Math.min(space, 10));
        } else if (typeof space === "string") {
          spacer = space.slice(0, 10);
        }
        if (replacer2 != null) {
          if (typeof replacer2 === "function") {
            return stringifyFnReplacer("", { "": value }, [], replacer2, spacer, "");
          }
          if (Array.isArray(replacer2)) {
            return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer2), spacer, "");
          }
        }
        if (spacer.length !== 0) {
          return stringifyIndent("", value, [], spacer, "");
        }
      }
      return stringifySimple("", value, []);
    }
    return stringify3;
  };
  var { hasOwnProperty: hasOwnProperty3 } = Object.prototype;
  var stringify2 = configure();
  stringify2.configure = configure;
  stringify2.stringify = stringify2;
  stringify2.default = stringify2;
  exports.stringify = stringify2;
  exports.configure = configure;
  module.exports = stringify2;
  var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
  var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array)), Symbol.toStringTag).get;
});

// ../../node_modules/logform/json.js
var require_json = __commonJS((exports, module) => {
  var replacer2 = function(key, value) {
    if (typeof value === "bigint")
      return value.toString();
    return value;
  };
  var format6 = require_format();
  var { MESSAGE } = require_triple_beam();
  var stringify2 = require_safe_stable_stringify();
  module.exports = format6((info, opts) => {
    const jsonStringify = stringify2.configure(opts);
    info[MESSAGE] = jsonStringify(info, opts.replacer || replacer2, opts.space);
    return info;
  });
});

// ../../node_modules/logform/label.js
var require_label = __commonJS((exports, module) => {
  var format6 = require_format();
  module.exports = format6((info, opts) => {
    if (opts.message) {
      info.message = `[${opts.label}] ${info.message}`;
      return info;
    }
    info.label = opts.label;
    return info;
  });
});

// ../../node_modules/logform/logstash.js
var require_logstash = __commonJS((exports, module) => {
  var format6 = require_format();
  var { MESSAGE } = require_triple_beam();
  var jsonStringify = require_safe_stable_stringify();
  module.exports = format6((info) => {
    const logstash = {};
    if (info.message) {
      logstash["@message"] = info.message;
      delete info.message;
    }
    if (info.timestamp) {
      logstash["@timestamp"] = info.timestamp;
      delete info.timestamp;
    }
    logstash["@fields"] = info;
    info[MESSAGE] = jsonStringify(logstash);
    return info;
  });
});

// ../../node_modules/logform/metadata.js
var require_metadata = __commonJS((exports, module) => {
  var fillExcept = function(info, fillExceptKeys, metadataKey) {
    const savedKeys = fillExceptKeys.reduce((acc, key) => {
      acc[key] = info[key];
      delete info[key];
      return acc;
    }, {});
    const metadata = Object.keys(info).reduce((acc, key) => {
      acc[key] = info[key];
      delete info[key];
      return acc;
    }, {});
    Object.assign(info, savedKeys, {
      [metadataKey]: metadata
    });
    return info;
  };
  var fillWith = function(info, fillWithKeys, metadataKey) {
    info[metadataKey] = fillWithKeys.reduce((acc, key) => {
      acc[key] = info[key];
      delete info[key];
      return acc;
    }, {});
    return info;
  };
  var format6 = require_format();
  module.exports = format6((info, opts = {}) => {
    let metadataKey = "metadata";
    if (opts.key) {
      metadataKey = opts.key;
    }
    let fillExceptKeys = [];
    if (!opts.fillExcept && !opts.fillWith) {
      fillExceptKeys.push("level");
      fillExceptKeys.push("message");
    }
    if (opts.fillExcept) {
      fillExceptKeys = opts.fillExcept;
    }
    if (fillExceptKeys.length > 0) {
      return fillExcept(info, fillExceptKeys, metadataKey);
    }
    if (opts.fillWith) {
      return fillWith(info, opts.fillWith, metadataKey);
    }
    return info;
  });
});

// ../../node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var parse4 = function(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  };
  var fmtShort = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms / h2) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  };
  var fmtLong = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h2) {
      return plural(ms, msAbs, h2, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  };
  var plural = function(ms, msAbs, n, name302) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name302 + (isPlural ? "s" : "");
  };
  var s = 1000;
  var m = s * 60;
  var h2 = m * 60;
  var d = h2 * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse4(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// ../../node_modules/logform/ms.js
var require_ms2 = __commonJS((exports, module) => {
  var format6 = require_format();
  var ms = require_ms();
  module.exports = format6((info) => {
    const curr = +new Date;
    exports.diff = curr - (exports.prevTime || curr);
    exports.prevTime = curr;
    info.ms = `+${ms(exports.diff)}`;
    return info;
  });
});

// ../../node_modules/logform/pretty-print.js
var require_pretty_print = __commonJS((exports, module) => {
  var inspect = __require("util").inspect;
  var format6 = require_format();
  var { LEVEL, MESSAGE, SPLAT } = require_triple_beam();
  module.exports = format6((info, opts = {}) => {
    const stripped = Object.assign({}, info);
    delete stripped[LEVEL];
    delete stripped[MESSAGE];
    delete stripped[SPLAT];
    info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
    return info;
  });
});

// ../../node_modules/logform/printf.js
var require_printf = __commonJS((exports, module) => {
  var { MESSAGE } = require_triple_beam();

  class Printf {
    constructor(templateFn) {
      this.template = templateFn;
    }
    transform(info) {
      info[MESSAGE] = this.template(info);
      return info;
    }
  }
  module.exports = (opts) => new Printf(opts);
  module.exports.Printf = module.exports.Format = Printf;
});

// ../../node_modules/logform/simple.js
var require_simple = __commonJS((exports, module) => {
  var format6 = require_format();
  var { MESSAGE } = require_triple_beam();
  var jsonStringify = require_safe_stable_stringify();
  module.exports = format6((info) => {
    const stringifiedRest = jsonStringify(Object.assign({}, info, {
      level: undefined,
      message: undefined,
      splat: undefined
    }));
    const padding = info.padding && info.padding[info.level] || "";
    if (stringifiedRest !== "{}") {
      info[MESSAGE] = `${info.level}:${padding} ${info.message} ${stringifiedRest}`;
    } else {
      info[MESSAGE] = `${info.level}:${padding} ${info.message}`;
    }
    return info;
  });
});

// ../../node_modules/logform/splat.js
var require_splat = __commonJS((exports, module) => {
  var util4 = __require("util");
  var { SPLAT } = require_triple_beam();
  var formatRegExp = /%[scdjifoO%]/g;
  var escapedPercent = /%%/g;

  class Splatter {
    constructor(opts) {
      this.options = opts;
    }
    _splat(info, tokens) {
      const msg = info.message;
      const splat = info[SPLAT] || info.splat || [];
      const percents = msg.match(escapedPercent);
      const escapes = percents && percents.length || 0;
      const expectedSplat = tokens.length - escapes;
      const extraSplat = expectedSplat - splat.length;
      const metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : [];
      const metalen = metas.length;
      if (metalen) {
        for (let i3 = 0;i3 < metalen; i3++) {
          Object.assign(info, metas[i3]);
        }
      }
      info.message = util4.format(msg, ...splat);
      return info;
    }
    transform(info) {
      const msg = info.message;
      const splat = info[SPLAT] || info.splat;
      if (!splat || !splat.length) {
        return info;
      }
      const tokens = msg && msg.match && msg.match(formatRegExp);
      if (!tokens && (splat || splat.length)) {
        const metas = splat.length > 1 ? splat.splice(0) : splat;
        const metalen = metas.length;
        if (metalen) {
          for (let i3 = 0;i3 < metalen; i3++) {
            Object.assign(info, metas[i3]);
          }
        }
        return info;
      }
      if (tokens) {
        return this._splat(info, tokens);
      }
      return info;
    }
  }
  module.exports = (opts) => new Splatter(opts);
});

// ../../node_modules/fecha/lib/fecha.umd.js
var require_fecha_umd = __commonJS((exports, module) => {
  (function(global2, factory309) {
    typeof exports === "object" && typeof module !== "undefined" ? factory309(exports) : typeof define === "function" && define.amd ? define(["exports"], factory309) : factory309(global2.fecha = {});
  })(exports, function(exports2) {
    var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
    var twoDigitsOptional = "\\d\\d?";
    var twoDigits = "\\d\\d";
    var threeDigits = "\\d{3}";
    var fourDigits = "\\d{4}";
    var word = "[^\\s]+";
    var literal = /\[([^]*?)\]/gm;
    function shorten(arr, sLen) {
      var newArr = [];
      for (var i3 = 0, len = arr.length;i3 < len; i3++) {
        newArr.push(arr[i3].substr(0, sLen));
      }
      return newArr;
    }
    var monthUpdate = function(arrName) {
      return function(v, i18n) {
        var lowerCaseArr = i18n[arrName].map(function(v2) {
          return v2.toLowerCase();
        });
        var index2 = lowerCaseArr.indexOf(v.toLowerCase());
        if (index2 > -1) {
          return index2;
        }
        return null;
      };
    };
    function assign3(origObj) {
      var args = [];
      for (var _i = 1;_i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      for (var _a = 0, args_1 = args;_a < args_1.length; _a++) {
        var obj = args_1[_a];
        for (var key in obj) {
          origObj[key] = obj[key];
        }
      }
      return origObj;
    }
    var dayNames = [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ];
    var monthNames = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    var monthNamesShort = shorten(monthNames, 3);
    var dayNamesShort = shorten(dayNames, 3);
    var defaultI18n = {
      dayNamesShort,
      dayNames,
      monthNamesShort,
      monthNames,
      amPm: ["am", "pm"],
      DoFn: function(dayOfMonth) {
        return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
      }
    };
    var globalI18n = assign3({}, defaultI18n);
    var setGlobalDateI18n = function(i18n) {
      return globalI18n = assign3(globalI18n, i18n);
    };
    var regexEscape = function(str) {
      return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
    };
    var pad = function(val, len) {
      if (len === undefined) {
        len = 2;
      }
      val = String(val);
      while (val.length < len) {
        val = "0" + val;
      }
      return val;
    };
    var formatFlags = {
      D: function(dateObj) {
        return String(dateObj.getDate());
      },
      DD: function(dateObj) {
        return pad(dateObj.getDate());
      },
      Do: function(dateObj, i18n) {
        return i18n.DoFn(dateObj.getDate());
      },
      d: function(dateObj) {
        return String(dateObj.getDay());
      },
      dd: function(dateObj) {
        return pad(dateObj.getDay());
      },
      ddd: function(dateObj, i18n) {
        return i18n.dayNamesShort[dateObj.getDay()];
      },
      dddd: function(dateObj, i18n) {
        return i18n.dayNames[dateObj.getDay()];
      },
      M: function(dateObj) {
        return String(dateObj.getMonth() + 1);
      },
      MM: function(dateObj) {
        return pad(dateObj.getMonth() + 1);
      },
      MMM: function(dateObj, i18n) {
        return i18n.monthNamesShort[dateObj.getMonth()];
      },
      MMMM: function(dateObj, i18n) {
        return i18n.monthNames[dateObj.getMonth()];
      },
      YY: function(dateObj) {
        return pad(String(dateObj.getFullYear()), 4).substr(2);
      },
      YYYY: function(dateObj) {
        return pad(dateObj.getFullYear(), 4);
      },
      h: function(dateObj) {
        return String(dateObj.getHours() % 12 || 12);
      },
      hh: function(dateObj) {
        return pad(dateObj.getHours() % 12 || 12);
      },
      H: function(dateObj) {
        return String(dateObj.getHours());
      },
      HH: function(dateObj) {
        return pad(dateObj.getHours());
      },
      m: function(dateObj) {
        return String(dateObj.getMinutes());
      },
      mm: function(dateObj) {
        return pad(dateObj.getMinutes());
      },
      s: function(dateObj) {
        return String(dateObj.getSeconds());
      },
      ss: function(dateObj) {
        return pad(dateObj.getSeconds());
      },
      S: function(dateObj) {
        return String(Math.round(dateObj.getMilliseconds() / 100));
      },
      SS: function(dateObj) {
        return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
      },
      SSS: function(dateObj) {
        return pad(dateObj.getMilliseconds(), 3);
      },
      a: function(dateObj, i18n) {
        return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
      },
      A: function(dateObj, i18n) {
        return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
      },
      ZZ: function(dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
      },
      Z: function(dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
      }
    };
    var monthParse = function(v) {
      return +v - 1;
    };
    var emptyDigits = [null, twoDigitsOptional];
    var emptyWord = [null, word];
    var amPm = [
      "isPm",
      word,
      function(v, i18n) {
        var val = v.toLowerCase();
        if (val === i18n.amPm[0]) {
          return 0;
        } else if (val === i18n.amPm[1]) {
          return 1;
        }
        return null;
      }
    ];
    var timezoneOffset = [
      "timezoneOffset",
      "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
      function(v) {
        var parts = (v + "").match(/([+-]|\d\d)/gi);
        if (parts) {
          var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
          return parts[0] === "+" ? minutes : -minutes;
        }
        return 0;
      }
    ];
    var parseFlags = {
      D: ["day", twoDigitsOptional],
      DD: ["day", twoDigits],
      Do: ["day", twoDigitsOptional + word, function(v) {
        return parseInt(v, 10);
      }],
      M: ["month", twoDigitsOptional, monthParse],
      MM: ["month", twoDigits, monthParse],
      YY: [
        "year",
        twoDigits,
        function(v) {
          var now = new Date;
          var cent = +("" + now.getFullYear()).substr(0, 2);
          return +("" + (+v > 68 ? cent - 1 : cent) + v);
        }
      ],
      h: ["hour", twoDigitsOptional, undefined, "isPm"],
      hh: ["hour", twoDigits, undefined, "isPm"],
      H: ["hour", twoDigitsOptional],
      HH: ["hour", twoDigits],
      m: ["minute", twoDigitsOptional],
      mm: ["minute", twoDigits],
      s: ["second", twoDigitsOptional],
      ss: ["second", twoDigits],
      YYYY: ["year", fourDigits],
      S: ["millisecond", "\\d", function(v) {
        return +v * 100;
      }],
      SS: ["millisecond", twoDigits, function(v) {
        return +v * 10;
      }],
      SSS: ["millisecond", threeDigits],
      d: emptyDigits,
      dd: emptyDigits,
      ddd: emptyWord,
      dddd: emptyWord,
      MMM: ["month", word, monthUpdate("monthNamesShort")],
      MMMM: ["month", word, monthUpdate("monthNames")],
      a: amPm,
      A: amPm,
      ZZ: timezoneOffset,
      Z: timezoneOffset
    };
    var globalMasks = {
      default: "ddd MMM DD YYYY HH:mm:ss",
      shortDate: "M/D/YY",
      mediumDate: "MMM D, YYYY",
      longDate: "MMMM D, YYYY",
      fullDate: "dddd, MMMM D, YYYY",
      isoDate: "YYYY-MM-DD",
      isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
      shortTime: "HH:mm",
      mediumTime: "HH:mm:ss",
      longTime: "HH:mm:ss.SSS"
    };
    var setGlobalDateMasks = function(masks) {
      return assign3(globalMasks, masks);
    };
    var format6 = function(dateObj, mask, i18n) {
      if (mask === undefined) {
        mask = globalMasks["default"];
      }
      if (i18n === undefined) {
        i18n = {};
      }
      if (typeof dateObj === "number") {
        dateObj = new Date(dateObj);
      }
      if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
        throw new Error("Invalid Date pass to format");
      }
      mask = globalMasks[mask] || mask;
      var literals = [];
      mask = mask.replace(literal, function($0, $1) {
        literals.push($1);
        return "@@@";
      });
      var combinedI18nSettings = assign3(assign3({}, globalI18n), i18n);
      mask = mask.replace(token, function($0) {
        return formatFlags[$0](dateObj, combinedI18nSettings);
      });
      return mask.replace(/@@@/g, function() {
        return literals.shift();
      });
    };
    function parse4(dateStr, format7, i18n) {
      if (i18n === undefined) {
        i18n = {};
      }
      if (typeof format7 !== "string") {
        throw new Error("Invalid format in fecha parse");
      }
      format7 = globalMasks[format7] || format7;
      if (dateStr.length > 1000) {
        return null;
      }
      var today = new Date;
      var dateInfo = {
        year: today.getFullYear(),
        month: 0,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0,
        isPm: null,
        timezoneOffset: null
      };
      var parseInfo = [];
      var literals = [];
      var newFormat = format7.replace(literal, function($0, $1) {
        literals.push(regexEscape($1));
        return "@@@";
      });
      var specifiedFields = {};
      var requiredFields = {};
      newFormat = regexEscape(newFormat).replace(token, function($0) {
        var info = parseFlags[$0];
        var field2 = info[0], regex = info[1], requiredField = info[3];
        if (specifiedFields[field2]) {
          throw new Error("Invalid format. " + field2 + " specified twice in format");
        }
        specifiedFields[field2] = true;
        if (requiredField) {
          requiredFields[requiredField] = true;
        }
        parseInfo.push(info);
        return "(" + regex + ")";
      });
      Object.keys(requiredFields).forEach(function(field2) {
        if (!specifiedFields[field2]) {
          throw new Error("Invalid format. " + field2 + " is required in specified format");
        }
      });
      newFormat = newFormat.replace(/@@@/g, function() {
        return literals.shift();
      });
      var matches = dateStr.match(new RegExp(newFormat, "i"));
      if (!matches) {
        return null;
      }
      var combinedI18nSettings = assign3(assign3({}, globalI18n), i18n);
      for (var i3 = 1;i3 < matches.length; i3++) {
        var _a = parseInfo[i3 - 1], field = _a[0], parser2 = _a[2];
        var value = parser2 ? parser2(matches[i3], combinedI18nSettings) : +matches[i3];
        if (value == null) {
          return null;
        }
        dateInfo[field] = value;
      }
      if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
        dateInfo.hour = +dateInfo.hour + 12;
      } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
        dateInfo.hour = 0;
      }
      var dateTZ;
      if (dateInfo.timezoneOffset == null) {
        dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
        var validateFields = [
          ["month", "getMonth"],
          ["day", "getDate"],
          ["hour", "getHours"],
          ["minute", "getMinutes"],
          ["second", "getSeconds"]
        ];
        for (var i3 = 0, len = validateFields.length;i3 < len; i3++) {
          if (specifiedFields[validateFields[i3][0]] && dateInfo[validateFields[i3][0]] !== dateTZ[validateFields[i3][1]]()) {
            return null;
          }
        }
      } else {
        dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
        if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
          return null;
        }
      }
      return dateTZ;
    }
    var fecha = {
      format: format6,
      parse: parse4,
      defaultI18n,
      setGlobalDateI18n,
      setGlobalDateMasks
    };
    exports2.assign = assign3;
    exports2.default = fecha;
    exports2.format = format6;
    exports2.parse = parse4;
    exports2.defaultI18n = defaultI18n;
    exports2.setGlobalDateI18n = setGlobalDateI18n;
    exports2.setGlobalDateMasks = setGlobalDateMasks;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// ../../node_modules/logform/timestamp.js
var require_timestamp = __commonJS((exports, module) => {
  var fecha = require_fecha_umd();
  var format6 = require_format();
  module.exports = format6((info, opts = {}) => {
    if (opts.format) {
      info.timestamp = typeof opts.format === "function" ? opts.format() : fecha.format(new Date, opts.format);
    }
    if (!info.timestamp) {
      info.timestamp = new Date().toISOString();
    }
    if (opts.alias) {
      info[opts.alias] = info.timestamp;
    }
    return info;
  });
});

// ../../node_modules/logform/uncolorize.js
var require_uncolorize = __commonJS((exports, module) => {
  var colors = require_safe();
  var format6 = require_format();
  var { MESSAGE } = require_triple_beam();
  module.exports = format6((info, opts) => {
    if (opts.level !== false) {
      info.level = colors.strip(info.level);
    }
    if (opts.message !== false) {
      info.message = colors.strip(String(info.message));
    }
    if (opts.raw !== false && info[MESSAGE]) {
      info[MESSAGE] = colors.strip(String(info[MESSAGE]));
    }
    return info;
  });
});

// ../../node_modules/logform/index.js
var require_logform = __commonJS((exports) => {
  var exposeFormat = function(name302, requireFormat) {
    Object.defineProperty(format6, name302, {
      get() {
        return requireFormat();
      },
      configurable: true
    });
  };
  var format6 = exports.format = require_format();
  exports.levels = require_levels();
  exposeFormat("align", function() {
    return require_align();
  });
  exposeFormat("errors", function() {
    return require_errors();
  });
  exposeFormat("cli", function() {
    return require_cli2();
  });
  exposeFormat("combine", function() {
    return require_combine();
  });
  exposeFormat("colorize", function() {
    return require_colorize();
  });
  exposeFormat("json", function() {
    return require_json();
  });
  exposeFormat("label", function() {
    return require_label();
  });
  exposeFormat("logstash", function() {
    return require_logstash();
  });
  exposeFormat("metadata", function() {
    return require_metadata();
  });
  exposeFormat("ms", function() {
    return require_ms2();
  });
  exposeFormat("padLevels", function() {
    return require_pad_levels();
  });
  exposeFormat("prettyPrint", function() {
    return require_pretty_print();
  });
  exposeFormat("printf", function() {
    return require_printf();
  });
  exposeFormat("simple", function() {
    return require_simple();
  });
  exposeFormat("splat", function() {
    return require_splat();
  });
  exposeFormat("timestamp", function() {
    return require_timestamp();
  });
  exposeFormat("uncolorize", function() {
    return require_uncolorize();
  });
});

// ../../node_modules/winston/lib/winston/common.js
var require_common3 = __commonJS((exports) => {
  var { format: format6 } = __require("util");
  exports.warn = {
    deprecated(prop) {
      return () => {
        throw new Error(format6("{ %s } was removed in winston@3.0.0.", prop));
      };
    },
    useFormat(prop) {
      return () => {
        throw new Error([
          format6("{ %s } was removed in winston@3.0.0.", prop),
          "Use a custom winston.format = winston.format(function) instead."
        ].join("\n"));
      };
    },
    forFunctions(obj, type, props) {
      props.forEach((prop) => {
        obj[prop] = exports.warn[type](prop);
      });
    },
    forProperties(obj, type, props) {
      props.forEach((prop) => {
        const notice = exports.warn[type](prop);
        Object.defineProperty(obj, prop, {
          get: notice,
          set: notice
        });
      });
    }
  };
});

// ../../node_modules/winston/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "winston",
    description: "A logger for just about everything.",
    version: "3.11.0",
    author: "Charlie Robbins <charlie.robbins@gmail.com>",
    maintainers: [
      "David Hyde <dabh@alumni.stanford.edu>"
    ],
    repository: {
      type: "git",
      url: "https://github.com/winstonjs/winston.git"
    },
    keywords: [
      "winston",
      "logger",
      "logging",
      "logs",
      "sysadmin",
      "bunyan",
      "pino",
      "loglevel",
      "tools",
      "json",
      "stream"
    ],
    dependencies: {
      "@dabh/diagnostics": "^2.0.2",
      "@colors/colors": "^1.6.0",
      async: "^3.2.3",
      "is-stream": "^2.0.0",
      logform: "^2.4.0",
      "one-time": "^1.0.0",
      "readable-stream": "^3.4.0",
      "safe-stable-stringify": "^2.3.1",
      "stack-trace": "0.0.x",
      "triple-beam": "^1.3.0",
      "winston-transport": "^4.5.0"
    },
    devDependencies: {
      "@babel/cli": "^7.17.0",
      "@babel/core": "^7.17.2",
      "@babel/preset-env": "^7.16.7",
      "@dabh/eslint-config-populist": "^5.0.0",
      "@types/node": "^20.3.1",
      "abstract-winston-transport": "^0.5.1",
      assume: "^2.2.0",
      "cross-spawn-async": "^2.2.5",
      eslint: "^8.9.0",
      hock: "^1.4.1",
      mocha: "8.1.3",
      nyc: "^15.1.0",
      rimraf: "^5.0.5",
      split2: "^4.1.0",
      "std-mocks": "^1.0.1",
      through2: "^4.0.2",
      "winston-compat": "^0.1.5"
    },
    main: "./lib/winston.js",
    browser: "./dist/winston",
    types: "./index.d.ts",
    scripts: {
      lint: "eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist",
      test: "mocha",
      "test:coverage": "nyc npm run test:unit",
      "test:unit": "mocha test/unit",
      "test:integration": "mocha test/integration",
      build: "rimraf dist && babel lib -d dist",
      prepublishOnly: "npm run build"
    },
    engines: {
      node: ">= 12.0.0"
    },
    license: "MIT"
  };
});

// ../../node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS((exports, module) => {
  var ownKeys3 = function(object36, enumerableOnly) {
    var keys = Object.keys(object36);
    if (Object.getOwnPropertySymbols) {
      var symbols2 = Object.getOwnPropertySymbols(object36);
      enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object36, sym).enumerable;
      })), keys.push.apply(keys, symbols2);
    }
    return keys;
  };
  var _objectSpread3 = function(target) {
    for (var i3 = 1;i3 < arguments.length; i3++) {
      var source = arguments[i3] != null ? arguments[i3] : {};
      i3 % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
        _defineProperty17(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  };
  var _defineProperty17 = function(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  };
  var _classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var _defineProperties = function(target, props) {
    for (var i3 = 0;i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  };
  var _createClass = function(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  };
  var _toPropertyKey = function(arg3) {
    var key = _toPrimitive(arg3, "string");
    return typeof key === "symbol" ? key : String(key);
  };
  var _toPrimitive = function(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  };
  var copyBuffer = function(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  };
  var _require = __require("buffer");
  var Buffer2 = _require.Buffer;
  var _require2 = __require("util");
  var inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  module.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next)
          ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i3 = 0;
        while (p) {
          copyBuffer(p.data, ret, i3);
          i3 += p.data.length;
          p = p.next;
        }
        return ret;
      }
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: custom,
      value: function value(_2, options) {
        return inspect(this, _objectSpread3(_objectSpread3({}, options), {}, {
          depth: 0,
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
});

// ../../node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports, module) => {
  var destroy = function(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  };
  var emitErrorAndCloseNT = function(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  };
  var emitCloseNT = function(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  };
  var undestroy = function() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  };
  var emitErrorNT = function(self2, err) {
    self2.emit("error", err);
  };
  var errorOrDestroy = function(stream3, err) {
    var rState = stream3._readableState;
    var wState = stream3._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream3.destroy(err);
    else
      stream3.emit("error", err);
  };
  module.exports = {
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// ../../node_modules/readable-stream/errors.js
var require_errors2 = __commonJS((exports, module) => {
  var createErrorType = function(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg22, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg22, arg3);
      }
    }

    class NodeError extends Base {
      constructor(arg1, arg22, arg3) {
        super(getMessage(arg1, arg22, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  };
  var oneOf = function(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i3) => String(i3));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  };
  var startsWith = function(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  };
  var endsWith2 = function(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  };
  var includes = function(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  };
  var codes = {};
  createErrorType("ERR_INVALID_OPT_VALUE", function(name302, value) {
    return 'The value "' + value + '" is invalid for option "' + name302 + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name302, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith2(name302, " argument")) {
      msg = `The ${name302} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type = includes(name302, ".") ? "property" : "argument";
      msg = `The "${name302}" ${type} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name302) {
    return "The " + name302 + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name302) {
    return "Cannot call " + name302 + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg3) {
    return "Unknown encoding: " + arg3;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  exports.codes = codes;
});

// ../../node_modules/readable-stream/lib/internal/streams/state.js
var require_state2 = __commonJS((exports, module) => {
  var highWaterMarkFrom = function(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  };
  var getHighWaterMark = function(state3, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name302 = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name302, hwm);
      }
      return Math.floor(hwm);
    }
    return state3.objectMode ? 16 : 16 * 1024;
  };
  var ERR_INVALID_OPT_VALUE = require_errors2().codes.ERR_INVALID_OPT_VALUE;
  module.exports = {
    getHighWaterMark
  };
});

// ../../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// ../../node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports, module) => {
  try {
    util4 = __require("util");
    if (typeof util4.inherits !== "function")
      throw "";
    module.exports = util4.inherits;
  } catch (e4) {
    module.exports = require_inherits_browser();
  }
  var util4;
});

// ../../node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS((exports, module) => {
  var once = function(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  };
  var noop6 = function() {
  };
  var isRequest = function(stream3) {
    return stream3.setHeader && typeof stream3.abort === "function";
  };
  var eos2 = function(stream3, opts, callback) {
    if (typeof opts === "function")
      return eos2(stream3, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop6);
    var readable = opts.readable || opts.readable !== false && stream3.readable;
    var writable = opts.writable || opts.writable !== false && stream3.writable;
    var onlegacyfinish = function onlegacyfinish() {
      if (!stream3.writable)
        onfinish();
    };
    var writableEnded = stream3._writableState && stream3._writableState.finished;
    var onfinish = function onfinish() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream3);
    };
    var readableEnded = stream3._readableState && stream3._readableState.endEmitted;
    var onend = function onend() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream3);
    };
    var onerror = function onerror(err) {
      callback.call(stream3, err);
    };
    var onclose = function onclose() {
      var err;
      if (readable && !readableEnded) {
        if (!stream3._readableState || !stream3._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream3, err);
      }
      if (writable && !writableEnded) {
        if (!stream3._writableState || !stream3._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream3, err);
      }
    };
    var onrequest = function onrequest() {
      stream3.req.on("finish", onfinish);
    };
    if (isRequest(stream3)) {
      stream3.on("complete", onfinish);
      stream3.on("abort", onclose);
      if (stream3.req)
        onrequest();
      else
        stream3.on("request", onrequest);
    } else if (writable && !stream3._writableState) {
      stream3.on("end", onlegacyfinish);
      stream3.on("close", onlegacyfinish);
    }
    stream3.on("end", onend);
    stream3.on("finish", onfinish);
    if (opts.error !== false)
      stream3.on("error", onerror);
    stream3.on("close", onclose);
    return function() {
      stream3.removeListener("complete", onfinish);
      stream3.removeListener("abort", onclose);
      stream3.removeListener("request", onrequest);
      if (stream3.req)
        stream3.req.removeListener("finish", onfinish);
      stream3.removeListener("end", onlegacyfinish);
      stream3.removeListener("close", onlegacyfinish);
      stream3.removeListener("finish", onfinish);
      stream3.removeListener("end", onend);
      stream3.removeListener("error", onerror);
      stream3.removeListener("close", onclose);
    };
  };
  var ERR_STREAM_PREMATURE_CLOSE = require_errors2().codes.ERR_STREAM_PREMATURE_CLOSE;
  module.exports = eos2;
});

// ../../node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS((exports, module) => {
  var _defineProperty17 = function(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  };
  var _toPropertyKey = function(arg3) {
    var key = _toPrimitive(arg3, "string");
    return typeof key === "symbol" ? key : String(key);
  };
  var _toPrimitive = function(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  };
  var createIterResult = function(value, done) {
    return {
      value,
      done
    };
  };
  var readAndResolve = function(iter) {
    var resolve4 = iter[kLastResolve];
    if (resolve4 !== null) {
      var data2 = iter[kStream].read();
      if (data2 !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve4(createIterResult(data2, false));
      }
    }
  };
  var onReadable = function(iter) {
    process.nextTick(readAndResolve, iter);
  };
  var wrapForNext = function(lastPromise, iter) {
    return function(resolve4, reject2) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve4(createIterResult(undefined, true));
          return;
        }
        iter[kHandlePromise](resolve4, reject2);
      }, reject2);
    };
  };
  var _Object$setPrototypeO;
  var finished = require_end_of_stream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(undefined, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve4, reject2) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject2(_this[kError]);
            } else {
              resolve4(createIterResult(undefined, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data2 = this[kStream].read();
        if (data2 !== null) {
          return Promise.resolve(createIterResult(data2, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty17(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty17(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve4, reject2) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject2(err);
          return;
        }
        resolve4(createIterResult(undefined, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream3) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty17(_Object$create, kStream, {
      value: stream3,
      writable: true
    }), _defineProperty17(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty17(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty17(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty17(_Object$create, kEnded, {
      value: stream3._readableState.endEmitted,
      writable: true
    }), _defineProperty17(_Object$create, kHandlePromise, {
      value: function value(resolve4, reject2) {
        var data2 = iterator[kStream].read();
        if (data2) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve4(createIterResult(data2, false));
        } else {
          iterator[kLastResolve] = resolve4;
          iterator[kLastReject] = reject2;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream3, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject2 = iterator[kLastReject];
        if (reject2 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject2(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve4 = iterator[kLastResolve];
      if (resolve4 !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve4(createIterResult(undefined, true));
      }
      iterator[kEnded] = true;
    });
    stream3.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  module.exports = createReadableStreamAsyncIterator;
});

// ../../node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS((exports, module) => {
  var asyncGeneratorStep = function(gen, resolve4, reject2, _next, _throw, key, arg3) {
    try {
      var info = gen[key](arg3);
      var value = info.value;
    } catch (error) {
      reject2(error);
      return;
    }
    if (info.done) {
      resolve4(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  };
  var _asyncToGenerator = function(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve4, reject2) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve4, reject2, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve4, reject2, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  };
  var ownKeys3 = function(object36, enumerableOnly) {
    var keys = Object.keys(object36);
    if (Object.getOwnPropertySymbols) {
      var symbols2 = Object.getOwnPropertySymbols(object36);
      enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object36, sym).enumerable;
      })), keys.push.apply(keys, symbols2);
    }
    return keys;
  };
  var _objectSpread3 = function(target) {
    for (var i3 = 1;i3 < arguments.length; i3++) {
      var source = arguments[i3] != null ? arguments[i3] : {};
      i3 % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
        _defineProperty17(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  };
  var _defineProperty17 = function(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  };
  var _toPropertyKey = function(arg3) {
    var key = _toPrimitive(arg3, "string");
    return typeof key === "symbol" ? key : String(key);
  };
  var _toPrimitive = function(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  };
  var from = function(Readable, iterable, opts) {
    var iterator;
    if (iterable && typeof iterable.next === "function") {
      iterator = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator])
      iterator = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator])
      iterator = iterable[Symbol.iterator]();
    else
      throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    var readable = new Readable(_objectSpread3({
      objectMode: true
    }, opts));
    var reading = false;
    readable._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    function next() {
      return _next2.apply(this, arguments);
    }
    function _next2() {
      _next2 = _asyncToGenerator(function* () {
        try {
          var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
          if (done) {
            readable.push(null);
          } else if (readable.push(yield value)) {
            next();
          } else {
            reading = false;
          }
        } catch (err) {
          readable.destroy(err);
        }
      });
      return _next2.apply(this, arguments);
    }
    return readable;
  };
  var ERR_INVALID_ARG_TYPE = require_errors2().codes.ERR_INVALID_ARG_TYPE;
  module.exports = from;
});

// ../../node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable = __commonJS((exports, module) => {
  var _uint8ArrayToBuffer = function(chunk) {
    return Buffer2.from(chunk);
  };
  var _isUint8Array = function(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  };
  var prependListener = function(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  };
  var ReadableState = function(options, stream3, isDuplex) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream3 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = __require("string_decoder/").StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  };
  var Readable = function(options) {
    Duplex = Duplex || require__stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  };
  var readableAddChunk = function(stream3, chunk, encoding, addToFront, skipChunkCheck) {
    debug2("readableAddChunk", chunk);
    var state3 = stream3._readableState;
    if (chunk === null) {
      state3.reading = false;
      onEofChunk(stream3, state3);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state3, chunk);
      if (er) {
        errorOrDestroy(stream3, er);
      } else if (state3.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state3.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state3.endEmitted)
            errorOrDestroy(stream3, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
          else
            addChunk(stream3, state3, chunk, true);
        } else if (state3.ended) {
          errorOrDestroy(stream3, new ERR_STREAM_PUSH_AFTER_EOF);
        } else if (state3.destroyed) {
          return false;
        } else {
          state3.reading = false;
          if (state3.decoder && !encoding) {
            chunk = state3.decoder.write(chunk);
            if (state3.objectMode || chunk.length !== 0)
              addChunk(stream3, state3, chunk, false);
            else
              maybeReadMore(stream3, state3);
          } else {
            addChunk(stream3, state3, chunk, false);
          }
        }
      } else if (!addToFront) {
        state3.reading = false;
        maybeReadMore(stream3, state3);
      }
    }
    return !state3.ended && (state3.length < state3.highWaterMark || state3.length === 0);
  };
  var addChunk = function(stream3, state3, chunk, addToFront) {
    if (state3.flowing && state3.length === 0 && !state3.sync) {
      state3.awaitDrain = 0;
      stream3.emit("data", chunk);
    } else {
      state3.length += state3.objectMode ? 1 : chunk.length;
      if (addToFront)
        state3.buffer.unshift(chunk);
      else
        state3.buffer.push(chunk);
      if (state3.needReadable)
        emitReadable(stream3);
    }
    maybeReadMore(stream3, state3);
  };
  var chunkInvalid = function(state3, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state3.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  };
  var computeNewHighWaterMark = function(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  };
  var howMuchToRead = function(n, state3) {
    if (n <= 0 || state3.length === 0 && state3.ended)
      return 0;
    if (state3.objectMode)
      return 1;
    if (n !== n) {
      if (state3.flowing && state3.length)
        return state3.buffer.head.data.length;
      else
        return state3.length;
    }
    if (n > state3.highWaterMark)
      state3.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state3.length)
      return n;
    if (!state3.ended) {
      state3.needReadable = true;
      return 0;
    }
    return state3.length;
  };
  var onEofChunk = function(stream3, state3) {
    debug2("onEofChunk");
    if (state3.ended)
      return;
    if (state3.decoder) {
      var chunk = state3.decoder.end();
      if (chunk && chunk.length) {
        state3.buffer.push(chunk);
        state3.length += state3.objectMode ? 1 : chunk.length;
      }
    }
    state3.ended = true;
    if (state3.sync) {
      emitReadable(stream3);
    } else {
      state3.needReadable = false;
      if (!state3.emittedReadable) {
        state3.emittedReadable = true;
        emitReadable_(stream3);
      }
    }
  };
  var emitReadable = function(stream3) {
    var state3 = stream3._readableState;
    debug2("emitReadable", state3.needReadable, state3.emittedReadable);
    state3.needReadable = false;
    if (!state3.emittedReadable) {
      debug2("emitReadable", state3.flowing);
      state3.emittedReadable = true;
      process.nextTick(emitReadable_, stream3);
    }
  };
  var emitReadable_ = function(stream3) {
    var state3 = stream3._readableState;
    debug2("emitReadable_", state3.destroyed, state3.length, state3.ended);
    if (!state3.destroyed && (state3.length || state3.ended)) {
      stream3.emit("readable");
      state3.emittedReadable = false;
    }
    state3.needReadable = !state3.flowing && !state3.ended && state3.length <= state3.highWaterMark;
    flow(stream3);
  };
  var maybeReadMore = function(stream3, state3) {
    if (!state3.readingMore) {
      state3.readingMore = true;
      process.nextTick(maybeReadMore_, stream3, state3);
    }
  };
  var maybeReadMore_ = function(stream3, state3) {
    while (!state3.reading && !state3.ended && (state3.length < state3.highWaterMark || state3.flowing && state3.length === 0)) {
      var len = state3.length;
      debug2("maybeReadMore read 0");
      stream3.read(0);
      if (len === state3.length)
        break;
    }
    state3.readingMore = false;
  };
  var pipeOnDrain = function(src) {
    return function pipeOnDrainFunctionResult() {
      var state3 = src._readableState;
      debug2("pipeOnDrain", state3.awaitDrain);
      if (state3.awaitDrain)
        state3.awaitDrain--;
      if (state3.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state3.flowing = true;
        flow(src);
      }
    };
  };
  var updateReadableListening = function(self2) {
    var state3 = self2._readableState;
    state3.readableListening = self2.listenerCount("readable") > 0;
    if (state3.resumeScheduled && !state3.paused) {
      state3.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  };
  var nReadingNextTick = function(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  };
  var resume = function(stream3, state3) {
    if (!state3.resumeScheduled) {
      state3.resumeScheduled = true;
      process.nextTick(resume_, stream3, state3);
    }
  };
  var resume_ = function(stream3, state3) {
    debug2("resume", state3.reading);
    if (!state3.reading) {
      stream3.read(0);
    }
    state3.resumeScheduled = false;
    stream3.emit("resume");
    flow(stream3);
    if (state3.flowing && !state3.reading)
      stream3.read(0);
  };
  var flow = function(stream3) {
    var state3 = stream3._readableState;
    debug2("flow", state3.flowing);
    while (state3.flowing && stream3.read() !== null)
      ;
  };
  var fromList = function(n, state3) {
    if (state3.length === 0)
      return null;
    var ret;
    if (state3.objectMode)
      ret = state3.buffer.shift();
    else if (!n || n >= state3.length) {
      if (state3.decoder)
        ret = state3.buffer.join("");
      else if (state3.buffer.length === 1)
        ret = state3.buffer.first();
      else
        ret = state3.buffer.concat(state3.length);
      state3.buffer.clear();
    } else {
      ret = state3.buffer.consume(n, state3.decoder);
    }
    return ret;
  };
  var endReadable = function(stream3) {
    var state3 = stream3._readableState;
    debug2("endReadable", state3.endEmitted);
    if (!state3.endEmitted) {
      state3.ended = true;
      process.nextTick(endReadableNT, state3, stream3);
    }
  };
  var endReadableNT = function(state3, stream3) {
    debug2("endReadableNT", state3.endEmitted, state3.length);
    if (!state3.endEmitted && state3.length === 0) {
      state3.endEmitted = true;
      stream3.readable = false;
      stream3.emit("end");
      if (state3.autoDestroy) {
        var wState = stream3._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream3.destroy();
        }
      }
    }
  };
  var indexOf = function(xs, x) {
    for (var i3 = 0, l = xs.length;i3 < l; i3++) {
      if (xs[i3] === x)
        return i3;
    }
    return -1;
  };
  module.exports = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = __require("events").EventEmitter;
  var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = __require("stream");
  var Buffer2 = __require("buffer").Buffer;
  var OurUint8Array = (typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  var debugUtil = __require("util");
  var debug2;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function debug() {
    };
  }
  var BufferList = require_buffer_list();
  var destroyImpl = require_destroy();
  var _require = require_state2();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors2().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  require_inherits()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  Object.defineProperty(Readable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state3 = this._readableState;
    var skipChunkCheck;
    if (!state3.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state3.defaultEncoding;
        if (encoding !== state3.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = __require("string_decoder/").StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  Readable.prototype.read = function(n) {
    debug2("read", n);
    n = parseInt(n, 10);
    var state3 = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state3.emittedReadable = false;
    if (n === 0 && state3.needReadable && ((state3.highWaterMark !== 0 ? state3.length >= state3.highWaterMark : state3.length > 0) || state3.ended)) {
      debug2("read: emitReadable", state3.length, state3.ended);
      if (state3.length === 0 && state3.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state3);
    if (n === 0 && state3.ended) {
      if (state3.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state3.needReadable;
    debug2("need readable", doRead);
    if (state3.length === 0 || state3.length - n < state3.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state3.ended || state3.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state3.reading = true;
      state3.sync = true;
      if (state3.length === 0)
        state3.needReadable = true;
      this._read(state3.highWaterMark);
      state3.sync = false;
      if (!state3.reading)
        n = howMuchToRead(nOrig, state3);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state3);
    else
      ret = null;
    if (ret === null) {
      state3.needReadable = state3.length <= state3.highWaterMark;
      n = 0;
    } else {
      state3.length -= n;
      state3.awaitDrain = 0;
    }
    if (state3.length === 0) {
      if (!state3.ended)
        state3.needReadable = true;
      if (nOrig !== n && state3.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state3 = this._readableState;
    switch (state3.pipesCount) {
      case 0:
        state3.pipes = dest;
        break;
      case 1:
        state3.pipes = [state3.pipes, dest];
        break;
      default:
        state3.pipes.push(dest);
        break;
    }
    state3.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state3.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state3.endEmitted)
      process.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug2("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state3.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      var ret = dest.write(chunk);
      debug2("dest.write", ret);
      if (ret === false) {
        if ((state3.pipesCount === 1 && state3.pipes === dest || state3.pipesCount > 1 && indexOf(state3.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state3.awaitDrain);
          state3.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state3.flowing) {
      debug2("pipe resume");
      src.resume();
    }
    return dest;
  };
  Readable.prototype.unpipe = function(dest) {
    var state3 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state3.pipesCount === 0)
      return this;
    if (state3.pipesCount === 1) {
      if (dest && dest !== state3.pipes)
        return this;
      if (!dest)
        dest = state3.pipes;
      state3.pipes = null;
      state3.pipesCount = 0;
      state3.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state3.pipes;
      var len = state3.pipesCount;
      state3.pipes = null;
      state3.pipesCount = 0;
      state3.flowing = false;
      for (var i3 = 0;i3 < len; i3++)
        dests[i3].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    var index2 = indexOf(state3.pipes, dest);
    if (index2 === -1)
      return this;
    state3.pipes.splice(index2, 1);
    state3.pipesCount -= 1;
    if (state3.pipesCount === 1)
      state3.pipes = state3.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state3 = this._readableState;
    if (ev === "data") {
      state3.readableListening = this.listenerCount("readable") > 0;
      if (state3.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state3.endEmitted && !state3.readableListening) {
        state3.readableListening = state3.needReadable = true;
        state3.flowing = false;
        state3.emittedReadable = false;
        debug2("on readable", state3.length, state3.reading);
        if (state3.length) {
          emitReadable(this);
        } else if (!state3.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.resume = function() {
    var state3 = this._readableState;
    if (!state3.flowing) {
      debug2("resume");
      state3.flowing = !state3.readableListening;
      resume(this, state3);
    }
    state3.paused = false;
    return this;
  };
  Readable.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  Readable.prototype.wrap = function(stream3) {
    var _this = this;
    var state3 = this._readableState;
    var paused = false;
    stream3.on("end", function() {
      debug2("wrapped end");
      if (state3.decoder && !state3.ended) {
        var chunk = state3.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream3.on("data", function(chunk) {
      debug2("wrapped data");
      if (state3.decoder)
        chunk = state3.decoder.write(chunk);
      if (state3.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state3.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream3.pause();
      }
    });
    for (var i3 in stream3) {
      if (this[i3] === undefined && typeof stream3[i3] === "function") {
        this[i3] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream3[method].apply(stream3, arguments);
          };
        }(i3);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream3.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n3) {
      debug2("wrapped _read", n3);
      if (paused) {
        paused = false;
        stream3.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === undefined) {
        createReadableStreamAsyncIterator = require_async_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state3) {
      if (this._readableState) {
        this._readableState.flowing = state3;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === undefined) {
        from = require_from();
      }
      return from(Readable, iterable, opts);
    };
  }
});

// ../../node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex = __commonJS((exports, module) => {
  var Duplex = function(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  };
  var onend = function() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  };
  var onEndNT = function(self2) {
    self2.end();
  };
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj)
      keys2.push(key);
    return keys2;
  };
  module.exports = Duplex;
  var Readable = require__stream_readable();
  var Writable = require__stream_writable();
  require_inherits()(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0;v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  Object.defineProperty(Duplex.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
});

// ../../node_modules/util-deprecate/node.js
var require_node3 = __commonJS((exports, module) => {
  module.exports = __require("util").deprecate;
});

// ../../node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable = __commonJS((exports, module) => {
  var CorkedRequest = function(state3) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state3);
    };
  };
  var _uint8ArrayToBuffer = function(chunk) {
    return Buffer2.from(chunk);
  };
  var _isUint8Array = function(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  };
  var nop = function() {
  };
  var WritableState = function(options, stream3, isDuplex) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream3 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream3, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  };
  var Writable = function(options) {
    Duplex = Duplex || require__stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  };
  var writeAfterEnd = function(stream3, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END;
    errorOrDestroy(stream3, er);
    process.nextTick(cb, er);
  };
  var validChunk = function(stream3, state3, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES;
    } else if (typeof chunk !== "string" && !state3.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream3, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  };
  var decodeChunk = function(state3, chunk, encoding) {
    if (!state3.objectMode && state3.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  };
  var writeOrBuffer = function(stream3, state3, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state3, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state3.objectMode ? 1 : chunk.length;
    state3.length += len;
    var ret = state3.length < state3.highWaterMark;
    if (!ret)
      state3.needDrain = true;
    if (state3.writing || state3.corked) {
      var last = state3.lastBufferedRequest;
      state3.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state3.lastBufferedRequest;
      } else {
        state3.bufferedRequest = state3.lastBufferedRequest;
      }
      state3.bufferedRequestCount += 1;
    } else {
      doWrite(stream3, state3, false, len, chunk, encoding, cb);
    }
    return ret;
  };
  var doWrite = function(stream3, state3, writev, len, chunk, encoding, cb) {
    state3.writelen = len;
    state3.writecb = cb;
    state3.writing = true;
    state3.sync = true;
    if (state3.destroyed)
      state3.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream3._writev(chunk, state3.onwrite);
    else
      stream3._write(chunk, encoding, state3.onwrite);
    state3.sync = false;
  };
  var onwriteError = function(stream3, state3, sync, er, cb) {
    --state3.pendingcb;
    if (sync) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream3, state3);
      stream3._writableState.errorEmitted = true;
      errorOrDestroy(stream3, er);
    } else {
      cb(er);
      stream3._writableState.errorEmitted = true;
      errorOrDestroy(stream3, er);
      finishMaybe(stream3, state3);
    }
  };
  var onwriteStateUpdate = function(state3) {
    state3.writing = false;
    state3.writecb = null;
    state3.length -= state3.writelen;
    state3.writelen = 0;
  };
  var onwrite = function(stream3, er) {
    var state3 = stream3._writableState;
    var sync = state3.sync;
    var cb = state3.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK;
    onwriteStateUpdate(state3);
    if (er)
      onwriteError(stream3, state3, sync, er, cb);
    else {
      var finished = needFinish(state3) || stream3.destroyed;
      if (!finished && !state3.corked && !state3.bufferProcessing && state3.bufferedRequest) {
        clearBuffer(stream3, state3);
      }
      if (sync) {
        process.nextTick(afterWrite, stream3, state3, finished, cb);
      } else {
        afterWrite(stream3, state3, finished, cb);
      }
    }
  };
  var afterWrite = function(stream3, state3, finished, cb) {
    if (!finished)
      onwriteDrain(stream3, state3);
    state3.pendingcb--;
    cb();
    finishMaybe(stream3, state3);
  };
  var onwriteDrain = function(stream3, state3) {
    if (state3.length === 0 && state3.needDrain) {
      state3.needDrain = false;
      stream3.emit("drain");
    }
  };
  var clearBuffer = function(stream3, state3) {
    state3.bufferProcessing = true;
    var entry = state3.bufferedRequest;
    if (stream3._writev && entry && entry.next) {
      var l = state3.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state3.corkedRequestsFree;
      holder.entry = entry;
      var count3 = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count3] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count3 += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream3, state3, true, state3.length, buffer, "", holder.finish);
      state3.pendingcb++;
      state3.lastBufferedRequest = null;
      if (holder.next) {
        state3.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state3.corkedRequestsFree = new CorkedRequest(state3);
      }
      state3.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state3.objectMode ? 1 : chunk.length;
        doWrite(stream3, state3, false, len, chunk, encoding, cb);
        entry = entry.next;
        state3.bufferedRequestCount--;
        if (state3.writing) {
          break;
        }
      }
      if (entry === null)
        state3.lastBufferedRequest = null;
    }
    state3.bufferedRequest = entry;
    state3.bufferProcessing = false;
  };
  var needFinish = function(state3) {
    return state3.ending && state3.length === 0 && state3.bufferedRequest === null && !state3.finished && !state3.writing;
  };
  var callFinal = function(stream3, state3) {
    stream3._final(function(err) {
      state3.pendingcb--;
      if (err) {
        errorOrDestroy(stream3, err);
      }
      state3.prefinished = true;
      stream3.emit("prefinish");
      finishMaybe(stream3, state3);
    });
  };
  var prefinish = function(stream3, state3) {
    if (!state3.prefinished && !state3.finalCalled) {
      if (typeof stream3._final === "function" && !state3.destroyed) {
        state3.pendingcb++;
        state3.finalCalled = true;
        process.nextTick(callFinal, stream3, state3);
      } else {
        state3.prefinished = true;
        stream3.emit("prefinish");
      }
    }
  };
  var finishMaybe = function(stream3, state3) {
    var need = needFinish(state3);
    if (need) {
      prefinish(stream3, state3);
      if (state3.pendingcb === 0) {
        state3.finished = true;
        stream3.emit("finish");
        if (state3.autoDestroy) {
          var rState = stream3._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream3.destroy();
          }
        }
      }
    }
    return need;
  };
  var endWritable = function(stream3, state3, cb) {
    state3.ending = true;
    finishMaybe(stream3, state3);
    if (cb) {
      if (state3.finished)
        process.nextTick(cb);
      else
        stream3.once("finish", cb);
    }
    state3.ended = true;
    stream3.writable = false;
  };
  var onCorkedFinish = function(corkReq, state3, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state3.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state3.corkedRequestsFree.next = corkReq;
  };
  module.exports = Writable;
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: require_node3()
  };
  var Stream = __require("stream");
  var Buffer2 = __require("buffer").Buffer;
  var OurUint8Array = (typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  var destroyImpl = require_destroy();
  var _require = require_state2();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors2().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
  var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
  var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  require_inherits()(Writable, Stream);
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object36) {
        if (realHasInstance.call(this, object36))
          return true;
        if (this !== Writable)
          return false;
        return object36 && object36._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance(object36) {
      return object36 instanceof this;
    };
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
  };
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state3 = this._writableState;
    var ret = false;
    var isBuf = !state3.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state3.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state3.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state3, chunk, cb)) {
      state3.pendingcb++;
      ret = writeOrBuffer(this, state3, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state3 = this._writableState;
    if (state3.corked) {
      state3.corked--;
      if (!state3.writing && !state3.corked && !state3.bufferProcessing && state3.bufferedRequest)
        clearBuffer(this, state3);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state3 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state3.corked) {
      state3.corked = 1;
      this.uncork();
    }
    if (!state3.ending)
      endWritable(this, state3, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  Object.defineProperty(Writable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
});

// ../../node_modules/winston-transport/legacy.js
var require_legacy = __commonJS((exports, module) => {
  var util4 = __require("util");
  var { LEVEL } = require_triple_beam();
  var TransportStream = require_winston_transport();
  var LegacyTransportStream = module.exports = function LegacyTransportStream(options = {}) {
    TransportStream.call(this, options);
    if (!options.transport || typeof options.transport.log !== "function") {
      throw new Error("Invalid transport, must be an object with a log method.");
    }
    this.transport = options.transport;
    this.level = this.level || options.transport.level;
    this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;
    this._deprecated();
    function transportError(err) {
      this.emit("error", err, this.transport);
    }
    if (!this.transport.__winstonError) {
      this.transport.__winstonError = transportError.bind(this);
      this.transport.on("error", this.transport.__winstonError);
    }
  };
  util4.inherits(LegacyTransportStream, TransportStream);
  LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
    if (this.silent || info.exception === true && !this.handleExceptions) {
      return callback(null);
    }
    if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
      this.transport.log(info[LEVEL], info.message, info, this._nop);
    }
    callback(null);
  };
  LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
    for (let i3 = 0;i3 < chunks.length; i3++) {
      if (this._accept(chunks[i3])) {
        this.transport.log(chunks[i3].chunk[LEVEL], chunks[i3].chunk.message, chunks[i3].chunk, this._nop);
        chunks[i3].callback();
      }
    }
    return callback(null);
  };
  LegacyTransportStream.prototype._deprecated = function _deprecated() {
    console.error([
      `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
      "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
    ].join("\n"));
  };
  LegacyTransportStream.prototype.close = function close() {
    if (this.transport.close) {
      this.transport.close();
    }
    if (this.transport.__winstonError) {
      this.transport.removeListener("error", this.transport.__winstonError);
      this.transport.__winstonError = null;
    }
  };
});

// ../../node_modules/winston-transport/index.js
var require_winston_transport = __commonJS((exports, module) => {
  var util4 = __require("util");
  var Writable = require__stream_writable();
  var { LEVEL } = require_triple_beam();
  var TransportStream = module.exports = function TransportStream(options = {}) {
    Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
    this.format = options.format;
    this.level = options.level;
    this.handleExceptions = options.handleExceptions;
    this.handleRejections = options.handleRejections;
    this.silent = options.silent;
    if (options.log)
      this.log = options.log;
    if (options.logv)
      this.logv = options.logv;
    if (options.close)
      this.close = options.close;
    this.once("pipe", (logger3) => {
      this.levels = logger3.levels;
      this.parent = logger3;
    });
    this.once("unpipe", (src) => {
      if (src === this.parent) {
        this.parent = null;
        if (this.close) {
          this.close();
        }
      }
    });
  };
  util4.inherits(TransportStream, Writable);
  TransportStream.prototype._write = function _write(info, enc, callback) {
    if (this.silent || info.exception === true && !this.handleExceptions) {
      return callback(null);
    }
    const level = this.level || this.parent && this.parent.level;
    if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
      if (info && !this.format) {
        return this.log(info, callback);
      }
      let errState;
      let transformed;
      try {
        transformed = this.format.transform(Object.assign({}, info), this.format.options);
      } catch (err) {
        errState = err;
      }
      if (errState || !transformed) {
        callback();
        if (errState)
          throw errState;
        return;
      }
      return this.log(transformed, callback);
    }
    this._writableState.sync = false;
    return callback(null);
  };
  TransportStream.prototype._writev = function _writev(chunks, callback) {
    if (this.logv) {
      const infos = chunks.filter(this._accept, this);
      if (!infos.length) {
        return callback(null);
      }
      return this.logv(infos, callback);
    }
    for (let i3 = 0;i3 < chunks.length; i3++) {
      if (!this._accept(chunks[i3]))
        continue;
      if (chunks[i3].chunk && !this.format) {
        this.log(chunks[i3].chunk, chunks[i3].callback);
        continue;
      }
      let errState;
      let transformed;
      try {
        transformed = this.format.transform(Object.assign({}, chunks[i3].chunk), this.format.options);
      } catch (err) {
        errState = err;
      }
      if (errState || !transformed) {
        chunks[i3].callback();
        if (errState) {
          callback(null);
          throw errState;
        }
      } else {
        this.log(transformed, chunks[i3].callback);
      }
    }
    return callback(null);
  };
  TransportStream.prototype._accept = function _accept(write) {
    const info = write.chunk;
    if (this.silent) {
      return false;
    }
    const level = this.level || this.parent && this.parent.level;
    if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
      if (this.handleExceptions || info.exception !== true) {
        return true;
      }
    }
    return false;
  };
  TransportStream.prototype._nop = function _nop() {
    return;
  };
  module.exports.LegacyTransportStream = require_legacy();
});

// ../../node_modules/winston/lib/winston/transports/console.js
var require_console = __commonJS((exports, module) => {
  var os = __require("os");
  var { LEVEL, MESSAGE } = require_triple_beam();
  var TransportStream = require_winston_transport();
  module.exports = class Console extends TransportStream {
    constructor(options = {}) {
      super(options);
      this.name = options.name || "console";
      this.stderrLevels = this._stringArrayToSet(options.stderrLevels);
      this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);
      this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      this.setMaxListeners(30);
    }
    log(info, callback) {
      setImmediate(() => this.emit("logged", info));
      if (this.stderrLevels[info[LEVEL]]) {
        if (console._stderr) {
          console._stderr.write(`${info[MESSAGE]}${this.eol}`);
        } else {
          console.error(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
        return;
      } else if (this.consoleWarnLevels[info[LEVEL]]) {
        if (console._stderr) {
          console._stderr.write(`${info[MESSAGE]}${this.eol}`);
        } else {
          console.warn(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
        return;
      }
      if (console._stdout) {
        console._stdout.write(`${info[MESSAGE]}${this.eol}`);
      } else {
        console.log(info[MESSAGE]);
      }
      if (callback) {
        callback();
      }
    }
    _stringArrayToSet(strArray, errMsg) {
      if (!strArray)
        return {};
      errMsg = errMsg || "Cannot make set from type other than Array of string elements";
      if (!Array.isArray(strArray)) {
        throw new Error(errMsg);
      }
      return strArray.reduce((set, el) => {
        if (typeof el !== "string") {
          throw new Error(errMsg);
        }
        set[el] = true;
        return set;
      }, {});
    }
  };
});

// ../../node_modules/async/internal/isArrayLike.js
var require_isArrayLike = __commonJS((exports, module) => {
  var isArrayLike = function(value) {
    return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isArrayLike;
  module.exports = exports.default;
});

// ../../node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = function(fn) {
    return function(...args) {
      var callback = args.pop();
      return fn.call(this, args, callback);
    };
  };
  module.exports = exports.default;
});

// ../../node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS((exports) => {
  var fallback = function(fn) {
    setTimeout(fn, 0);
  };
  var wrap = function(defer) {
    return (fn, ...args) => defer(() => fn(...args));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.fallback = fallback;
  exports.wrap = wrap;
  var hasQueueMicrotask = exports.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
  var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
  var hasNextTick = exports.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
  var _defer;
  if (hasQueueMicrotask) {
    _defer = queueMicrotask;
  } else if (hasSetImmediate) {
    _defer = setImmediate;
  } else if (hasNextTick) {
    _defer = process.nextTick;
  } else {
    _defer = fallback;
  }
  exports.default = wrap(_defer);
});

// ../../node_modules/async/asyncify.js
var require_asyncify = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var asyncify = function(func) {
    if ((0, _wrapAsync.isAsync)(func)) {
      return function(...args) {
        const callback = args.pop();
        const promise = func.apply(this, args);
        return handlePromise(promise, callback);
      };
    }
    return (0, _initialParams2.default)(function(args, callback) {
      var result;
      try {
        result = func.apply(this, args);
      } catch (e4) {
        return callback(e4);
      }
      if (result && typeof result.then === "function") {
        return handlePromise(result, callback);
      } else {
        callback(null, result);
      }
    });
  };
  var handlePromise = function(promise, callback) {
    return promise.then((value) => {
      invokeCallback(callback, null, value);
    }, (err) => {
      invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
    });
  };
  var invokeCallback = function(callback, error, value) {
    try {
      callback(error, value);
    } catch (err) {
      (0, _setImmediate2.default)((e4) => {
        throw e4;
      }, err);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = asyncify;
  var _initialParams = require_initialParams();
  var _initialParams2 = _interopRequireDefault(_initialParams);
  var _setImmediate = require_setImmediate();
  var _setImmediate2 = _interopRequireDefault(_setImmediate);
  var _wrapAsync = require_wrapAsync();
  module.exports = exports.default;
});

// ../../node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isAsync = function(fn) {
    return fn[Symbol.toStringTag] === "AsyncFunction";
  };
  var isAsyncGenerator = function(fn) {
    return fn[Symbol.toStringTag] === "AsyncGenerator";
  };
  var isAsyncIterable = function(obj) {
    return typeof obj[Symbol.asyncIterator] === "function";
  };
  var wrapAsync = function(asyncFn) {
    if (typeof asyncFn !== "function")
      throw new Error("expected a function");
    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = undefined;
  var _asyncify = require_asyncify();
  var _asyncify2 = _interopRequireDefault(_asyncify);
  exports.default = wrapAsync;
  exports.isAsync = isAsync;
  exports.isAsyncGenerator = isAsyncGenerator;
  exports.isAsyncIterable = isAsyncIterable;
});

// ../../node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS((exports, module) => {
  var awaitify = function(asyncFn, arity) {
    if (!arity)
      arity = asyncFn.length;
    if (!arity)
      throw new Error("arity is undefined");
    function awaitable(...args) {
      if (typeof args[arity - 1] === "function") {
        return asyncFn.apply(this, args);
      }
      return new Promise((resolve4, reject2) => {
        args[arity - 1] = (err, ...cbArgs) => {
          if (err)
            return reject2(err);
          resolve4(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
        };
        asyncFn.apply(this, args);
      });
    }
    return awaitable;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = awaitify;
  module.exports = exports.default;
});

// ../../node_modules/async/internal/parallel.js
var require_parallel2 = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
    var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
    eachfn(tasks, (task, key, taskCb) => {
      (0, _wrapAsync2.default)(task)((err, ...result) => {
        if (result.length < 2) {
          [result] = result;
        }
        results[key] = result;
        taskCb(err);
      });
    }, (err) => callback(err, results));
  }, 3);
  module.exports = exports.default;
});

// ../../node_modules/async/internal/once.js
var require_once = __commonJS((exports, module) => {
  var once = function(fn) {
    function wrapper(...args) {
      if (fn === null)
        return;
      var callFn = fn;
      fn = null;
      callFn.apply(this, args);
    }
    Object.assign(wrapper, fn);
    return wrapper;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = once;
  module.exports = exports.default;
});

// ../../node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = function(coll) {
    return coll[Symbol.iterator] && coll[Symbol.iterator]();
  };
  module.exports = exports.default;
});

// ../../node_modules/async/internal/iterator.js
var require_iterator = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var createArrayIterator = function(coll) {
    var i3 = -1;
    var len = coll.length;
    return function next() {
      return ++i3 < len ? { value: coll[i3], key: i3 } : null;
    };
  };
  var createES2015Iterator = function(iterator) {
    var i3 = -1;
    return function next() {
      var item = iterator.next();
      if (item.done)
        return null;
      i3++;
      return { value: item.value, key: i3 };
    };
  };
  var createObjectIterator = function(obj) {
    var okeys = obj ? Object.keys(obj) : [];
    var i3 = -1;
    var len = okeys.length;
    return function next() {
      var key = okeys[++i3];
      if (key === "__proto__") {
        return next();
      }
      return i3 < len ? { value: obj[key], key } : null;
    };
  };
  var createIterator = function(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
      return createArrayIterator(coll);
    }
    var iterator = (0, _getIterator2.default)(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createIterator;
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _getIterator = require_getIterator();
  var _getIterator2 = _interopRequireDefault(_getIterator);
  module.exports = exports.default;
});

// ../../node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS((exports, module) => {
  var onlyOnce = function(fn) {
    return function(...args) {
      if (fn === null)
        throw new Error("Callback was already called.");
      var callFn = fn;
      fn = null;
      callFn.apply(this, args);
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = onlyOnce;
  module.exports = exports.default;
});

// ../../node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var breakLoop = {};
  exports.default = breakLoop;
  module.exports = exports.default;
});

// ../../node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var asyncEachOfLimit = function(generator2, limit, iteratee, callback) {
    let done = false;
    let canceled = false;
    let awaiting = false;
    let running = 0;
    let idx = 0;
    function replenish() {
      if (running >= limit || awaiting || done)
        return;
      awaiting = true;
      generator2.next().then(({ value, done: iterDone }) => {
        if (canceled || done)
          return;
        awaiting = false;
        if (iterDone) {
          done = true;
          if (running <= 0) {
            callback(null);
          }
          return;
        }
        running++;
        iteratee(value, idx, iterateeCallback);
        idx++;
        replenish();
      }).catch(handleError);
    }
    function iterateeCallback(err, result) {
      running -= 1;
      if (canceled)
        return;
      if (err)
        return handleError(err);
      if (err === false) {
        done = true;
        canceled = true;
        return;
      }
      if (result === _breakLoop2.default || done && running <= 0) {
        done = true;
        return callback(null);
      }
      replenish();
    }
    function handleError(err) {
      if (canceled)
        return;
      awaiting = false;
      done = true;
      callback(err);
    }
    replenish();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = asyncEachOfLimit;
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  module.exports = exports.default;
});

// ../../node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _once = require_once();
  var _once2 = _interopRequireDefault(_once);
  var _iterator = require_iterator();
  var _iterator2 = _interopRequireDefault(_iterator);
  var _onlyOnce = require_onlyOnce();
  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
  var _wrapAsync = require_wrapAsync();
  var _asyncEachOfLimit = require_asyncEachOfLimit();
  var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  exports.default = (limit) => {
    return (obj, iteratee, callback) => {
      callback = (0, _once2.default)(callback);
      if (limit <= 0) {
        throw new RangeError("concurrency limit cannot be less than 1");
      }
      if (!obj) {
        return callback(null);
      }
      if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
        return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
      }
      if ((0, _wrapAsync.isAsyncIterable)(obj)) {
        return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
      }
      var nextElem = (0, _iterator2.default)(obj);
      var done = false;
      var canceled = false;
      var running = 0;
      var looping = false;
      function iterateeCallback(err, value) {
        if (canceled)
          return;
        running -= 1;
        if (err) {
          done = true;
          callback(err);
        } else if (err === false) {
          done = true;
          canceled = true;
        } else if (value === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        } else if (!looping) {
          replenish();
        }
      }
      function replenish() {
        looping = true;
        while (running < limit && !done) {
          var elem = nextElem();
          if (elem === null) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running += 1;
          iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
        }
        looping = false;
      }
      replenish();
    };
  };
  module.exports = exports.default;
});

// ../../node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachOfLimit = function(coll, limit, iteratee, callback) {
    return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOfLimit2 = require_eachOfLimit();
  var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(eachOfLimit, 4);
  module.exports = exports.default;
});

// ../../node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachOfSeries = function(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOfLimit = require_eachOfLimit2();
  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(eachOfSeries, 3);
  module.exports = exports.default;
});

// ../../node_modules/async/series.js
var require_series = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var series = function(tasks, callback) {
    return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = series;
  var _parallel2 = require_parallel2();
  var _parallel3 = _interopRequireDefault(_parallel2);
  var _eachOfSeries = require_eachOfSeries();
  var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
  module.exports = exports.default;
});

// ../../node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform = __commonJS((exports, module) => {
  var afterTransform = function(er, data2) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK);
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data2 != null)
      this.push(data2);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  };
  var Transform = function(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  };
  var prefinish = function() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data2) {
        done(_this, er, data2);
      });
    } else {
      done(this, null, null);
    }
  };
  var done = function(stream3, er, data2) {
    if (er)
      return stream3.emit("error", er);
    if (data2 != null)
      stream3.push(data2);
    if (stream3._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0;
    if (stream3._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING;
    return stream3.push(null);
  };
  module.exports = Transform;
  var _require$codes = require_errors2().codes;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
  var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require__stream_duplex();
  require_inherits()(Transform, Duplex);
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
});

// ../../node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough = __commonJS((exports, module) => {
  var PassThrough = function(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  };
  module.exports = PassThrough;
  var Transform = require__stream_transform();
  require_inherits()(PassThrough, Transform);
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// ../../node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS((exports, module) => {
  var once = function(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(undefined, arguments);
    };
  };
  var noop6 = function(err) {
    if (err)
      throw err;
  };
  var isRequest = function(stream3) {
    return stream3.setHeader && typeof stream3.abort === "function";
  };
  var destroyer = function(stream3, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream3.on("close", function() {
      closed = true;
    });
    if (eos2 === undefined)
      eos2 = require_end_of_stream();
    eos2(stream3, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream3))
        return stream3.abort();
      if (typeof stream3.destroy === "function")
        return stream3.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  };
  var call = function(fn) {
    fn();
  };
  var pipe = function(from, to3) {
    return from.pipe(to3);
  };
  var popCallback = function(streams) {
    if (!streams.length)
      return noop6;
    if (typeof streams[streams.length - 1] !== "function")
      return noop6;
    return streams.pop();
  };
  var pipeline = function() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0;_key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream3, i3) {
      var reading = i3 < streams.length - 1;
      var writing = i3 > 0;
      return destroyer(stream3, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  };
  var eos2;
  var _require$codes = require_errors2().codes;
  var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  module.exports = pipeline;
});

// ../../node_modules/readable-stream/readable.js
var require_readable = __commonJS((exports, module) => {
  var Stream = __require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream.Readable;
    Object.assign(module.exports, Stream);
    module.exports.Stream = Stream;
  } else {
    exports = module.exports = require__stream_readable();
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require__stream_writable();
    exports.Duplex = require__stream_duplex();
    exports.Transform = require__stream_transform();
    exports.PassThrough = require__stream_passthrough();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// ../../node_modules/@dabh/diagnostics/diagnostics.js
var require_diagnostics = __commonJS((exports, module) => {
  var use = function(adapter2) {
    if (~adapters.indexOf(adapter2))
      return false;
    adapters.push(adapter2);
    return true;
  };
  var set = function(custom) {
    logger3 = custom;
  };
  var enabled = function(namespace) {
    var async = [];
    for (var i3 = 0;i3 < adapters.length; i3++) {
      if (adapters[i3].async) {
        async.push(adapters[i3]);
        continue;
      }
      if (adapters[i3](namespace))
        return true;
    }
    if (!async.length)
      return false;
    return new Promise(function pinky(resolve4) {
      Promise.all(async.map(function prebind(fn) {
        return fn(namespace);
      })).then(function resolved(values) {
        resolve4(values.some(Boolean));
      });
    });
  };
  var modify = function(fn) {
    if (~modifiers.indexOf(fn))
      return false;
    modifiers.push(fn);
    return true;
  };
  var write = function() {
    logger3.apply(logger3, arguments);
  };
  var process2 = function(message) {
    for (var i3 = 0;i3 < modifiers.length; i3++) {
      message = modifiers[i3].apply(modifiers[i3], arguments);
    }
    return message;
  };
  var introduce = function(fn, options) {
    var has = Object.prototype.hasOwnProperty;
    for (var key in options) {
      if (has.call(options, key)) {
        fn[key] = options[key];
      }
    }
    return fn;
  };
  var nope = function(options) {
    options.enabled = false;
    options.modify = modify;
    options.set = set;
    options.use = use;
    return introduce(function diagnopes() {
      return false;
    }, options);
  };
  var yep = function(options) {
    function diagnostics() {
      var args = Array.prototype.slice.call(arguments, 0);
      write.call(write, options, process2(args, options));
      return true;
    }
    options.enabled = true;
    options.modify = modify;
    options.set = set;
    options.use = use;
    return introduce(diagnostics, options);
  };
  var adapters = [];
  var modifiers = [];
  var logger3 = function devnull() {
  };
  module.exports = function create(diagnostics) {
    diagnostics.introduce = introduce;
    diagnostics.enabled = enabled;
    diagnostics.process = process2;
    diagnostics.modify = modify;
    diagnostics.write = write;
    diagnostics.nope = nope;
    diagnostics.yep = yep;
    diagnostics.set = set;
    diagnostics.use = use;
    return diagnostics;
  };
});

// ../../node_modules/color-name/index.js
var require_color_name = __commonJS((exports, module) => {
  module.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../../node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS((exports, module) => {
  module.exports = function isArrayish(obj) {
    if (!obj || typeof obj === "string") {
      return false;
    }
    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
  };
});

// ../../node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS((exports, module) => {
  var isArrayish = require_is_arrayish();
  var concat4 = Array.prototype.concat;
  var slice = Array.prototype.slice;
  var swizzle = module.exports = function swizzle(args) {
    var results = [];
    for (var i3 = 0, len = args.length;i3 < len; i3++) {
      var arg3 = args[i3];
      if (isArrayish(arg3)) {
        results = concat4.call(results, slice.call(arg3));
      } else {
        results.push(arg3);
      }
    }
    return results;
  };
  swizzle.wrap = function(fn) {
    return function() {
      return fn(swizzle(arguments));
    };
  };
});

// ../../node_modules/color-string/index.js
var require_color_string = __commonJS((exports, module) => {
  var clamp4 = function(num, min5, max5) {
    return Math.min(Math.max(min5, num), max5);
  };
  var hexDouble = function(num) {
    var str = Math.round(num).toString(16).toUpperCase();
    return str.length < 2 ? "0" + str : str;
  };
  var colorNames = require_color_name();
  var swizzle = require_simple_swizzle();
  var hasOwnProperty3 = Object.hasOwnProperty;
  var reverseNames = Object.create(null);
  for (name302 in colorNames) {
    if (hasOwnProperty3.call(colorNames, name302)) {
      reverseNames[colorNames[name302]] = name302;
    }
  }
  var name302;
  var cs = module.exports = {
    to: {},
    get: {}
  };
  cs.get = function(string31) {
    var prefix = string31.substring(0, 3).toLowerCase();
    var val;
    var model;
    switch (prefix) {
      case "hsl":
        val = cs.get.hsl(string31);
        model = "hsl";
        break;
      case "hwb":
        val = cs.get.hwb(string31);
        model = "hwb";
        break;
      default:
        val = cs.get.rgb(string31);
        model = "rgb";
        break;
    }
    if (!val) {
      return null;
    }
    return { model, value: val };
  };
  cs.get.rgb = function(string31) {
    if (!string31) {
      return null;
    }
    var abbr = /^#([a-f0-9]{3,4})$/i;
    var hex4 = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
    var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var keyword = /^(\w+)$/;
    var rgb = [0, 0, 0, 1];
    var match;
    var i3;
    var hexAlpha;
    if (match = string31.match(hex4)) {
      hexAlpha = match[2];
      match = match[1];
      for (i3 = 0;i3 < 3; i3++) {
        var i22 = i3 * 2;
        rgb[i3] = parseInt(match.slice(i22, i22 + 2), 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha, 16) / 255;
      }
    } else if (match = string31.match(abbr)) {
      match = match[1];
      hexAlpha = match[3];
      for (i3 = 0;i3 < 3; i3++) {
        rgb[i3] = parseInt(match[i3] + match[i3], 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
      }
    } else if (match = string31.match(rgba)) {
      for (i3 = 0;i3 < 3; i3++) {
        rgb[i3] = parseInt(match[i3 + 1], 0);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string31.match(per)) {
      for (i3 = 0;i3 < 3; i3++) {
        rgb[i3] = Math.round(parseFloat(match[i3 + 1]) * 2.55);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string31.match(keyword)) {
      if (match[1] === "transparent") {
        return [0, 0, 0, 0];
      }
      if (!hasOwnProperty3.call(colorNames, match[1])) {
        return null;
      }
      rgb = colorNames[match[1]];
      rgb[3] = 1;
      return rgb;
    } else {
      return null;
    }
    for (i3 = 0;i3 < 3; i3++) {
      rgb[i3] = clamp4(rgb[i3], 0, 255);
    }
    rgb[3] = clamp4(rgb[3], 0, 1);
    return rgb;
  };
  cs.get.hsl = function(string31) {
    if (!string31) {
      return null;
    }
    var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string31.match(hsl);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
      var s = clamp4(parseFloat(match[2]), 0, 100);
      var l = clamp4(parseFloat(match[3]), 0, 100);
      var a = clamp4(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h2, s, l, a];
    }
    return null;
  };
  cs.get.hwb = function(string31) {
    if (!string31) {
      return null;
    }
    var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string31.match(hwb);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
      var w = clamp4(parseFloat(match[2]), 0, 100);
      var b = clamp4(parseFloat(match[3]), 0, 100);
      var a = clamp4(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h2, w, b, a];
    }
    return null;
  };
  cs.to.hex = function() {
    var rgba = swizzle(arguments);
    return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
  };
  cs.to.rgb = function() {
    var rgba = swizzle(arguments);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
  };
  cs.to.rgb.percent = function() {
    var rgba = swizzle(arguments);
    var r = Math.round(rgba[0] / 255 * 100);
    var g = Math.round(rgba[1] / 255 * 100);
    var b = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
  };
  cs.to.hsl = function() {
    var hsla = swizzle(arguments);
    return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
  };
  cs.to.hwb = function() {
    var hwba = swizzle(arguments);
    var a = "";
    if (hwba.length >= 4 && hwba[3] !== 1) {
      a = ", " + hwba[3];
    }
    return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
  };
  cs.to.keyword = function(rgb) {
    return reverseNames[rgb.slice(0, 3)];
  };
});

// ../../node_modules/color/node_modules/color-name/index.js
var require_color_name2 = __commonJS((exports, module) => {
  module.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../../node_modules/color/node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports, module) => {
  var comparativeDistance = function(x, y) {
    return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
  };
  var cssKeywords = require_color_name2();
  var reverseKeywords = {};
  for (key in cssKeywords) {
    if (cssKeywords.hasOwnProperty(key)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
  }
  var key;
  var convert = module.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (model in convert) {
    if (convert.hasOwnProperty(model)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      channels = convert[model].channels;
      labels = convert[model].labels;
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
  }
  var channels;
  var labels;
  var model;
  convert.rgb.hsl = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var min5 = Math.min(r, g, b);
    var max5 = Math.max(r, g, b);
    var delta = max5 - min5;
    var h2;
    var s;
    var l;
    if (max5 === min5) {
      h2 = 0;
    } else if (r === max5) {
      h2 = (g - b) / delta;
    } else if (g === max5) {
      h2 = 2 + (b - r) / delta;
    } else if (b === max5) {
      h2 = 4 + (r - g) / delta;
    }
    h2 = Math.min(h2 * 60, 360);
    if (h2 < 0) {
      h2 += 360;
    }
    l = (min5 + max5) / 2;
    if (max5 === min5) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max5 + min5);
    } else {
      s = delta / (2 - max5 - min5);
    }
    return [h2, s * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h2;
    var s;
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var v = Math.max(r, g, b);
    var diff4 = v - Math.min(r, g, b);
    var diffc = function(c) {
      return (v - c) / 6 / diff4 + 1 / 2;
    };
    if (diff4 === 0) {
      h2 = s = 0;
    } else {
      s = diff4 / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h2 = bdif - gdif;
      } else if (g === v) {
        h2 = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h2 = 2 / 3 + gdif - rdif;
      }
      if (h2 < 0) {
        h2 += 1;
      } else if (h2 > 1) {
        h2 -= 1;
      }
    }
    return [
      h2 * 360,
      s * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    var r = rgb[0];
    var g = rgb[1];
    var b = rgb[2];
    var h2 = convert.rgb.hsl(rgb)[0];
    var w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h2, w * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var c;
    var m;
    var y;
    var k;
    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m = (1 - g - k) / (1 - k) || 0;
    y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  convert.rgb.keyword = function(rgb) {
    var reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    var currentClosestDistance = Infinity;
    var currentClosestKeyword;
    for (var keyword in cssKeywords) {
      if (cssKeywords.hasOwnProperty(keyword)) {
        var value = cssKeywords[keyword];
        var distance3 = comparativeDistance(rgb, value);
        if (distance3 < currentClosestDistance) {
          currentClosestDistance = distance3;
          currentClosestKeyword = keyword;
        }
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z2 = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z2 * 100];
  };
  convert.rgb.lab = function(rgb) {
    var xyz = convert.rgb.xyz(rgb);
    var x = xyz[0];
    var y = xyz[1];
    var z2 = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z2 /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z2 = z2 > 0.008856 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z2);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    var h2 = hsl[0] / 360;
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var t1;
    var t2;
    var t3;
    var rgb;
    var val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    t1 = 2 * l - t2;
    rgb = [0, 0, 0];
    for (var i3 = 0;i3 < 3; i3++) {
      t3 = h2 + 1 / 3 * -(i3 - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i3] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    var h2 = hsl[0];
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var smin = s;
    var lmin = Math.max(l, 0.01);
    var sv;
    var v;
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    v = (l + s) / 2;
    sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h2, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    var h2 = hsv[0] / 60;
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var hi = Math.floor(h2) % 6;
    var f = h2 - Math.floor(h2);
    var p = 255 * v * (1 - s);
    var q = 255 * v * (1 - s * f);
    var t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    var h2 = hsv[0];
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var vmin = Math.max(v, 0.01);
    var lmin;
    var sl;
    var l;
    l = (2 - s) * v;
    lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h2, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    var h2 = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var i3;
    var v;
    var f;
    var n;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    i3 = Math.floor(6 * h2);
    v = 1 - bl;
    f = 6 * h2 - i3;
    if ((i3 & 1) !== 0) {
      f = 1 - f;
    }
    n = wh + f * (v - wh);
    var r;
    var g;
    var b;
    switch (i3) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    var c = cmyk[0] / 100;
    var m = cmyk[1] / 100;
    var y = cmyk[2] / 100;
    var k = cmyk[3] / 100;
    var r;
    var g;
    var b;
    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m * (1 - k) + k);
    b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    var x = xyz[0] / 100;
    var y = xyz[1] / 100;
    var z2 = xyz[2] / 100;
    var r;
    var g;
    var b;
    r = x * 3.2406 + y * -1.5372 + z2 * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z2 * 0.0415;
    b = x * 0.0557 + y * -0.204 + z2 * 1.057;
    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    var x = xyz[0];
    var y = xyz[1];
    var z2 = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z2 /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z2 = z2 > 0.008856 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z2);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var x;
    var y;
    var z2;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z2 = y - b / 200;
    var y2 = Math.pow(y, 3);
    var x2 = Math.pow(x, 3);
    var z22 = Math.pow(z2, 3);
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z2 = z22 > 0.008856 ? z22 : (z2 - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z2 *= 108.883;
    return [x, y, z2];
  };
  convert.lab.lch = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var hr;
    var h2;
    var c;
    hr = Math.atan2(b, a);
    h2 = hr * 360 / 2 / Math.PI;
    if (h2 < 0) {
      h2 += 360;
    }
    c = Math.sqrt(a * a + b * b);
    return [l, c, h2];
  };
  convert.lch.lab = function(lch) {
    var l = lch[0];
    var c = lch[1];
    var h2 = lch[2];
    var a;
    var b;
    var hr;
    hr = h2 / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args) {
    var color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    var mult = (~~(args > 50) + 1) * 0.5;
    var r = (color & 1) * mult * 255;
    var g = (color >> 1 & 1) * mult * 255;
    var b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      var c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    var rem;
    var r = Math.floor(args / 36) / 5 * 255;
    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    var b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    var integer2 = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    var string31 = integer2.toString(16).toUpperCase();
    return "000000".substring(string31.length) + string31;
  };
  convert.hex.rgb = function(args) {
    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    var colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map(function(char) {
        return char + char;
      }).join("");
    }
    var integer2 = parseInt(colorString, 16);
    var r = integer2 >> 16 & 255;
    var g = integer2 >> 8 & 255;
    var b = integer2 & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var max5 = Math.max(Math.max(r, g), b);
    var min5 = Math.min(Math.min(r, g), b);
    var chroma = max5 - min5;
    var grayscale;
    var hue;
    if (chroma < 1) {
      grayscale = min5 / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max5 === r) {
      hue = (g - b) / chroma % 6;
    } else if (max5 === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma + 4;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var c = 1;
    var f = 0;
    if (l < 0.5) {
      c = 2 * s * l;
    } else {
      c = 2 * s * (1 - l);
    }
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var c = s * v;
    var f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    var h2 = hcg[0] / 360;
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    var pure = [0, 0, 0];
    var hi = h2 % 1 * 6;
    var v = hi % 1;
    var w = 1 - v;
    var mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    var f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var l = g * (1 - c) + 0.5 * c;
    var s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    var w = hwb[1] / 100;
    var b = hwb[2] / 100;
    var v = 1 - b;
    var c = v - w;
    var g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = convert.gray.hsv = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    var val = Math.round(gray[0] / 100 * 255) & 255;
    var integer2 = (val << 16) + (val << 8) + val;
    var string31 = integer2.toString(16).toUpperCase();
    return "000000".substring(string31.length) + string31;
  };
  convert.rgb.gray = function(rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// ../../node_modules/color/node_modules/color-convert/route.js
var require_route = __commonJS((exports, module) => {
  var buildGraph = function() {
    var graph = {};
    var models = Object.keys(conversions);
    for (var len = models.length, i3 = 0;i3 < len; i3++) {
      graph[models[i3]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  };
  var deriveBFS = function(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);
      for (var len = adjacents.length, i3 = 0;i3 < len; i3++) {
        var adjacent = adjacents[i3];
        var node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  };
  var link3 = function(from, to3) {
    return function(args) {
      return to3(from(args));
    };
  };
  var wrapConversion = function(toModel, graph) {
    var path3 = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path3.unshift(graph[cur].parent);
      fn = link3(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path3;
    return fn;
  };
  var conversions = require_conversions();
  module.exports = function(fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);
    for (var len = models.length, i3 = 0;i3 < len; i3++) {
      var toModel = models[i3];
      var node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// ../../node_modules/color/node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports, module) => {
  var wrapRaw = function(fn) {
    var wrappedFn = function(args) {
      if (args === undefined || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  };
  var wrapRounded = function(fn) {
    var wrappedFn = function(args) {
      if (args === undefined || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      var result = fn(args);
      if (typeof result === "object") {
        for (var len = result.length, i3 = 0;i3 < len; i3++) {
          result[i3] = Math.round(result[i3]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  };
  var conversions = require_conversions();
  var route = require_route();
  var convert = {};
  var models = Object.keys(conversions);
  models.forEach(function(fromModel) {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
    Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function(toModel) {
      var fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module.exports = convert;
});

// ../../node_modules/color/index.js
var require_color = __commonJS((exports, module) => {
  var Color = function(obj, model) {
    if (!(this instanceof Color)) {
      return new Color(obj, model);
    }
    if (model && model in skippedModels) {
      model = null;
    }
    if (model && !(model in convert)) {
      throw new Error("Unknown model: " + model);
    }
    var i3;
    var channels;
    if (obj == null) {
      this.model = "rgb";
      this.color = [0, 0, 0];
      this.valpha = 1;
    } else if (obj instanceof Color) {
      this.model = obj.model;
      this.color = obj.color.slice();
      this.valpha = obj.valpha;
    } else if (typeof obj === "string") {
      var result = colorString.get(obj);
      if (result === null) {
        throw new Error("Unable to parse color from string: " + obj);
      }
      this.model = result.model;
      channels = convert[this.model].channels;
      this.color = result.value.slice(0, channels);
      this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
    } else if (obj.length) {
      this.model = model || "rgb";
      channels = convert[this.model].channels;
      var newArr = _slice.call(obj, 0, channels);
      this.color = zeroArray(newArr, channels);
      this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
    } else if (typeof obj === "number") {
      obj &= 16777215;
      this.model = "rgb";
      this.color = [
        obj >> 16 & 255,
        obj >> 8 & 255,
        obj & 255
      ];
      this.valpha = 1;
    } else {
      this.valpha = 1;
      var keys = Object.keys(obj);
      if ("alpha" in obj) {
        keys.splice(keys.indexOf("alpha"), 1);
        this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
      }
      var hashedKeys = keys.sort().join("");
      if (!(hashedKeys in hashedModelKeys)) {
        throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
      }
      this.model = hashedModelKeys[hashedKeys];
      var labels = convert[this.model].labels;
      var color = [];
      for (i3 = 0;i3 < labels.length; i3++) {
        color.push(obj[labels[i3]]);
      }
      this.color = zeroArray(color);
    }
    if (limiters[this.model]) {
      channels = convert[this.model].channels;
      for (i3 = 0;i3 < channels; i3++) {
        var limit = limiters[this.model][i3];
        if (limit) {
          this.color[i3] = limit(this.color[i3]);
        }
      }
    }
    this.valpha = Math.max(0, Math.min(1, this.valpha));
    if (Object.freeze) {
      Object.freeze(this);
    }
  };
  var roundTo = function(num, places) {
    return Number(num.toFixed(places));
  };
  var roundToPlace = function(places) {
    return function(num) {
      return roundTo(num, places);
    };
  };
  var getset = function(model, channel, modifier) {
    model = Array.isArray(model) ? model : [model];
    model.forEach(function(m) {
      (limiters[m] || (limiters[m] = []))[channel] = modifier;
    });
    model = model[0];
    return function(val) {
      var result;
      if (arguments.length) {
        if (modifier) {
          val = modifier(val);
        }
        result = this[model]();
        result.color[channel] = val;
        return result;
      }
      result = this[model]().color[channel];
      if (modifier) {
        result = modifier(result);
      }
      return result;
    };
  };
  var maxfn = function(max5) {
    return function(v) {
      return Math.max(0, Math.min(max5, v));
    };
  };
  var assertArray = function(val) {
    return Array.isArray(val) ? val : [val];
  };
  var zeroArray = function(arr, length) {
    for (var i3 = 0;i3 < length; i3++) {
      if (typeof arr[i3] !== "number") {
        arr[i3] = 0;
      }
    }
    return arr;
  };
  var colorString = require_color_string();
  var convert = require_color_convert();
  var _slice = [].slice;
  var skippedModels = [
    "keyword",
    "gray",
    "hex"
  ];
  var hashedModelKeys = {};
  Object.keys(convert).forEach(function(model) {
    hashedModelKeys[_slice.call(convert[model].labels).sort().join("")] = model;
  });
  var limiters = {};
  Color.prototype = {
    toString: function() {
      return this.string();
    },
    toJSON: function() {
      return this[this.model]();
    },
    string: function(places) {
      var self2 = this.model in colorString.to ? this : this.rgb();
      self2 = self2.round(typeof places === "number" ? places : 1);
      var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
      return colorString.to[self2.model](args);
    },
    percentString: function(places) {
      var self2 = this.rgb().round(typeof places === "number" ? places : 1);
      var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
      return colorString.to.rgb.percent(args);
    },
    array: function() {
      return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
    },
    object: function() {
      var result = {};
      var channels = convert[this.model].channels;
      var labels = convert[this.model].labels;
      for (var i3 = 0;i3 < channels; i3++) {
        result[labels[i3]] = this.color[i3];
      }
      if (this.valpha !== 1) {
        result.alpha = this.valpha;
      }
      return result;
    },
    unitArray: function() {
      var rgb = this.rgb().color;
      rgb[0] /= 255;
      rgb[1] /= 255;
      rgb[2] /= 255;
      if (this.valpha !== 1) {
        rgb.push(this.valpha);
      }
      return rgb;
    },
    unitObject: function() {
      var rgb = this.rgb().object();
      rgb.r /= 255;
      rgb.g /= 255;
      rgb.b /= 255;
      if (this.valpha !== 1) {
        rgb.alpha = this.valpha;
      }
      return rgb;
    },
    round: function(places) {
      places = Math.max(places || 0, 0);
      return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
    },
    alpha: function(val) {
      if (arguments.length) {
        return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
      }
      return this.valpha;
    },
    red: getset("rgb", 0, maxfn(255)),
    green: getset("rgb", 1, maxfn(255)),
    blue: getset("rgb", 2, maxfn(255)),
    hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
      return (val % 360 + 360) % 360;
    }),
    saturationl: getset("hsl", 1, maxfn(100)),
    lightness: getset("hsl", 2, maxfn(100)),
    saturationv: getset("hsv", 1, maxfn(100)),
    value: getset("hsv", 2, maxfn(100)),
    chroma: getset("hcg", 1, maxfn(100)),
    gray: getset("hcg", 2, maxfn(100)),
    white: getset("hwb", 1, maxfn(100)),
    wblack: getset("hwb", 2, maxfn(100)),
    cyan: getset("cmyk", 0, maxfn(100)),
    magenta: getset("cmyk", 1, maxfn(100)),
    yellow: getset("cmyk", 2, maxfn(100)),
    black: getset("cmyk", 3, maxfn(100)),
    x: getset("xyz", 0, maxfn(100)),
    y: getset("xyz", 1, maxfn(100)),
    z: getset("xyz", 2, maxfn(100)),
    l: getset("lab", 0, maxfn(100)),
    a: getset("lab", 1),
    b: getset("lab", 2),
    keyword: function(val) {
      if (arguments.length) {
        return new Color(val);
      }
      return convert[this.model].keyword(this.color);
    },
    hex: function(val) {
      if (arguments.length) {
        return new Color(val);
      }
      return colorString.to.hex(this.rgb().round().color);
    },
    rgbNumber: function() {
      var rgb = this.rgb().color;
      return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
    },
    luminosity: function() {
      var rgb = this.rgb().color;
      var lum = [];
      for (var i3 = 0;i3 < rgb.length; i3++) {
        var chan = rgb[i3] / 255;
        lum[i3] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    },
    contrast: function(color2) {
      var lum1 = this.luminosity();
      var lum2 = color2.luminosity();
      if (lum1 > lum2) {
        return (lum1 + 0.05) / (lum2 + 0.05);
      }
      return (lum2 + 0.05) / (lum1 + 0.05);
    },
    level: function(color2) {
      var contrastRatio = this.contrast(color2);
      if (contrastRatio >= 7.1) {
        return "AAA";
      }
      return contrastRatio >= 4.5 ? "AA" : "";
    },
    isDark: function() {
      var rgb = this.rgb().color;
      var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
      return yiq < 128;
    },
    isLight: function() {
      return !this.isDark();
    },
    negate: function() {
      var rgb = this.rgb();
      for (var i3 = 0;i3 < 3; i3++) {
        rgb.color[i3] = 255 - rgb.color[i3];
      }
      return rgb;
    },
    lighten: function(ratio) {
      var hsl = this.hsl();
      hsl.color[2] += hsl.color[2] * ratio;
      return hsl;
    },
    darken: function(ratio) {
      var hsl = this.hsl();
      hsl.color[2] -= hsl.color[2] * ratio;
      return hsl;
    },
    saturate: function(ratio) {
      var hsl = this.hsl();
      hsl.color[1] += hsl.color[1] * ratio;
      return hsl;
    },
    desaturate: function(ratio) {
      var hsl = this.hsl();
      hsl.color[1] -= hsl.color[1] * ratio;
      return hsl;
    },
    whiten: function(ratio) {
      var hwb = this.hwb();
      hwb.color[1] += hwb.color[1] * ratio;
      return hwb;
    },
    blacken: function(ratio) {
      var hwb = this.hwb();
      hwb.color[2] += hwb.color[2] * ratio;
      return hwb;
    },
    grayscale: function() {
      var rgb = this.rgb().color;
      var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      return Color.rgb(val, val, val);
    },
    fade: function(ratio) {
      return this.alpha(this.valpha - this.valpha * ratio);
    },
    opaquer: function(ratio) {
      return this.alpha(this.valpha + this.valpha * ratio);
    },
    rotate: function(degrees) {
      var hsl = this.hsl();
      var hue = hsl.color[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      hsl.color[0] = hue;
      return hsl;
    },
    mix: function(mixinColor, weight) {
      if (!mixinColor || !mixinColor.rgb) {
        throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
      }
      var color1 = mixinColor.rgb();
      var color2 = this.rgb();
      var p = weight === undefined ? 0.5 : weight;
      var w = 2 * p - 1;
      var a = color1.alpha() - color2.alpha();
      var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      var w2 = 1 - w1;
      return Color.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));
    }
  };
  Object.keys(convert).forEach(function(model) {
    if (skippedModels.indexOf(model) !== -1) {
      return;
    }
    var channels = convert[model].channels;
    Color.prototype[model] = function() {
      if (this.model === model) {
        return new Color(this);
      }
      if (arguments.length) {
        return new Color(arguments, model);
      }
      var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
      return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
    };
    Color[model] = function(color) {
      if (typeof color === "number") {
        color = zeroArray(_slice.call(arguments), channels);
      }
      return new Color(color, model);
    };
  });
  module.exports = Color;
});

// ../../node_modules/text-hex/index.js
var require_text_hex = __commonJS((exports, module) => {
  module.exports = function hex(str) {
    for (var i3 = 0, hash = 0;i3 < str.length; hash = str.charCodeAt(i3++) + ((hash << 5) - hash))
      ;
    var color = Math.floor(Math.abs(Math.sin(hash) * 1e4 % 1 * 16777216)).toString(16);
    return "#" + Array(6 - color.length + 1).join("0") + color;
  };
});

// ../../node_modules/colorspace/index.js
var require_colorspace = __commonJS((exports, module) => {
  var color = require_color();
  var hex4 = require_text_hex();
  module.exports = function colorspace(namespace, delimiter) {
    var split = namespace.split(delimiter || ":");
    var base15 = hex4(split[0]);
    if (!split.length)
      return base15;
    for (var i3 = 0, l = split.length - 1;i3 < l; i3++) {
      base15 = color(base15).mix(color(hex4(split[i3 + 1]))).saturate(1).hex();
    }
    return base15;
  };
});

// ../../node_modules/kuler/index.js
var require_kuler = __commonJS((exports, module) => {
  var Kuler = function(text, color) {
    if (color)
      return new Kuler(text).style(color);
    if (!(this instanceof Kuler))
      return new Kuler(text);
    this.text = text;
  };
  Kuler.prototype.prefix = "\x1B[";
  Kuler.prototype.suffix = "m";
  Kuler.prototype.hex = function hex(color) {
    color = color[0] === "#" ? color.substring(1) : color;
    if (color.length === 3) {
      color = color.split("");
      color[5] = color[2];
      color[4] = color[2];
      color[3] = color[1];
      color[2] = color[1];
      color[1] = color[0];
      color = color.join("");
    }
    var r = color.substring(0, 2), g = color.substring(2, 4), b = color.substring(4, 6);
    return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
  };
  Kuler.prototype.rgb = function rgb(r, g, b) {
    var red = r / 255 * 5, green = g / 255 * 5, blue = b / 255 * 5;
    return this.ansi(red, green, blue);
  };
  Kuler.prototype.ansi = function ansi(r, g, b) {
    var red = Math.round(r), green = Math.round(g), blue = Math.round(b);
    return 16 + red * 36 + green * 6 + blue;
  };
  Kuler.prototype.reset = function reset() {
    return this.prefix + "39;49" + this.suffix;
  };
  Kuler.prototype.style = function style(color) {
    return this.prefix + "38;5;" + this.rgb.apply(this, this.hex(color)) + this.suffix + this.text + this.reset();
  };
  module.exports = Kuler;
});

// ../../node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js
var require_namespace_ansi = __commonJS((exports, module) => {
  var colorspace = require_colorspace();
  var kuler = require_kuler();
  module.exports = function ansiModifier(args, options) {
    var namespace = options.namespace;
    var ansi = options.colors !== false ? kuler(namespace + ":", colorspace(namespace)) : namespace + ":";
    args[0] = ansi + " " + args[0];
    return args;
  };
});

// ../../node_modules/enabled/index.js
var require_enabled = __commonJS((exports, module) => {
  module.exports = function enabled(name302, variable) {
    if (!variable)
      return false;
    var variables = variable.split(/[\s,]+/), i3 = 0;
    for (;i3 < variables.length; i3++) {
      variable = variables[i3].replace("*", ".*?");
      if (variable.charAt(0) === "-") {
        if (new RegExp("^" + variable.substr(1) + "$").test(name302)) {
          return false;
        }
        continue;
      }
      if (new RegExp("^" + variable + "$").test(name302)) {
        return true;
      }
    }
    return false;
  };
});

// ../../node_modules/@dabh/diagnostics/adapters/index.js
var require_adapters = __commonJS((exports, module) => {
  var enabled = require_enabled();
  module.exports = function create(fn) {
    return function adapter(namespace) {
      try {
        return enabled(namespace, fn());
      } catch (e4) {
      }
      return false;
    };
  };
});

// ../../node_modules/@dabh/diagnostics/adapters/process.env.js
var require_process_env = __commonJS((exports, module) => {
  var adapter2 = require_adapters();
  module.exports = adapter2(function processenv() {
    return process.env.DEBUG || process.env.DIAGNOSTICS;
  });
});

// ../../node_modules/@dabh/diagnostics/logger/console.js
var require_console2 = __commonJS((exports, module) => {
  module.exports = function(meta, messages) {
    try {
      Function.prototype.apply.call(console.log, console, messages);
    } catch (e4) {
    }
  };
});

// ../../node_modules/@dabh/diagnostics/node/development.js
var require_development = __commonJS((exports, module) => {
  var create2 = require_diagnostics();
  var tty = __require("tty").isatty(1);
  var diagnostics = create2(function dev(namespace, options) {
    options = options || {};
    options.colors = "colors" in options ? options.colors : tty;
    options.namespace = namespace;
    options.prod = false;
    options.dev = true;
    if (!dev.enabled(namespace) && !(options.force || dev.force)) {
      return dev.nope(options);
    }
    return dev.yep(options);
  });
  diagnostics.modify(require_namespace_ansi());
  diagnostics.use(require_process_env());
  diagnostics.set(require_console2());
  module.exports = diagnostics;
});

// ../../node_modules/@dabh/diagnostics/node/index.js
var require_node4 = __commonJS((exports, module) => {
  if (false) {
  } else {
    module.exports = require_development();
  }
});

// ../../node_modules/winston/lib/winston/tail-file.js
var require_tail_file = __commonJS((exports, module) => {
  var noop6 = function() {
  };
  var fs6 = __require("fs");
  var { StringDecoder } = __require("string_decoder");
  var { Stream } = require_readable();
  module.exports = (options, iter) => {
    const buffer = Buffer.alloc(64 * 1024);
    const decode = new StringDecoder("utf8");
    const stream3 = new Stream;
    let buff = "";
    let pos = 0;
    let row4 = 0;
    if (options.start === -1) {
      delete options.start;
    }
    stream3.readable = true;
    stream3.destroy = () => {
      stream3.destroyed = true;
      stream3.emit("end");
      stream3.emit("close");
    };
    fs6.open(options.file, "a+", "0644", (err, fd) => {
      if (err) {
        if (!iter) {
          stream3.emit("error", err);
        } else {
          iter(err);
        }
        stream3.destroy();
        return;
      }
      (function read() {
        if (stream3.destroyed) {
          fs6.close(fd, noop6);
          return;
        }
        return fs6.read(fd, buffer, 0, buffer.length, pos, (error, bytes) => {
          if (error) {
            if (!iter) {
              stream3.emit("error", error);
            } else {
              iter(error);
            }
            stream3.destroy();
            return;
          }
          if (!bytes) {
            if (buff) {
              if (options.start == null || row4 > options.start) {
                if (!iter) {
                  stream3.emit("line", buff);
                } else {
                  iter(null, buff);
                }
              }
              row4++;
              buff = "";
            }
            return setTimeout(read, 1000);
          }
          let data2 = decode.write(buffer.slice(0, bytes));
          if (!iter) {
            stream3.emit("data", data2);
          }
          data2 = (buff + data2).split(/\n+/);
          const l = data2.length - 1;
          let i3 = 0;
          for (;i3 < l; i3++) {
            if (options.start == null || row4 > options.start) {
              if (!iter) {
                stream3.emit("line", data2[i3]);
              } else {
                iter(null, data2[i3]);
              }
            }
            row4++;
          }
          buff = data2[l];
          pos += bytes;
          return read();
        });
      })();
    });
    if (!iter) {
      return stream3;
    }
    return stream3.destroy;
  };
});

// ../../node_modules/winston/lib/winston/transports/file.js
var require_file = __commonJS((exports, module) => {
  var fs6 = __require("fs");
  var path3 = __require("path");
  var asyncSeries = require_series();
  var zlib = __require("zlib");
  var { MESSAGE } = require_triple_beam();
  var { Stream, PassThrough } = require_readable();
  var TransportStream = require_winston_transport();
  var debug2 = require_node4()("winston:file");
  var os = __require("os");
  var tailFile = require_tail_file();
  module.exports = class File extends TransportStream {
    constructor(options = {}) {
      super(options);
      this.name = options.name || "file";
      function throwIf(target, ...args) {
        args.slice(1).forEach((name302) => {
          if (options[name302]) {
            throw new Error(`Cannot set ${name302} and ${target} together`);
          }
        });
      }
      this._stream = new PassThrough;
      this._stream.setMaxListeners(30);
      this._onError = this._onError.bind(this);
      if (options.filename || options.dirname) {
        throwIf("filename or dirname", "stream");
        this._basename = this.filename = options.filename ? path3.basename(options.filename) : "winston.log";
        this.dirname = options.dirname || path3.dirname(options.filename);
        this.options = options.options || { flags: "a" };
      } else if (options.stream) {
        console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream");
        throwIf("stream", "filename", "maxsize");
        this._dest = this._stream.pipe(this._setupStream(options.stream));
        this.dirname = path3.dirname(this._dest.path);
      } else {
        throw new Error("Cannot log to file without filename or stream.");
      }
      this.maxsize = options.maxsize || null;
      this.rotationFormat = options.rotationFormat || false;
      this.zippedArchive = options.zippedArchive || false;
      this.maxFiles = options.maxFiles || null;
      this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      this.tailable = options.tailable || false;
      this.lazy = options.lazy || false;
      this._size = 0;
      this._pendingSize = 0;
      this._created = 0;
      this._drain = false;
      this._opening = false;
      this._ending = false;
      this._fileExist = false;
      if (this.dirname)
        this._createLogDirIfNotExist(this.dirname);
      if (!this.lazy)
        this.open();
    }
    finishIfEnding() {
      if (this._ending) {
        if (this._opening) {
          this.once("open", () => {
            this._stream.once("finish", () => this.emit("finish"));
            setImmediate(() => this._stream.end());
          });
        } else {
          this._stream.once("finish", () => this.emit("finish"));
          setImmediate(() => this._stream.end());
        }
      }
    }
    log(info, callback = () => {
    }) {
      if (this.silent) {
        callback();
        return true;
      }
      if (this._drain) {
        this._stream.once("drain", () => {
          this._drain = false;
          this.log(info, callback);
        });
        return;
      }
      if (this._rotate) {
        this._stream.once("rotate", () => {
          this._rotate = false;
          this.log(info, callback);
        });
        return;
      }
      if (this.lazy) {
        if (!this._fileExist) {
          if (!this._opening) {
            this.open();
          }
          this.once("open", () => {
            this._fileExist = true;
            this.log(info, callback);
            return;
          });
          return;
        }
        if (this._needsNewFile(this._pendingSize)) {
          this._dest.once("close", () => {
            if (!this._opening) {
              this.open();
            }
            this.once("open", () => {
              this.log(info, callback);
              return;
            });
            return;
          });
          return;
        }
      }
      const output = `${info[MESSAGE]}${this.eol}`;
      const bytes = Buffer.byteLength(output);
      function logged() {
        this._size += bytes;
        this._pendingSize -= bytes;
        debug2("logged %s %s", this._size, output);
        this.emit("logged", info);
        if (this._rotate) {
          return;
        }
        if (this._opening) {
          return;
        }
        if (!this._needsNewFile()) {
          return;
        }
        if (this.lazy) {
          this._endStream(() => {
            this.emit("fileclosed");
          });
          return;
        }
        this._rotate = true;
        this._endStream(() => this._rotateFile());
      }
      this._pendingSize += bytes;
      if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {
        this.rotatedWhileOpening = true;
      }
      const written = this._stream.write(output, logged.bind(this));
      if (!written) {
        this._drain = true;
        this._stream.once("drain", () => {
          this._drain = false;
          callback();
        });
      } else {
        callback();
      }
      debug2("written", written, this._drain);
      this.finishIfEnding();
      return written;
    }
    query(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = normalizeQuery(options);
      const file = path3.join(this.dirname, this.filename);
      let buff = "";
      let results = [];
      let row4 = 0;
      const stream3 = fs6.createReadStream(file, {
        encoding: "utf8"
      });
      stream3.on("error", (err) => {
        if (stream3.readable) {
          stream3.destroy();
        }
        if (!callback) {
          return;
        }
        return err.code !== "ENOENT" ? callback(err) : callback(null, results);
      });
      stream3.on("data", (data2) => {
        data2 = (buff + data2).split(/\n+/);
        const l = data2.length - 1;
        let i3 = 0;
        for (;i3 < l; i3++) {
          if (!options.start || row4 >= options.start) {
            add5(data2[i3]);
          }
          row4++;
        }
        buff = data2[l];
      });
      stream3.on("close", () => {
        if (buff) {
          add5(buff, true);
        }
        if (options.order === "desc") {
          results = results.reverse();
        }
        if (callback)
          callback(null, results);
      });
      function add5(buff2, attempt) {
        try {
          const log4 = JSON.parse(buff2);
          if (check(log4)) {
            push2(log4);
          }
        } catch (e4) {
          if (!attempt) {
            stream3.emit("error", e4);
          }
        }
      }
      function push2(log4) {
        if (options.rows && results.length >= options.rows && options.order !== "desc") {
          if (stream3.readable) {
            stream3.destroy();
          }
          return;
        }
        if (options.fields) {
          log4 = options.fields.reduce((obj, key) => {
            obj[key] = log4[key];
            return obj;
          }, {});
        }
        if (options.order === "desc") {
          if (results.length >= options.rows) {
            results.shift();
          }
        }
        results.push(log4);
      }
      function check(log4) {
        if (!log4) {
          return;
        }
        if (typeof log4 !== "object") {
          return;
        }
        const time = new Date(log4.timestamp);
        if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log4.level) {
          return;
        }
        return true;
      }
      function normalizeQuery(options2) {
        options2 = options2 || {};
        options2.rows = options2.rows || options2.limit || 10;
        options2.start = options2.start || 0;
        options2.until = options2.until || new Date;
        if (typeof options2.until !== "object") {
          options2.until = new Date(options2.until);
        }
        options2.from = options2.from || options2.until - 24 * 60 * 60 * 1000;
        if (typeof options2.from !== "object") {
          options2.from = new Date(options2.from);
        }
        options2.order = options2.order || "desc";
        return options2;
      }
    }
    stream(options = {}) {
      const file = path3.join(this.dirname, this.filename);
      const stream3 = new Stream;
      const tail = {
        file,
        start: options.start
      };
      stream3.destroy = tailFile(tail, (err, line) => {
        if (err) {
          return stream3.emit("error", err);
        }
        try {
          stream3.emit("data", line);
          line = JSON.parse(line);
          stream3.emit("log", line);
        } catch (e4) {
          stream3.emit("error", e4);
        }
      });
      return stream3;
    }
    open() {
      if (!this.filename)
        return;
      if (this._opening)
        return;
      this._opening = true;
      this.stat((err, size3) => {
        if (err) {
          return this.emit("error", err);
        }
        debug2("stat done: %s { size: %s }", this.filename, size3);
        this._size = size3;
        this._dest = this._createStream(this._stream);
        this._opening = false;
        this.once("open", () => {
          if (this._stream.eventNames().includes("rotate")) {
            this._stream.emit("rotate");
          } else {
            this._rotate = false;
          }
        });
      });
    }
    stat(callback) {
      const target = this._getFile();
      const fullpath = path3.join(this.dirname, target);
      fs6.stat(fullpath, (err, stat) => {
        if (err && err.code === "ENOENT") {
          debug2("ENOENT\xA0ok", fullpath);
          this.filename = target;
          return callback(null, 0);
        }
        if (err) {
          debug2(`err ${err.code} ${fullpath}`);
          return callback(err);
        }
        if (!stat || this._needsNewFile(stat.size)) {
          return this._incFile(() => this.stat(callback));
        }
        this.filename = target;
        callback(null, stat.size);
      });
    }
    close(cb) {
      if (!this._stream) {
        return;
      }
      this._stream.end(() => {
        if (cb) {
          cb();
        }
        this.emit("flush");
        this.emit("closed");
      });
    }
    _needsNewFile(size3) {
      size3 = size3 || this._size;
      return this.maxsize && size3 >= this.maxsize;
    }
    _onError(err) {
      this.emit("error", err);
    }
    _setupStream(stream3) {
      stream3.on("error", this._onError);
      return stream3;
    }
    _cleanupStream(stream3) {
      stream3.removeListener("error", this._onError);
      stream3.destroy();
      return stream3;
    }
    _rotateFile() {
      this._incFile(() => this.open());
    }
    _endStream(callback = () => {
    }) {
      if (this._dest) {
        this._stream.unpipe(this._dest);
        this._dest.end(() => {
          this._cleanupStream(this._dest);
          callback();
        });
      } else {
        callback();
      }
    }
    _createStream(source) {
      const fullpath = path3.join(this.dirname, this.filename);
      debug2("create stream start", fullpath, this.options);
      const dest = fs6.createWriteStream(fullpath, this.options).on("error", (err) => debug2(err)).on("close", () => debug2("close", dest.path, dest.bytesWritten)).on("open", () => {
        debug2("file open ok", fullpath);
        this.emit("open", fullpath);
        source.pipe(dest);
        if (this.rotatedWhileOpening) {
          this._stream = new PassThrough;
          this._stream.setMaxListeners(30);
          this._rotateFile();
          this.rotatedWhileOpening = false;
          this._cleanupStream(dest);
          source.end();
        }
      });
      debug2("create stream ok", fullpath);
      if (this.zippedArchive) {
        const gzip = zlib.createGzip();
        gzip.pipe(dest);
        return gzip;
      }
      return dest;
    }
    _incFile(callback) {
      debug2("_incFile", this.filename);
      const ext = path3.extname(this._basename);
      const basename2 = path3.basename(this._basename, ext);
      if (!this.tailable) {
        this._created += 1;
        this._checkMaxFilesIncrementing(ext, basename2, callback);
      } else {
        this._checkMaxFilesTailable(ext, basename2, callback);
      }
    }
    _getFile() {
      const ext = path3.extname(this._basename);
      const basename2 = path3.basename(this._basename, ext);
      const isRotation = this.rotationFormat ? this.rotationFormat() : this._created;
      const target = !this.tailable && this._created ? `${basename2}${isRotation}${ext}` : `${basename2}${ext}`;
      return this.zippedArchive && !this.tailable ? `${target}.gz` : target;
    }
    _checkMaxFilesIncrementing(ext, basename2, callback) {
      if (!this.maxFiles || this._created < this.maxFiles) {
        return setImmediate(callback);
      }
      const oldest = this._created - this.maxFiles;
      const isOldest = oldest !== 0 ? oldest : "";
      const isZipped = this.zippedArchive ? ".gz" : "";
      const filePath = `${basename2}${isOldest}${ext}${isZipped}`;
      const target = path3.join(this.dirname, filePath);
      fs6.unlink(target, callback);
    }
    _checkMaxFilesTailable(ext, basename2, callback) {
      const tasks = [];
      if (!this.maxFiles) {
        return;
      }
      const isZipped = this.zippedArchive ? ".gz" : "";
      for (let x = this.maxFiles - 1;x > 1; x--) {
        tasks.push(function(i3, cb) {
          let fileName = `${basename2}${i3 - 1}${ext}${isZipped}`;
          const tmppath = path3.join(this.dirname, fileName);
          fs6.exists(tmppath, (exists) => {
            if (!exists) {
              return cb(null);
            }
            fileName = `${basename2}${i3}${ext}${isZipped}`;
            fs6.rename(tmppath, path3.join(this.dirname, fileName), cb);
          });
        }.bind(this, x));
      }
      asyncSeries(tasks, () => {
        fs6.rename(path3.join(this.dirname, `${basename2}${ext}`), path3.join(this.dirname, `${basename2}1${ext}${isZipped}`), callback);
      });
    }
    _createLogDirIfNotExist(dirPath) {
      if (!fs6.existsSync(dirPath)) {
        fs6.mkdirSync(dirPath, { recursive: true });
      }
    }
  };
});

// ../../node_modules/winston/lib/winston/transports/http.js
var require_http = __commonJS((exports, module) => {
  var http = __require("http");
  var https = __require("https");
  var { Stream } = require_readable();
  var TransportStream = require_winston_transport();
  var jsonStringify = require_safe_stable_stringify();
  module.exports = class Http extends TransportStream {
    constructor(options = {}) {
      super(options);
      this.options = options;
      this.name = options.name || "http";
      this.ssl = !!options.ssl;
      this.host = options.host || "localhost";
      this.port = options.port;
      this.auth = options.auth;
      this.path = options.path || "";
      this.agent = options.agent;
      this.headers = options.headers || {};
      this.headers["content-type"] = "application/json";
      this.batch = options.batch || false;
      this.batchInterval = options.batchInterval || 5000;
      this.batchCount = options.batchCount || 10;
      this.batchOptions = [];
      this.batchTimeoutID = -1;
      this.batchCallback = {};
      if (!this.port) {
        this.port = this.ssl ? 443 : 80;
      }
    }
    log(info, callback) {
      this._request(info, null, null, (err, res) => {
        if (res && res.statusCode !== 200) {
          err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
        }
        if (err) {
          this.emit("warn", err);
        } else {
          this.emit("logged", info);
        }
      });
      if (callback) {
        setImmediate(callback);
      }
    }
    query(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = {
        method: "query",
        params: this.normalizeQuery(options)
      };
      const auth = options.params.auth || null;
      delete options.params.auth;
      const path3 = options.params.path || null;
      delete options.params.path;
      this._request(options, auth, path3, (err, res, body) => {
        if (res && res.statusCode !== 200) {
          err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
        }
        if (err) {
          return callback(err);
        }
        if (typeof body === "string") {
          try {
            body = JSON.parse(body);
          } catch (e4) {
            return callback(e4);
          }
        }
        callback(null, body);
      });
    }
    stream(options = {}) {
      const stream3 = new Stream;
      options = {
        method: "stream",
        params: options
      };
      const path3 = options.params.path || null;
      delete options.params.path;
      const auth = options.params.auth || null;
      delete options.params.auth;
      let buff = "";
      const req = this._request(options, auth, path3);
      stream3.destroy = () => req.destroy();
      req.on("data", (data2) => {
        data2 = (buff + data2).split(/\n+/);
        const l = data2.length - 1;
        let i3 = 0;
        for (;i3 < l; i3++) {
          try {
            stream3.emit("log", JSON.parse(data2[i3]));
          } catch (e4) {
            stream3.emit("error", e4);
          }
        }
        buff = data2[l];
      });
      req.on("error", (err) => stream3.emit("error", err));
      return stream3;
    }
    _request(options, auth, path3, callback) {
      options = options || {};
      auth = auth || this.auth;
      path3 = path3 || this.path || "";
      if (this.batch) {
        this._doBatch(options, callback, auth, path3);
      } else {
        this._doRequest(options, callback, auth, path3);
      }
    }
    _doBatch(options, callback, auth, path3) {
      this.batchOptions.push(options);
      if (this.batchOptions.length === 1) {
        const me = this;
        this.batchCallback = callback;
        this.batchTimeoutID = setTimeout(function() {
          me.batchTimeoutID = -1;
          me._doBatchRequest(me.batchCallback, auth, path3);
        }, this.batchInterval);
      }
      if (this.batchOptions.length === this.batchCount) {
        this._doBatchRequest(this.batchCallback, auth, path3);
      }
    }
    _doBatchRequest(callback, auth, path3) {
      if (this.batchTimeoutID > 0) {
        clearTimeout(this.batchTimeoutID);
        this.batchTimeoutID = -1;
      }
      const batchOptionsCopy = this.batchOptions.slice();
      this.batchOptions = [];
      this._doRequest(batchOptionsCopy, callback, auth, path3);
    }
    _doRequest(options, callback, auth, path3) {
      const headers = Object.assign({}, this.headers);
      if (auth && auth.bearer) {
        headers.Authorization = `Bearer ${auth.bearer}`;
      }
      const req = (this.ssl ? https : http).request({
        ...this.options,
        method: "POST",
        host: this.host,
        port: this.port,
        path: `/${path3.replace(/^\//, "")}`,
        headers,
        auth: auth && auth.username && auth.password ? `${auth.username}:${auth.password}` : "",
        agent: this.agent
      });
      req.on("error", callback);
      req.on("response", (res) => res.on("end", () => callback(null, res)).resume());
      req.end(Buffer.from(jsonStringify(options, this.options.replacer), "utf8"));
    }
  };
});

// ../../node_modules/is-stream/index.js
var require_is_stream = __commonJS((exports, module) => {
  var isStream = (stream3) => stream3 !== null && typeof stream3 === "object" && typeof stream3.pipe === "function";
  isStream.writable = (stream3) => isStream(stream3) && stream3.writable !== false && typeof stream3._write === "function" && typeof stream3._writableState === "object";
  isStream.readable = (stream3) => isStream(stream3) && stream3.readable !== false && typeof stream3._read === "function" && typeof stream3._readableState === "object";
  isStream.duplex = (stream3) => isStream.writable(stream3) && isStream.readable(stream3);
  isStream.transform = (stream3) => isStream.duplex(stream3) && typeof stream3._transform === "function";
  module.exports = isStream;
});

// ../../node_modules/winston/lib/winston/transports/stream.js
var require_stream6 = __commonJS((exports, module) => {
  var isStream = require_is_stream();
  var { MESSAGE } = require_triple_beam();
  var os = __require("os");
  var TransportStream = require_winston_transport();
  module.exports = class Stream extends TransportStream {
    constructor(options = {}) {
      super(options);
      if (!options.stream || !isStream(options.stream)) {
        throw new Error("options.stream is required.");
      }
      this._stream = options.stream;
      this._stream.setMaxListeners(Infinity);
      this.isObjectMode = options.stream._writableState.objectMode;
      this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
    }
    log(info, callback) {
      setImmediate(() => this.emit("logged", info));
      if (this.isObjectMode) {
        this._stream.write(info);
        if (callback) {
          callback();
        }
        return;
      }
      this._stream.write(`${info[MESSAGE]}${this.eol}`);
      if (callback) {
        callback();
      }
      return;
    }
  };
});

// ../../node_modules/winston/lib/winston/transports/index.js
var require_transports = __commonJS((exports) => {
  Object.defineProperty(exports, "Console", {
    configurable: true,
    enumerable: true,
    get() {
      return require_console();
    }
  });
  Object.defineProperty(exports, "File", {
    configurable: true,
    enumerable: true,
    get() {
      return require_file();
    }
  });
  Object.defineProperty(exports, "Http", {
    configurable: true,
    enumerable: true,
    get() {
      return require_http();
    }
  });
  Object.defineProperty(exports, "Stream", {
    configurable: true,
    enumerable: true,
    get() {
      return require_stream6();
    }
  });
});

// ../../node_modules/winston/lib/winston/config/index.js
var require_config2 = __commonJS((exports) => {
  var logform = require_logform();
  var { configs } = require_triple_beam();
  exports.cli = logform.levels(configs.cli);
  exports.npm = logform.levels(configs.npm);
  exports.syslog = logform.levels(configs.syslog);
  exports.addColors = logform.levels;
});

// ../../node_modules/async/eachOf.js
var require_eachOf = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachOfArrayLike = function(coll, iteratee, callback) {
    callback = (0, _once2.default)(callback);
    var index2 = 0, completed = 0, { length } = coll, canceled = false;
    if (length === 0) {
      callback(null);
    }
    function iteratorCallback(err, value) {
      if (err === false) {
        canceled = true;
      }
      if (canceled === true)
        return;
      if (err) {
        callback(err);
      } else if (++completed === length || value === _breakLoop2.default) {
        callback(null);
      }
    }
    for (;index2 < length; index2++) {
      iteratee(coll[index2], index2, (0, _onlyOnce2.default)(iteratorCallback));
    }
  };
  var eachOfGeneric = function(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
  };
  var eachOf = function(coll, iteratee, callback) {
    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
    return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  var _eachOfLimit = require_eachOfLimit2();
  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
  var _once = require_once();
  var _once2 = _interopRequireDefault(_once);
  var _onlyOnce = require_onlyOnce();
  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(eachOf, 3);
  module.exports = exports.default;
});

// ../../node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS((exports, module) => {
  var _withoutIndex = function(iteratee) {
    return (value, index2, callback) => iteratee(value, callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _withoutIndex;
  module.exports = exports.default;
});

// ../../node_modules/async/forEach.js
var require_forEach = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachLimit = function(coll, iteratee, callback) {
    return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOf = require_eachOf();
  var _eachOf2 = _interopRequireDefault(_eachOf);
  var _withoutIndex = require_withoutIndex();
  var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(eachLimit, 3);
  module.exports = exports.default;
});

// ../../node_modules/fn.name/index.js
var require_fn = __commonJS((exports, module) => {
  var toString = Object.prototype.toString;
  module.exports = function name(fn) {
    if (typeof fn.displayName === "string" && fn.constructor.name) {
      return fn.displayName;
    } else if (typeof fn.name === "string" && fn.name) {
      return fn.name;
    }
    if (typeof fn === "object" && fn.constructor && typeof fn.constructor.name === "string")
      return fn.constructor.name;
    var named = fn.toString(), type = toString.call(fn).slice(8, -1);
    if (type === "Function") {
      named = named.substring(named.indexOf("(") + 1, named.indexOf(")"));
    } else {
      named = type;
    }
    return named || "anonymous";
  };
});

// ../../node_modules/one-time/index.js
var require_one_time = __commonJS((exports, module) => {
  var name302 = require_fn();
  module.exports = function one(fn) {
    var called = 0, value;
    function onetime() {
      if (called)
        return value;
      called = 1;
      value = fn.apply(this, arguments);
      fn = null;
      return value;
    }
    onetime.displayName = name302(fn);
    return onetime;
  };
});

// ../../node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS((exports) => {
  var CallSite = function(properties2) {
    for (var property in properties2) {
      this[property] = properties2[property];
    }
  };
  exports.get = function(belowFn) {
    var oldLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = Infinity;
    var dummyObject = {};
    var v8Handler = Error.prepareStackTrace;
    Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
      return v8StackTrace2;
    };
    Error.captureStackTrace(dummyObject, belowFn || exports.get);
    var v8StackTrace = dummyObject.stack;
    Error.prepareStackTrace = v8Handler;
    Error.stackTraceLimit = oldLimit;
    return v8StackTrace;
  };
  exports.parse = function(err) {
    if (!err.stack) {
      return [];
    }
    var self2 = this;
    var lines = err.stack.split("\n").slice(1);
    return lines.map(function(line) {
      if (line.match(/^\s*[-]{4,}$/)) {
        return self2._createParsedCallSite({
          fileName: line,
          lineNumber: null,
          functionName: null,
          typeName: null,
          methodName: null,
          columnNumber: null,
          native: null
        });
      }
      var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
      if (!lineMatch) {
        return;
      }
      var object36 = null;
      var method = null;
      var functionName = null;
      var typeName = null;
      var methodName = null;
      var isNative = lineMatch[5] === "native";
      if (lineMatch[1]) {
        functionName = lineMatch[1];
        var methodStart = functionName.lastIndexOf(".");
        if (functionName[methodStart - 1] == ".")
          methodStart--;
        if (methodStart > 0) {
          object36 = functionName.substr(0, methodStart);
          method = functionName.substr(methodStart + 1);
          var objectEnd = object36.indexOf(".Module");
          if (objectEnd > 0) {
            functionName = functionName.substr(objectEnd + 1);
            object36 = object36.substr(0, objectEnd);
          }
        }
        typeName = null;
      }
      if (method) {
        typeName = object36;
        methodName = method;
      }
      if (method === "<anonymous>") {
        methodName = null;
        functionName = null;
      }
      var properties2 = {
        fileName: lineMatch[2] || null,
        lineNumber: parseInt(lineMatch[3], 10) || null,
        functionName,
        typeName,
        methodName,
        columnNumber: parseInt(lineMatch[4], 10) || null,
        native: isNative
      };
      return self2._createParsedCallSite(properties2);
    }).filter(function(callSite) {
      return !!callSite;
    });
  };
  var strProperties = [
    "this",
    "typeName",
    "functionName",
    "methodName",
    "fileName",
    "lineNumber",
    "columnNumber",
    "function",
    "evalOrigin"
  ];
  var boolProperties = [
    "topLevel",
    "eval",
    "native",
    "constructor"
  ];
  strProperties.forEach(function(property) {
    CallSite.prototype[property] = null;
    CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
      return this[property];
    };
  });
  boolProperties.forEach(function(property) {
    CallSite.prototype[property] = false;
    CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
      return this[property];
    };
  });
  exports._createParsedCallSite = function(properties2) {
    return new CallSite(properties2);
  };
});

// ../../node_modules/winston/lib/winston/exception-stream.js
var require_exception_stream = __commonJS((exports, module) => {
  var { Writable } = require_readable();
  module.exports = class ExceptionStream extends Writable {
    constructor(transport) {
      super({ objectMode: true });
      if (!transport) {
        throw new Error("ExceptionStream requires a TransportStream instance.");
      }
      this.handleExceptions = true;
      this.transport = transport;
    }
    _write(info, enc, callback) {
      if (info.exception) {
        return this.transport.log(info, callback);
      }
      callback();
      return true;
    }
  };
});

// ../../node_modules/winston/lib/winston/exception-handler.js
var require_exception_handler = __commonJS((exports, module) => {
  var os = __require("os");
  var asyncForEach = require_forEach();
  var debug2 = require_node4()("winston:exception");
  var once = require_one_time();
  var stackTrace = require_stack_trace();
  var ExceptionStream = require_exception_stream();
  module.exports = class ExceptionHandler {
    constructor(logger3) {
      if (!logger3) {
        throw new Error("Logger is required to handle exceptions");
      }
      this.logger = logger3;
      this.handlers = new Map;
    }
    handle(...args) {
      args.forEach((arg3) => {
        if (Array.isArray(arg3)) {
          return arg3.forEach((handler) => this._addHandler(handler));
        }
        this._addHandler(arg3);
      });
      if (!this.catcher) {
        this.catcher = this._uncaughtException.bind(this);
        process.on("uncaughtException", this.catcher);
      }
    }
    unhandle() {
      if (this.catcher) {
        process.removeListener("uncaughtException", this.catcher);
        this.catcher = false;
        Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
      }
    }
    getAllInfo(err) {
      let message = null;
      if (err) {
        message = typeof err === "string" ? err : err.message;
      }
      return {
        error: err,
        level: "error",
        message: [
          `uncaughtException: ${message || "(no error message)"}`,
          err && err.stack || "  No stack trace"
        ].join("\n"),
        stack: err && err.stack,
        exception: true,
        date: new Date().toString(),
        process: this.getProcessInfo(),
        os: this.getOsInfo(),
        trace: this.getTrace(err)
      };
    }
    getProcessInfo() {
      return {
        pid: process.pid,
        uid: process.getuid ? process.getuid() : null,
        gid: process.getgid ? process.getgid() : null,
        cwd: process.cwd(),
        execPath: process.execPath,
        version: process.version,
        argv: process.argv,
        memoryUsage: process.memoryUsage()
      };
    }
    getOsInfo() {
      return {
        loadavg: os.loadavg(),
        uptime: os.uptime()
      };
    }
    getTrace(err) {
      const trace3 = err ? stackTrace.parse(err) : stackTrace.get();
      return trace3.map((site) => {
        return {
          column: site.getColumnNumber(),
          file: site.getFileName(),
          function: site.getFunctionName(),
          line: site.getLineNumber(),
          method: site.getMethodName(),
          native: site.isNative()
        };
      });
    }
    _addHandler(handler) {
      if (!this.handlers.has(handler)) {
        handler.handleExceptions = true;
        const wrapper = new ExceptionStream(handler);
        this.handlers.set(handler, wrapper);
        this.logger.pipe(wrapper);
      }
    }
    _uncaughtException(err) {
      const info = this.getAllInfo(err);
      const handlers = this._getExceptionHandlers();
      let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
      let timeout;
      if (!handlers.length && doExit) {
        console.warn("winston: exitOnError cannot be true with no exception handlers.");
        console.warn("winston: not exiting process.");
        doExit = false;
      }
      function gracefulExit() {
        debug2("doExit", doExit);
        debug2("process._exiting", process._exiting);
        if (doExit && !process._exiting) {
          if (timeout) {
            clearTimeout(timeout);
          }
          process.exit(1);
        }
      }
      if (!handlers || handlers.length === 0) {
        return process.nextTick(gracefulExit);
      }
      asyncForEach(handlers, (handler, next) => {
        const done = once(next);
        const transport = handler.transport || handler;
        function onDone(event) {
          return () => {
            debug2(event);
            done();
          };
        }
        transport._ending = true;
        transport.once("finish", onDone("finished"));
        transport.once("error", onDone("error"));
      }, () => doExit && gracefulExit());
      this.logger.log(info);
      if (doExit) {
        timeout = setTimeout(gracefulExit, 3000);
      }
    }
    _getExceptionHandlers() {
      return this.logger.transports.filter((wrap) => {
        const transport = wrap.transport || wrap;
        return transport.handleExceptions;
      });
    }
  };
});

// ../../node_modules/winston/lib/winston/rejection-handler.js
var require_rejection_handler = __commonJS((exports, module) => {
  var os = __require("os");
  var asyncForEach = require_forEach();
  var debug2 = require_node4()("winston:rejection");
  var once = require_one_time();
  var stackTrace = require_stack_trace();
  var ExceptionStream = require_exception_stream();
  module.exports = class RejectionHandler {
    constructor(logger3) {
      if (!logger3) {
        throw new Error("Logger is required to handle rejections");
      }
      this.logger = logger3;
      this.handlers = new Map;
    }
    handle(...args) {
      args.forEach((arg3) => {
        if (Array.isArray(arg3)) {
          return arg3.forEach((handler) => this._addHandler(handler));
        }
        this._addHandler(arg3);
      });
      if (!this.catcher) {
        this.catcher = this._unhandledRejection.bind(this);
        process.on("unhandledRejection", this.catcher);
      }
    }
    unhandle() {
      if (this.catcher) {
        process.removeListener("unhandledRejection", this.catcher);
        this.catcher = false;
        Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
      }
    }
    getAllInfo(err) {
      let message = null;
      if (err) {
        message = typeof err === "string" ? err : err.message;
      }
      return {
        error: err,
        level: "error",
        message: [
          `unhandledRejection: ${message || "(no error message)"}`,
          err && err.stack || "  No stack trace"
        ].join("\n"),
        stack: err && err.stack,
        exception: true,
        date: new Date().toString(),
        process: this.getProcessInfo(),
        os: this.getOsInfo(),
        trace: this.getTrace(err)
      };
    }
    getProcessInfo() {
      return {
        pid: process.pid,
        uid: process.getuid ? process.getuid() : null,
        gid: process.getgid ? process.getgid() : null,
        cwd: process.cwd(),
        execPath: process.execPath,
        version: process.version,
        argv: process.argv,
        memoryUsage: process.memoryUsage()
      };
    }
    getOsInfo() {
      return {
        loadavg: os.loadavg(),
        uptime: os.uptime()
      };
    }
    getTrace(err) {
      const trace3 = err ? stackTrace.parse(err) : stackTrace.get();
      return trace3.map((site) => {
        return {
          column: site.getColumnNumber(),
          file: site.getFileName(),
          function: site.getFunctionName(),
          line: site.getLineNumber(),
          method: site.getMethodName(),
          native: site.isNative()
        };
      });
    }
    _addHandler(handler) {
      if (!this.handlers.has(handler)) {
        handler.handleRejections = true;
        const wrapper = new ExceptionStream(handler);
        this.handlers.set(handler, wrapper);
        this.logger.pipe(wrapper);
      }
    }
    _unhandledRejection(err) {
      const info = this.getAllInfo(err);
      const handlers = this._getRejectionHandlers();
      let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
      let timeout;
      if (!handlers.length && doExit) {
        console.warn("winston: exitOnError cannot be true with no rejection handlers.");
        console.warn("winston: not exiting process.");
        doExit = false;
      }
      function gracefulExit() {
        debug2("doExit", doExit);
        debug2("process._exiting", process._exiting);
        if (doExit && !process._exiting) {
          if (timeout) {
            clearTimeout(timeout);
          }
          process.exit(1);
        }
      }
      if (!handlers || handlers.length === 0) {
        return process.nextTick(gracefulExit);
      }
      asyncForEach(handlers, (handler, next) => {
        const done = once(next);
        const transport = handler.transport || handler;
        function onDone(event) {
          return () => {
            debug2(event);
            done();
          };
        }
        transport._ending = true;
        transport.once("finish", onDone("finished"));
        transport.once("error", onDone("error"));
      }, () => doExit && gracefulExit());
      this.logger.log(info);
      if (doExit) {
        timeout = setTimeout(gracefulExit, 3000);
      }
    }
    _getRejectionHandlers() {
      return this.logger.transports.filter((wrap) => {
        const transport = wrap.transport || wrap;
        return transport.handleRejections;
      });
    }
  };
});

// ../../node_modules/winston/lib/winston/profiler.js
var require_profiler = __commonJS((exports, module) => {
  class Profiler {
    constructor(logger3) {
      const Logger3 = require_logger();
      if (typeof logger3 !== "object" || Array.isArray(logger3) || !(logger3 instanceof Logger3)) {
        throw new Error("Logger is required for profiling");
      } else {
        this.logger = logger3;
        this.start = Date.now();
      }
    }
    done(...args) {
      if (typeof args[args.length - 1] === "function") {
        console.warn("Callback function no longer supported as of winston@3.0.0");
        args.pop();
      }
      const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
      info.level = info.level || "info";
      info.durationMs = Date.now() - this.start;
      return this.logger.write(info);
    }
  }
  module.exports = Profiler;
});

// ../../node_modules/winston/lib/winston/logger.js
var require_logger = __commonJS((exports, module) => {
  var getLevelValue = function(levels, level) {
    const value = levels[level];
    if (!value && value !== 0) {
      return null;
    }
    return value;
  };
  var { Stream, Transform } = require_readable();
  var asyncForEach = require_forEach();
  var { LEVEL, SPLAT } = require_triple_beam();
  var isStream = require_is_stream();
  var ExceptionHandler = require_exception_handler();
  var RejectionHandler = require_rejection_handler();
  var LegacyTransportStream = require_legacy();
  var Profiler = require_profiler();
  var { warn } = require_common3();
  var config8 = require_config2();
  var formatRegExp = /%[scdjifoO%]/g;

  class Logger3 extends Transform {
    constructor(options) {
      super({ objectMode: true });
      this.configure(options);
    }
    child(defaultRequestMetadata) {
      const logger3 = this;
      return Object.create(logger3, {
        write: {
          value: function(info) {
            const infoClone = Object.assign({}, defaultRequestMetadata, info);
            if (info instanceof Error) {
              infoClone.stack = info.stack;
              infoClone.message = info.message;
            }
            logger3.write(infoClone);
          }
        }
      });
    }
    configure({
      silent,
      format: format6,
      defaultMeta,
      levels,
      level = "info",
      exitOnError = true,
      transports,
      colors,
      emitErrs,
      formatters,
      padLevels,
      rewriters,
      stripColors,
      exceptionHandlers,
      rejectionHandlers
    } = {}) {
      if (this.transports.length) {
        this.clear();
      }
      this.silent = silent;
      this.format = format6 || this.format || require_json()();
      this.defaultMeta = defaultMeta || null;
      this.levels = levels || this.levels || config8.npm.levels;
      this.level = level;
      if (this.exceptions) {
        this.exceptions.unhandle();
      }
      if (this.rejections) {
        this.rejections.unhandle();
      }
      this.exceptions = new ExceptionHandler(this);
      this.rejections = new RejectionHandler(this);
      this.profilers = {};
      this.exitOnError = exitOnError;
      if (transports) {
        transports = Array.isArray(transports) ? transports : [transports];
        transports.forEach((transport) => this.add(transport));
      }
      if (colors || emitErrs || formatters || padLevels || rewriters || stripColors) {
        throw new Error([
          "{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.",
          "Use a custom winston.format(function) instead.",
          "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
        ].join("\n"));
      }
      if (exceptionHandlers) {
        this.exceptions.handle(exceptionHandlers);
      }
      if (rejectionHandlers) {
        this.rejections.handle(rejectionHandlers);
      }
    }
    isLevelEnabled(level) {
      const givenLevelValue = getLevelValue(this.levels, level);
      if (givenLevelValue === null) {
        return false;
      }
      const configuredLevelValue = getLevelValue(this.levels, this.level);
      if (configuredLevelValue === null) {
        return false;
      }
      if (!this.transports || this.transports.length === 0) {
        return configuredLevelValue >= givenLevelValue;
      }
      const index2 = this.transports.findIndex((transport) => {
        let transportLevelValue = getLevelValue(this.levels, transport.level);
        if (transportLevelValue === null) {
          transportLevelValue = configuredLevelValue;
        }
        return transportLevelValue >= givenLevelValue;
      });
      return index2 !== -1;
    }
    log(level, msg, ...splat) {
      if (arguments.length === 1) {
        level[LEVEL] = level.level;
        this._addDefaultMeta(level);
        this.write(level);
        return this;
      }
      if (arguments.length === 2) {
        if (msg && typeof msg === "object") {
          msg[LEVEL] = msg.level = level;
          this._addDefaultMeta(msg);
          this.write(msg);
          return this;
        }
        msg = { [LEVEL]: level, level, message: msg };
        this._addDefaultMeta(msg);
        this.write(msg);
        return this;
      }
      const [meta] = splat;
      if (typeof meta === "object" && meta !== null) {
        const tokens = msg && msg.match && msg.match(formatRegExp);
        if (!tokens) {
          const info = Object.assign({}, this.defaultMeta, meta, {
            [LEVEL]: level,
            [SPLAT]: splat,
            level,
            message: msg
          });
          if (meta.message)
            info.message = `${info.message} ${meta.message}`;
          if (meta.stack)
            info.stack = meta.stack;
          this.write(info);
          return this;
        }
      }
      this.write(Object.assign({}, this.defaultMeta, {
        [LEVEL]: level,
        [SPLAT]: splat,
        level,
        message: msg
      }));
      return this;
    }
    _transform(info, enc, callback) {
      if (this.silent) {
        return callback();
      }
      if (!info[LEVEL]) {
        info[LEVEL] = info.level;
      }
      if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
        console.error("[winston] Unknown logger level: %s", info[LEVEL]);
      }
      if (!this._readableState.pipes) {
        console.error("[winston] Attempt to write logs with no transports, which can increase memory usage: %j", info);
      }
      try {
        this.push(this.format.transform(info, this.format.options));
      } finally {
        this._writableState.sync = false;
        callback();
      }
    }
    _final(callback) {
      const transports = this.transports.slice();
      asyncForEach(transports, (transport, next) => {
        if (!transport || transport.finished)
          return setImmediate(next);
        transport.once("finish", next);
        transport.end();
      }, callback);
    }
    add(transport) {
      const target = !isStream(transport) || transport.log.length > 2 ? new LegacyTransportStream({ transport }) : transport;
      if (!target._writableState || !target._writableState.objectMode) {
        throw new Error("Transports must WritableStreams in objectMode. Set { objectMode: true }.");
      }
      this._onEvent("error", target);
      this._onEvent("warn", target);
      this.pipe(target);
      if (transport.handleExceptions) {
        this.exceptions.handle();
      }
      if (transport.handleRejections) {
        this.rejections.handle();
      }
      return this;
    }
    remove(transport) {
      if (!transport)
        return this;
      let target = transport;
      if (!isStream(transport) || transport.log.length > 2) {
        target = this.transports.filter((match) => match.transport === transport)[0];
      }
      if (target) {
        this.unpipe(target);
      }
      return this;
    }
    clear() {
      this.unpipe();
      return this;
    }
    close() {
      this.exceptions.unhandle();
      this.rejections.unhandle();
      this.clear();
      this.emit("close");
      return this;
    }
    setLevels() {
      warn.deprecated("setLevels");
    }
    query(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      const results = {};
      const queryObject = Object.assign({}, options.query || {});
      function queryTransport(transport, next) {
        if (options.query && typeof transport.formatQuery === "function") {
          options.query = transport.formatQuery(queryObject);
        }
        transport.query(options, (err, res) => {
          if (err) {
            return next(err);
          }
          if (typeof transport.formatResults === "function") {
            res = transport.formatResults(res, options.format);
          }
          next(null, res);
        });
      }
      function addResults(transport, next) {
        queryTransport(transport, (err, result) => {
          if (next) {
            result = err || result;
            if (result) {
              results[transport.name] = result;
            }
            next();
          }
          next = null;
        });
      }
      asyncForEach(this.transports.filter((transport) => !!transport.query), addResults, () => callback(null, results));
    }
    stream(options = {}) {
      const out = new Stream;
      const streams = [];
      out._streams = streams;
      out.destroy = () => {
        let i3 = streams.length;
        while (i3--) {
          streams[i3].destroy();
        }
      };
      this.transports.filter((transport) => !!transport.stream).forEach((transport) => {
        const str = transport.stream(options);
        if (!str) {
          return;
        }
        streams.push(str);
        str.on("log", (log4) => {
          log4.transport = log4.transport || [];
          log4.transport.push(transport.name);
          out.emit("log", log4);
        });
        str.on("error", (err) => {
          err.transport = err.transport || [];
          err.transport.push(transport.name);
          out.emit("error", err);
        });
      });
      return out;
    }
    startTimer() {
      return new Profiler(this);
    }
    profile(id, ...args) {
      const time = Date.now();
      if (this.profilers[id]) {
        const timeEnd = this.profilers[id];
        delete this.profilers[id];
        if (typeof args[args.length - 2] === "function") {
          console.warn("Callback function no longer supported as of winston@3.0.0");
          args.pop();
        }
        const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
        info.level = info.level || "info";
        info.durationMs = time - timeEnd;
        info.message = info.message || id;
        return this.write(info);
      }
      this.profilers[id] = time;
      return this;
    }
    handleExceptions(...args) {
      console.warn("Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()");
      this.exceptions.handle(...args);
    }
    unhandleExceptions(...args) {
      console.warn("Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()");
      this.exceptions.unhandle(...args);
    }
    cli() {
      throw new Error([
        "Logger.cli() was removed in winston@3.0.0",
        "Use a custom winston.formats.cli() instead.",
        "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
      ].join("\n"));
    }
    _onEvent(event, transport) {
      function transportEvent(err) {
        if (event === "error" && !this.transports.includes(transport)) {
          this.add(transport);
        }
        this.emit(event, err, transport);
      }
      if (!transport["__winston" + event]) {
        transport["__winston" + event] = transportEvent.bind(this);
        transport.on(event, transport["__winston" + event]);
      }
    }
    _addDefaultMeta(msg) {
      if (this.defaultMeta) {
        Object.assign(msg, this.defaultMeta);
      }
    }
  }
  Object.defineProperty(Logger3.prototype, "transports", {
    configurable: false,
    enumerable: true,
    get() {
      const { pipes } = this._readableState;
      return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;
    }
  });
  module.exports = Logger3;
});

// ../../node_modules/winston/lib/winston/create-logger.js
var require_create_logger = __commonJS((exports, module) => {
  var isLevelEnabledFunctionName = function(level) {
    return "is" + level.charAt(0).toUpperCase() + level.slice(1) + "Enabled";
  };
  var { LEVEL } = require_triple_beam();
  var config8 = require_config2();
  var Logger3 = require_logger();
  var debug2 = require_node4()("winston:create-logger");
  module.exports = function(opts = {}) {
    opts.levels = opts.levels || config8.npm.levels;

    class DerivedLogger extends Logger3 {
      constructor(options) {
        super(options);
      }
    }
    const logger3 = new DerivedLogger(opts);
    Object.keys(opts.levels).forEach(function(level) {
      debug2('Define prototype method for "%s"', level);
      if (level === "log") {
        console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
        return;
      }
      DerivedLogger.prototype[level] = function(...args) {
        const self2 = this || logger3;
        if (args.length === 1) {
          const [msg] = args;
          const info = msg && msg.message && msg || { message: msg };
          info.level = info[LEVEL] = level;
          self2._addDefaultMeta(info);
          self2.write(info);
          return this || logger3;
        }
        if (args.length === 0) {
          self2.log(level, "");
          return self2;
        }
        return self2.log(level, ...args);
      };
      DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function() {
        return (this || logger3).isLevelEnabled(level);
      };
    });
    return logger3;
  };
});

// ../../node_modules/winston/lib/winston/container.js
var require_container = __commonJS((exports, module) => {
  var createLogger = require_create_logger();
  module.exports = class Container {
    constructor(options = {}) {
      this.loggers = new Map;
      this.options = options;
    }
    add(id, options) {
      if (!this.loggers.has(id)) {
        options = Object.assign({}, options || this.options);
        const existing = options.transports || this.options.transports;
        if (existing) {
          options.transports = Array.isArray(existing) ? existing.slice() : [existing];
        } else {
          options.transports = [];
        }
        const logger3 = createLogger(options);
        logger3.on("close", () => this._delete(id));
        this.loggers.set(id, logger3);
      }
      return this.loggers.get(id);
    }
    get(id, options) {
      return this.add(id, options);
    }
    has(id) {
      return !!this.loggers.has(id);
    }
    close(id) {
      if (id) {
        return this._removeLogger(id);
      }
      this.loggers.forEach((val, key) => this._removeLogger(key));
    }
    _removeLogger(id) {
      if (!this.loggers.has(id)) {
        return;
      }
      const logger3 = this.loggers.get(id);
      logger3.close();
      this._delete(id);
    }
    _delete(id) {
      this.loggers.delete(id);
    }
  };
});

// ../../node_modules/winston/lib/winston.js
var require_winston = __commonJS((exports) => {
  var logform = require_logform();
  var { warn } = require_common3();
  exports.version = require_package().version;
  exports.transports = require_transports();
  exports.config = require_config2();
  exports.addColors = logform.levels;
  exports.format = logform.format;
  exports.createLogger = require_create_logger();
  exports.Logger = require_logger();
  exports.ExceptionHandler = require_exception_handler();
  exports.RejectionHandler = require_rejection_handler();
  exports.Container = require_container();
  exports.Transport = require_winston_transport();
  exports.loggers = new exports.Container;
  var defaultLogger = exports.createLogger();
  Object.keys(exports.config.npm.levels).concat([
    "log",
    "query",
    "stream",
    "add",
    "remove",
    "clear",
    "profile",
    "startTimer",
    "handleExceptions",
    "unhandleExceptions",
    "handleRejections",
    "unhandleRejections",
    "configure",
    "child"
  ]).forEach((method) => exports[method] = (...args) => defaultLogger[method](...args));
  Object.defineProperty(exports, "level", {
    get() {
      return defaultLogger.level;
    },
    set(val) {
      defaultLogger.level = val;
    }
  });
  Object.defineProperty(exports, "exceptions", {
    get() {
      return defaultLogger.exceptions;
    }
  });
  ["exitOnError"].forEach((prop) => {
    Object.defineProperty(exports, prop, {
      get() {
        return defaultLogger[prop];
      },
      set(val) {
        defaultLogger[prop] = val;
      }
    });
  });
  Object.defineProperty(exports, "default", {
    get() {
      return {
        exceptionHandlers: defaultLogger.exceptionHandlers,
        rejectionHandlers: defaultLogger.rejectionHandlers,
        transports: defaultLogger.transports
      };
    }
  });
  warn.deprecated(exports, "setLevels");
  warn.forFunctions(exports, "useFormat", ["cli"]);
  warn.forProperties(exports, "useFormat", ["padLevels", "stripColors"]);
  warn.forFunctions(exports, "deprecated", [
    "addRewriter",
    "addFilter",
    "clone",
    "extend"
  ]);
  warn.forProperties(exports, "deprecated", ["emitErrs", "levelLength"]);
});

// node_modules/lru-cache/index.js
var require_lru_cache2 = __commonJS((exports, module) => {
  var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
  var hasAbortController = typeof AbortController === "function";
  var AC = hasAbortController ? AbortController : class AbortController2 {
    constructor() {
      this.signal = new AS;
    }
    abort() {
      this.signal.dispatchEvent("abort");
    }
  };
  var hasAbortSignal = typeof AbortSignal === "function";
  var hasACAbortSignal = typeof AC.AbortSignal === "function";
  var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal2 {
    constructor() {
      this.aborted = false;
      this._listeners = [];
    }
    dispatchEvent(type) {
      if (type === "abort") {
        this.aborted = true;
        const e4 = { type, target: this };
        this.onabort(e4);
        this._listeners.forEach((f) => f(e4), this);
      }
    }
    onabort() {
    }
    addEventListener(ev, fn) {
      if (ev === "abort") {
        this._listeners.push(fn);
      }
    }
    removeEventListener(ev, fn) {
      if (ev === "abort") {
        this._listeners = this._listeners.filter((f) => f !== fn);
      }
    }
  };
  var warned = new Set;
  var deprecatedOption = (opt, instead) => {
    const code = `LRU_CACHE_OPTION_${opt}`;
    if (shouldWarn(code)) {
      warn(code, `${opt} option`, `options.${instead}`, LRUCache2);
    }
  };
  var deprecatedMethod = (method, instead) => {
    const code = `LRU_CACHE_METHOD_${method}`;
    if (shouldWarn(code)) {
      const { prototype } = LRUCache2;
      const { get } = Object.getOwnPropertyDescriptor(prototype, method);
      warn(code, `${method} method`, `cache.${instead}()`, get);
    }
  };
  var deprecatedProperty = (field, instead) => {
    const code = `LRU_CACHE_PROPERTY_${field}`;
    if (shouldWarn(code)) {
      const { prototype } = LRUCache2;
      const { get } = Object.getOwnPropertyDescriptor(prototype, field);
      warn(code, `${field} property`, `cache.${instead}`, get);
    }
  };
  var emitWarning = (...a) => {
    typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
  };
  var shouldWarn = (code) => !warned.has(code);
  var warn = (code, what, instead, fn) => {
    warned.add(code);
    const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
    emitWarning(msg, "DeprecationWarning", code, fn);
  };
  var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
  var getUintArray = (max5) => !isPosInt(max5) ? null : max5 <= Math.pow(2, 8) ? Uint8Array : max5 <= Math.pow(2, 16) ? Uint16Array : max5 <= Math.pow(2, 32) ? Uint32Array : max5 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

  class ZeroArray extends Array {
    constructor(size3) {
      super(size3);
      this.fill(0);
    }
  }

  class Stack {
    constructor(max5) {
      if (max5 === 0) {
        return [];
      }
      const UintArray = getUintArray(max5);
      this.heap = new UintArray(max5);
      this.length = 0;
    }
    push(n) {
      this.heap[this.length++] = n;
    }
    pop() {
      return this.heap[--this.length];
    }
  }

  class LRUCache2 {
    constructor(options = {}) {
      const {
        max: max5 = 0,
        ttl,
        ttlResolution = 1,
        ttlAutopurge,
        updateAgeOnGet,
        updateAgeOnHas,
        allowStale,
        dispose,
        disposeAfter,
        noDisposeOnSet,
        noUpdateTTL,
        maxSize = 0,
        maxEntrySize = 0,
        sizeCalculation,
        fetchMethod,
        fetchContext,
        noDeleteOnFetchRejection,
        noDeleteOnStaleGet
      } = options;
      const { length, maxAge, stale } = options instanceof LRUCache2 ? {} : options;
      if (max5 !== 0 && !isPosInt(max5)) {
        throw new TypeError("max option must be a nonnegative integer");
      }
      const UintArray = max5 ? getUintArray(max5) : Array;
      if (!UintArray) {
        throw new Error("invalid max value: " + max5);
      }
      this.max = max5;
      this.maxSize = maxSize;
      this.maxEntrySize = maxEntrySize || this.maxSize;
      this.sizeCalculation = sizeCalculation || length;
      if (this.sizeCalculation) {
        if (!this.maxSize && !this.maxEntrySize) {
          throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        }
        if (typeof this.sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation set to non-function");
        }
      }
      this.fetchMethod = fetchMethod || null;
      if (this.fetchMethod && typeof this.fetchMethod !== "function") {
        throw new TypeError("fetchMethod must be a function if specified");
      }
      this.fetchContext = fetchContext;
      if (!this.fetchMethod && fetchContext !== undefined) {
        throw new TypeError("cannot set fetchContext without fetchMethod");
      }
      this.keyMap = new Map;
      this.keyList = new Array(max5).fill(null);
      this.valList = new Array(max5).fill(null);
      this.next = new UintArray(max5);
      this.prev = new UintArray(max5);
      this.head = 0;
      this.tail = 0;
      this.free = new Stack(max5);
      this.initialFill = 1;
      this.size = 0;
      if (typeof dispose === "function") {
        this.dispose = dispose;
      }
      if (typeof disposeAfter === "function") {
        this.disposeAfter = disposeAfter;
        this.disposed = [];
      } else {
        this.disposeAfter = null;
        this.disposed = null;
      }
      this.noDisposeOnSet = !!noDisposeOnSet;
      this.noUpdateTTL = !!noUpdateTTL;
      this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
      if (this.maxEntrySize !== 0) {
        if (this.maxSize !== 0) {
          if (!isPosInt(this.maxSize)) {
            throw new TypeError("maxSize must be a positive integer if specified");
          }
        }
        if (!isPosInt(this.maxEntrySize)) {
          throw new TypeError("maxEntrySize must be a positive integer if specified");
        }
        this.initializeSizeTracking();
      }
      this.allowStale = !!allowStale || !!stale;
      this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
      this.updateAgeOnGet = !!updateAgeOnGet;
      this.updateAgeOnHas = !!updateAgeOnHas;
      this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
      this.ttlAutopurge = !!ttlAutopurge;
      this.ttl = ttl || maxAge || 0;
      if (this.ttl) {
        if (!isPosInt(this.ttl)) {
          throw new TypeError("ttl must be a positive integer if specified");
        }
        this.initializeTTLTracking();
      }
      if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
        throw new TypeError("At least one of max, maxSize, or ttl is required");
      }
      if (!this.ttlAutopurge && !this.max && !this.maxSize) {
        const code = "LRU_CACHE_UNBOUNDED";
        if (shouldWarn(code)) {
          warned.add(code);
          const msg = "TTL caching without ttlAutopurge, max, or maxSize can " + "result in unbounded memory consumption.";
          emitWarning(msg, "UnboundedCacheWarning", code, LRUCache2);
        }
      }
      if (stale) {
        deprecatedOption("stale", "allowStale");
      }
      if (maxAge) {
        deprecatedOption("maxAge", "ttl");
      }
      if (length) {
        deprecatedOption("length", "sizeCalculation");
      }
    }
    getRemainingTTL(key) {
      return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
    }
    initializeTTLTracking() {
      this.ttls = new ZeroArray(this.max);
      this.starts = new ZeroArray(this.max);
      this.setItemTTL = (index2, ttl, start = perf.now()) => {
        this.starts[index2] = ttl !== 0 ? start : 0;
        this.ttls[index2] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (this.isStale(index2)) {
              this.delete(this.keyList[index2]);
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
        }
      };
      this.updateItemAge = (index2) => {
        this.starts[index2] = this.ttls[index2] !== 0 ? perf.now() : 0;
      };
      let cachedNow = 0;
      const getNow = () => {
        const n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index2 = this.keyMap.get(key);
        if (index2 === undefined) {
          return 0;
        }
        return this.ttls[index2] === 0 || this.starts[index2] === 0 ? Infinity : this.starts[index2] + this.ttls[index2] - (cachedNow || getNow());
      };
      this.isStale = (index2) => {
        return this.ttls[index2] !== 0 && this.starts[index2] !== 0 && (cachedNow || getNow()) - this.starts[index2] > this.ttls[index2];
      };
    }
    updateItemAge(index2) {
    }
    setItemTTL(index2, ttl, start) {
    }
    isStale(index2) {
      return false;
    }
    initializeSizeTracking() {
      this.calculatedSize = 0;
      this.sizes = new ZeroArray(this.max);
      this.removeItemSize = (index2) => {
        this.calculatedSize -= this.sizes[index2];
        this.sizes[index2] = 0;
      };
      this.requireSize = (k, v, size3, sizeCalculation) => {
        if (!isPosInt(size3)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size3 = sizeCalculation(v, k);
            if (!isPosInt(size3)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer)");
          }
        }
        return size3;
      };
      this.addItemSize = (index2, size3) => {
        this.sizes[index2] = size3;
        const maxSize = this.maxSize - this.sizes[index2];
        while (this.calculatedSize > maxSize) {
          this.evict(true);
        }
        this.calculatedSize += this.sizes[index2];
      };
    }
    removeItemSize(index2) {
    }
    addItemSize(index2, size3) {
    }
    requireSize(k, v, size3, sizeCalculation) {
      if (size3 || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
    }
    *indexes({ allowStale = this.allowStale } = {}) {
      if (this.size) {
        for (let i3 = this.tail;; ) {
          if (!this.isValidIndex(i3)) {
            break;
          }
          if (allowStale || !this.isStale(i3)) {
            yield i3;
          }
          if (i3 === this.head) {
            break;
          } else {
            i3 = this.prev[i3];
          }
        }
      }
    }
    *rindexes({ allowStale = this.allowStale } = {}) {
      if (this.size) {
        for (let i3 = this.head;; ) {
          if (!this.isValidIndex(i3)) {
            break;
          }
          if (allowStale || !this.isStale(i3)) {
            yield i3;
          }
          if (i3 === this.tail) {
            break;
          } else {
            i3 = this.next[i3];
          }
        }
      }
    }
    isValidIndex(index2) {
      return this.keyMap.get(this.keyList[index2]) === index2;
    }
    *entries() {
      for (const i3 of this.indexes()) {
        yield [this.keyList[i3], this.valList[i3]];
      }
    }
    *rentries() {
      for (const i3 of this.rindexes()) {
        yield [this.keyList[i3], this.valList[i3]];
      }
    }
    *keys() {
      for (const i3 of this.indexes()) {
        yield this.keyList[i3];
      }
    }
    *rkeys() {
      for (const i3 of this.rindexes()) {
        yield this.keyList[i3];
      }
    }
    *values() {
      for (const i3 of this.indexes()) {
        yield this.valList[i3];
      }
    }
    *rvalues() {
      for (const i3 of this.rindexes()) {
        yield this.valList[i3];
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    find(fn, getOptions = {}) {
      for (const i3 of this.indexes()) {
        if (fn(this.valList[i3], this.keyList[i3], this)) {
          return this.get(this.keyList[i3], getOptions);
        }
      }
    }
    forEach(fn, thisp = this) {
      for (const i3 of this.indexes()) {
        fn.call(thisp, this.valList[i3], this.keyList[i3], this);
      }
    }
    rforEach(fn, thisp = this) {
      for (const i3 of this.rindexes()) {
        fn.call(thisp, this.valList[i3], this.keyList[i3], this);
      }
    }
    get prune() {
      deprecatedMethod("prune", "purgeStale");
      return this.purgeStale;
    }
    purgeStale() {
      let deleted = false;
      for (const i3 of this.rindexes({ allowStale: true })) {
        if (this.isStale(i3)) {
          this.delete(this.keyList[i3]);
          deleted = true;
        }
      }
      return deleted;
    }
    dump() {
      const arr = [];
      for (const i3 of this.indexes({ allowStale: true })) {
        const key = this.keyList[i3];
        const v = this.valList[i3];
        const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        const entry = { value };
        if (this.ttls) {
          entry.ttl = this.ttls[i3];
          const age = perf.now() - this.starts[i3];
          entry.start = Math.floor(Date.now() - age);
        }
        if (this.sizes) {
          entry.size = this.sizes[i3];
        }
        arr.unshift([key, entry]);
      }
      return arr;
    }
    load(arr) {
      this.clear();
      for (const [key, entry] of arr) {
        if (entry.start) {
          const age = Date.now() - entry.start;
          entry.start = perf.now() - age;
        }
        this.set(key, entry.value, entry);
      }
    }
    dispose(v, k, reason) {
    }
    set(k, v, {
      ttl = this.ttl,
      start,
      noDisposeOnSet = this.noDisposeOnSet,
      size: size3 = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL
    } = {}) {
      size3 = this.requireSize(k, v, size3, sizeCalculation);
      if (this.maxEntrySize && size3 > this.maxEntrySize) {
        return this;
      }
      let index2 = this.size === 0 ? undefined : this.keyMap.get(k);
      if (index2 === undefined) {
        index2 = this.newIndex();
        this.keyList[index2] = k;
        this.valList[index2] = v;
        this.keyMap.set(k, index2);
        this.next[this.tail] = index2;
        this.prev[index2] = this.tail;
        this.tail = index2;
        this.size++;
        this.addItemSize(index2, size3);
        noUpdateTTL = false;
      } else {
        const oldVal = this.valList[index2];
        if (v !== oldVal) {
          if (this.isBackgroundFetch(oldVal)) {
            oldVal.__abortController.abort();
          } else {
            if (!noDisposeOnSet) {
              this.dispose(oldVal, k, "set");
              if (this.disposeAfter) {
                this.disposed.push([oldVal, k, "set"]);
              }
            }
          }
          this.removeItemSize(index2);
          this.valList[index2] = v;
          this.addItemSize(index2, size3);
        }
        this.moveToTail(index2);
      }
      if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
        this.initializeTTLTracking();
      }
      if (!noUpdateTTL) {
        this.setItemTTL(index2, ttl, start);
      }
      if (this.disposeAfter) {
        while (this.disposed.length) {
          this.disposeAfter(...this.disposed.shift());
        }
      }
      return this;
    }
    newIndex() {
      if (this.size === 0) {
        return this.tail;
      }
      if (this.size === this.max && this.max !== 0) {
        return this.evict(false);
      }
      if (this.free.length !== 0) {
        return this.free.pop();
      }
      return this.initialFill++;
    }
    pop() {
      if (this.size) {
        const val = this.valList[this.head];
        this.evict(true);
        return val;
      }
    }
    evict(free) {
      const head = this.head;
      const k = this.keyList[head];
      const v = this.valList[head];
      if (this.isBackgroundFetch(v)) {
        v.__abortController.abort();
      } else {
        this.dispose(v, k, "evict");
        if (this.disposeAfter) {
          this.disposed.push([v, k, "evict"]);
        }
      }
      this.removeItemSize(head);
      if (free) {
        this.keyList[head] = null;
        this.valList[head] = null;
        this.free.push(head);
      }
      this.head = this.next[head];
      this.keyMap.delete(k);
      this.size--;
      return head;
    }
    has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
      const index2 = this.keyMap.get(k);
      if (index2 !== undefined) {
        if (!this.isStale(index2)) {
          if (updateAgeOnHas) {
            this.updateItemAge(index2);
          }
          return true;
        }
      }
      return false;
    }
    peek(k, { allowStale = this.allowStale } = {}) {
      const index2 = this.keyMap.get(k);
      if (index2 !== undefined && (allowStale || !this.isStale(index2))) {
        const v = this.valList[index2];
        return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
    }
    backgroundFetch(k, index2, options, context2) {
      const v = index2 === undefined ? undefined : this.valList[index2];
      if (this.isBackgroundFetch(v)) {
        return v;
      }
      const ac = new AC;
      const fetchOpts = {
        signal: ac.signal,
        options,
        context: context2
      };
      const cb = (v2) => {
        if (!ac.signal.aborted) {
          this.set(k, v2, fetchOpts.options);
        }
        return v2;
      };
      const eb = (er) => {
        if (this.valList[index2] === p) {
          const del = !options.noDeleteOnFetchRejection || p.__staleWhileFetching === undefined;
          if (del) {
            this.delete(k);
          } else {
            this.valList[index2] = p.__staleWhileFetching;
          }
        }
        if (p.__returned === p) {
          throw er;
        }
      };
      const pcall = (res) => res(this.fetchMethod(k, v, fetchOpts));
      const p = new Promise(pcall).then(cb, eb);
      p.__abortController = ac;
      p.__staleWhileFetching = v;
      p.__returned = null;
      if (index2 === undefined) {
        this.set(k, p, fetchOpts.options);
        index2 = this.keyMap.get(k);
      } else {
        this.valList[index2] = p;
      }
      return p;
    }
    isBackgroundFetch(p) {
      return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(p, "__staleWhileFetching") && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
    }
    async fetch(k, {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size: size3 = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      fetchContext = this.fetchContext,
      forceRefresh = false
    } = {}) {
      if (!this.fetchMethod) {
        return this.get(k, {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet
        });
      }
      const options = {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        ttl,
        noDisposeOnSet,
        size: size3,
        sizeCalculation,
        noUpdateTTL,
        noDeleteOnFetchRejection
      };
      let index2 = this.keyMap.get(k);
      if (index2 === undefined) {
        const p = this.backgroundFetch(k, index2, options, fetchContext);
        return p.__returned = p;
      } else {
        const v = this.valList[index2];
        if (this.isBackgroundFetch(v)) {
          return allowStale && v.__staleWhileFetching !== undefined ? v.__staleWhileFetching : v.__returned = v;
        }
        if (!forceRefresh && !this.isStale(index2)) {
          this.moveToTail(index2);
          if (updateAgeOnGet) {
            this.updateItemAge(index2);
          }
          return v;
        }
        const p = this.backgroundFetch(k, index2, options, fetchContext);
        return allowStale && p.__staleWhileFetching !== undefined ? p.__staleWhileFetching : p.__returned = p;
      }
    }
    get(k, {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet
    } = {}) {
      const index2 = this.keyMap.get(k);
      if (index2 !== undefined) {
        const value = this.valList[index2];
        const fetching = this.isBackgroundFetch(value);
        if (this.isStale(index2)) {
          if (!fetching) {
            if (!noDeleteOnStaleGet) {
              this.delete(k);
            }
            return allowStale ? value : undefined;
          } else {
            return allowStale ? value.__staleWhileFetching : undefined;
          }
        } else {
          if (fetching) {
            return;
          }
          this.moveToTail(index2);
          if (updateAgeOnGet) {
            this.updateItemAge(index2);
          }
          return value;
        }
      }
    }
    connect(p, n) {
      this.prev[n] = p;
      this.next[p] = n;
    }
    moveToTail(index2) {
      if (index2 !== this.tail) {
        if (index2 === this.head) {
          this.head = this.next[index2];
        } else {
          this.connect(this.prev[index2], this.next[index2]);
        }
        this.connect(this.tail, index2);
        this.tail = index2;
      }
    }
    get del() {
      deprecatedMethod("del", "delete");
      return this.delete;
    }
    delete(k) {
      let deleted = false;
      if (this.size !== 0) {
        const index2 = this.keyMap.get(k);
        if (index2 !== undefined) {
          deleted = true;
          if (this.size === 1) {
            this.clear();
          } else {
            this.removeItemSize(index2);
            const v = this.valList[index2];
            if (this.isBackgroundFetch(v)) {
              v.__abortController.abort();
            } else {
              this.dispose(v, k, "delete");
              if (this.disposeAfter) {
                this.disposed.push([v, k, "delete"]);
              }
            }
            this.keyMap.delete(k);
            this.keyList[index2] = null;
            this.valList[index2] = null;
            if (index2 === this.tail) {
              this.tail = this.prev[index2];
            } else if (index2 === this.head) {
              this.head = this.next[index2];
            } else {
              this.next[this.prev[index2]] = this.next[index2];
              this.prev[this.next[index2]] = this.prev[index2];
            }
            this.size--;
            this.free.push(index2);
          }
        }
      }
      if (this.disposed) {
        while (this.disposed.length) {
          this.disposeAfter(...this.disposed.shift());
        }
      }
      return deleted;
    }
    clear() {
      for (const index2 of this.rindexes({ allowStale: true })) {
        const v = this.valList[index2];
        if (this.isBackgroundFetch(v)) {
          v.__abortController.abort();
        } else {
          const k = this.keyList[index2];
          this.dispose(v, k, "delete");
          if (this.disposeAfter) {
            this.disposed.push([v, k, "delete"]);
          }
        }
      }
      this.keyMap.clear();
      this.valList.fill(null);
      this.keyList.fill(null);
      if (this.ttls) {
        this.ttls.fill(0);
        this.starts.fill(0);
      }
      if (this.sizes) {
        this.sizes.fill(0);
      }
      this.head = 0;
      this.tail = 0;
      this.initialFill = 1;
      this.free.length = 0;
      this.calculatedSize = 0;
      this.size = 0;
      if (this.disposed) {
        while (this.disposed.length) {
          this.disposeAfter(...this.disposed.shift());
        }
      }
    }
    get reset() {
      deprecatedMethod("reset", "clear");
      return this.clear;
    }
    get length() {
      deprecatedProperty("length", "size");
      return this.size;
    }
    static get AbortController() {
      return AC;
    }
    static get AbortSignal() {
      return AS;
    }
  }
  module.exports = LRUCache2;
});

// src/app/wsclient.ts
var import_mobx = __toESM(require_dist(), 1);

// src/adapter/utils.ts
var adapter_qq = __toESM(require_lib16(), 1);
var adapter_kook = __toESM(require_lib17(), 1);
function getBotId(platform, appid) {
  return `${platform}:${appid}`;
}
function getChannelUnionId(platform, guildId, channelId) {
  return `${platform}_${guildId}_${channelId}`;
}
function asChannelUnionId(maybeUnionId) {
  if (maybeUnionId.match(/^[a-z]+_.+_+/)) {
    return maybeUnionId;
  } else {
    return;
  }
}
function adapterPlugin(platform) {
  switch (platform) {
    case "qqguild":
      return adapter_qq.QQBot;
    case "kook":
      return adapter_kook.KookBot;
  }
}
function adapterConfig(config) {
  switch (config.platform) {
    case "qqguild":
      return adapterQQ(config);
    case "kook":
      return adapterKook(config);
  }
}
var adapterQQ = function(config) {
  const type = config.type ?? "private";
  return {
    id: config.appid,
    secret: config.secret,
    token: config.token,
    type,
    sandbox: config.sandbox ?? false,
    intents: adapter_qq.QQ.Intents.GUILDS | adapter_qq.QQ.Intents.GUILD_MEMBERS | (type === "private" ? adapter_qq.QQ.Intents.GUILD_MESSAGES : adapter_qq.QQ.Intents.PUBLIC_GUILD_MESSAGES) | adapter_qq.QQ.Intents.GUILD_MESSAGE_REACTIONS | adapter_qq.QQ.Intents.DIRECT_MESSAGES,
    retryWhen: []
  };
};
var adapterKook = function(config) {
  return {
    protocol: "ws",
    token: config.token
  };
};

// src/app/wsclient.ts
class WsClient {
  peer;
  _botId;
  _listenToGuildId = "";
  _listenToChannelId = "";
  server;
  disposers = [];
  get id() {
    return this.peer?.id;
  }
  get botId() {
    return this._botId;
  }
  get bot() {
    return this.server.bots.find(this.botId);
  }
  get platform() {
    return this.bot?.platform;
  }
  get listenToGuildId() {
    return this._listenToGuildId;
  }
  get listenToChannelId() {
    return this._listenToChannelId;
  }
  get listenToChannelUnionId() {
    if (this.platform && this.listenToGuildId && this.listenToChannelId) {
      return getChannelUnionId(this.platform, this.listenToGuildId, this.listenToChannelId);
    } else {
      return;
    }
  }
  constructor(server, peer) {
    this.peer = peer;
    import_mobx.makeAutoObservable(this, { peer: false });
    this.server = server;
    this.autorun((ws) => this.server.sendToClient(ws, this.onCardListUpdate()));
  }
  onMessage(rawData) {
    try {
      const body = JSON.parse(rawData.toString());
      console.log(body);
      this.server.handleClientRequest(this, body);
    } catch (e) {
      console.error("\u6D88\u606F\u5904\u7406\u5931\u8D25", e);
      console.error("\u539F\u59CB\u6D88\u606F", rawData);
    }
  }
  onError(e) {
    console.error("\u5BA2\u6237\u7AEF\u56E0\u53D1\u751F\u9519\u8BEF\u800C\u5173\u95ED", e);
    this.disposeAllEffects();
    this.server.removeClient(this);
  }
  onClose() {
    console.log("\u5BA2\u6237\u7AEF\u5173\u95ED");
    this.disposeAllEffects();
    this.server.removeClient(this);
  }
  onCardListUpdate() {
    const cardList = this.server.cards.cardList;
    return {
      cmd: "card/list",
      success: true,
      data: cardList
    };
  }
  bindToBot(botId) {
    this._botId = botId;
  }
  listenTo(channelId, guildId) {
    this._listenToChannelId = channelId;
    this._listenToGuildId = guildId;
    this.bot.listenTo(channelId, guildId);
  }
  send(data) {
    console.log("send", this.peer);
    this.peer?.send(JSON.stringify(data), {});
  }
  autorun(effect) {
    const dispose = import_mobx.autorun(() => effect(this));
    this.disposers.push(dispose);
  }
  disposeAllEffects() {
    this.disposers.forEach((dispose) => dispose());
    this.disposers.length = 0;
  }
}

// ../../node_modules/mitt/dist/mitt.mjs
function mitt_default(n) {
  return { all: n = n || new Map, on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}

// ../../packages/dicecore/lib/utils/eventBus.js
var eventBus = mitt_default();

// ../../packages/dicecore/lib/config/plugin-provider.js
class PluginProvider {
  static INSTANCE = new PluginProvider;
  pluginMap = new Map;
  pluginId2ItemIds = new Map;
  itemsMap = new Map;
  constructor() {
  }
  get allPlugins() {
    return Array.from(this.pluginMap.values());
  }
  register(plugins) {
    if (plugins.length > 0) {
      for (const plugin2 of plugins) {
        this._register(plugin2.id, plugin2);
      }
      eventBus.emit("plugins-added", plugins);
    }
  }
  _register(pluginId, plugin2) {
    if (this.pluginMap.has(pluginId)) {
      this._unregister(pluginId);
    }
    this.pluginMap.set(pluginId, plugin2);
    const allIds = new Set;
    ["customReply", "rollDecider", "aliasRoll", "customText"].forEach((key) => {
      plugin2[key]?.forEach((item) => {
        const fullId = `${plugin2.id}.${item.id}`;
        allIds.add(fullId);
        this.itemsMap.set(fullId, item);
      });
    });
    ["onReceiveCommand", "beforeParseDiceRoll", "onCardEntryChange", "onMessageReaction", "beforeDiceRoll", "afterDiceRoll"].forEach((key) => {
      plugin2.hook?.[key]?.forEach((item) => {
        const fullId = `${plugin2.id}.${item.id}`;
        allIds.add(fullId);
        this.itemsMap.set(fullId, item);
      });
    });
    this.pluginId2ItemIds.set(pluginId, allIds);
  }
  _unregister(pluginId) {
    const itemIds = this.pluginId2ItemIds.get(pluginId);
    if (itemIds) {
      itemIds.forEach((id) => this.itemsMap.delete(id));
    }
    this.pluginId2ItemIds.delete(pluginId);
    this.pluginMap.delete(pluginId);
  }
  getPluginItem(fullId) {
    return this.itemsMap.get(fullId);
  }
}

// ../../packages/dicecore/lib/utils/sync-lru-cache.js
var import_lru_cache = __toESM(require_lru_cache(), 1);

class SyncLruCache {
  cache;
  fetchMethod;
  constructor({ max, fetchMethod }) {
    this.cache = new import_lru_cache.default({ max });
    this.fetchMethod = fetchMethod;
  }
  get(key) {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    const value = this.fetchMethod(key);
    this.cache.set(key, value);
    return value;
  }
}

// ../../packages/dicecore/lib/config/helpers/decider.js
function decideRoll(decider, context2) {
  if (!decider) {
    return;
  }
  const resultLevel = rollDeciderHit(decider, context2);
  if (!resultLevel) {
    return;
  }
  return {
    success: ["\u6210\u529F", "\u56F0\u96BE\u6210\u529F", "\u6781\u96BE\u6210\u529F", "\u5927\u6210\u529F"].includes(resultLevel),
    level: resultLevel
  };
}
var rollDeciderHit = function(decider, context2) {
  try {
    for (const rule of decider.rules) {
      const func = RollDeciderExpressionCache.get(rule.expression);
      if (func?.(context2)) {
        return rule.level;
      }
    }
    return;
  } catch (e) {
    console.error("[Config] \u5224\u65AD\u6210\u529F\u7B49\u7EA7\u51FA\u9519", e?.message, "context=", JSON.stringify(context2));
    return;
  }
};
var RollDeciderExpressionCache = new SyncLruCache({
  max: 50,
  fetchMethod: (expression) => {
    const normalized = expression.trim() || false;
    return new Function("context", `"use strict"; const { baseValue, targetValue, roll } = context; return !!(${normalized})`);
  }
});

// ../../packages/card/lib/types.js
class BaseCard {
  data;
  get type() {
    return this.data.type;
  }
  get name() {
    return this.data.name;
  }
  get isTemplate() {
    return this.data.isTemplate;
  }
  constructor(data) {
    this.data = data;
  }
  getEntryDisplay(name) {
    const entry = this.getEntry(name);
    if (entry) {
      return `${name}:${entry.value}`;
    }
    const ability = this.getAbility(name);
    if (ability) {
      return `${name}:${ability.value}`;
    }
    return `${name}:-`;
  }
  getAliases(name) {
    return [name.toUpperCase()];
  }
  emitter = mitt_default();
  emitCardEntryChange(key, value, oldValue) {
    this.emitter.emit("EntryChange", {
      key,
      value,
      oldValue,
      card: this
    });
  }
  addCardEntryChangeListener(listener) {
    this.emitter.on("EntryChange", listener);
  }
  removeCardEntryChangeListener(listener) {
    this.emitter.off("EntryChange", listener);
  }
}

// ../../packages/card/lib/coc.js
var parseDifficulty = function(expression) {
  let difficulty = "normal";
  if (expression.includes("\u56F0\u96BE")) {
    difficulty = "hard";
  } else if (expression.includes("\u6781\u96BE") || expression.includes("\u6781\u9650")) {
    difficulty = "ex";
  }
  expression = expression.replace(/(||)/g, "");
  return [expression.trim(), difficulty];
};
function calculateTargetValueWithDifficulty(baseValue, difficulty, reverse = false) {
  if (difficulty === "hard") {
    return reverse ? baseValue * 2 : Math.floor(baseValue / 2);
  } else if (difficulty === "ex") {
    return reverse ? baseValue * 5 : Math.floor(baseValue / 5);
  } else {
    return baseValue;
  }
}
function getCocTempEntry(key, tempValue) {
  const [skillWithoutDifficulty, difficulty] = parseDifficulty(key);
  const value = calculateTargetValueWithDifficulty(tempValue, difficulty);
  return { input: key, type: "skills", key: skillWithoutDifficulty, difficulty, value, baseValue: tempValue, isTemp: true, readonly: true };
}
var clamp = function(num, min, max) {
  return Math.min(Math.max(num, min), max);
};

class CocCard extends BaseCard {
  defaultRoll = "d%";
  riDefaultRoll = "$\u654F\u6377";
  get HP() {
    return this.data.basic.HP;
  }
  set HP(value) {
    this.data.basic.HP = clamp(value, 0, this.MAXHP);
  }
  get MAXHP() {
    return Math.floor((this.data.props[""] + this.data.props[""]) / 10);
  }
  get MP() {
    return this.data.basic.MP;
  }
  set MP(value) {
    this.data.basic.MP = clamp(value, 0, this.MAXMP);
  }
  get MAXMP() {
    return Math.floor(this.data.props[""] / 5);
  }
  get SAN() {
    return this.data.basic.SAN;
  }
  set SAN(value) {
    this.data.basic.SAN = clamp(value, 0, this.MAXSAN);
  }
  get MAXSAN() {
    return Math.max(0, 99 - this.data.basic.CM);
  }
  get CM() {
    return this.data.basic.CM;
  }
  set CM(value) {
    this.data.basic.CM = value;
    this.SAN = Math.min(this.SAN, this.MAXSAN);
  }
  get dbAndBuild() {
    const sum = this.data.props[""] + this.data.props[""];
    if (sum < 65) {
      return ["-2", -2];
    } else if (sum < 85) {
      return ["-1", -1];
    } else if (sum < 125) {
      return ["0", 0];
    } else if (sum < 165) {
      return ["1d4", 1];
    } else if (sum < 205) {
      return ["1d6", 2];
    } else {
      const extra = Math.floor((sum - 205) / 80);
      return [`${2 + extra}d6`, 3 + extra];
    }
  }
  get DB() {
    return this.dbAndBuild[0];
  }
  get ""() {
    return this.dbAndBuild[1];
  }
  getAbility(input) {
    const possibleNames = this.getAliases(input);
    for (const key of possibleNames) {
      const ability = this.data.abilities.find((item) => item.name.toUpperCase() === key);
      if (ability) {
        return { input, key: ability.name, value: ability.expression, readonly: false };
      }
    }
    for (const key of possibleNames) {
      const keyAsComputedAbilities = key;
      if (COMPUTED_ABILITIES.includes(keyAsComputedAbilities)) {
        return { input, key, value: this[keyAsComputedAbilities], readonly: true };
      }
    }
    return;
  }
  setAbility(name, expression) {
    const abilityRet = this.getAbility(name);
    if (abilityRet && !abilityRet.readonly) {
      const ability = this.data.abilities.find((item) => item.name === abilityRet.key);
      if (ability.expression !== expression) {
        ability.expression = expression;
        this.data.lastModified = Date.now();
        return true;
      } else {
        return false;
      }
    } else {
      this.data.abilities.push({ name, expression, ext: "" });
      this.data.lastModified = Date.now();
      return true;
    }
  }
  removeAbility(name) {
    const abilityRet = this.getAbility(name);
    if (abilityRet && !abilityRet.readonly) {
      const index = this.data.abilities.findIndex((item) => item.name === abilityRet.key);
      if (index >= 0) {
        this.data.abilities.splice(index, 1);
        this.data.lastModified = Date.now();
        return true;
      }
    }
    return false;
  }
  getRawEntry(input) {
    const possibleSkills = this.getAliases(input);
    for (const key of possibleSkills) {
      for (const type of ["skills", "basic", "props"]) {
        const target = this.data[type][key];
        if (typeof target === "number") {
          return { input, key, baseValue: target, isTemp: false, readonly: false, type };
        }
      }
    }
    for (const key of possibleSkills) {
      const keyAsComputedEntries = key;
      if (COMPUTED_ENTRIES.includes(keyAsComputedEntries)) {
        return { input, key, baseValue: this[keyAsComputedEntries], isTemp: false, readonly: true, type: "basic" };
      }
    }
    return;
  }
  getEntry(input) {
    const [skillWithoutDifficulty, difficulty] = parseDifficulty(input);
    if (!skillWithoutDifficulty)
      return;
    const target = this.getRawEntry(skillWithoutDifficulty);
    if (target) {
      const value = calculateTargetValueWithDifficulty(target.baseValue, difficulty);
      return { ...target, value, difficulty };
    } else {
      return;
    }
  }
  setEntry(name, value) {
    const [skillWithoutDifficulty, difficulty] = parseDifficulty(name);
    if (!skillWithoutDifficulty)
      return false;
    const _input = skillWithoutDifficulty.toUpperCase();
    const rawEntry = this.getRawEntry(skillWithoutDifficulty);
    if (rawEntry && rawEntry.type === "basic") {
      const keyAsSpecialSetters = rawEntry.key;
      if (SPECIAL_ENTRY_SETTERS.includes(keyAsSpecialSetters)) {
        const oldValue = this[keyAsSpecialSetters];
        this[keyAsSpecialSetters] = value;
        const newValue = this[keyAsSpecialSetters];
        if (oldValue !== newValue) {
          this.data.lastModified = Date.now();
          this.emitCardEntryChange(rawEntry.key, newValue, oldValue);
          return true;
        } else {
          return false;
        }
      }
    }
    const targetValue = calculateTargetValueWithDifficulty(value, difficulty, true);
    if (rawEntry && !rawEntry.readonly) {
      if (targetValue !== rawEntry.baseValue) {
        const oldValue = rawEntry.baseValue;
        this.data[rawEntry.type][rawEntry.key] = targetValue;
        this.data.lastModified = Date.now();
        this.emitCardEntryChange(rawEntry.key, targetValue, oldValue);
        return true;
      } else {
        return false;
      }
    } else {
      this.data.skills[_input] = targetValue;
      this.data.lastModified = Date.now();
      this.emitCardEntryChange(_input, targetValue, undefined);
      return true;
    }
  }
  removeEntry(name) {
    const [skillWithoutDifficulty] = parseDifficulty(name);
    if (!skillWithoutDifficulty)
      return false;
    const entry = this.getRawEntry(skillWithoutDifficulty);
    if (entry && entry.type === "skills" && !entry.readonly) {
      const oldValue = entry.baseValue;
      delete this.data.skills[entry.key];
      this.data.lastModified = Date.now();
      this.emitCardEntryChange(entry.key, undefined, oldValue);
      return true;
    } else {
      return false;
    }
  }
  markSkillGrowth(skill) {
    const entry = this.getRawEntry(skill);
    if (!entry || entry.type !== "skills")
      return false;
    const key = entry.key;
    if (this.data.meta.skillGrowth[key]) {
      return false;
    } else {
      this.data.meta.skillGrowth[key] = true;
      this.data.lastModified = Date.now();
      return true;
    }
  }
  cancelSkillGrowth(skill) {
    let updated = false;
    const possibleSkills = this.getAliases(skill);
    possibleSkills.forEach((skill2) => {
      if (this.data.meta.skillGrowth[skill2]) {
        delete this.data.meta.skillGrowth[skill2];
        updated = true;
      }
    });
    return updated;
  }
  clearSkillGrowth() {
    const count = Object.keys(this.data.meta.skillGrowth).length;
    this.data.meta.skillGrowth = {};
    return count > 0;
  }
  applyDefaultValues() {
    if (!this.HP)
      this.HP = this.MAXHP;
    if (!this.MP)
      this.MP = this.MAXMP;
    if (!this.SAN)
      this.SAN = this.data.props[""];
    Object.entries(DEFAULT_SKILLS).forEach(([key, value]) => {
      const entry = this.getRawEntry(key);
      if (!entry) {
        this.data.skills[key] = value;
      }
    });
    const shanbiEntry = this.getRawEntry("\u95EA\u907F");
    if (!shanbiEntry) {
      this.data.skills["\u95EA\u907F"] = Math.floor(this.data.props[""] / 2);
    }
    const muyuEntry = this.getRawEntry("\u6BCD\u8BED");
    if (!muyuEntry) {
      this.data.skills["\u6BCD\u8BED"] = this.data.props[""];
    }
    this.data.lastModified = Date.now();
  }
  getEntryDisplay(name) {
    const entry = this.getEntry(name);
    if (entry) {
      const isSkillGrowth = entry && entry.type === "skills" && this.data.meta.skillGrowth[entry.key];
      return `${name}${isSkillGrowth ? "*" : ""}:${entry.value}`;
    }
    const ability = this.getAbility(name);
    if (ability) {
      return `${name}:${ability.value}`;
    }
    return `${name}:-`;
  }
  getSummary() {
    const _ = (name) => this.getEntry(name)?.value ?? "-";
    const basic = [
      `\u751F\u547D:${_("HP")}/${_("MAXHP")}`,
      `\u7406\u667A:${_("SAN")}/${_("MAXSAN")}`,
      `\u5E78\u8FD0:${_("LUCK")}`,
      `\u9B54\u6CD5:${_("MP")}/${_("MAXMP")}`,
      `\u514B\u82CF\u9C81\u795E\u8BDD:${_("CM")}`,
      `\u4FE1\u7528\u8BC4\u7EA7:${_("\u4FE1\u7528")}`
    ].join(" ");
    const props = Object.entries(this.data.props).map(([k, v]) => `${k}:${v}`).join(" ");
    const skills = Object.keys(this.data.skills).map((name) => this.getEntryDisplay(name)).join(" ");
    const abilities = this.data.abilities.map((item) => `${item.name}:${item.expression}`).join("\n");
    return "\u89D2\u8272\uFF1A" + this.name + "\n" + basic + "\n" + props + "\n" + skills + "\n" + abilities;
  }
  getAliases(name) {
    const _input = name.toUpperCase();
    return SKILL_ALIAS[_input] ?? [_input];
  }
}
var COMPUTED_ENTRIES = ["MAXHP", "MAXMP", "MAXSAN", "\u4F53\u683C"];
var COMPUTED_ABILITIES = ["DB"];
var SPECIAL_ENTRY_SETTERS = ["HP", "MP", "SAN", "CM"];
var _SKILL_ALIAS = Object.freeze([
  ["\u529B\u91CF", "STR"],
  ["\u654F\u6377", "DEX"],
  ["\u610F\u5FD7", "POW"],
  ["\u4F53\u8D28", "CON"],
  ["\u5916\u8C8C", "APP"],
  ["\u6559\u80B2", "\u77E5\u8BC6", "EDU"],
  ["\u4F53\u578B", "SIZ", "SIZE"],
  ["\u667A\u529B", "\u7075\u611F", "INT"],
  ["\u751F\u547D", "HP", "\u751F\u547D\u503C"],
  ["\u751F\u547D\u4E0A\u9650", "MAXHP", "HPMAX", "\u751F\u547D\u503C\u4E0A\u9650"],
  ["\u7406\u667A", "SC", "SAN", "SAN\u503C", "\u7406\u667A\u503C"],
  ["\u7406\u667A\u4E0A\u9650", "MAXSAN", "SANMAX", "\u7406\u667A\u503C\u4E0A\u9650"],
  ["\u9B54\u6CD5", "MP", "\u9B54\u6CD5\u503C"],
  ["\u9B54\u6CD5\u4E0A\u9650", "MAXMP", "MPMAX", "\u9B54\u6CD5\u503C\u4E0A\u9650"],
  ["\u5E78\u8FD0", "LUCK", "LUK", "\u8FD0\u6C14"],
  ["\u5E74\u9F84", "AGE"],
  ["\u4F24\u5BB3\u52A0\u503C", "DB"],
  ["\u4F53\u683C", "BUILD"],
  ["\u4FA6\u67E5", "\u4FA6\u5BDF"],
  ["\u4FE1\u7528", "\u4FE1\u8A89", "\u4FE1\u7528\u8BC4\u7EA7"],
  ["\u514B\u82CF\u9C81", "\u514B\u82CF\u9C81\u795E\u8BDD", "CM"],
  ["\u8BA1\u7B97\u673A", "\u8BA1\u7B97\u673A\u4F7F\u7528", "\u7535\u8111"],
  ["\u56FE\u4E66\u9986", "\u56FE\u4E66\u9986\u4F7F\u7528"],
  ["\u6C7D\u8F66", "\u9A7E\u9A76", "\u6C7D\u8F66\u9A7E\u9A76"],
  ["\u535A\u7269", "\u535A\u7269\u5B66", "\u81EA\u7136\u5B66"],
  ["\u9886\u822A", "\u5BFC\u822A"],
  ["\u9501\u5320", "\u5F00\u9501", "\u64AC\u9501"],
  ["\u91CD\u578B\u673A\u68B0", "\u91CD\u578B\u64CD\u4F5C", "\u64CD\u4F5C\u91CD\u578B\u673A\u68B0", "\u91CD\u578B"],
  ["\u9A6F\u517D", "\u52A8\u7269\u9A6F\u517B"],
  ["\u9A91\u4E58", "\u9A91\u672F"]
]);
var SKILL_ALIAS = _SKILL_ALIAS.map((line) => line.reduce((obj, str) => Object.assign(obj, { [str]: line }), {})).reduce((total, obj) => Object.assign(total, obj), {});
var DEFAULT_SKILLS = Object.freeze({
  "\u4F1A\u8BA1": 5,
  "\u4EBA\u7C7B\u5B66": 1,
  "\u4F30\u4EF7": 5,
  "\u8003\u53E4\u5B66": 1,
  "\u53D6\u60A6": 15,
  "\u6500\u722C": 20,
  "\u8BA1\u7B97\u673A": 5,
  "\u4E54\u88C5": 5,
  "\u9A7E\u9A76": 20,
  "\u7535\u6C14\u7EF4\u4FEE": 10,
  "\u7535\u5B50\u5B66": 1,
  "\u8BDD\u672F": 5,
  "\u6025\u6551": 30,
  "\u5386\u53F2": 5,
  "\u6050\u5413": 15,
  "\u8DF3\u8DC3": 20,
  "\u6CD5\u5F8B": 5,
  "\u56FE\u4E66\u9986": 20,
  "\u8046\u542C": 20,
  "\u9501\u5320": 1,
  "\u673A\u68B0\u7EF4\u4FEE": 10,
  "\u533B\u5B66": 1,
  "\u535A\u7269": 10,
  "\u5BFC\u822A": 10,
  "\u795E\u79D8\u5B66": 5,
  "\u514B\u82CF\u9C81": 0,
  "\u91CD\u578B\u673A\u68B0": 1,
  "\u8BF4\u670D": 10,
  "\u7CBE\u795E\u5206\u6790": 1,
  "\u5FC3\u7406\u5B66": 10,
  "\u9A91\u4E58": 5,
  "\u5999\u624B": 10,
  "\u4FA6\u67E5": 25,
  "\u6F5C\u884C": 20,
  "\u6E38\u6CF3": 20,
  "\u6295\u63B7": 20,
  "\u8FFD\u8E2A": 10,
  "\u9A6F\u517D": 5,
  "\u6F5C\u6C34": 1,
  "\u7206\u7834": 1,
  "\u8BFB\u5507": 1,
  "\u50AC\u7720": 1,
  "\u70AE\u672F": 1,
  "\u97AD": 5,
  "\u5200\u5251": 20,
  "\u6597\u6BB4": 25,
  "\u65A7": 15,
  "\u7EDE\u7D22": 15,
  "\u8FDE\u67B7": 10,
  "\u94FE\u952F": 10,
  "\u6B65\u67AA": 25,
  "\u51B2\u950B\u67AA": 15,
  "\u5F13": 15,
  "\u77DB": 20,
  "\u706B\u7130\u55B7\u5C04\u5668": 10,
  "\u673A\u67AA": 10,
  "\u624B\u67AA": 20,
  "\u9730\u5F39\u67AA": 25,
  "\u91CD\u6B66\u5668": 10,
  "\u8868\u6F14": 5,
  "\u7F8E\u672F": 5,
  "\u6444\u5F71": 5,
  "\u4F2A\u9020\u6587\u4E66": 5,
  "\u5730\u8D28\u5B66": 1,
  "\u52A8\u7269\u5B66": 1,
  "\u5316\u5B66": 1,
  "\u5BC6\u7801\u5B66": 1,
  "\u6C14\u8C61\u5B66": 1,
  "\u751F\u7269\u5B66": 1,
  "\u6570\u5B66": 10,
  "\u53F8\u6CD5\u79D1\u5B66": 1,
  "\u5929\u6587\u5B66": 1,
  "\u7269\u7406\u5B66": 1,
  "\u836F\u5B66": 1,
  "\u690D\u7269\u5B66": 1
});

// ../../packages/card/lib/general.js
class GeneralCard extends BaseCard {
  get HP() {
    return this.getEntry("HP")?.value;
  }
  get MAXHP() {
    return this.getEntry("MAXHP")?.value;
  }
  getAbility(input) {
    const key = input.toUpperCase();
    const ability = this.data.abilities.find((item) => item.key.toUpperCase() === key);
    if (ability) {
      return { input, key: ability.key, value: ability.value };
    }
    return;
  }
  setAbility(name, value) {
    const abilityRet = this.getAbility(name);
    if (abilityRet) {
      const ability = this.data.abilities.find((item) => item.key === abilityRet.key);
      if (ability.value !== value) {
        ability.value = value;
        this.data.lastModified = Date.now();
        return true;
      } else {
        return false;
      }
    } else {
      this.data.abilities.push({ key: name, value });
      this.data.lastModified = Date.now();
      return true;
    }
  }
  removeAbility(name) {
    const abilityRet = this.getAbility(name);
    if (abilityRet) {
      const index = this.data.abilities.findIndex((item) => item.key === abilityRet.key);
      if (index >= 0) {
        this.data.abilities.splice(index, 1);
        this.data.lastModified = Date.now();
        return true;
      }
    }
    return false;
  }
  getEntry(input) {
    const key = input.toUpperCase();
    const value = this.data.skills[key];
    if (typeof value !== "undefined") {
      return { input, key, value, isTemp: false };
    } else {
      return;
    }
  }
  setEntry(name, value) {
    const key = name.toUpperCase();
    const oldValue = this.data.skills[key];
    if (oldValue !== value) {
      this.data.skills[key] = value;
      this.data.lastModified = Date.now();
      this.emitCardEntryChange(key, value, oldValue);
      return true;
    }
    return false;
  }
  removeEntry(name) {
    const key = name.toUpperCase();
    const oldValue = this.data.skills[key];
    if (typeof oldValue !== "undefined") {
      delete this.data.skills[key];
      this.data.lastModified = Date.now();
      this.emitCardEntryChange(key, undefined, oldValue);
      return true;
    } else {
      return false;
    }
  }
  getSummary() {
    const skills = Object.entries(this.data.skills).map(([k, v]) => `${k}:${v}`).join(" ");
    const abilities = this.data.abilities.map((item) => `${item.key}:${item.value}`).join("\n");
    return "\u89D2\u8272\uFF1A" + this.name + "\n" + skills + "\n" + abilities;
  }
}

// ../../packages/card/lib/dnd.js
function getPropOfSkill(skill) {
  return _SKILL2PROP[skill];
}
var parseInput = function(expression) {
  let type = "none";
  if (expression.endsWith("\u8C03\u6574") || expression.endsWith("\u8C03\u6574\u503C") || expression.endsWith("\u4FEE\u6B63") || expression.endsWith("\u4FEE\u6B63\u503C")) {
    type = "modifier";
  } else if (expression.endsWith("\u8C41\u514D")) {
    type = "saving";
  }
  expression = expression.replace(/(||||)$/g, "");
  return [expression.trim(), type];
};
var calculatePropModifier = function(value) {
  return Math.floor(value / 2) - 5;
};
var clamp2 = function(num, min, max) {
  return Math.min(Math.max(num, min), max);
};

class DndCard extends BaseCard {
  defaultRoll = "d20";
  riDefaultRoll = "d20+{$\u654F\u6377\u8C03\u6574}[\u654F\u6377]+{$\u5148\u653B\u4E34\u65F6}[\u4E34\u65F6]";
  get HP() {
    return this.data.basic.HP;
  }
  set HP(value) {
    this.data.basic.HP = clamp2(value, 0, this.MAXHP);
  }
  get MAXHP() {
    return this.data.basic.MAXHP;
  }
  getAbility(input) {
    const possibleNames = this.getAliases(input);
    for (const key of possibleNames) {
      for (const type of ["spells", "equips"]) {
        const ability = this.data[type].find((item) => item.name.toUpperCase() === key);
        if (ability) {
          return { input, key: ability.name, value: ability.expression, type };
        }
      }
    }
    return;
  }
  setAbility(name, expression) {
    const abilityRet = this.getAbility(name);
    if (abilityRet) {
      const ability = this.data[abilityRet.type].find((item) => item.name === abilityRet.key);
      if (ability.expression !== expression) {
        ability.expression = expression;
        this.data.lastModified = Date.now();
        return true;
      } else {
        return false;
      }
    } else {
      this.data.equips.push({ name, expression, ext: "" });
      this.data.lastModified = Date.now();
      return true;
    }
  }
  removeAbility(name) {
    const abilityRet = this.getAbility(name);
    if (abilityRet) {
      const index = this.data[abilityRet.type].findIndex((item) => item.name === abilityRet.key);
      if (index >= 0) {
        this.data[abilityRet.type].splice(index, 1);
        this.data.lastModified = Date.now();
        return true;
      }
    }
    return false;
  }
  getValueByPostfix(type, key, value, postfix) {
    if (type === "props") {
      if (postfix === "modifier") {
        return calculatePropModifier(value);
      } else if (postfix === "saving") {
        const experienced = !!this.data.meta.experienced[key];
        return calculatePropModifier(value) + (experienced ? this.data.basic[""] : 0);
      }
    } else if (type === "skills") {
      if (postfix === "none") {
        const prop = getPropOfSkill(key);
        const modifiedValue = calculatePropModifier(this.data.props[prop]);
        const isExperienced = !!this.data.meta.experienced[key];
        return modifiedValue + value + (isExperienced ? this.data.basic[""] : 0);
      } else if (postfix === "modifier") {
        return value;
      }
    }
    return value;
  }
  getEntry(input) {
    const [skillName, postfix] = parseInput(input);
    if (!skillName)
      return;
    const possibleSkills = this.getAliases(skillName);
    for (const key of possibleSkills) {
      for (const type of ["items", "basic", "props", "skills"]) {
        const target = this.data[type][key];
        if (typeof target === "number") {
          const value = this.getValueByPostfix(type, key, target, postfix);
          return { input, key, value, isTemp: false, type, postfix };
        }
      }
    }
    return;
  }
  setEntry(name, value) {
    const [skillName, postfix] = parseInput(name);
    if (!skillName)
      return false;
    const _input = skillName.toUpperCase();
    const entry = this.getEntry(name);
    if (entry && entry.type === "basic") {
      const keyAsSpecialSetters = entry.key;
      if (SPECIAL_ENTRY_SETTERS2.includes(keyAsSpecialSetters)) {
        const oldValue = this[keyAsSpecialSetters];
        this[keyAsSpecialSetters] = value;
        const newValue = this[keyAsSpecialSetters];
        if (oldValue !== newValue) {
          this.data.lastModified = Date.now();
          this.emitCardEntryChange(entry.key, newValue, oldValue);
          return true;
        } else {
          return false;
        }
      }
    }
    if (entry) {
      if (value !== entry.value) {
        const oldValue = entry.value;
        this.data[entry.type][entry.key] = value;
        this.data.lastModified = Date.now();
        this.emitCardEntryChange(entry.key, value, oldValue);
        return true;
      } else {
        return false;
      }
    } else {
      this.data.items[_input] = value;
      this.data.lastModified = Date.now();
      this.emitCardEntryChange(_input, value, undefined);
      return true;
    }
  }
  removeEntry(name) {
    const [skillName, postfix] = parseInput(name);
    if (!skillName)
      return false;
    if (postfix !== "none")
      return false;
    const entry = this.getEntry(name);
    if (entry && entry.type === "items" && !["CP", "SP", "GP", "EP", "PP"].includes(entry.key)) {
      const oldValue = entry.value;
      delete this.data.items[entry.key];
      this.data.lastModified = Date.now();
      this.emitCardEntryChange(entry.key, undefined, oldValue);
      return true;
    } else {
      return false;
    }
  }
  markExperienced(skill) {
    const entry = this.getEntry(skill);
    if (!entry || !["props", "skills"].includes(entry.type))
      return false;
    const key = entry.key;
    if (this.data.meta.experienced[key]) {
      return false;
    } else {
      this.data.meta.experienced[key] = true;
      this.data.lastModified = Date.now();
      return true;
    }
  }
  cancelExperienced(skill) {
    let updated = false;
    const possibleSkills = this.getAliases(skill);
    possibleSkills.forEach((skill2) => {
      if (this.data.meta.experienced[skill2]) {
        delete this.data.meta.experienced[skill2];
        updated = true;
      }
    });
    return updated;
  }
  getEntryDisplay(name) {
    const entry = this.getEntry(name);
    if (entry) {
      const isExperienced = !!this.data.meta.experienced[entry.key];
      if (entry.type === "skills" && entry.postfix === "none") {
        const skillModifier = this.data.skills[entry.key];
        const skillSign = skillModifier > 0 ? "+" : "";
        return `${name}${isExperienced ? "*" : ""}:${entry.value}(${skillSign}${skillModifier})`;
      } else {
        return `${name}${isExperienced ? "*" : ""}:${entry.value}`;
      }
    }
    const ability = this.getAbility(name);
    if (ability) {
      return `${name}:${ability.value}`;
    }
    return `${name}:-`;
  }
  getSummary() {
    const _ = (name) => this.getEntry(name)?.value ?? "-";
    const basic = [
      `\u751F\u547D:${_("HP")}/${_("MAXHP")}`,
      `LV:${_("LV")}`,
      `AC:${_("AC")}`
    ].join(" ");
    const props = Object.keys(this.data.props).map((name) => this.getEntryDisplay(name)).join(" ");
    const skills = Object.keys(this.data.skills).map((name) => this.getEntryDisplay(name)).join(" ");
    const items = Object.entries(this.data.items).map(([k, v]) => `${k}:${v}`).join(" ");
    return "\u89D2\u8272\uFF1A" + this.name + "\n" + basic + "\n" + props + "\n" + skills + "\n" + items;
  }
  getAliases(name) {
    const _input = name.toUpperCase();
    return SKILL_ALIAS2[_input] ?? [_input];
  }
}
var SPECIAL_ENTRY_SETTERS2 = ["HP"];
var _PROP2SKILLS = Object.freeze({
  "\u529B\u91CF": ["\u8FD0\u52A8"],
  "\u654F\u6377": ["\u4F53\u64CD", "\u5DE7\u624B", "\u9690\u533F"],
  "\u667A\u529B": ["\u5965\u79D8", "\u5386\u53F2", "\u8C03\u67E5", "\u81EA\u7136", "\u5B97\u6559"],
  "\u611F\u77E5": ["\u9A6F\u517D", "\u6D1E\u6089", "\u533B\u7597", "\u5BDF\u89C9", "\u751F\u5B58"],
  "\u9B45\u529B": ["\u6B3A\u7792", "\u5A01\u5413", "\u8868\u6F14", "\u8BF4\u670D"]
});
var _SKILL2PROP = (() => {
  const ret = {};
  Object.keys(_PROP2SKILLS).forEach((prop) => {
    const skills = _PROP2SKILLS[prop];
    skills.forEach((skill) => {
      ret[skill] = prop;
    });
  });
  return ret;
})();
var _SKILL_ALIAS2 = Object.freeze([
  ["\u529B\u91CF", "STR"],
  ["\u654F\u6377", "DEX"],
  ["\u4F53\u8D28", "CON"],
  ["\u667A\u529B", "INT"],
  ["\u611F\u77E5", "WIS"],
  ["\u9B45\u529B", "CHA"],
  ["EXP", "XP", "\u7ECF\u9A8C", "\u7ECF\u9A8C\u503C"],
  ["LV", "LEVEL", "\u7B49\u7EA7"],
  ["\u751F\u547D", "HP", "\u751F\u547D\u503C"],
  ["\u751F\u547D\u4E0A\u9650", "MAXHP", "HPMAX", "\u751F\u547D\u503C\u4E0A\u9650"],
  ["AC", "\u62A4\u7532"],
  ["\u94DC\u5E01", "CP"],
  ["\u94F6\u5E01", "SP"],
  ["\u91D1\u5E01", "GP"],
  ["\u94F6\u91D1\u5E01", "EP"],
  ["\u94C2\u91D1\u5E01", "PP"],
  ["\u8BF4\u670D", "\u6E38\u8BF4"],
  ["\u533B\u7597", "\u533B\u836F"],
  ["\u751F\u5B58", "\u6C42\u751F"],
  ["\u4F53\u64CD", "\u7279\u6280"]
]);
var SKILL_ALIAS2 = _SKILL_ALIAS2.map((line) => line.reduce((obj, str) => Object.assign(obj, { [str]: line }), {})).reduce((total, obj) => Object.assign(total, obj), {});

// ../../packages/card/lib/utils/upgrade.js
function handleCardUpgrade(card) {
  if (card.version === 1) {
    card.meta.lastModified = 0;
    card.version = 2;
  }
  if (card.version === 2) {
    card.ext = "";
    card.abilities = [];
    card.version = 3;
  }
  if (card.version < 17) {
    card.basic.AGE = card.basic.age;
    delete card.basic.age;
    card.basic.HP = card.basic.hp;
    delete card.basic.hp;
    card.basic.SAN = card.basic.san;
    delete card.basic.san;
    card.basic.LUCK = card.basic.luck;
    delete card.basic.luck;
    card.basic.MP = card.basic.mp;
    delete card.basic.mp;
    card.basic.CM = card.skills[""] ?? card.skills[""] ?? card.skills.CM ?? card.skills.cm ?? 0;
    delete card.skills[""];
    delete card.skills[""];
    delete card.skills.CM;
    delete card.skills.cm;
    card.basic[""] = card.skills[""] ?? card.skills[""] ?? card.skills[""] ?? 0;
    delete card.skills[""];
    delete card.skills[""];
    delete card.skills[""];
    card.name = card.basic.name;
    delete card.basic.name;
    card.lastModified = card.meta.lastModified;
    delete card.meta.lastModified;
    card.type = "coc";
    card.version = 17;
  }
  if (card.version < 18) {
    if (card.type === "dnd") {
      card.jobAbilities = [];
      card.specialists = [];
      card.basic[""] = 0;
    }
    card.isTemplate = false;
    card.version = 18;
  }
  if (card.version < 22) {
    card.created = 0;
    card.version = 22;
  }
  return card;
}

// D:/workspace/qqchannel-bot/node_modules/@paotuan/card/lib/index.js
var createCard = function(data) {
  switch (data.type) {
    case "coc":
      return new CocCard(data);
    case "dnd":
      return new DndCard(data);
    case "general":
      return new GeneralCard(data);
    default:
      throw new Error("Invalid card type!");
  }
};

// ../../packages/dicecore/lib/card/card-linker.js
class DefaultCardLinker {
  channelLinkMap;
  constructor(map = {}) {
    this.channelLinkMap = map;
  }
  getLinkMap(channelUnionId) {
    if (!this.channelLinkMap[channelUnionId]) {
      this.channelLinkMap[channelUnionId] = {};
    }
    return this.channelLinkMap[channelUnionId];
  }
  linkCard(channelUnionId, cardId, userId) {
    const linkMap = this.getLinkMap(channelUnionId);
    const user2delete = Object.keys(linkMap).find((userId2) => linkMap[userId2] === cardId);
    if (user2delete) {
      delete linkMap[user2delete];
    }
    if (userId) {
      linkMap[userId] = cardId;
    }
    eventBus.emit("card-link-change", {
      channelUnionId,
      cardId,
      oldUserId: user2delete,
      userId
    });
  }
  deleteCard(cardId) {
    Object.keys(this.channelLinkMap).forEach((channelUnionId) => {
      const linkMap = this.channelLinkMap[channelUnionId];
      const user2delete = Object.keys(linkMap).find((uid) => linkMap[uid] === cardId);
      if (user2delete) {
        delete linkMap[user2delete];
        eventBus.emit("card-link-change", {
          channelUnionId,
          cardId,
          oldUserId: user2delete,
          userId: undefined
        });
      }
    });
  }
}

// ../../packages/dicecore/lib/card/card-provider.js
class CardProvider {
  static INSTANCE = new CardProvider;
  cardMap = new Map;
  _linker;
  constructor() {
  }
  get linker() {
    if (!this._linker) {
      this._linker = new DefaultCardLinker;
    }
    return this._linker;
  }
  setLinker(linker) {
    this._linker = linker;
  }
  registerCard(id, card2) {
    const oldCard = this.cardMap.get(id);
    oldCard?.removeCardEntryChangeListener();
    const newCard = createCard(card2);
    newCard.addCardEntryChangeListener((e) => eventBus.emit("card-entry-change", e));
    this.cardMap.set(id, newCard);
  }
  unregisterCard(id) {
    const oldCard = this.cardMap.get(id);
    if (oldCard) {
      oldCard.removeCardEntryChangeListener();
      this.cardMap.delete(id);
    }
    this.linker.deleteCard(id);
  }
  getCardById(id) {
    return this.cardMap.get(id);
  }
  getLinkMap(channelUnionId) {
    return this.linker.getLinkMap(channelUnionId);
  }
  getCard(channelUnionId, userId) {
    const linkMap = this.getLinkMap(channelUnionId);
    const cardId = linkMap[userId];
    return this.getCardById(cardId);
  }
  linkCard(channelUnionId, cardId, userId) {
    this.linker.linkCard(channelUnionId, cardId, userId);
  }
  queryCard(query = {}) {
    let list = Array.from(this.cardMap.values());
    if (typeof query.isTemplate === "boolean") {
      list = list.filter((data) => data.isTemplate === query.isTemplate);
    }
    if (Array.isArray(query.type)) {
      list = list.filter((data) => query.type.includes(data.type));
    }
    if (query.name) {
      const keyword = query.name.toLowerCase();
      list = list.filter((data) => data.name.toLowerCase().includes(keyword));
    }
    return list;
  }
}

// ../../node_modules/mathjs/lib/esm/entry/configReadonly.js
var extends2 = __toESM(require_extends(), 1);

// ../../node_modules/mathjs/lib/esm/core/config.js
var DEFAULT_CONFIG = {
  epsilon: 0.000000000001,
  matrix: "Matrix",
  number: "number",
  precision: 64,
  predictable: false,
  randomSeed: null
};

// ../../node_modules/mathjs/lib/esm/utils/is.js
function isNumber(x) {
  return typeof x === "number";
}
function isBigNumber(x) {
  if (!x || typeof x !== "object" || typeof x.constructor !== "function") {
    return false;
  }
  if (x.isBigNumber === true && typeof x.constructor.prototype === "object" && x.constructor.prototype.isBigNumber === true) {
    return true;
  }
  if (typeof x.constructor.isDecimal === "function" && x.constructor.isDecimal(x) === true) {
    return true;
  }
  return false;
}
function isComplex(x) {
  return x && typeof x === "object" && Object.getPrototypeOf(x).isComplex === true || false;
}
function isFraction(x) {
  return x && typeof x === "object" && Object.getPrototypeOf(x).isFraction === true || false;
}
function isUnit(x) {
  return x && x.constructor.prototype.isUnit === true || false;
}
function isString(x) {
  return typeof x === "string";
}
function isMatrix(x) {
  return x && x.constructor.prototype.isMatrix === true || false;
}
function isCollection(x) {
  return Array.isArray(x) || isMatrix(x);
}
function isDenseMatrix(x) {
  return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
}
function isSparseMatrix(x) {
  return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
}
function isRange(x) {
  return x && x.constructor.prototype.isRange === true || false;
}
function isIndex(x) {
  return x && x.constructor.prototype.isIndex === true || false;
}
function isBoolean(x) {
  return typeof x === "boolean";
}
function isResultSet(x) {
  return x && x.constructor.prototype.isResultSet === true || false;
}
function isHelp(x) {
  return x && x.constructor.prototype.isHelp === true || false;
}
function isFunction(x) {
  return typeof x === "function";
}
function isDate(x) {
  return x instanceof Date;
}
function isRegExp(x) {
  return x instanceof RegExp;
}
function isObject(x) {
  return !!(x && typeof x === "object" && x.constructor === Object && !isComplex(x) && !isFraction(x));
}
function isNull(x) {
  return x === null;
}
function isUndefined(x) {
  return x === undefined;
}
function isAccessorNode(x) {
  return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
}
function isArrayNode(x) {
  return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
}
function isAssignmentNode(x) {
  return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
}
function isBlockNode(x) {
  return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
}
function isConditionalNode(x) {
  return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
}
function isConstantNode(x) {
  return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
}
function rule2Node(node) {
  return isConstantNode(node) || isOperatorNode(node) && node.args.length === 1 && isConstantNode(node.args[0]) && "-+~".includes(node.op);
}
function isFunctionAssignmentNode(x) {
  return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
}
function isFunctionNode(x) {
  return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
}
function isIndexNode(x) {
  return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
}
function isNode(x) {
  return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
}
function isObjectNode(x) {
  return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
}
function isOperatorNode(x) {
  return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
}
function isParenthesisNode(x) {
  return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
}
function isRangeNode(x) {
  return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
}
function isRelationalNode(x) {
  return x && x.isRelationalNode === true && x.constructor.prototype.isNode === true || false;
}
function isSymbolNode(x) {
  return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
}
function isChain(x) {
  return x && x.constructor.prototype.isChain === true || false;
}
function typeOf(x) {
  var t = typeof x;
  if (t === "object") {
    if (x === null)
      return "null";
    if (isBigNumber(x))
      return "BigNumber";
    if (x.constructor && x.constructor.name)
      return x.constructor.name;
    return "Object";
  }
  return t;
}
var isArray = Array.isArray;

// ../../node_modules/mathjs/lib/esm/utils/object.js
function clone(x) {
  var type = typeof x;
  if (type === "number" || type === "string" || type === "boolean" || x === null || x === undefined) {
    return x;
  }
  if (typeof x.clone === "function") {
    return x.clone();
  }
  if (Array.isArray(x)) {
    return x.map(function(value) {
      return clone(value);
    });
  }
  if (x instanceof Date)
    return new Date(x.valueOf());
  if (isBigNumber(x))
    return x;
  if (x instanceof RegExp)
    throw new TypeError("Cannot clone " + x);
  return mapObject(x, clone);
}
function mapObject(object, callback) {
  var clone2 = {};
  for (var key in object) {
    if (hasOwnProperty2(object, key)) {
      clone2[key] = callback(object[key]);
    }
  }
  return clone2;
}
function extend(a, b) {
  for (var prop in b) {
    if (hasOwnProperty2(b, prop)) {
      a[prop] = b[prop];
    }
  }
  return a;
}
function deepStrictEqual(a, b) {
  var prop, i, len;
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (i = 0, len = a.length;i < len; i++) {
      if (!deepStrictEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  } else if (typeof a === "function") {
    return a === b;
  } else if (a instanceof Object) {
    if (Array.isArray(b) || !(b instanceof Object)) {
      return false;
    }
    for (prop in a) {
      if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
        return false;
      }
    }
    for (prop in b) {
      if (!(prop in a)) {
        return false;
      }
    }
    return true;
  } else {
    return a === b;
  }
}
function lazy(object, prop, valueResolver) {
  var _uninitialized = true;
  var _value;
  Object.defineProperty(object, prop, {
    get: function get() {
      if (_uninitialized) {
        _value = valueResolver();
        _uninitialized = false;
      }
      return _value;
    },
    set: function set(value) {
      _value = value;
      _uninitialized = false;
    },
    configurable: true,
    enumerable: true
  });
}
function hasOwnProperty2(object, property) {
  return object && Object.hasOwnProperty.call(object, property);
}
function pickShallow(object, properties) {
  var copy = {};
  for (var i = 0;i < properties.length; i++) {
    var key = properties[i];
    var value = object[key];
    if (value !== undefined) {
      copy[key] = value;
    }
  }
  return copy;
}

// ../../node_modules/mathjs/lib/esm/core/function/config.js
var MATRIX_OPTIONS = ["Matrix", "Array"];
var NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"];

// ../../node_modules/mathjs/lib/esm/entry/configReadonly.js
var config3 = function config4(options) {
  if (options) {
    throw new Error("The globalThis config is readonly. \n" + "Please create a mathjs instance if you want to change the default configuration. \n" + "Example:\n" + "\n" + "  import { create, all } from \'mathjs\';\n" + "  const mathjs = create(all);\n" + "  mathjs.config({ number: \'BigNumber\' });\n");
  }
  return Object.freeze(DEFAULT_CONFIG);
};
extends2.default(config3, DEFAULT_CONFIG, {
  MATRIX_OPTIONS,
  NUMBER_OPTIONS
});

// ../../node_modules/mathjs/lib/esm/core/function/typed.js
var import_typed_function = __toESM(require_typed_function(), 1);

// ../../node_modules/mathjs/lib/esm/utils/number.js
function isInteger(value) {
  if (typeof value === "boolean") {
    return true;
  }
  return isFinite(value) ? value === Math.round(value) : false;
}
var formatNumberToBase = function(n, base, size) {
  var prefixes = {
    2: "0b",
    8: "0o",
    16: "0x"
  };
  var prefix = prefixes[base];
  var suffix = "";
  if (size) {
    if (size < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger(size)) {
      throw new Error("size must be an integer");
    }
    if (n > 2 ** (size - 1) - 1 || n < -(2 ** (size - 1))) {
      throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
    }
    if (!isInteger(n)) {
      throw new Error("Value must be an integer");
    }
    if (n < 0) {
      n = n + 2 ** size;
    }
    suffix = "i".concat(size);
  }
  var sign = "";
  if (n < 0) {
    n = -n;
    sign = "-";
  }
  return "".concat(sign).concat(prefix).concat(n.toString(base)).concat(suffix);
};
function format(value, options) {
  if (typeof options === "function") {
    return options(value);
  }
  if (value === Infinity) {
    return "Infinity";
  } else if (value === -Infinity) {
    return "-Infinity";
  } else if (isNaN(value)) {
    return "NaN";
  }
  var notation = "auto";
  var precision;
  var wordSize;
  if (options) {
    if (options.notation) {
      notation = options.notation;
    }
    if (isNumber(options)) {
      precision = options;
    } else if (isNumber(options.precision)) {
      precision = options.precision;
    }
    if (options.wordSize) {
      wordSize = options.wordSize;
      if (typeof wordSize !== "number") {
        throw new Error('Option "wordSize" must be a number');
      }
    }
  }
  switch (notation) {
    case "fixed":
      return toFixed(value, precision);
    case "exponential":
      return toExponential(value, precision);
    case "engineering":
      return toEngineering(value, precision);
    case "bin":
      return formatNumberToBase(value, 2, wordSize);
    case "oct":
      return formatNumberToBase(value, 8, wordSize);
    case "hex":
      return formatNumberToBase(value, 16, wordSize);
    case "auto":
      return toPrecision(value, precision, options && options).replace(/((\.\d*?)(0+))($|e)/, function() {
        var digits = arguments[2];
        var e = arguments[4];
        return digits !== "." ? digits + e : e;
      });
    default:
      throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function splitNumber(value) {
  var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
  if (!match) {
    throw new SyntaxError("Invalid number " + value);
  }
  var sign = match[1];
  var digits = match[2];
  var exponent = parseFloat(match[4] || "0");
  var dot = digits.indexOf(".");
  exponent += dot !== -1 ? dot - 1 : digits.length - 1;
  var coefficients = digits.replace(".", "").replace(/^0*/, function(zeros) {
    exponent -= zeros.length;
    return "";
  }).replace(/0*$/, "").split("").map(function(d) {
    return parseInt(d);
  });
  if (coefficients.length === 0) {
    coefficients.push(0);
    exponent++;
  }
  return {
    sign,
    coefficients,
    exponent
  };
}
function toEngineering(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var split = splitNumber(value);
  var rounded = roundDigits(split, precision);
  var e = rounded.exponent;
  var c = rounded.coefficients;
  var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
  if (isNumber(precision)) {
    while (precision > c.length || e - newExp + 1 > c.length) {
      c.push(0);
    }
  } else {
    var missingZeros = Math.abs(e - newExp) - (c.length - 1);
    for (var i = 0;i < missingZeros; i++) {
      c.push(0);
    }
  }
  var expDiff = Math.abs(e - newExp);
  var decimalIdx = 1;
  while (expDiff > 0) {
    decimalIdx++;
    expDiff--;
  }
  var decimals = c.slice(decimalIdx).join("");
  var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
  var str = c.slice(0, decimalIdx).join("") + decimalVal + "e" + (e >= 0 ? "+" : "") + newExp.toString();
  return rounded.sign + str;
}
function toFixed(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var splitValue = splitNumber(value);
  var rounded = typeof precision === "number" ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
  var c = rounded.coefficients;
  var p = rounded.exponent + 1;
  var pp = p + (precision || 0);
  if (c.length < pp) {
    c = c.concat(zeros(pp - c.length));
  }
  if (p < 0) {
    c = zeros(-p + 1).concat(c);
    p = 1;
  }
  if (p < c.length) {
    c.splice(p, 0, p === 0 ? "0." : ".");
  }
  return rounded.sign + c.join("");
}
function toExponential(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var split = splitNumber(value);
  var rounded = precision ? roundDigits(split, precision) : split;
  var c = rounded.coefficients;
  var e = rounded.exponent;
  if (c.length < precision) {
    c = c.concat(zeros(precision - c.length));
  }
  var first = c.shift();
  return rounded.sign + first + (c.length > 0 ? "." + c.join("") : "") + "e" + (e >= 0 ? "+" : "") + e;
}
function toPrecision(value, precision, options) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;
  var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5;
  var split = splitNumber(value);
  var rounded = precision ? roundDigits(split, precision) : split;
  if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
    return toExponential(value, precision);
  } else {
    var c = rounded.coefficients;
    var e = rounded.exponent;
    if (c.length < precision) {
      c = c.concat(zeros(precision - c.length));
    }
    c = c.concat(zeros(e - c.length + 1 + (c.length < precision ? precision - c.length : 0)));
    c = zeros(-e).concat(c);
    var dot = e > 0 ? e : 0;
    if (dot < c.length - 1) {
      c.splice(dot + 1, 0, ".");
    }
    return rounded.sign + c.join("");
  }
}
function roundDigits(split, precision) {
  var rounded = {
    sign: split.sign,
    coefficients: split.coefficients,
    exponent: split.exponent
  };
  var c = rounded.coefficients;
  while (precision <= 0) {
    c.unshift(0);
    rounded.exponent++;
    precision++;
  }
  if (c.length > precision) {
    var removed = c.splice(precision, c.length - precision);
    if (removed[0] >= 5) {
      var i = precision - 1;
      c[i]++;
      while (c[i] === 10) {
        c.pop();
        if (i === 0) {
          c.unshift(0);
          rounded.exponent++;
          i++;
        }
        i--;
        c[i]++;
      }
    }
  }
  return rounded;
}
var zeros = function(length) {
  var arr = [];
  for (var i = 0;i < length; i++) {
    arr.push(0);
  }
  return arr;
};
function digits(value) {
  return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
}
function nearlyEqual(x, y, epsilon) {
  if (epsilon === null || epsilon === undefined) {
    return x === y;
  }
  if (x === y) {
    return true;
  }
  if (isNaN(x) || isNaN(y)) {
    return false;
  }
  if (isFinite(x) && isFinite(y)) {
    var diff = Math.abs(x - y);
    if (diff < DBL_EPSILON) {
      return true;
    } else {
      return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
    }
  }
  return false;
}
function copysign(x, y) {
  var signx = x > 0 ? true : x < 0 ? false : 1 / x === Infinity;
  var signy = y > 0 ? true : y < 0 ? false : 1 / y === Infinity;
  return signx ^ signy ? -x : x;
}
var sign = Math.sign || function(x) {
  if (x > 0) {
    return 1;
  } else if (x < 0) {
    return -1;
  } else {
    return 0;
  }
};
var log2 = Math.log2 || function log22(x) {
  return Math.log(x) / Math.LN2;
};
var log10 = Math.log10 || function log102(x) {
  return Math.log(x) / Math.LN10;
};
var log1p = Math.log1p || function(x) {
  return Math.log(x + 1);
};
var cbrt = Math.cbrt || function cbrt2(x) {
  if (x === 0) {
    return x;
  }
  var negate = x < 0;
  var result;
  if (negate) {
    x = -x;
  }
  if (isFinite(x)) {
    result = Math.exp(Math.log(x) / 3);
    result = (x / (result * result) + 2 * result) / 3;
  } else {
    result = x;
  }
  return negate ? -result : result;
};
var expm1 = Math.expm1 || function expm12(x) {
  return x >= 0.0002 || x <= -0.0002 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;
};
var DBL_EPSILON = Number.EPSILON || 0.0000000000000002220446049250313;
var acosh = Math.acosh || function(x) {
  return Math.log(Math.sqrt(x * x - 1) + x);
};
var asinh = Math.asinh || function(x) {
  return Math.log(Math.sqrt(x * x + 1) + x);
};
var atanh = Math.atanh || function(x) {
  return Math.log((1 + x) / (1 - x)) / 2;
};
var cosh = Math.cosh || function(x) {
  return (Math.exp(x) + Math.exp(-x)) / 2;
};
var sinh = Math.sinh || function(x) {
  return (Math.exp(x) - Math.exp(-x)) / 2;
};
var tanh = Math.tanh || function(x) {
  var e = Math.exp(2 * x);
  return (e - 1) / (e + 1);
};

// ../../node_modules/mathjs/lib/esm/utils/bignumber/formatter.js
var formatBigNumberToBase = function(n, base, size) {
  var BigNumberCtor = n.constructor;
  var big2 = new BigNumberCtor(2);
  var suffix = "";
  if (size) {
    if (size < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger(size)) {
      throw new Error("size must be an integer");
    }
    if (n.greaterThan(big2.pow(size - 1).sub(1)) || n.lessThan(big2.pow(size - 1).mul(-1))) {
      throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
    }
    if (!n.isInteger()) {
      throw new Error("Value must be an integer");
    }
    if (n.lessThan(0)) {
      n = n.add(big2.pow(size));
    }
    suffix = "i".concat(size);
  }
  switch (base) {
    case 2:
      return "".concat(n.toBinary()).concat(suffix);
    case 8:
      return "".concat(n.toOctal()).concat(suffix);
    case 16:
      return "".concat(n.toHexadecimal()).concat(suffix);
    default:
      throw new Error("Base ".concat(base, " not supported "));
  }
};
function format2(value, options) {
  if (typeof options === "function") {
    return options(value);
  }
  if (!value.isFinite()) {
    return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
  }
  var notation = "auto";
  var precision;
  var wordSize;
  if (options !== undefined) {
    if (options.notation) {
      notation = options.notation;
    }
    if (typeof options === "number") {
      precision = options;
    } else if (options.precision) {
      precision = options.precision;
    }
    if (options.wordSize) {
      wordSize = options.wordSize;
      if (typeof wordSize !== "number") {
        throw new Error('Option "wordSize" must be a number');
      }
    }
  }
  switch (notation) {
    case "fixed":
      return toFixed2(value, precision);
    case "exponential":
      return toExponential2(value, precision);
    case "engineering":
      return toEngineering2(value, precision);
    case "bin":
      return formatBigNumberToBase(value, 2, wordSize);
    case "oct":
      return formatBigNumberToBase(value, 8, wordSize);
    case "hex":
      return formatBigNumberToBase(value, 16, wordSize);
    case "auto": {
      var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;
      var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5;
      if (value.isZero())
        return "0";
      var str;
      var rounded = value.toSignificantDigits(precision);
      var exp = rounded.e;
      if (exp >= lowerExp && exp < upperExp) {
        str = rounded.toFixed();
      } else {
        str = toExponential2(value, precision);
      }
      return str.replace(/((\.\d*?)(0+))($|e)/, function() {
        var digits2 = arguments[2];
        var e = arguments[4];
        return digits2 !== "." ? digits2 + e : e;
      });
    }
    default:
      throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function toEngineering2(value, precision) {
  var e = value.e;
  var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
  var valueWithoutExp = value.mul(Math.pow(10, -newExp));
  var valueStr = valueWithoutExp.toPrecision(precision);
  if (valueStr.indexOf("e") !== -1) {
    valueStr = valueWithoutExp.toString();
  }
  return valueStr + "e" + (e >= 0 ? "+" : "") + newExp.toString();
}
function toExponential2(value, precision) {
  if (precision !== undefined) {
    return value.toExponential(precision - 1);
  } else {
    return value.toExponential();
  }
}
function toFixed2(value, precision) {
  return value.toFixed(precision);
}

// ../../node_modules/mathjs/lib/esm/utils/string.js
function endsWith(text, search) {
  var start = text.length - search.length;
  var end = text.length;
  return text.substring(start, end) === search;
}
function format3(value, options) {
  var result = _format(value, options);
  if (options && typeof options === "object" && "truncate" in options && result.length > options.truncate) {
    return result.substring(0, options.truncate - 3) + "...";
  }
  return result;
}
var _format = function(value, options) {
  if (typeof value === "number") {
    return format(value, options);
  }
  if (isBigNumber(value)) {
    return format2(value, options);
  }
  if (looksLikeFraction(value)) {
    if (!options || options.fraction !== "decimal") {
      return value.s * value.n + "/" + value.d;
    } else {
      return value.toString();
    }
  }
  if (Array.isArray(value)) {
    return formatArray(value, options);
  }
  if (isString(value)) {
    return '"' + value + '"';
  }
  if (typeof value === "function") {
    return value.syntax ? String(value.syntax) : "function";
  }
  if (value && typeof value === "object") {
    if (typeof value.format === "function") {
      return value.format(options);
    } else if (value && value.toString(options) !== {}.toString()) {
      return value.toString(options);
    } else {
      var entries = Object.keys(value).map((key) => {
        return '"' + key + '": ' + format3(value[key], options);
      });
      return "{" + entries.join(", ") + "}";
    }
  }
  return String(value);
};
function stringify(value) {
  var text = String(value);
  var escaped = "";
  var i = 0;
  while (i < text.length) {
    var c = text.charAt(i);
    if (c === "\\") {
      escaped += c;
      i++;
      c = text.charAt(i);
      if (c === "" || '"\\/bfnrtu'.indexOf(c) === -1) {
        escaped += "\\";
      }
      escaped += c;
    } else if (c === '"') {
      escaped += '\\"';
    } else {
      escaped += c;
    }
    i++;
  }
  return '"' + escaped + '"';
}
function escape(value) {
  var text = String(value);
  text = text.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  return text;
}
var formatArray = function(array, options) {
  if (Array.isArray(array)) {
    var str = "[";
    var len = array.length;
    for (var i = 0;i < len; i++) {
      if (i !== 0) {
        str += ", ";
      }
      str += formatArray(array[i], options);
    }
    str += "]";
    return str;
  } else {
    return format3(array, options);
  }
};
var looksLikeFraction = function(value) {
  return value && typeof value === "object" && typeof value.s === "number" && typeof value.n === "number" && typeof value.d === "number" || false;
};
function compareText(x, y) {
  if (!isString(x)) {
    throw new TypeError("Unexpected type of argument in function compareText " + "(expected: string or Array or Matrix, actual: " + typeOf(x) + ", index: 0)");
  }
  if (!isString(y)) {
    throw new TypeError("Unexpected type of argument in function compareText " + "(expected: string or Array or Matrix, actual: " + typeOf(y) + ", index: 1)");
  }
  return x === y ? 0 : x > y ? 1 : -1;
}

// ../../node_modules/mathjs/lib/esm/error/DimensionError.js
function DimensionError(actual, expected, relation) {
  if (!(this instanceof DimensionError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.actual = actual;
  this.expected = expected;
  this.relation = relation;
  this.message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (this.relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
  this.stack = new Error().stack;
}
DimensionError.prototype = new RangeError;
DimensionError.prototype.constructor = RangeError;
DimensionError.prototype.name = "DimensionError";
DimensionError.prototype.isDimensionError = true;

// ../../node_modules/mathjs/lib/esm/error/IndexError.js
function IndexError(index, min, max) {
  if (!(this instanceof IndexError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.index = index;
  if (arguments.length < 3) {
    this.min = 0;
    this.max = min;
  } else {
    this.min = min;
    this.max = max;
  }
  if (this.min !== undefined && this.index < this.min) {
    this.message = "Index out of range (" + this.index + " < " + this.min + ")";
  } else if (this.max !== undefined && this.index >= this.max) {
    this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")";
  } else {
    this.message = "Index out of range (" + this.index + ")";
  }
  this.stack = new Error().stack;
}
IndexError.prototype = new RangeError;
IndexError.prototype.constructor = RangeError;
IndexError.prototype.name = "IndexError";
IndexError.prototype.isIndexError = true;

// ../../node_modules/mathjs/lib/esm/utils/array.js
function arraySize(x) {
  var s = [];
  while (Array.isArray(x)) {
    s.push(x.length);
    x = x[0];
  }
  return s;
}
var _validate = function(array, size, dim) {
  var i;
  var len = array.length;
  if (len !== size[dim]) {
    throw new DimensionError(len, size[dim]);
  }
  if (dim < size.length - 1) {
    var dimNext = dim + 1;
    for (i = 0;i < len; i++) {
      var child = array[i];
      if (!Array.isArray(child)) {
        throw new DimensionError(size.length - 1, size.length, "<");
      }
      _validate(array[i], size, dimNext);
    }
  } else {
    for (i = 0;i < len; i++) {
      if (Array.isArray(array[i])) {
        throw new DimensionError(size.length + 1, size.length, ">");
      }
    }
  }
};
function validate(array, size) {
  var isScalar = size.length === 0;
  if (isScalar) {
    if (Array.isArray(array)) {
      throw new DimensionError(array.length, 0);
    }
  } else {
    _validate(array, size, 0);
  }
}
function validateIndex(index, length) {
  if (!isNumber(index) || !isInteger(index)) {
    throw new TypeError("Index must be an integer (value: " + index + ")");
  }
  if (index < 0 || typeof length === "number" && index >= length) {
    throw new IndexError(index, length);
  }
}
function resize(array, size, defaultValue) {
  if (!Array.isArray(array) || !Array.isArray(size)) {
    throw new TypeError("Array expected");
  }
  if (size.length === 0) {
    throw new Error("Resizing to scalar is not supported");
  }
  size.forEach(function(value) {
    if (!isNumber(value) || !isInteger(value) || value < 0) {
      throw new TypeError("Invalid size, must contain positive integers " + "(size: " + format3(size) + ")");
    }
  });
  var _defaultValue = defaultValue !== undefined ? defaultValue : 0;
  _resize(array, size, 0, _defaultValue);
  return array;
}
var _resize = function(array, size, dim, defaultValue) {
  var i;
  var elem;
  var oldLen = array.length;
  var newLen = size[dim];
  var minLen = Math.min(oldLen, newLen);
  array.length = newLen;
  if (dim < size.length - 1) {
    var dimNext = dim + 1;
    for (i = 0;i < minLen; i++) {
      elem = array[i];
      if (!Array.isArray(elem)) {
        elem = [elem];
        array[i] = elem;
      }
      _resize(elem, size, dimNext, defaultValue);
    }
    for (i = minLen;i < newLen; i++) {
      elem = [];
      array[i] = elem;
      _resize(elem, size, dimNext, defaultValue);
    }
  } else {
    for (i = 0;i < minLen; i++) {
      while (Array.isArray(array[i])) {
        array[i] = array[i][0];
      }
    }
    for (i = minLen;i < newLen; i++) {
      array[i] = defaultValue;
    }
  }
};
function reshape(array, sizes) {
  var flatArray = flatten(array);
  var currentLength = flatArray.length;
  if (!Array.isArray(array) || !Array.isArray(sizes)) {
    throw new TypeError("Array expected");
  }
  if (sizes.length === 0) {
    throw new DimensionError(0, currentLength, "!=");
  }
  sizes = processSizesWildcard(sizes, currentLength);
  var newLength = product(sizes);
  if (currentLength !== newLength) {
    throw new DimensionError(newLength, currentLength, "!=");
  }
  try {
    return _reshape(flatArray, sizes);
  } catch (e) {
    if (e instanceof DimensionError) {
      throw new DimensionError(newLength, currentLength, "!=");
    }
    throw e;
  }
}
function processSizesWildcard(sizes, currentLength) {
  var newLength = product(sizes);
  var processedSizes = sizes.slice();
  var WILDCARD = -1;
  var wildCardIndex = sizes.indexOf(WILDCARD);
  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
  if (isMoreThanOneWildcard) {
    throw new Error("More than one wildcard in sizes");
  }
  var hasWildcard = wildCardIndex >= 0;
  var canReplaceWildcard = currentLength % newLength === 0;
  if (hasWildcard) {
    if (canReplaceWildcard) {
      processedSizes[wildCardIndex] = -currentLength / newLength;
    } else {
      throw new Error("Could not replace wildcard, since " + currentLength + " is no multiple of " + -newLength);
    }
  }
  return processedSizes;
}
var product = function(array) {
  return array.reduce((prev, curr) => prev * curr, 1);
};
var _reshape = function(array, sizes) {
  var tmpArray = array;
  var tmpArray2;
  for (var sizeIndex = sizes.length - 1;sizeIndex > 0; sizeIndex--) {
    var size = sizes[sizeIndex];
    tmpArray2 = [];
    var length = tmpArray.length / size;
    for (var i = 0;i < length; i++) {
      tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
    }
    tmpArray = tmpArray2;
  }
  return tmpArray;
};
function squeeze(array, size) {
  var s = size || arraySize(array);
  while (Array.isArray(array) && array.length === 1) {
    array = array[0];
    s.shift();
  }
  var dims = s.length;
  while (s[dims - 1] === 1) {
    dims--;
  }
  if (dims < s.length) {
    array = _squeeze(array, dims, 0);
    s.length = dims;
  }
  return array;
}
var _squeeze = function(array, dims, dim) {
  var i, ii;
  if (dim < dims) {
    var next = dim + 1;
    for (i = 0, ii = array.length;i < ii; i++) {
      array[i] = _squeeze(array[i], dims, next);
    }
  } else {
    while (Array.isArray(array)) {
      array = array[0];
    }
  }
  return array;
};
function unsqueeze(array, dims, outer, size) {
  var s = size || arraySize(array);
  if (outer) {
    for (var i = 0;i < outer; i++) {
      array = [array];
      s.unshift(1);
    }
  }
  array = _unsqueeze(array, dims, 0);
  while (s.length < dims) {
    s.push(1);
  }
  return array;
}
var _unsqueeze = function(array, dims, dim) {
  var i, ii;
  if (Array.isArray(array)) {
    var next = dim + 1;
    for (i = 0, ii = array.length;i < ii; i++) {
      array[i] = _unsqueeze(array[i], dims, next);
    }
  } else {
    for (var d = dim;d < dims; d++) {
      array = [array];
    }
  }
  return array;
};
function flatten(array) {
  if (!Array.isArray(array)) {
    return array;
  }
  var flat = [];
  array.forEach(function callback(value) {
    if (Array.isArray(value)) {
      value.forEach(callback);
    } else {
      flat.push(value);
    }
  });
  return flat;
}
function map(array, callback) {
  return Array.prototype.map.call(array, callback);
}
function forEach(array, callback) {
  Array.prototype.forEach.call(array, callback);
}
function filter(array, callback) {
  if (arraySize(array).length !== 1) {
    throw new Error("Only one dimensional matrices supported");
  }
  return Array.prototype.filter.call(array, callback);
}
function filterRegExp(array, regexp) {
  if (arraySize(array).length !== 1) {
    throw new Error("Only one dimensional matrices supported");
  }
  return Array.prototype.filter.call(array, (entry) => regexp.test(entry));
}
function join(array, separator) {
  return Array.prototype.join.call(array, separator);
}
function identify(a) {
  if (!Array.isArray(a)) {
    throw new TypeError("Array input expected");
  }
  if (a.length === 0) {
    return a;
  }
  var b = [];
  var count = 0;
  b[0] = {
    value: a[0],
    identifier: 0
  };
  for (var i = 1;i < a.length; i++) {
    if (a[i] === a[i - 1]) {
      count++;
    } else {
      count = 0;
    }
    b.push({
      value: a[i],
      identifier: count
    });
  }
  return b;
}
function generalize(a) {
  if (!Array.isArray(a)) {
    throw new TypeError("Array input expected");
  }
  if (a.length === 0) {
    return a;
  }
  var b = [];
  for (var i = 0;i < a.length; i++) {
    b.push(a[i].value);
  }
  return b;
}
function getArrayDataType(array, typeOf2) {
  var type;
  var length = 0;
  for (var i = 0;i < array.length; i++) {
    var item = array[i];
    var isArray2 = Array.isArray(item);
    if (i === 0 && isArray2) {
      length = item.length;
    }
    if (isArray2 && item.length !== length) {
      return;
    }
    var itemType = isArray2 ? getArrayDataType(item, typeOf2) : typeOf2(item);
    if (type === undefined) {
      type = itemType;
    } else if (type !== itemType) {
      return "mixed";
    } else {
    }
  }
  return type;
}

// ../../node_modules/mathjs/lib/esm/utils/factory.js
function factory(name, dependencies, create, meta) {
  function assertAndCreate(scope) {
    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));
    assertDependencies(name, dependencies, scope);
    return create(deps);
  }
  assertAndCreate.isFactory = true;
  assertAndCreate.fn = name;
  assertAndCreate.dependencies = dependencies.slice().sort();
  if (meta) {
    assertAndCreate.meta = meta;
  }
  return assertAndCreate;
}
function assertDependencies(name, dependencies, scope) {
  var allDefined = dependencies.filter((dependency) => !isOptionalDependency(dependency)).every((dependency) => scope[dependency] !== undefined);
  if (!allDefined) {
    var missingDependencies = dependencies.filter((dependency) => scope[dependency] === undefined);
    throw new Error("Cannot create function \"".concat(name, "\", ") + "some dependencies are missing: ".concat(missingDependencies.map((d) => "\"".concat(d, "\"")).join(", "), "."));
  }
}
function isOptionalDependency(dependency) {
  return dependency && dependency[0] === "?";
}
function stripOptionalNotation(dependency) {
  return dependency && dependency[0] === "?" ? dependency.slice(1) : dependency;
}

// ../../node_modules/mathjs/lib/esm/utils/customs.js
var getSafeProperty = function(object3, prop) {
  if (isPlainObject(object3) && isSafeProperty(object3, prop)) {
    return object3[prop];
  }
  if (typeof object3[prop] === "function" && isSafeMethod(object3, prop)) {
    throw new Error('Cannot access method "' + prop + '" as a property');
  }
  throw new Error('No access to property "' + prop + '"');
};
var setSafeProperty = function(object3, prop, value) {
  if (isPlainObject(object3) && isSafeProperty(object3, prop)) {
    object3[prop] = value;
    return value;
  }
  throw new Error('No access to property "' + prop + '"');
};
var hasSafeProperty = function(object3, prop) {
  return prop in object3;
};
var isSafeProperty = function(object3, prop) {
  if (!object3 || typeof object3 !== "object") {
    return false;
  }
  if (hasOwnProperty2(safeNativeProperties, prop)) {
    return true;
  }
  if (prop in Object.prototype) {
    return false;
  }
  if (prop in Function.prototype) {
    return false;
  }
  return true;
};
var validateSafeMethod = function(object3, method) {
  if (!isSafeMethod(object3, method)) {
    throw new Error('No access to method "' + method + '"');
  }
};
var isSafeMethod = function(object3, method) {
  if (object3 === null || object3 === undefined || typeof object3[method] !== "function") {
    return false;
  }
  if (hasOwnProperty2(object3, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object3)) {
    return false;
  }
  if (hasOwnProperty2(safeNativeMethods, method)) {
    return true;
  }
  if (method in Object.prototype) {
    return false;
  }
  if (method in Function.prototype) {
    return false;
  }
  return true;
};
var isPlainObject = function(object3) {
  return typeof object3 === "object" && object3 && object3.constructor === Object;
};
var safeNativeProperties = {
  length: true,
  name: true
};
var safeNativeMethods = {
  toString: true,
  valueOf: true,
  toLocaleString: true
};

// ../../node_modules/mathjs/lib/esm/utils/map.js
function createEmptyMap() {
  return new Map;
}
function createMap(mapOrObject) {
  if (!mapOrObject) {
    return createEmptyMap();
  }
  if (isMap(mapOrObject)) {
    return mapOrObject;
  }
  if (isObject(mapOrObject)) {
    return new ObjectWrappingMap(mapOrObject);
  }
  throw new Error("createMap can create maps from objects or Maps");
}
function toObject(map2) {
  if (map2 instanceof ObjectWrappingMap) {
    return map2.wrappedObject;
  }
  var object3 = {};
  for (var key of map2.keys()) {
    var value = map2.get(key);
    setSafeProperty(object3, key, value);
  }
  return object3;
}
function isMap(object3) {
  if (!object3) {
    return false;
  }
  return object3 instanceof Map || object3 instanceof ObjectWrappingMap || typeof object3.set === "function" && typeof object3.get === "function" && typeof object3.keys === "function" && typeof object3.has === "function";
}
function assign(map2) {
  for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
    objects[_key - 1] = arguments[_key];
  }
  for (var args of objects) {
    if (!args) {
      continue;
    }
    if (isMap(args)) {
      for (var key of args.keys()) {
        map2.set(key, args.get(key));
      }
    } else if (isObject(args)) {
      for (var _key2 of Object.keys(args)) {
        map2.set(_key2, args[_key2]);
      }
    }
  }
  return map2;
}

class ObjectWrappingMap {
  constructor(object3) {
    this.wrappedObject = object3;
  }
  keys() {
    return Object.keys(this.wrappedObject);
  }
  get(key) {
    return getSafeProperty(this.wrappedObject, key);
  }
  set(key, value) {
    setSafeProperty(this.wrappedObject, key, value);
    return this;
  }
  has(key) {
    return hasSafeProperty(this.wrappedObject, key);
  }
}

// ../../node_modules/mathjs/lib/esm/core/function/typed.js
var throwNoBignumber = function(x) {
  throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
};
var throwNoComplex = function(x) {
  throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
};
var throwNoMatrix = function() {
  throw new Error("Cannot convert array into a Matrix: no class \'DenseMatrix\' provided");
};
var throwNoFraction = function(x) {
  throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
};
var _createTyped2 = function _createTyped() {
  _createTyped2 = import_typed_function.default.create;
  return import_typed_function.default;
};
var dependencies = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"];
var createTyped = factory("typed", dependencies, function createTyped2(_ref) {
  var {
    BigNumber,
    Complex,
    DenseMatrix,
    Fraction
  } = _ref;
  var typed = _createTyped2();
  typed.clear();
  typed.addTypes([
    {
      name: "number",
      test: isNumber
    },
    {
      name: "Complex",
      test: isComplex
    },
    {
      name: "BigNumber",
      test: isBigNumber
    },
    {
      name: "Fraction",
      test: isFraction
    },
    {
      name: "Unit",
      test: isUnit
    },
    {
      name: "identifier",
      test: (s) => isString && /^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(s)
    },
    {
      name: "string",
      test: isString
    },
    {
      name: "Chain",
      test: isChain
    },
    {
      name: "Array",
      test: isArray
    },
    {
      name: "Matrix",
      test: isMatrix
    },
    {
      name: "DenseMatrix",
      test: isDenseMatrix
    },
    {
      name: "SparseMatrix",
      test: isSparseMatrix
    },
    {
      name: "Range",
      test: isRange
    },
    {
      name: "Index",
      test: isIndex
    },
    {
      name: "boolean",
      test: isBoolean
    },
    {
      name: "ResultSet",
      test: isResultSet
    },
    {
      name: "Help",
      test: isHelp
    },
    {
      name: "function",
      test: isFunction
    },
    {
      name: "Date",
      test: isDate
    },
    {
      name: "RegExp",
      test: isRegExp
    },
    {
      name: "null",
      test: isNull
    },
    {
      name: "undefined",
      test: isUndefined
    },
    {
      name: "AccessorNode",
      test: isAccessorNode
    },
    {
      name: "ArrayNode",
      test: isArrayNode
    },
    {
      name: "AssignmentNode",
      test: isAssignmentNode
    },
    {
      name: "BlockNode",
      test: isBlockNode
    },
    {
      name: "ConditionalNode",
      test: isConditionalNode
    },
    {
      name: "ConstantNode",
      test: isConstantNode
    },
    {
      name: "FunctionNode",
      test: isFunctionNode
    },
    {
      name: "FunctionAssignmentNode",
      test: isFunctionAssignmentNode
    },
    {
      name: "IndexNode",
      test: isIndexNode
    },
    {
      name: "Node",
      test: isNode
    },
    {
      name: "ObjectNode",
      test: isObjectNode
    },
    {
      name: "OperatorNode",
      test: isOperatorNode
    },
    {
      name: "ParenthesisNode",
      test: isParenthesisNode
    },
    {
      name: "RangeNode",
      test: isRangeNode
    },
    {
      name: "RelationalNode",
      test: isRelationalNode
    },
    {
      name: "SymbolNode",
      test: isSymbolNode
    },
    {
      name: "Map",
      test: isMap
    },
    {
      name: "Object",
      test: isObject
    }
  ]);
  typed.addConversions([{
    from: "number",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber) {
        throwNoBignumber(x);
      }
      if (digits(x) > 15) {
        throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber " + "(value: " + x + "). " + "Use function bignumber(x) to convert to BigNumber.");
      }
      return new BigNumber(x);
    }
  }, {
    from: "number",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex) {
        throwNoComplex(x);
      }
      return new Complex(x, 0);
    }
  }, {
    from: "BigNumber",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex) {
        throwNoComplex(x);
      }
      return new Complex(x.toNumber(), 0);
    }
  }, {
    from: "Fraction",
    to: "BigNumber",
    convert: function convert(x) {
      throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. " + "Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
    }
  }, {
    from: "Fraction",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex) {
        throwNoComplex(x);
      }
      return new Complex(x.valueOf(), 0);
    }
  }, {
    from: "number",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction) {
        throwNoFraction(x);
      }
      var f = new Fraction(x);
      if (f.valueOf() !== x) {
        throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision " + "(value: " + x + "). " + "Use function fraction(x) to convert to Fraction.");
      }
      return f;
    }
  }, {
    from: "string",
    to: "number",
    convert: function convert(x) {
      var n = Number(x);
      if (isNaN(n)) {
        throw new Error('Cannot convert "' + x + '" to a number');
      }
      return n;
    }
  }, {
    from: "string",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber) {
        throwNoBignumber(x);
      }
      try {
        return new BigNumber(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to BigNumber');
      }
    }
  }, {
    from: "string",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction) {
        throwNoFraction(x);
      }
      try {
        return new Fraction(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to Fraction');
      }
    }
  }, {
    from: "string",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex) {
        throwNoComplex(x);
      }
      try {
        return new Complex(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to Complex');
      }
    }
  }, {
    from: "boolean",
    to: "number",
    convert: function convert(x) {
      return +x;
    }
  }, {
    from: "boolean",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber) {
        throwNoBignumber(x);
      }
      return new BigNumber(+x);
    }
  }, {
    from: "boolean",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction) {
        throwNoFraction(x);
      }
      return new Fraction(+x);
    }
  }, {
    from: "boolean",
    to: "string",
    convert: function convert(x) {
      return String(x);
    }
  }, {
    from: "Array",
    to: "Matrix",
    convert: function convert(array) {
      if (!DenseMatrix) {
        throwNoMatrix();
      }
      return new DenseMatrix(array);
    }
  }, {
    from: "Matrix",
    to: "Array",
    convert: function convert(matrix) {
      return matrix.valueOf();
    }
  }]);
  typed.onMismatch = (name, args, signatures) => {
    var usualError = typed.createError(name, args, signatures);
    if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && signatures.some((sig) => !sig.params.includes(","))) {
      var err = new TypeError("Function '".concat(name, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name, ")'."));
      err.data = usualError.data;
      throw err;
    }
    throw usualError;
  };
  typed.onMismatch = (name, args, signatures) => {
    var usualError = typed.createError(name, args, signatures);
    if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && signatures.some((sig) => !sig.params.includes(","))) {
      var err = new TypeError("Function '".concat(name, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name, ")'."));
      err.data = usualError.data;
      throw err;
    }
    throw usualError;
  };
  return typed;
});
// ../../node_modules/mathjs/lib/esm/type/resultset/ResultSet.js
var name = "ResultSet";
var dependencies2 = [];
var createResultSet = factory(name, dependencies2, () => {
  function ResultSet(entries) {
    if (!(this instanceof ResultSet)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.entries = entries || [];
  }
  ResultSet.prototype.type = "ResultSet";
  ResultSet.prototype.isResultSet = true;
  ResultSet.prototype.valueOf = function() {
    return this.entries;
  };
  ResultSet.prototype.toString = function() {
    return "[" + this.entries.join(", ") + "]";
  };
  ResultSet.prototype.toJSON = function() {
    return {
      mathjs: "ResultSet",
      entries: this.entries
    };
  };
  ResultSet.fromJSON = function(json) {
    return new ResultSet(json.entries);
  };
  return ResultSet;
}, {
  isClass: true
});
// ../../node_modules/decimal.js/decimal.mjs
var digitsToString = function(d) {
  var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1;i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k)
      str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (;w % 10 === 0; )
    w /= 10;
  return str + w;
};
var checkInt32 = function(i, min, max) {
  if (i !== ~~i || i < min || i > max) {
    throw Error(invalidArgument + i);
  }
};
var checkRoundingDigits = function(d, i, rm, repeating) {
  var di, k, r, rd;
  for (k = d[0];k >= 10; k /= 10)
    --i;
  if (--i < 0) {
    i += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE);
    i %= LOG_BASE;
  }
  k = mathpow(10, LOG_BASE - i);
  rd = d[di] % k | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0)
        rd = rd / 100 | 0;
      else if (i == 1)
        rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0)
        rd = rd / 1000 | 0;
      else if (i == 1)
        rd = rd / 100 | 0;
      else if (i == 2)
        rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
    }
  }
  return r;
};
var convertBase = function(str, baseIn, baseOut) {
  var j, arr = [0], arrL, i = 0, strL = str.length;
  for (;i < strL; ) {
    for (arrL = arr.length;arrL--; )
      arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i++));
    for (j = 0;j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === undefined)
          arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
};
var cosine = function(Ctor, x) {
  var k, len, y;
  if (x.isZero())
    return x;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
  for (var i = k;i--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
};
var finalise = function(x, sd, rm, isTruncated) {
  var digits2, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
  out:
    if (sd != null) {
      xd = x.d;
      if (!xd)
        return x;
      for (digits2 = 1, k = xd[0];k >= 10; k /= 10)
        digits2++;
      i = sd - digits2;
      if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];
        rd = w / mathpow(10, digits2 - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {
            for (;k++ <= xdi; )
              xd.push(0);
            w = rd = 0;
            digits2 = 1;
            i %= LOG_BASE;
            j = i - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];
          for (digits2 = 1;k >= 10; k /= 10)
            digits2++;
          i %= LOG_BASE;
          j = i - LOG_BASE + digits2;
          rd = j < 0 ? 0 : w / mathpow(10, digits2 - j - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== undefined || (j < 0 ? w : w % mathpow(10, digits2 - j - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits2 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x.e + 1;
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {
          xd[0] = x.e = 0;
        }
        return x;
      }
      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i);
        xd[xdi] = j > 0 ? (w / mathpow(10, digits2 - j) % mathpow(10, j) | 0) * k : 0;
      }
      if (roundUp) {
        for (;; ) {
          if (xdi == 0) {
            for (i = 1, j = xd[0];j >= 10; j /= 10)
              i++;
            j = xd[0] += k;
            for (k = 1;j >= 10; j /= 10)
              k++;
            if (i != k) {
              x.e++;
              if (xd[0] == BASE)
                xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE)
              break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }
      for (i = xd.length;xd[--i] === 0; )
        xd.pop();
    }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
};
var finiteToString = function(x, isExp, sd) {
  if (!x.isFinite())
    return nonFiniteToString(x);
  var k, e = x.e, str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0)
      str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0)
      str = str + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len)
      str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len)
        str += ".";
      str += getZeroString(k);
    }
  }
  return str;
};
var getBase10Exponent = function(digits2, e) {
  var w = digits2[0];
  for (e *= LOG_BASE;w >= 10; w /= 10)
    e++;
  return e;
};
var getLn10 = function(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
};
var getPi = function(Ctor, sd, rm) {
  if (sd > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
};
var getPrecision = function(digits2) {
  var w = digits2.length - 1, len = w * LOG_BASE + 1;
  w = digits2[w];
  if (w) {
    for (;w % 10 == 0; w /= 10)
      len--;
    for (w = digits2[0];w >= 10; w /= 10)
      len++;
  }
  return len;
};
var getZeroString = function(k) {
  var zs = "";
  for (;k--; )
    zs += "0";
  return zs;
};
var intPow = function(Ctor, x, n, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (;; ) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k))
        isTruncated = true;
    }
    n = mathfloor(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0)
        ++r.d[n];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
};
var isOdd = function(n) {
  return n.d[n.d.length - 1] & 1;
};
var maxOrMin = function(Ctor, args, ltgt) {
  var y, x = new Ctor(args[0]), i = 0;
  for (;++i < args.length; ) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x = y;
      break;
    } else if (x[ltgt](y)) {
      x = y;
    }
  }
  return x;
};
var naturalExponential = function(x, sd) {
  var denominator, guard, j, pow, sum, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow = sum = new Ctor(1);
  Ctor.precision = wpr;
  for (;; ) {
    pow = finalise(pow.times(x), wpr, 1);
    denominator = denominator.times(++i);
    t = sum.plus(divide(pow, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      j = k;
      while (j--)
        sum = finalise(sum.times(sum), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum;
      }
    }
    sum = t;
  }
};
var naturalLogarithm = function(y, sd) {
  var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e = x.e) < 1500000000000000) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (;; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      sum = sum.times(2);
      if (e !== 0)
        sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum = divide(sum, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum;
      }
    }
    sum = t;
    denominator += 2;
  }
};
var nonFiniteToString = function(x) {
  return String(x.s * x.s / 0);
};
var parseDecimal = function(x, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0)
      e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0;str.charCodeAt(i) === 48; i++)
    ;
  for (len = str.length;str.charCodeAt(len - 1) === 48; --len)
    ;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    x.e = e = e - i - 1;
    x.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0)
      i += LOG_BASE;
    if (i < len) {
      if (i)
        x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE;i < len; )
        x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (;i--; )
      str += "0";
    x.d.push(+str);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
};
var parseOther = function(x, str) {
  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str))
      return parseDecimal(x, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str)
      x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex.test(str)) {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base = 2;
  } else if (isOctal.test(str)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i = str.search(/p/i);
  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }
  i = str.indexOf(".");
  isFloat = i >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i = len - i;
    divisor = intPow(Ctor, new Ctor(base), i, i * 2);
  }
  xd = convertBase(str, base, BASE);
  xe = xd.length - 1;
  for (i = xe;xd[i] === 0; --i)
    xd.pop();
  if (i < 0)
    return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat)
    x = divide(x, divisor, len * 4);
  if (p)
    x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x;
};
var sine = function(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (;k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
};
var taylorSeries = function(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y);
  for (;; ) {
    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);
    if (t.d[k] !== undefined) {
      for (j = k;t.d[j] === u.d[j] && j--; )
        ;
      if (j == -1)
        break;
    }
    j = u;
    u = y;
    y = t;
    t = j;
    i++;
  }
  external = true;
  t.d.length = k + 1;
  return t;
};
var tinyPow = function(b, e) {
  var n = b;
  while (--e)
    n *= b;
  return n;
};
var toLessThanHalfPi = function(Ctor, x) {
  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }
  t = x.divToInt(pi);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi));
    if (x.lte(halfPi)) {
      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x;
    }
    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x.minus(pi).abs();
};
var toStringBinary = function(x, baseOut, sd, rm) {
  var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== undefined;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i = str.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i >= 0) {
      str = str.replace(".", "");
      y = new Ctor(1);
      y.e = str.length - i;
      y.d = convertBase(finiteToString(y), 10, base);
      y.e = y.d.length;
    }
    xd = convertBase(str, 10, base);
    e = len = xd.length;
    for (;xd[--len] == 0; )
      xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e;
        x = divide(x, y, sd, rm, 0, base);
        xd = x.d;
        e = x.e;
        roundUp = inexact;
      }
      i = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== undefined;
      roundUp = rm < 4 ? (i !== undefined || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (;++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length;!xd[len - 1]; --len)
        ;
      for (i = 0, str = "";i < len; i++)
        str += NUMERALS.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len;len % i; len++)
              str += "0";
            xd = convertBase(str, base, baseOut);
            for (len = xd.length;!xd[len - 1]; --len)
              ;
            for (i = 1, str = "1.";i < len; i++)
              str += NUMERALS.charAt(xd[i]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e < 0 ? "p" : "p+") + e;
      } else if (e < 0) {
        for (;++e; )
          str = "0" + str;
        str = "0." + str;
      } else {
        if (++e > len)
          for (e -= len;e--; )
            str += "0";
        else if (e < len)
          str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x.s < 0 ? "-" + str : str;
};
var truncate = function(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
};
var abs = function(x) {
  return new this(x).abs();
};
var acos = function(x) {
  return new this(x).acos();
};
var acosh2 = function(x) {
  return new this(x).acosh();
};
var add = function(x, y) {
  return new this(x).plus(y);
};
var asin = function(x) {
  return new this(x).asin();
};
var asinh2 = function(x) {
  return new this(x).asinh();
};
var atan = function(x) {
  return new this(x).atan();
};
var atanh2 = function(x) {
  return new this(x).atanh();
};
var atan2 = function(y, x) {
  y = new this(y);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y.s || !x.s) {
    r = new this(NaN);
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }
  return r;
};
var cbrt3 = function(x) {
  return new this(x).cbrt();
};
var ceil = function(x) {
  return finalise(x = new this(x), x.e + 1, 2);
};
var clamp3 = function(x, min, max) {
  return new this(x).clamp(min, max);
};
var config5 = function(obj) {
  if (!obj || typeof obj !== "object")
    throw Error(decimalError + "Object expected");
  var i, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0;i < ps.length; i += 3) {
    if (p = ps[i], useDefaults)
      this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== undefined) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
        this[p] = v;
      else
        throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults)
    this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== undefined) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
};
var cos = function(x) {
  return new this(x).cos();
};
var cosh2 = function(x) {
  return new this(x).cosh();
};
var clone2 = function(obj) {
  var i, p, ps;
  function Decimal(v) {
    var e, i2, t, x = this;
    if (!(x instanceof Decimal))
      return new Decimal(v);
    x.constructor = Decimal;
    if (isDecimalInstance(v)) {
      x.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e = 0, i2 = v;i2 >= 10; i2 /= 10)
          e++;
        if (external) {
          if (e > Decimal.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e < Decimal.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e;
            x.d = [v];
          }
        } else {
          x.e = e;
          x.d = [v];
        }
        return;
      } else if (v * 0 !== 0) {
        if (!v)
          x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v.toString());
    } else if (t !== "string") {
      throw Error(invalidArgument + v);
    }
    if ((i2 = v.charCodeAt(0)) === 45) {
      v = v.slice(1);
      x.s = -1;
    } else {
      if (i2 === 43)
        v = v.slice(1);
      x.s = 1;
    }
    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
  }
  Decimal.prototype = P;
  Decimal.ROUND_UP = 0;
  Decimal.ROUND_DOWN = 1;
  Decimal.ROUND_CEIL = 2;
  Decimal.ROUND_FLOOR = 3;
  Decimal.ROUND_HALF_UP = 4;
  Decimal.ROUND_HALF_DOWN = 5;
  Decimal.ROUND_HALF_EVEN = 6;
  Decimal.ROUND_HALF_CEIL = 7;
  Decimal.ROUND_HALF_FLOOR = 8;
  Decimal.EUCLID = 9;
  Decimal.config = Decimal.set = config5;
  Decimal.clone = clone2;
  Decimal.isDecimal = isDecimalInstance;
  Decimal.abs = abs;
  Decimal.acos = acos;
  Decimal.acosh = acosh2;
  Decimal.add = add;
  Decimal.asin = asin;
  Decimal.asinh = asinh2;
  Decimal.atan = atan;
  Decimal.atanh = atanh2;
  Decimal.atan2 = atan2;
  Decimal.cbrt = cbrt3;
  Decimal.ceil = ceil;
  Decimal.clamp = clamp3;
  Decimal.cos = cos;
  Decimal.cosh = cosh2;
  Decimal.div = div;
  Decimal.exp = exp;
  Decimal.floor = floor;
  Decimal.hypot = hypot;
  Decimal.ln = ln;
  Decimal.log = log;
  Decimal.log10 = log103;
  Decimal.log2 = log23;
  Decimal.max = max;
  Decimal.min = min;
  Decimal.mod = mod;
  Decimal.mul = mul;
  Decimal.pow = pow;
  Decimal.random = random;
  Decimal.round = round;
  Decimal.sign = sign2;
  Decimal.sin = sin;
  Decimal.sinh = sinh2;
  Decimal.sqrt = sqrt;
  Decimal.sub = sub;
  Decimal.sum = sum;
  Decimal.tan = tan;
  Decimal.tanh = tanh2;
  Decimal.trunc = trunc;
  if (obj === undefined)
    obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0;i < ps.length; )
        if (!obj.hasOwnProperty(p = ps[i++]))
          obj[p] = this[p];
    }
  }
  Decimal.config(obj);
  return Decimal;
};
var div = function(x, y) {
  return new this(x).div(y);
};
var exp = function(x) {
  return new this(x).exp();
};
var floor = function(x) {
  return finalise(x = new this(x), x.e + 1, 3);
};
var hypot = function() {
  var i, n, t = new this(0);
  external = false;
  for (i = 0;i < arguments.length; ) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
};
var isDecimalInstance = function(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
};
var ln = function(x) {
  return new this(x).ln();
};
var log = function(x, y) {
  return new this(x).log(y);
};
var log23 = function(x) {
  return new this(x).log(2);
};
var log103 = function(x) {
  return new this(x).log(10);
};
var max = function() {
  return maxOrMin(this, arguments, "lt");
};
var min = function() {
  return maxOrMin(this, arguments, "gt");
};
var mod = function(x, y) {
  return new this(x).mod(y);
};
var mul = function(x, y) {
  return new this(x).mul(y);
};
var pow = function(x, y) {
  return new this(x).pow(y);
};
var random = function(sd) {
  var d, e, k, n, i = 0, r = new this(1), rd = [];
  if (sd === undefined)
    sd = this.precision;
  else
    checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (;i < k; )
      rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));
    for (;i < k; ) {
      n = d[i];
      if (n >= 4290000000) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k *= 4);
    for (;i < k; ) {
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
      if (n >= 2140000000) {
        crypto.randomBytes(4).copy(d, i);
      } else {
        rd.push(n % 1e7);
        i += 4;
      }
    }
    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i];
  sd %= LOG_BASE;
  if (k && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n | 0) * n;
  }
  for (;rd[i] === 0; i--)
    rd.pop();
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;
    for (;rd[0] === 0; e -= LOG_BASE)
      rd.shift();
    for (k = 1, n = rd[0];n >= 10; n /= 10)
      k++;
    if (k < LOG_BASE)
      e -= LOG_BASE - k;
  }
  r.e = e;
  r.d = rd;
  return r;
};
var round = function(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
};
var sign2 = function(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
};
var sin = function(x) {
  return new this(x).sin();
};
var sinh2 = function(x) {
  return new this(x).sinh();
};
var sqrt = function(x) {
  return new this(x).sqrt();
};
var sub = function(x, y) {
  return new this(x).sub(y);
};
var sum = function() {
  var i = 0, args = arguments, x = new this(args[i]);
  external = false;
  for (;x.s && ++i < args.length; )
    x = x.plus(args[i]);
  external = true;
  return finalise(x, this.precision, this.rounding);
};
var tan = function(x) {
  return new this(x).tan();
};
var tanh2 = function(x) {
  return new this(x).tanh();
};
var trunc = function(x) {
  return finalise(x = new this(x), x.e + 1, 1);
};
/*!
 *  decimal.js v10.4.3
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var EXP_LIMIT = 9000000000000000;
var MAX_DIGITS = 1e9;
var NUMERALS = "0123456789abcdef";
var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var DEFAULTS = {
  precision: 20,
  rounding: 4,
  modulo: 1,
  toExpNeg: -7,
  toExpPos: 21,
  minE: -EXP_LIMIT,
  maxE: EXP_LIMIT,
  crypto: false
};
var inexact;
var quadrant;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var precisionLimitExceeded = decimalError + "Precision limit exceeded";
var cryptoUnavailable = decimalError + "crypto unavailable";
var tag = "[object Decimal]";
var mathfloor = Math.floor;
var mathpow = Math.pow;
var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var BASE = 1e7;
var LOG_BASE = 7;
var MAX_SAFE_INTEGER = 9007199254740991;
var LN10_PRECISION = LN10.length - 1;
var PI_PRECISION = PI.length - 1;
var P = { toStringTag: tag };
P.absoluteValue = P.abs = function() {
  var x = new this.constructor(this);
  if (x.s < 0)
    x.s = 1;
  return finalise(x);
};
P.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P.clampedTo = P.clamp = function(min2, max2) {
  var k, x = this, Ctor = x.constructor;
  min2 = new Ctor(min2);
  max2 = new Ctor(max2);
  if (!min2.s || !max2.s)
    return new Ctor(NaN);
  if (min2.gt(max2))
    throw Error(invalidArgument + max2);
  k = x.cmp(min2);
  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
};
P.comparedTo = P.cmp = function(y) {
  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0])
    return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys)
    return xs;
  if (x.e !== y.e)
    return x.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL;i < j; ++i) {
    if (xd[i] !== yd[i])
      return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P.cosine = P.cos = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.d)
    return new Ctor(NaN);
  if (!x.d[0])
    return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};
P.cubeRoot = P.cbrt = function() {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  external = false;
  s = x.s * mathpow(x.s * x, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;
    if (s = (e - n.length + 1) % 3)
      n += s == 1 || s == -2 ? "0" : "00";
    s = mathpow(n, 1 / 3);
    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (;; ) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.decimalPlaces = P.dp = function() {
  var w, d = this.d, n = NaN;
  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w = d[w];
    if (w)
      for (;w % 10 == 0; w /= 10)
        n--;
    if (n < 0)
      n = 0;
  }
  return n;
};
P.dividedBy = P.div = function(y) {
  return divide(this, new this.constructor(y));
};
P.dividedToIntegerBy = P.divToInt = function(y) {
  var x = this, Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P.equals = P.eq = function(y) {
  return this.cmp(y) === 0;
};
P.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P.greaterThan = P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};
P.hyperbolicCosine = P.cosh = function() {
  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
  if (!x.isFinite())
    return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero())
    return one;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = "2.3283064365386962890625e-10";
  }
  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
  var cosh2_x, i = k, d8 = new Ctor(8);
  for (;i--; ) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.hyperbolicSine = P.sinh = function() {
  var k, pr, rm, len, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (;k--; ) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x, pr, rm, true);
};
P.hyperbolicTangent = P.tanh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(x.s);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P.inverseCosine = P.acos = function() {
  var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k !== -1) {
    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x.isZero())
    return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return halfPi.minus(x);
};
P.inverseHyperbolicCosine = P.acosh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (x.lte(1))
    return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).minus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicSine = P.asinh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).plus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicTangent = P.atanh = function() {
  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.e >= 0)
    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();
  if (Math.max(xsd, pr) < 2 * -x.e - 1)
    return finalise(new Ctor(x), pr, rm, true);
  Ctor.precision = wpr = xsd - x.e;
  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x = x.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(0.5);
};
P.inverseSine = P.asin = function() {
  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
  if (x.isZero())
    return new Ctor(x);
  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P.inverseTangent = P.atan = function() {
  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x.isFinite()) {
    if (!x.s)
      return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i = k;i; --i)
    x = x.div(x.times(x).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;
  for (;i !== -1; ) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));
    px = px.times(x2);
    r = t.plus(px.div(n += 2));
    if (r.d[j] !== undefined)
      for (i = j;r.d[i] === t.d[i] && i--; )
        ;
  }
  if (k)
    r = r.times(2 << k - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.isFinite = function() {
  return !!this.d;
};
P.isInteger = P.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P.isNaN = function() {
  return !this.s;
};
P.isNegative = P.isNeg = function() {
  return this.s < 0;
};
P.isPositive = P.isPos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P.lessThan = P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.logarithm = P.log = function(base) {
  var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;
    if (base.s < 0 || !d || !d[0] || base.eq(1))
      return new Ctor(NaN);
    isBase10 = base.eq(10);
  }
  d = arg.d;
  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0];k % 10 === 0; )
        k /= 10;
      inf = k !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  r = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 100000000000000) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P.minus = P.sub = function(y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (x.d)
      y.s = -y.s;
    else
      y = new Ctor(y.d || x.s !== y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0])
      y.s = -y.s;
    else if (xd[0])
      y = new Ctor(x);
    else
      return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y, pr, rm) : y;
  }
  e = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);
  xd = xd.slice();
  k = xe - e;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i) {
      k = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k;i--; )
      d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy)
      len = i;
    for (i = 0;i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len;i > 0; --i)
    xd[len++] = 0;
  for (i = yd.length;i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i;j && xd[--j] === 0; )
        xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (;xd[--len] === 0; )
    xd.pop();
  for (;xd[0] === 0; xd.shift())
    --e;
  if (!xd[0])
    return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.modulo = P.mod = function(y) {
  var q, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.s || y.d && !y.d[0])
    return new Ctor(NaN);
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }
  q = q.times(y);
  external = true;
  return x.minus(q);
};
P.naturalExponential = P.exp = function() {
  return naturalExponential(this);
};
P.naturalLogarithm = P.ln = function() {
  return naturalLogarithm(this);
};
P.negated = P.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};
P.plus = P.add = function(y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (!x.d)
      y = new Ctor(y.d || x.s === y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0])
      y = new Ctor(x);
    return external ? finalise(y, pr, rm) : y;
  }
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);
  xd = xd.slice();
  i = k - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (;i--; )
      d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0;i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length;xd[--len] == 0; )
    xd.pop();
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.precision = P.sd = function(z2) {
  var k, x = this;
  if (z2 !== undefined && z2 !== !!z2 && z2 !== 1 && z2 !== 0)
    throw Error(invalidArgument + z2);
  if (x.d) {
    k = getPrecision(x.d);
    if (z2 && x.e + 1 > k)
      k = x.e + 1;
  } else {
    k = NaN;
  }
  return k;
};
P.round = function() {
  var x = this, Ctor = x.constructor;
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};
P.sine = P.sin = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = sine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};
P.squareRoot = P.sqrt = function() {
  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);
    if ((n.length + e) % 2 == 0)
      n += "0";
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (;; ) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.tangent = P.tan = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};
P.times = P.mul = function(y) {
  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  y.s *= x.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL;i--; )
    r.push(0);
  for (i = ydL;--i >= 0; ) {
    carry = 0;
    for (k = xdL + i;k > i; ) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k] = (r[k] + carry) % BASE | 0;
  }
  for (;!r[--rL]; )
    r.pop();
  if (carry)
    ++e;
  else
    r.shift();
  y.d = r;
  y.e = getBase10Exponent(r, e);
  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};
P.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P.toDecimalPlaces = P.toDP = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === undefined)
    return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === undefined)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return finalise(x, dp + x.e + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str, x = this, Ctor = x.constructor;
  if (dp === undefined) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFixed = function(dp, rm) {
  var str, y, x = this, Ctor = x.constructor;
  if (dp === undefined) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFraction = function(maxD) {
  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
  if (!xd)
    return new Ctor(x);
  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
  if (maxD == null) {
    maxD = e > 0 ? d : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1))
      throw Error(invalidArgument + n);
    maxD = n.gt(d) ? e > 0 ? d : n1 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE * 2;
  for (;; ) {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1)
      break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }
  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x.s;
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P.toHexadecimal = P.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P.toNearest = function(y, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (y == null) {
    if (!x.d)
      return x;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === undefined) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x.d)
      return y.s ? x : y;
    if (!y.d) {
      if (y.s)
        y.s = x.s;
      return y;
    }
  }
  if (y.d[0]) {
    external = false;
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);
  } else {
    y.s = x.s;
    x = y;
  }
  return x;
};
P.toNumber = function() {
  return +this;
};
P.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P.toPower = P.pow = function(y) {
  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
  if (!x.d || !y.d || !x.d[0] || !y.d[0])
    return new Ctor(mathpow(+x, yn));
  x = new Ctor(x);
  if (x.eq(1))
    return x;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1))
    return finalise(x, pr, rm);
  e = mathfloor(y.e / LOG_BASE);
  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s = x.s;
  if (s < 0) {
    if (e < y.d.length - 1)
      return new Ctor(NaN);
    if ((y.d[e] & 1) == 0)
      s = 1;
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
    return new Ctor(e > 0 ? s / 0 : 0);
  external = false;
  Ctor.rounding = x.s = 1;
  k = Math.min(12, (e + "").length);
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10;
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 100000000000000) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P.toPrecision = function(sd, rm) {
  var str, x = this, Ctor = x.constructor;
  if (sd === undefined) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toSignificantDigits = P.toSD = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === undefined) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x), sd, rm);
};
P.toString = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.truncated = P.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P.valueOf = P.toJSON = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() ? "-" + str : str;
};
var divide = function() {
  function multiplyInteger(x, k, base) {
    var temp, carry = 0, i = x.length;
    for (x = x.slice();i--; ) {
      temp = x[i] * k + carry;
      x[i] = temp % base | 0;
      carry = temp / base | 0;
    }
    if (carry)
      x.unshift(carry);
    return x;
  }
  function compare(a, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0;i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract(a, b, aL, base) {
    var i = 0;
    for (;aL--; ) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * base + a[aL] - b[aL];
    }
    for (;!a[0] && a.length > 1; )
      a.shift();
  }
  return function(x, y, pr, rm, dp, base) {
    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign3 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign3 * 0 : sign3 / 0);
    }
    if (base) {
      logBase = 1;
      e = x.e - y.e;
    } else {
      base = BASE;
      logBase = LOG_BASE;
      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign3);
    qd = q.d = [];
    for (i = 0;yd[i] == (xd[i] || 0); i++)
      ;
    if (yd[i] > (xd[i] || 0))
      e--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i = 0;
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;
        for (;(i < xL || k) && sd--; i++) {
          t = k * base + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k = t % yd | 0;
        }
        more = k || i < xL;
      } else {
        k = base / (yd[0] + 1) | 0;
        if (k > 1) {
          yd = multiplyInteger(yd, k, base);
          xd = multiplyInteger(xd, k, base);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (;remL < yL; )
          rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base / 2)
          ++yd0;
        do {
          k = 0;
          cmp = compare(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= base)
                k = base - 1;
              prod = multiplyInteger(yd, k, base);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base);
              }
            } else {
              if (k == 0)
                cmp = k = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL)
              prod.unshift(0);
            subtract(rem, prod, remL, base);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract(rem, yL < remL ? yz : yd, remL, base);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd[i++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== undefined) && sd--);
        more = rem[0] !== undefined;
      }
      if (!qd[0])
        qd.shift();
    }
    if (logBase == 1) {
      q.e = e;
      inexact = more;
    } else {
      for (i = 1, k = qd[0];k >= 10; k /= 10)
        i++;
      q.e = i + e * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
}();
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal = P.constructor = clone2(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var decimal_default = Decimal;

// ../../node_modules/mathjs/lib/esm/type/bignumber/BigNumber.js
var name2 = "BigNumber";
var dependencies3 = ["?on", "config"];
var createBigNumberClass = factory(name2, dependencies3, (_ref) => {
  var {
    on,
    config: config6
  } = _ref;
  var BigNumber = decimal_default.clone({
    precision: config6.precision,
    modulo: decimal_default.EUCLID
  });
  BigNumber.prototype = Object.create(BigNumber.prototype);
  BigNumber.prototype.type = "BigNumber";
  BigNumber.prototype.isBigNumber = true;
  BigNumber.prototype.toJSON = function() {
    return {
      mathjs: "BigNumber",
      value: this.toString()
    };
  };
  BigNumber.fromJSON = function(json) {
    return new BigNumber(json.value);
  };
  if (on) {
    on("config", function(curr, prev) {
      if (curr.precision !== prev.precision) {
        BigNumber.config({
          precision: curr.precision
        });
      }
    });
  }
  return BigNumber;
}, {
  isClass: true
});
// ../../node_modules/mathjs/lib/esm/type/complex/Complex.js
var import_complex = __toESM(require_complex(), 1);
var name3 = "Complex";
var dependencies4 = [];
var createComplexClass = factory(name3, dependencies4, () => {
  Object.defineProperty(import_complex.default, "name", {
    value: "Complex"
  });
  import_complex.default.prototype.constructor = import_complex.default;
  import_complex.default.prototype.type = "Complex";
  import_complex.default.prototype.isComplex = true;
  import_complex.default.prototype.toJSON = function() {
    return {
      mathjs: "Complex",
      re: this.re,
      im: this.im
    };
  };
  import_complex.default.prototype.toPolar = function() {
    return {
      r: this.abs(),
      phi: this.arg()
    };
  };
  import_complex.default.prototype.format = function(options) {
    var str = "";
    var im = this.im;
    var re = this.re;
    var strRe = format(this.re, options);
    var strIm = format(this.im, options);
    var precision = isNumber(options) ? options : options ? options.precision : null;
    if (precision !== null) {
      var epsilon = Math.pow(10, -precision);
      if (Math.abs(re / im) < epsilon) {
        re = 0;
      }
      if (Math.abs(im / re) < epsilon) {
        im = 0;
      }
    }
    if (im === 0) {
      str = strRe;
    } else if (re === 0) {
      if (im === 1) {
        str = "i";
      } else if (im === -1) {
        str = "-i";
      } else {
        str = strIm + "i";
      }
    } else {
      if (im < 0) {
        if (im === -1) {
          str = strRe + " - i";
        } else {
          str = strRe + " - " + strIm.substring(1) + "i";
        }
      } else {
        if (im === 1) {
          str = strRe + " + i";
        } else {
          str = strRe + " + " + strIm + "i";
        }
      }
    }
    return str;
  };
  import_complex.default.fromPolar = function(args) {
    switch (arguments.length) {
      case 1: {
        var arg = arguments[0];
        if (typeof arg === "object") {
          return import_complex.default(arg);
        } else {
          throw new TypeError("Input has to be an object with r and phi keys.");
        }
      }
      case 2: {
        var r = arguments[0];
        var phi = arguments[1];
        if (isNumber(r)) {
          if (isUnit(phi) && phi.hasBase("ANGLE")) {
            phi = phi.toNumber("rad");
          }
          if (isNumber(phi)) {
            return new import_complex.default({
              r,
              phi
            });
          }
          throw new TypeError("Phi is not a number nor an angle unit.");
        } else {
          throw new TypeError("Radius r is not a number.");
        }
      }
      default:
        throw new SyntaxError("Wrong number of arguments in function fromPolar");
    }
  };
  import_complex.default.prototype.valueOf = import_complex.default.prototype.toString;
  import_complex.default.fromJSON = function(json) {
    return new import_complex.default(json);
  };
  import_complex.default.compare = function(a, b) {
    if (a.re > b.re) {
      return 1;
    }
    if (a.re < b.re) {
      return -1;
    }
    if (a.im > b.im) {
      return 1;
    }
    if (a.im < b.im) {
      return -1;
    }
    return 0;
  };
  return import_complex.default;
}, {
  isClass: true
});
// ../../node_modules/mathjs/lib/esm/type/fraction/Fraction.js
var import_fraction = __toESM(require_fraction(), 1);
var name4 = "Fraction";
var dependencies5 = [];
var createFractionClass = factory(name4, dependencies5, () => {
  Object.defineProperty(import_fraction.default, "name", {
    value: "Fraction"
  });
  import_fraction.default.prototype.constructor = import_fraction.default;
  import_fraction.default.prototype.type = "Fraction";
  import_fraction.default.prototype.isFraction = true;
  import_fraction.default.prototype.toJSON = function() {
    return {
      mathjs: "Fraction",
      n: this.s * this.n,
      d: this.d
    };
  };
  import_fraction.default.fromJSON = function(json) {
    return new import_fraction.default(json);
  };
  return import_fraction.default;
}, {
  isClass: true
});
// ../../node_modules/mathjs/lib/esm/type/matrix/Range.js
var name5 = "Range";
var dependencies6 = [];
var createRangeClass = factory(name5, dependencies6, () => {
  function Range(start, end, step) {
    if (!(this instanceof Range)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    var hasStart = start !== null && start !== undefined;
    var hasEnd = end !== null && end !== undefined;
    var hasStep = step !== null && step !== undefined;
    if (hasStart) {
      if (isBigNumber(start)) {
        start = start.toNumber();
      } else if (typeof start !== "number") {
        throw new TypeError("Parameter start must be a number");
      }
    }
    if (hasEnd) {
      if (isBigNumber(end)) {
        end = end.toNumber();
      } else if (typeof end !== "number") {
        throw new TypeError("Parameter end must be a number");
      }
    }
    if (hasStep) {
      if (isBigNumber(step)) {
        step = step.toNumber();
      } else if (typeof step !== "number") {
        throw new TypeError("Parameter step must be a number");
      }
    }
    this.start = hasStart ? parseFloat(start) : 0;
    this.end = hasEnd ? parseFloat(end) : 0;
    this.step = hasStep ? parseFloat(step) : 1;
  }
  Range.prototype.type = "Range";
  Range.prototype.isRange = true;
  Range.parse = function(str) {
    if (typeof str !== "string") {
      return null;
    }
    var args = str.split(":");
    var nums = args.map(function(arg) {
      return parseFloat(arg);
    });
    var invalid = nums.some(function(num) {
      return isNaN(num);
    });
    if (invalid) {
      return null;
    }
    switch (nums.length) {
      case 2:
        return new Range(nums[0], nums[1]);
      case 3:
        return new Range(nums[0], nums[2], nums[1]);
      default:
        return null;
    }
  };
  Range.prototype.clone = function() {
    return new Range(this.start, this.end, this.step);
  };
  Range.prototype.size = function() {
    var len = 0;
    var start = this.start;
    var step = this.step;
    var end = this.end;
    var diff = end - start;
    if (sign(step) === sign(diff)) {
      len = Math.ceil(diff / step);
    } else if (diff === 0) {
      len = 0;
    }
    if (isNaN(len)) {
      len = 0;
    }
    return [len];
  };
  Range.prototype.min = function() {
    var size = this.size()[0];
    if (size > 0) {
      if (this.step > 0) {
        return this.start;
      } else {
        return this.start + (size - 1) * this.step;
      }
    } else {
      return;
    }
  };
  Range.prototype.max = function() {
    var size = this.size()[0];
    if (size > 0) {
      if (this.step > 0) {
        return this.start + (size - 1) * this.step;
      } else {
        return this.start;
      }
    } else {
      return;
    }
  };
  Range.prototype.forEach = function(callback) {
    var x = this.start;
    var step = this.step;
    var end = this.end;
    var i = 0;
    if (step > 0) {
      while (x < end) {
        callback(x, [i], this);
        x += step;
        i++;
      }
    } else if (step < 0) {
      while (x > end) {
        callback(x, [i], this);
        x += step;
        i++;
      }
    }
  };
  Range.prototype.map = function(callback) {
    var array = [];
    this.forEach(function(value, index, obj) {
      array[index[0]] = callback(value, index, obj);
    });
    return array;
  };
  Range.prototype.toArray = function() {
    var array = [];
    this.forEach(function(value, index) {
      array[index[0]] = value;
    });
    return array;
  };
  Range.prototype.valueOf = function() {
    return this.toArray();
  };
  Range.prototype.format = function(options) {
    var str = format(this.start, options);
    if (this.step !== 1) {
      str += ":" + format(this.step, options);
    }
    str += ":" + format(this.end, options);
    return str;
  };
  Range.prototype.toString = function() {
    return this.format();
  };
  Range.prototype.toJSON = function() {
    return {
      mathjs: "Range",
      start: this.start,
      end: this.end,
      step: this.step
    };
  };
  Range.fromJSON = function(json) {
    return new Range(json.start, json.end, json.step);
  };
  return Range;
}, {
  isClass: true
});
// ../../node_modules/mathjs/lib/esm/type/matrix/Matrix.js
var name6 = "Matrix";
var dependencies7 = [];
var createMatrixClass = factory(name6, dependencies7, () => {
  function Matrix() {
    if (!(this instanceof Matrix)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
  }
  Matrix.prototype.type = "Matrix";
  Matrix.prototype.isMatrix = true;
  Matrix.prototype.storage = function() {
    throw new Error("Cannot invoke storage on a Matrix interface");
  };
  Matrix.prototype.datatype = function() {
    throw new Error("Cannot invoke datatype on a Matrix interface");
  };
  Matrix.prototype.create = function(data, datatype) {
    throw new Error("Cannot invoke create on a Matrix interface");
  };
  Matrix.prototype.subset = function(index, replacement, defaultValue) {
    throw new Error("Cannot invoke subset on a Matrix interface");
  };
  Matrix.prototype.get = function(index) {
    throw new Error("Cannot invoke get on a Matrix interface");
  };
  Matrix.prototype.set = function(index, value, defaultValue) {
    throw new Error("Cannot invoke set on a Matrix interface");
  };
  Matrix.prototype.resize = function(size, defaultValue) {
    throw new Error("Cannot invoke resize on a Matrix interface");
  };
  Matrix.prototype.reshape = function(size, defaultValue) {
    throw new Error("Cannot invoke reshape on a Matrix interface");
  };
  Matrix.prototype.clone = function() {
    throw new Error("Cannot invoke clone on a Matrix interface");
  };
  Matrix.prototype.size = function() {
    throw new Error("Cannot invoke size on a Matrix interface");
  };
  Matrix.prototype.map = function(callback, skipZeros) {
    throw new Error("Cannot invoke map on a Matrix interface");
  };
  Matrix.prototype.forEach = function(callback) {
    throw new Error("Cannot invoke forEach on a Matrix interface");
  };
  Matrix.prototype[Symbol.iterator] = function() {
    throw new Error("Cannot iterate a Matrix interface");
  };
  Matrix.prototype.toArray = function() {
    throw new Error("Cannot invoke toArray on a Matrix interface");
  };
  Matrix.prototype.valueOf = function() {
    throw new Error("Cannot invoke valueOf on a Matrix interface");
  };
  Matrix.prototype.format = function(options) {
    throw new Error("Cannot invoke format on a Matrix interface");
  };
  Matrix.prototype.toString = function() {
    throw new Error("Cannot invoke toString on a Matrix interface");
  };
  return Matrix;
}, {
  isClass: true
});
// ../../node_modules/mathjs/lib/esm/utils/lruQueue.js
function lruQueue(limit) {
  var size = 0;
  var base = 1;
  var queue = Object.create(null);
  var map3 = Object.create(null);
  var index = 0;
  var del = function del(id) {
    var oldIndex = map3[id];
    if (!oldIndex)
      return;
    delete queue[oldIndex];
    delete map3[id];
    --size;
    if (base !== oldIndex)
      return;
    if (!size) {
      index = 0;
      base = 1;
      return;
    }
    while (!hasOwnProperty.call(queue, ++base))
      continue;
  };
  limit = Math.abs(limit);
  return {
    hit: function hit(id) {
      var oldIndex = map3[id];
      var nuIndex = ++index;
      queue[nuIndex] = id;
      map3[id] = nuIndex;
      if (!oldIndex) {
        ++size;
        if (size <= limit)
          return;
        id = queue[base];
        del(id);
        return id;
      }
      delete queue[oldIndex];
      if (base !== oldIndex)
        return;
      while (!hasOwnProperty.call(queue, ++base))
        continue;
      return;
    },
    delete: del,
    clear: function clear() {
      size = index = 0;
      base = 1;
      queue = Object.create(null);
      map3 = Object.create(null);
    }
  };
}

// ../../node_modules/mathjs/lib/esm/utils/function.js
function memoize(fn) {
  var {
    hasher,
    limit
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  limit = limit == null ? Number.POSITIVE_INFINITY : limit;
  hasher = hasher == null ? JSON.stringify : hasher;
  return function memoize() {
    if (typeof memoize.cache !== "object") {
      memoize.cache = {
        values: new Map,
        lru: lruQueue(limit || Number.POSITIVE_INFINITY)
      };
    }
    var args = [];
    for (var i = 0;i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    var hash = hasher(args);
    if (memoize.cache.values.has(hash)) {
      memoize.cache.lru.hit(hash);
      return memoize.cache.values.get(hash);
    }
    var newVal = fn.apply(fn, args);
    memoize.cache.values.set(hash, newVal);
    memoize.cache.values.delete(memoize.cache.lru.hit(hash));
    return newVal;
  };
}
function maxArgumentCount(fn) {
  return Object.keys(fn.signatures || {}).reduce(function(args, signature) {
    var count = (signature.match(/,/g) || []).length + 1;
    return Math.max(args, count);
  }, -1);
}

// ../../node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js
var name7 = "DenseMatrix";
var dependencies8 = ["Matrix"];
var createDenseMatrixClass = factory(name7, dependencies8, (_ref) => {
  var {
    Matrix
  } = _ref;
  function DenseMatrix(data, datatype) {
    if (!(this instanceof DenseMatrix)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      if (data.type === "DenseMatrix") {
        this._data = clone(data._data);
        this._size = clone(data._size);
        this._datatype = datatype || data._datatype;
      } else {
        this._data = data.toArray();
        this._size = data.size();
        this._datatype = datatype || data._datatype;
      }
    } else if (data && isArray(data.data) && isArray(data.size)) {
      this._data = data.data;
      this._size = data.size;
      validate(this._data, this._size);
      this._datatype = datatype || data.datatype;
    } else if (isArray(data)) {
      this._data = preprocess(data);
      this._size = arraySize(this._data);
      validate(this._data, this._size);
      this._datatype = datatype;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
    }
  }
  DenseMatrix.prototype = new Matrix;
  DenseMatrix.prototype.createDenseMatrix = function(data, datatype) {
    return new DenseMatrix(data, datatype);
  };
  Object.defineProperty(DenseMatrix, "name", {
    value: "DenseMatrix"
  });
  DenseMatrix.prototype.constructor = DenseMatrix;
  DenseMatrix.prototype.type = "DenseMatrix";
  DenseMatrix.prototype.isDenseMatrix = true;
  DenseMatrix.prototype.getDataType = function() {
    return getArrayDataType(this._data, typeOf);
  };
  DenseMatrix.prototype.storage = function() {
    return "dense";
  };
  DenseMatrix.prototype.datatype = function() {
    return this._datatype;
  };
  DenseMatrix.prototype.create = function(data, datatype) {
    return new DenseMatrix(data, datatype);
  };
  DenseMatrix.prototype.subset = function(index, replacement, defaultValue) {
    switch (arguments.length) {
      case 1:
        return _get(this, index);
      case 2:
      case 3:
        return _set(this, index, replacement, defaultValue);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  DenseMatrix.prototype.get = function(index) {
    if (!isArray(index)) {
      throw new TypeError("Array expected");
    }
    if (index.length !== this._size.length) {
      throw new DimensionError(index.length, this._size.length);
    }
    for (var x = 0;x < index.length; x++) {
      validateIndex(index[x], this._size[x]);
    }
    var data = this._data;
    for (var i = 0, ii = index.length;i < ii; i++) {
      var indexI = index[i];
      validateIndex(indexI, data.length);
      data = data[indexI];
    }
    return data;
  };
  DenseMatrix.prototype.set = function(index, value, defaultValue) {
    if (!isArray(index)) {
      throw new TypeError("Array expected");
    }
    if (index.length < this._size.length) {
      throw new DimensionError(index.length, this._size.length, "<");
    }
    var i, ii, indexI;
    var size = index.map(function(i2) {
      return i2 + 1;
    });
    _fit(this, size, defaultValue);
    var data = this._data;
    for (i = 0, ii = index.length - 1;i < ii; i++) {
      indexI = index[i];
      validateIndex(indexI, data.length);
      data = data[indexI];
    }
    indexI = index[index.length - 1];
    validateIndex(indexI, data.length);
    data[indexI] = value;
    return this;
  };
  function _get(matrix, index) {
    if (!isIndex(index)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = index.isScalar();
    if (isScalar) {
      return matrix.get(index.min());
    } else {
      var size = index.size();
      if (size.length !== matrix._size.length) {
        throw new DimensionError(size.length, matrix._size.length);
      }
      var min2 = index.min();
      var max2 = index.max();
      for (var i = 0, ii = matrix._size.length;i < ii; i++) {
        validateIndex(min2[i], matrix._size[i]);
        validateIndex(max2[i], matrix._size[i]);
      }
      return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);
    }
  }
  function _getSubmatrix(data, index, dims, dim) {
    var last = dim === dims - 1;
    var range = index.dimension(dim);
    if (last) {
      return range.map(function(i) {
        validateIndex(i, data.length);
        return data[i];
      }).valueOf();
    } else {
      return range.map(function(i) {
        validateIndex(i, data.length);
        var child = data[i];
        return _getSubmatrix(child, index, dims, dim + 1);
      }).valueOf();
    }
  }
  function _set(matrix, index, submatrix, defaultValue) {
    if (!index || index.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index.size();
    var isScalar = index.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.valueOf();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix.set(index.min(), submatrix, defaultValue);
    } else {
      if (iSize.length < matrix._size.length) {
        throw new DimensionError(iSize.length, matrix._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i = 0;
        var outer = 0;
        while (iSize[i] === 1 && sSize[i] === 1) {
          i++;
        }
        while (iSize[i] === 1) {
          outer++;
          i++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      var size = index.max().map(function(i2) {
        return i2 + 1;
      });
      _fit(matrix, size, defaultValue);
      var dims = iSize.length;
      var dim = 0;
      _setSubmatrix(matrix._data, index, submatrix, dims, dim);
    }
    return matrix;
  }
  function _setSubmatrix(data, index, submatrix, dims, dim) {
    var last = dim === dims - 1;
    var range = index.dimension(dim);
    if (last) {
      range.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        data[dataIndex] = submatrix[subIndex[0]];
      });
    } else {
      range.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);
      });
    }
  }
  DenseMatrix.prototype.resize = function(size, defaultValue, copy) {
    if (!isCollection(size)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    var m = copy ? this.clone() : this;
    return _resize2(m, sizeArray, defaultValue);
  };
  function _resize2(matrix, size, defaultValue) {
    if (size.length === 0) {
      var v = matrix._data;
      while (isArray(v)) {
        v = v[0];
      }
      return v;
    }
    matrix._size = size.slice(0);
    matrix._data = resize(matrix._data, matrix._size, defaultValue);
    return matrix;
  }
  DenseMatrix.prototype.reshape = function(size, copy) {
    var m = copy ? this.clone() : this;
    m._data = reshape(m._data, size);
    var currentLength = m._size.reduce((length, size2) => length * size2);
    m._size = processSizesWildcard(size, currentLength);
    return m;
  };
  function _fit(matrix, size, defaultValue) {
    var newSize = matrix._size.slice(0);
    var changed = false;
    while (newSize.length < size.length) {
      newSize.push(0);
      changed = true;
    }
    for (var i = 0, ii = size.length;i < ii; i++) {
      if (size[i] > newSize[i]) {
        newSize[i] = size[i];
        changed = true;
      }
    }
    if (changed) {
      _resize2(matrix, newSize, defaultValue);
    }
  }
  DenseMatrix.prototype.clone = function() {
    var m = new DenseMatrix({
      data: clone(this._data),
      size: clone(this._size),
      datatype: this._datatype
    });
    return m;
  };
  DenseMatrix.prototype.size = function() {
    return this._size.slice(0);
  };
  DenseMatrix.prototype.map = function(callback) {
    var me = this;
    var args = maxArgumentCount(callback);
    var recurse = function recurse(value, index) {
      if (isArray(value)) {
        return value.map(function(child, i) {
          return recurse(child, index.concat(i));
        });
      } else {
        if (args === 1) {
          return callback(value);
        } else if (args === 2) {
          return callback(value, index);
        } else {
          return callback(value, index, me);
        }
      }
    };
    var data = recurse(this._data, []);
    var datatype = this._datatype !== undefined ? getArrayDataType(data, typeOf) : undefined;
    return new DenseMatrix(data, datatype);
  };
  DenseMatrix.prototype.forEach = function(callback) {
    var me = this;
    var recurse = function recurse(value, index) {
      if (isArray(value)) {
        value.forEach(function(child, i) {
          recurse(child, index.concat(i));
        });
      } else {
        callback(value, index, me);
      }
    };
    recurse(this._data, []);
  };
  DenseMatrix.prototype[Symbol.iterator] = function* () {
    var recurse = function* recurse(value, index) {
      if (isArray(value)) {
        for (var i = 0;i < value.length; i++) {
          yield* recurse(value[i], index.concat(i));
        }
      } else {
        yield {
          value,
          index
        };
      }
    };
    yield* recurse(this._data, []);
  };
  DenseMatrix.prototype.rows = function() {
    var result = [];
    var s = this.size();
    if (s.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    for (var row of data) {
      result.push(new DenseMatrix([row], this._datatype));
    }
    return result;
  };
  DenseMatrix.prototype.columns = function() {
    var _this = this;
    var result = [];
    var s = this.size();
    if (s.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    var _loop = function _loop(i2) {
      var col = data.map((row) => [row[i2]]);
      result.push(new DenseMatrix(col, _this._datatype));
    };
    for (var i = 0;i < s[1]; i++) {
      _loop(i);
    }
    return result;
  };
  DenseMatrix.prototype.toArray = function() {
    return clone(this._data);
  };
  DenseMatrix.prototype.valueOf = function() {
    return this._data;
  };
  DenseMatrix.prototype.format = function(options) {
    return format3(this._data, options);
  };
  DenseMatrix.prototype.toString = function() {
    return format3(this._data);
  };
  DenseMatrix.prototype.toJSON = function() {
    return {
      mathjs: "DenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  DenseMatrix.prototype.diagonal = function(k) {
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var data = [];
    for (var i = 0;i < n; i++) {
      data[i] = this._data[i + kSub][i + kSuper];
    }
    return new DenseMatrix({
      data,
      size: [n],
      datatype: this._datatype
    });
  };
  DenseMatrix.diagonal = function(size, value, k, defaultValue) {
    if (!isArray(size)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size = size.map(function(s) {
      if (isBigNumber(s)) {
        s = s.toNumber();
      }
      if (!isNumber(s) || !isInteger(s) || s < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s;
    });
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = size[0];
    var columns = size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value(i) {
        return value[i];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value(i) {
        return value.get([i]);
      };
    } else {
      _value = function _value() {
        return value;
      };
    }
    if (!defaultValue) {
      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
    }
    var data = [];
    if (size.length > 0) {
      data = resize(data, size, defaultValue);
      for (var d = 0;d < n; d++) {
        data[d + kSub][d + kSuper] = _value(d);
      }
    }
    return new DenseMatrix({
      data,
      size: [rows, columns]
    });
  };
  DenseMatrix.fromJSON = function(json) {
    return new DenseMatrix(json);
  };
  DenseMatrix.prototype.swapRows = function(i, j) {
    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i, this._size[0]);
    validateIndex(j, this._size[0]);
    DenseMatrix._swapRows(i, j, this._data);
    return this;
  };
  DenseMatrix._swapRows = function(i, j, data) {
    var vi = data[i];
    data[i] = data[j];
    data[j] = vi;
  };
  function preprocess(data) {
    for (var i = 0, ii = data.length;i < ii; i++) {
      var elem = data[i];
      if (isArray(elem)) {
        data[i] = preprocess(elem);
      } else if (elem && elem.isMatrix === true) {
        data[i] = preprocess(elem.valueOf());
      }
    }
    return data;
  }
  return DenseMatrix;
}, {
  isClass: true
});
// ../../node_modules/mathjs/lib/esm/function/utils/clone.js
var name8 = "clone";
var dependencies9 = ["typed"];
var createClone = factory(name8, dependencies9, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name8, {
    any: clone
  });
});
// ../../node_modules/mathjs/lib/esm/utils/switch.js
function _switch(mat) {
  var I = mat.length;
  var J = mat[0].length;
  var i, j;
  var ret = [];
  for (j = 0;j < J; j++) {
    var tmp = [];
    for (i = 0;i < I; i++) {
      tmp.push(mat[i][j]);
    }
    ret.push(tmp);
  }
  return ret;
}

// ../../node_modules/mathjs/lib/esm/utils/collection.js
function containsCollections(array3) {
  for (var i = 0;i < array3.length; i++) {
    if (isCollection(array3[i])) {
      return true;
    }
  }
  return false;
}
function deepForEach(array3, callback) {
  if (isMatrix(array3)) {
    array3 = array3.valueOf();
  }
  for (var i = 0, ii = array3.length;i < ii; i++) {
    var value = array3[i];
    if (Array.isArray(value)) {
      deepForEach(value, callback);
    } else {
      callback(value);
    }
  }
}
function deepMap(array3, callback, skipZeros) {
  if (array3 && typeof array3.map === "function") {
    return array3.map(function(x) {
      return deepMap(x, callback, skipZeros);
    });
  } else {
    return callback(array3);
  }
}
function reduce(mat, dim, callback) {
  var size = Array.isArray(mat) ? arraySize(mat) : mat.size();
  if (dim < 0 || dim >= size.length) {
    throw new IndexError(dim, size.length);
  }
  if (isMatrix(mat)) {
    return mat.create(_reduce(mat.valueOf(), dim, callback));
  } else {
    return _reduce(mat, dim, callback);
  }
}
var _reduce = function(mat, dim, callback) {
  var i, ret, val, tran;
  if (dim <= 0) {
    if (!Array.isArray(mat[0])) {
      val = mat[0];
      for (i = 1;i < mat.length; i++) {
        val = callback(val, mat[i]);
      }
      return val;
    } else {
      tran = _switch(mat);
      ret = [];
      for (i = 0;i < tran.length; i++) {
        ret[i] = _reduce(tran[i], dim - 1, callback);
      }
      return ret;
    }
  } else {
    ret = [];
    for (i = 0;i < mat.length; i++) {
      ret[i] = _reduce(mat[i], dim - 1, callback);
    }
    return ret;
  }
};
function scatter(a, j, w, x, u, mark, cindex, f, inverse, update, value) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var k, k0, k1, i;
  if (x) {
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0;k < k1; k++) {
      i = aindex[k];
      if (w[i] !== mark) {
        w[i] = mark;
        cindex.push(i);
        if (update) {
          x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]);
          u[i] = mark;
        } else {
          x[i] = avalues[k];
        }
      } else {
        x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]);
        u[i] = mark;
      }
    }
  } else {
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0;k < k1; k++) {
      i = aindex[k];
      if (w[i] !== mark) {
        w[i] = mark;
        cindex.push(i);
      } else {
        u[i] = mark;
      }
    }
  }
}

// ../../node_modules/mathjs/lib/esm/function/utils/isInteger.js
var name9 = "isInteger";
var dependencies10 = ["typed"];
var createIsInteger = factory(name9, dependencies10, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name9, {
    number: isInteger,
    BigNumber: function BigNumber(x) {
      return x.isInt();
    },
    Fraction: function Fraction(x) {
      return x.d === 1 && isFinite(x.n);
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/plain/number/arithmetic.js
function absNumber(a) {
  return Math.abs(a);
}
function addNumber(a, b) {
  return a + b;
}
function subtractNumber(a, b) {
  return a - b;
}
function multiplyNumber(a, b) {
  return a * b;
}
function divideNumber(a, b) {
  return a / b;
}
function unaryMinusNumber(x) {
  return -x;
}
function unaryPlusNumber(x) {
  return x;
}
function cbrtNumber(x) {
  return cbrt(x);
}
function cubeNumber(x) {
  return x * x * x;
}
function expNumber(x) {
  return Math.exp(x);
}
function expm1Number(x) {
  return expm1(x);
}
function gcdNumber(a, b) {
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error("Parameters in function gcd must be integer numbers");
  }
  var r;
  while (b !== 0) {
    r = a % b;
    a = b;
    b = r;
  }
  return a < 0 ? -a : a;
}
function lcmNumber(a, b) {
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error("Parameters in function lcm must be integer numbers");
  }
  if (a === 0 || b === 0) {
    return 0;
  }
  var t;
  var prod = a * b;
  while (b !== 0) {
    t = b;
    b = a % t;
    a = t;
  }
  return Math.abs(prod / a);
}
function logNumber(x, y) {
  if (y) {
    return Math.log(x) / Math.log(y);
  }
  return Math.log(x);
}
function log10Number(x) {
  return log10(x);
}
function log2Number(x) {
  return log2(x);
}
function log1pNumber(x) {
  return log1p(x);
}
function modNumber(x, y) {
  if (y > 0) {
    return x - y * Math.floor(x / y);
  } else if (y === 0) {
    return x;
  } else {
    throw new Error("Cannot calculate mod for a negative divisor");
  }
}
function nthRootNumber(a) {
  var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var inv = root < 0;
  if (inv) {
    root = -root;
  }
  if (root === 0) {
    throw new Error("Root must be non-zero");
  }
  if (a < 0 && Math.abs(root) % 2 !== 1) {
    throw new Error("Root must be odd when a is negative.");
  }
  if (a === 0) {
    return inv ? Infinity : 0;
  }
  if (!isFinite(a)) {
    return inv ? 0 : a;
  }
  var x = Math.pow(Math.abs(a), 1 / root);
  x = a < 0 ? -x : x;
  return inv ? 1 / x : x;
}
function signNumber(x) {
  return sign(x);
}
function sqrtNumber(x) {
  return Math.sqrt(x);
}
function squareNumber(x) {
  return x * x;
}
function xgcdNumber(a, b) {
  var t;
  var q;
  var r;
  var x = 0;
  var lastx = 1;
  var y = 1;
  var lasty = 0;
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error("Parameters in function xgcd must be integer numbers");
  }
  while (b) {
    q = Math.floor(a / b);
    r = a - q * b;
    t = x;
    x = lastx - q * x;
    lastx = t;
    t = y;
    y = lasty - q * y;
    lasty = t;
    a = b;
    b = r;
  }
  var res;
  if (a < 0) {
    res = [-a, -lastx, -lasty];
  } else {
    res = [a, a ? lastx : 0, lasty];
  }
  return res;
}
function powNumber(x, y) {
  if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
    return 0;
  }
  return Math.pow(x, y);
}
function roundNumber(value) {
  var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  if (!isInteger(decimals) || decimals < 0 || decimals > 15) {
    throw new Error("Number of decimals in function round must be an integer from 0 to 15 inclusive");
  }
  return parseFloat(toFixed(value, decimals));
}
function normNumber(x) {
  return Math.abs(x);
}
var n1 = "number";
var n2 = "number, number";
absNumber.signature = n1;
addNumber.signature = n2;
subtractNumber.signature = n2;
multiplyNumber.signature = n2;
divideNumber.signature = n2;
unaryMinusNumber.signature = n1;
unaryPlusNumber.signature = n1;
cbrtNumber.signature = n1;
cubeNumber.signature = n1;
expNumber.signature = n1;
expm1Number.signature = n1;
gcdNumber.signature = n2;
lcmNumber.signature = n2;
log10Number.signature = n1;
log2Number.signature = n1;
log1pNumber.signature = n1;
modNumber.signature = n2;
signNumber.signature = n1;
sqrtNumber.signature = n1;
squareNumber.signature = n1;
xgcdNumber.signature = n2;
powNumber.signature = n2;
normNumber.signature = n1;

// ../../node_modules/mathjs/lib/esm/plain/number/bitwise.js
function bitAndNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function bitAnd");
  }
  return x & y;
}
function bitNotNumber(x) {
  if (!isInteger(x)) {
    throw new Error("Integer expected in function bitNot");
  }
  return ~x;
}
function bitOrNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function bitOr");
  }
  return x | y;
}
function bitXorNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function bitXor");
  }
  return x ^ y;
}
function leftShiftNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function leftShift");
  }
  return x << y;
}
function rightArithShiftNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function rightArithShift");
  }
  return x >> y;
}
function rightLogShiftNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function rightLogShift");
  }
  return x >>> y;
}
var n12 = "number";
var n22 = "number, number";
bitAndNumber.signature = n22;
bitNotNumber.signature = n12;
bitOrNumber.signature = n22;
bitXorNumber.signature = n22;
leftShiftNumber.signature = n22;
rightArithShiftNumber.signature = n22;
rightLogShiftNumber.signature = n22;

// ../../node_modules/mathjs/lib/esm/utils/product.js
function product2(i, n) {
  if (n < i) {
    return 1;
  }
  if (n === i) {
    return n;
  }
  var half = n + i >> 1;
  return product2(i, half) * product2(half + 1, n);
}

// ../../node_modules/mathjs/lib/esm/plain/number/combinations.js
function combinationsNumber(n, k) {
  if (!isInteger(n) || n < 0) {
    throw new TypeError("Positive integer value expected in function combinations");
  }
  if (!isInteger(k) || k < 0) {
    throw new TypeError("Positive integer value expected in function combinations");
  }
  if (k > n) {
    throw new TypeError("k must be less than or equal to n");
  }
  var nMinusk = n - k;
  var answer = 1;
  var firstnumerator = k < nMinusk ? nMinusk + 1 : k + 1;
  var nextdivisor = 2;
  var lastdivisor = k < nMinusk ? k : nMinusk;
  for (var nextnumerator = firstnumerator;nextnumerator <= n; ++nextnumerator) {
    answer *= nextnumerator;
    while (nextdivisor <= lastdivisor && answer % nextdivisor === 0) {
      answer /= nextdivisor;
      ++nextdivisor;
    }
  }
  if (nextdivisor <= lastdivisor) {
    answer /= product2(nextdivisor, lastdivisor);
  }
  return answer;
}
combinationsNumber.signature = "number, number";

// ../../node_modules/mathjs/lib/esm/plain/number/constants.js
var pi = Math.PI;
var tau = 2 * Math.PI;
var e = Math.E;
var phi = 1.618033988749895;

// ../../node_modules/mathjs/lib/esm/plain/number/logical.js
function notNumber(x) {
  return !x;
}
function orNumber(x, y) {
  return !!(x || y);
}
function xorNumber(x, y) {
  return !!x !== !!y;
}
function andNumber(x, y) {
  return !!(x && y);
}
var n13 = "number";
var n23 = "number, number";
notNumber.signature = n13;
orNumber.signature = n23;
xorNumber.signature = n23;
andNumber.signature = n23;

// ../../node_modules/mathjs/lib/esm/plain/number/probability.js
function gammaNumber(n) {
  var x;
  if (isInteger(n)) {
    if (n <= 0) {
      return isFinite(n) ? Infinity : NaN;
    }
    if (n > 171) {
      return Infinity;
    }
    return product2(1, n - 1);
  }
  if (n < 0.5) {
    return Math.PI / (Math.sin(Math.PI * n) * gammaNumber(1 - n));
  }
  if (n >= 171.35) {
    return Infinity;
  }
  if (n > 85) {
    var twoN = n * n;
    var threeN = twoN * n;
    var fourN = threeN * n;
    var fiveN = fourN * n;
    return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
  }
  --n;
  x = gammaP[0];
  for (var i = 1;i < gammaP.length; ++i) {
    x += gammaP[i] / (n + i);
  }
  var t = n + gammaG + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
}
function lgammaNumber(n) {
  if (n < 0)
    return NaN;
  if (n === 0)
    return Infinity;
  if (!isFinite(n))
    return n;
  if (n < 0.5) {
    return Math.log(Math.PI / Math.sin(Math.PI * n)) - lgammaNumber(1 - n);
  }
  n = n - 1;
  var base = n + lgammaG + 0.5;
  var sum2 = lgammaSeries[0];
  for (var i = lgammaN - 1;i >= 1; i--) {
    sum2 += lgammaSeries[i] / (n + i);
  }
  return lnSqrt2PI + (n + 0.5) * Math.log(base) - base + Math.log(sum2);
}
gammaNumber.signature = "number";
var gammaG = 4.7421875;
var gammaP = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 0.00003399464998481189, 0.00004652362892704858, -0.00009837447530487956, 0.0001580887032249125, -0.00021026444172410488, 0.00021743961811521265, -0.0001643181065367639, 0.00008441822398385275, -0.000026190838401581408, 0.0000036899182659531625];
var lnSqrt2PI = 0.9189385332046728;
var lgammaG = 5;
var lgammaN = 7;
var lgammaSeries = [1.000000000190015, 76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -0.000005395239384953];
lgammaNumber.signature = "number";

// ../../node_modules/mathjs/lib/esm/plain/number/trigonometry.js
function acosNumber(x) {
  return Math.acos(x);
}
function acoshNumber(x) {
  return acosh(x);
}
function acotNumber(x) {
  return Math.atan(1 / x);
}
function acothNumber(x) {
  return isFinite(x) ? (Math.log((x + 1) / x) + Math.log(x / (x - 1))) / 2 : 0;
}
function acscNumber(x) {
  return Math.asin(1 / x);
}
function acschNumber(x) {
  var xInv = 1 / x;
  return Math.log(xInv + Math.sqrt(xInv * xInv + 1));
}
function asecNumber(x) {
  return Math.acos(1 / x);
}
function asechNumber(x) {
  var xInv = 1 / x;
  var ret = Math.sqrt(xInv * xInv - 1);
  return Math.log(ret + xInv);
}
function asinNumber(x) {
  return Math.asin(x);
}
function asinhNumber(x) {
  return asinh(x);
}
function atanNumber(x) {
  return Math.atan(x);
}
function atan2Number(y, x) {
  return Math.atan2(y, x);
}
function atanhNumber(x) {
  return atanh(x);
}
function cosNumber(x) {
  return Math.cos(x);
}
function coshNumber(x) {
  return cosh(x);
}
function cotNumber(x) {
  return 1 / Math.tan(x);
}
function cothNumber(x) {
  var e2 = Math.exp(2 * x);
  return (e2 + 1) / (e2 - 1);
}
function cscNumber(x) {
  return 1 / Math.sin(x);
}
function cschNumber(x) {
  if (x === 0) {
    return Number.POSITIVE_INFINITY;
  } else {
    return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * sign(x);
  }
}
function secNumber(x) {
  return 1 / Math.cos(x);
}
function sechNumber(x) {
  return 2 / (Math.exp(x) + Math.exp(-x));
}
function sinNumber(x) {
  return Math.sin(x);
}
function sinhNumber(x) {
  return sinh(x);
}
function tanNumber(x) {
  return Math.tan(x);
}
function tanhNumber(x) {
  return tanh(x);
}
var n14 = "number";
var n24 = "number, number";
acosNumber.signature = n14;
acoshNumber.signature = n14;
acotNumber.signature = n14;
acothNumber.signature = n14;
acscNumber.signature = n14;
acschNumber.signature = n14;
asecNumber.signature = n14;
asechNumber.signature = n14;
asinNumber.signature = n14;
asinhNumber.signature = n14;
atanNumber.signature = n14;
atan2Number.signature = n24;
atanhNumber.signature = n14;
cosNumber.signature = n14;
coshNumber.signature = n14;
cotNumber.signature = n14;
cothNumber.signature = n14;
cscNumber.signature = n14;
cschNumber.signature = n14;
secNumber.signature = n14;
sechNumber.signature = n14;
sinNumber.signature = n14;
sinhNumber.signature = n14;
tanNumber.signature = n14;
tanhNumber.signature = n14;

// ../../node_modules/mathjs/lib/esm/plain/number/utils.js
function isIntegerNumber(x) {
  return isInteger(x);
}
function isNegativeNumber(x) {
  return x < 0;
}
function isPositiveNumber(x) {
  return x > 0;
}
function isZeroNumber(x) {
  return x === 0;
}
function isNaNNumber(x) {
  return Number.isNaN(x);
}
var n15 = "number";
isIntegerNumber.signature = n15;
isNegativeNumber.signature = n15;
isPositiveNumber.signature = n15;
isZeroNumber.signature = n15;
isNaNNumber.signature = n15;

// ../../node_modules/mathjs/lib/esm/function/utils/isNegative.js
var name10 = "isNegative";
var dependencies11 = ["typed"];
var createIsNegative = factory(name10, dependencies11, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name10, {
    number: isNegativeNumber,
    BigNumber: function BigNumber(x) {
      return x.isNeg() && !x.isZero() && !x.isNaN();
    },
    Fraction: function Fraction(x) {
      return x.s < 0;
    },
    Unit: typed.referToSelf((self2) => (x) => typed.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/function/utils/isNumeric.js
var name11 = "isNumeric";
var dependencies12 = ["typed"];
var createIsNumeric = factory(name11, dependencies12, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name11, {
    "number | BigNumber | Fraction | boolean": () => true,
    "Complex | Unit | string | null | undefined | Node": () => false,
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/function/utils/hasNumericValue.js
var name12 = "hasNumericValue";
var dependencies13 = ["typed", "isNumeric"];
var createHasNumericValue = factory(name12, dependencies13, (_ref) => {
  var {
    typed,
    isNumeric
  } = _ref;
  return typed(name12, {
    boolean: () => true,
    string: function string(x) {
      return x.trim().length > 0 && !isNaN(Number(x));
    },
    any: function any(x) {
      return isNumeric(x);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/utils/isPositive.js
var name13 = "isPositive";
var dependencies14 = ["typed"];
var createIsPositive = factory(name13, dependencies14, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name13, {
    number: isPositiveNumber,
    BigNumber: function BigNumber(x) {
      return !x.isNeg() && !x.isZero() && !x.isNaN();
    },
    Fraction: function Fraction(x) {
      return x.s > 0 && x.n > 0;
    },
    Unit: typed.referToSelf((self2) => (x) => typed.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/function/utils/isZero.js
var name14 = "isZero";
var dependencies15 = ["typed"];
var createIsZero = factory(name14, dependencies15, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name14, {
    number: isZeroNumber,
    BigNumber: function BigNumber(x) {
      return x.isZero();
    },
    Complex: function Complex(x) {
      return x.re === 0 && x.im === 0;
    },
    Fraction: function Fraction(x) {
      return x.d === 1 && x.n === 0;
    },
    Unit: typed.referToSelf((self2) => (x) => typed.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/function/utils/isNaN.js
var name15 = "isNaN";
var dependencies16 = ["typed"];
var createIsNaN = factory(name15, dependencies16, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name15, {
    number: isNaNNumber,
    BigNumber: function BigNumber(x) {
      return x.isNaN();
    },
    Fraction: function Fraction(x) {
      return false;
    },
    Complex: function Complex(x) {
      return x.isNaN();
    },
    Unit: function Unit(x) {
      return Number.isNaN(x.value);
    },
    "Array | Matrix": function ArrayMatrix(x) {
      return deepMap(x, Number.isNaN);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/utils/typeOf.js
var name16 = "typeOf";
var dependencies17 = ["typed"];
var createTypeOf = factory(name16, dependencies17, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name16, {
    any: typeOf
  });
});
// ../../node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js
function nearlyEqual2(x, y, epsilon) {
  if (epsilon === null || epsilon === undefined) {
    return x.eq(y);
  }
  if (x.eq(y)) {
    return true;
  }
  if (x.isNaN() || y.isNaN()) {
    return false;
  }
  if (x.isFinite() && y.isFinite()) {
    var diff = x.minus(y).abs();
    if (diff.isZero()) {
      return true;
    } else {
      var max2 = x.constructor.max(x.abs(), y.abs());
      return diff.lte(max2.times(epsilon));
    }
  }
  return false;
}

// ../../node_modules/mathjs/lib/esm/utils/complex.js
function complexEquals(x, y, epsilon) {
  return nearlyEqual(x.re, y.re, epsilon) && nearlyEqual(x.im, y.im, epsilon);
}

// ../../node_modules/mathjs/lib/esm/function/relational/compareUnits.js
var createCompareUnits = factory("compareUnits", ["typed"], (_ref) => {
  var {
    typed
  } = _ref;
  return {
    "Unit, Unit": typed.referToSelf((self2) => (x, y) => {
      if (!x.equalBase(y)) {
        throw new Error("Cannot compare units with different base");
      }
      return typed.find(self2, [x.valueType(), y.valueType()])(x.value, y.value);
    })
  };
});

// ../../node_modules/mathjs/lib/esm/function/relational/equalScalar.js
var name17 = "equalScalar";
var dependencies18 = ["typed", "config"];
var createEqualScalar = factory(name17, dependencies18, (_ref) => {
  var {
    typed,
    config: config6
  } = _ref;
  var compareUnits2 = createCompareUnits({
    typed
  });
  return typed(name17, {
    "boolean, boolean": function booleanBoolean(x, y) {
      return x === y;
    },
    "number, number": function numberNumber(x, y) {
      return nearlyEqual(x, y, config6.epsilon);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.eq(y) || nearlyEqual2(x, y, config6.epsilon);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.equals(y);
    },
    "Complex, Complex": function ComplexComplex(x, y) {
      return complexEquals(x, y, config6.epsilon);
    }
  }, compareUnits2);
});
var createEqualScalarNumber = factory(name17, ["typed", "config"], (_ref2) => {
  var {
    typed,
    config: config6
  } = _ref2;
  return typed(name17, {
    "number, number": function numberNumber(x, y) {
      return nearlyEqual(x, y, config6.epsilon);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js
var name18 = "SparseMatrix";
var dependencies19 = ["typed", "equalScalar", "Matrix"];
var createSparseMatrixClass = factory(name18, dependencies19, (_ref) => {
  var {
    typed,
    equalScalar,
    Matrix
  } = _ref;
  function SparseMatrix(data, datatype) {
    if (!(this instanceof SparseMatrix)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      _createFromMatrix(this, data, datatype);
    } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
      this._values = data.values;
      this._index = data.index;
      this._ptr = data.ptr;
      this._size = data.size;
      this._datatype = datatype || data.datatype;
    } else if (isArray(data)) {
      _createFromArray(this, data, datatype);
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._values = [];
      this._index = [];
      this._ptr = [0];
      this._size = [0, 0];
      this._datatype = datatype;
    }
  }
  function _createFromMatrix(matrix, source, datatype) {
    if (source.type === "SparseMatrix") {
      matrix._values = source._values ? clone(source._values) : undefined;
      matrix._index = clone(source._index);
      matrix._ptr = clone(source._ptr);
      matrix._size = clone(source._size);
      matrix._datatype = datatype || source._datatype;
    } else {
      _createFromArray(matrix, source.valueOf(), datatype || source._datatype);
    }
  }
  function _createFromArray(matrix, data, datatype) {
    matrix._values = [];
    matrix._index = [];
    matrix._ptr = [];
    matrix._datatype = datatype;
    var rows = data.length;
    var columns = 0;
    var eq = equalScalar;
    var zero = 0;
    if (isString(datatype)) {
      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;
      zero = typed.convert(0, datatype);
    }
    if (rows > 0) {
      var j = 0;
      do {
        matrix._ptr.push(matrix._index.length);
        for (var i = 0;i < rows; i++) {
          var row = data[i];
          if (isArray(row)) {
            if (j === 0 && columns < row.length) {
              columns = row.length;
            }
            if (j < row.length) {
              var v = row[j];
              if (!eq(v, zero)) {
                matrix._values.push(v);
                matrix._index.push(i);
              }
            }
          } else {
            if (j === 0 && columns < 1) {
              columns = 1;
            }
            if (!eq(row, zero)) {
              matrix._values.push(row);
              matrix._index.push(i);
            }
          }
        }
        j++;
      } while (j < columns);
    }
    matrix._ptr.push(matrix._index.length);
    matrix._size = [rows, columns];
  }
  SparseMatrix.prototype = new Matrix;
  SparseMatrix.prototype.createSparseMatrix = function(data, datatype) {
    return new SparseMatrix(data, datatype);
  };
  Object.defineProperty(SparseMatrix, "name", {
    value: "SparseMatrix"
  });
  SparseMatrix.prototype.constructor = SparseMatrix;
  SparseMatrix.prototype.type = "SparseMatrix";
  SparseMatrix.prototype.isSparseMatrix = true;
  SparseMatrix.prototype.getDataType = function() {
    return getArrayDataType(this._values, typeOf);
  };
  SparseMatrix.prototype.storage = function() {
    return "sparse";
  };
  SparseMatrix.prototype.datatype = function() {
    return this._datatype;
  };
  SparseMatrix.prototype.create = function(data, datatype) {
    return new SparseMatrix(data, datatype);
  };
  SparseMatrix.prototype.density = function() {
    var rows = this._size[0];
    var columns = this._size[1];
    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
  };
  SparseMatrix.prototype.subset = function(index, replacement, defaultValue) {
    if (!this._values) {
      throw new Error("Cannot invoke subset on a Pattern only matrix");
    }
    switch (arguments.length) {
      case 1:
        return _getsubset(this, index);
      case 2:
      case 3:
        return _setsubset(this, index, replacement, defaultValue);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  function _getsubset(matrix, idx) {
    if (!isIndex(idx)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = idx.isScalar();
    if (isScalar) {
      return matrix.get(idx.min());
    }
    var size = idx.size();
    if (size.length !== matrix._size.length) {
      throw new DimensionError(size.length, matrix._size.length);
    }
    var i, ii, k, kk;
    var min2 = idx.min();
    var max2 = idx.max();
    for (i = 0, ii = matrix._size.length;i < ii; i++) {
      validateIndex(min2[i], matrix._size[i]);
      validateIndex(max2[i], matrix._size[i]);
    }
    var mvalues = matrix._values;
    var mindex = matrix._index;
    var mptr = matrix._ptr;
    var rows = idx.dimension(0);
    var columns = idx.dimension(1);
    var w = [];
    var pv = [];
    rows.forEach(function(i2, r) {
      pv[i2] = r[0];
      w[i2] = true;
    });
    var values = mvalues ? [] : undefined;
    var index = [];
    var ptr = [];
    columns.forEach(function(j) {
      ptr.push(index.length);
      for (k = mptr[j], kk = mptr[j + 1];k < kk; k++) {
        i = mindex[k];
        if (w[i] === true) {
          index.push(pv[i]);
          if (values) {
            values.push(mvalues[k]);
          }
        }
      }
    });
    ptr.push(index.length);
    return new SparseMatrix({
      values,
      index,
      ptr,
      size,
      datatype: matrix._datatype
    });
  }
  function _setsubset(matrix, index, submatrix, defaultValue) {
    if (!index || index.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index.size();
    var isScalar = index.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.toArray();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix.set(index.min(), submatrix, defaultValue);
    } else {
      if (iSize.length !== 1 && iSize.length !== 2) {
        throw new DimensionError(iSize.length, matrix._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i = 0;
        var outer = 0;
        while (iSize[i] === 1 && sSize[i] === 1) {
          i++;
        }
        while (iSize[i] === 1) {
          outer++;
          i++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      if (iSize.length === 1) {
        var range = index.dimension(0);
        range.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          matrix.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
        });
      } else {
        var firstDimensionRange = index.dimension(0);
        var secondDimensionRange = index.dimension(1);
        firstDimensionRange.forEach(function(firstDataIndex, firstSubIndex) {
          validateIndex(firstDataIndex);
          secondDimensionRange.forEach(function(secondDataIndex, secondSubIndex) {
            validateIndex(secondDataIndex);
            matrix.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
          });
        });
      }
    }
    return matrix;
  }
  SparseMatrix.prototype.get = function(index) {
    if (!isArray(index)) {
      throw new TypeError("Array expected");
    }
    if (index.length !== this._size.length) {
      throw new DimensionError(index.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke get on a Pattern only matrix");
    }
    var i = index[0];
    var j = index[1];
    validateIndex(i, this._size[0]);
    validateIndex(j, this._size[1]);
    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
    if (k < this._ptr[j + 1] && this._index[k] === i) {
      return this._values[k];
    }
    return 0;
  };
  SparseMatrix.prototype.set = function(index, v, defaultValue) {
    if (!isArray(index)) {
      throw new TypeError("Array expected");
    }
    if (index.length !== this._size.length) {
      throw new DimensionError(index.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke set on a Pattern only matrix");
    }
    var i = index[0];
    var j = index[1];
    var rows = this._size[0];
    var columns = this._size[1];
    var eq = equalScalar;
    var zero = 0;
    if (isString(this._datatype)) {
      eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar;
      zero = typed.convert(0, this._datatype);
    }
    if (i > rows - 1 || j > columns - 1) {
      _resize2(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue);
      rows = this._size[0];
      columns = this._size[1];
    }
    validateIndex(i, rows);
    validateIndex(j, columns);
    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
    if (k < this._ptr[j + 1] && this._index[k] === i) {
      if (!eq(v, zero)) {
        this._values[k] = v;
      } else {
        _remove(k, j, this._values, this._index, this._ptr);
      }
    } else {
      if (!eq(v, zero)) {
        _insert(k, i, j, v, this._values, this._index, this._ptr);
      }
    }
    return this;
  };
  function _getValueIndex(i, top, bottom, index) {
    if (bottom - top === 0) {
      return bottom;
    }
    for (var r = top;r < bottom; r++) {
      if (index[r] === i) {
        return r;
      }
    }
    return top;
  }
  function _remove(k, j, values, index, ptr) {
    values.splice(k, 1);
    index.splice(k, 1);
    for (var x = j + 1;x < ptr.length; x++) {
      ptr[x]--;
    }
  }
  function _insert(k, i, j, v, values, index, ptr) {
    values.splice(k, 0, v);
    index.splice(k, 0, i);
    for (var x = j + 1;x < ptr.length; x++) {
      ptr[x]++;
    }
  }
  SparseMatrix.prototype.resize = function(size, defaultValue, copy) {
    if (!isCollection(size)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    if (sizeArray.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    sizeArray.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value < 0) {
        throw new TypeError("Invalid size, must contain positive integers " + "(size: " + format3(sizeArray) + ")");
      }
    });
    var m = copy ? this.clone() : this;
    return _resize2(m, sizeArray[0], sizeArray[1], defaultValue);
  };
  function _resize2(matrix, rows, columns, defaultValue) {
    var value = defaultValue || 0;
    var eq = equalScalar;
    var zero = 0;
    if (isString(matrix._datatype)) {
      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;
      zero = typed.convert(0, matrix._datatype);
      value = typed.convert(value, matrix._datatype);
    }
    var ins = !eq(value, zero);
    var r = matrix._size[0];
    var c = matrix._size[1];
    var i, j, k;
    if (columns > c) {
      for (j = c;j < columns; j++) {
        matrix._ptr[j] = matrix._values.length;
        if (ins) {
          for (i = 0;i < r; i++) {
            matrix._values.push(value);
            matrix._index.push(i);
          }
        }
      }
      matrix._ptr[columns] = matrix._values.length;
    } else if (columns < c) {
      matrix._ptr.splice(columns + 1, c - columns);
      matrix._values.splice(matrix._ptr[columns], matrix._values.length);
      matrix._index.splice(matrix._ptr[columns], matrix._index.length);
    }
    c = columns;
    if (rows > r) {
      if (ins) {
        var n = 0;
        for (j = 0;j < c; j++) {
          matrix._ptr[j] = matrix._ptr[j] + n;
          k = matrix._ptr[j + 1] + n;
          var p = 0;
          for (i = r;i < rows; i++, p++) {
            matrix._values.splice(k + p, 0, value);
            matrix._index.splice(k + p, 0, i);
            n++;
          }
        }
        matrix._ptr[c] = matrix._values.length;
      }
    } else if (rows < r) {
      var d = 0;
      for (j = 0;j < c; j++) {
        matrix._ptr[j] = matrix._ptr[j] - d;
        var k0 = matrix._ptr[j];
        var k1 = matrix._ptr[j + 1] - d;
        for (k = k0;k < k1; k++) {
          i = matrix._index[k];
          if (i > rows - 1) {
            matrix._values.splice(k, 1);
            matrix._index.splice(k, 1);
            d++;
          }
        }
      }
      matrix._ptr[j] = matrix._values.length;
    }
    matrix._size[0] = rows;
    matrix._size[1] = columns;
    return matrix;
  }
  SparseMatrix.prototype.reshape = function(sizes, copy) {
    if (!isArray(sizes)) {
      throw new TypeError("Array expected");
    }
    if (sizes.length !== 2) {
      throw new Error("Sparse matrices can only be reshaped in two dimensions");
    }
    sizes.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
        throw new TypeError("Invalid size, must contain positive integers or -1 " + "(size: " + format3(sizes) + ")");
      }
    });
    var currentLength = this._size[0] * this._size[1];
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = sizes[0] * sizes[1];
    if (currentLength !== newLength) {
      throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
    }
    var m = copy ? this.clone() : this;
    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
      return m;
    }
    var colIndex = [];
    for (var i = 0;i < m._ptr.length; i++) {
      for (var j = 0;j < m._ptr[i + 1] - m._ptr[i]; j++) {
        colIndex.push(i);
      }
    }
    var values = m._values.slice();
    var rowIndex = m._index.slice();
    for (var _i = 0;_i < m._index.length; _i++) {
      var r1 = rowIndex[_i];
      var c1 = colIndex[_i];
      var flat = r1 * m._size[1] + c1;
      colIndex[_i] = flat % sizes[1];
      rowIndex[_i] = Math.floor(flat / sizes[1]);
    }
    m._values.length = 0;
    m._index.length = 0;
    m._ptr.length = sizes[1] + 1;
    m._size = sizes.slice();
    for (var _i2 = 0;_i2 < m._ptr.length; _i2++) {
      m._ptr[_i2] = 0;
    }
    for (var h2 = 0;h2 < values.length; h2++) {
      var _i3 = rowIndex[h2];
      var _j = colIndex[h2];
      var v = values[h2];
      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
    }
    return m;
  };
  SparseMatrix.prototype.clone = function() {
    var m = new SparseMatrix({
      values: this._values ? clone(this._values) : undefined,
      index: clone(this._index),
      ptr: clone(this._ptr),
      size: clone(this._size),
      datatype: this._datatype
    });
    return m;
  };
  SparseMatrix.prototype.size = function() {
    return this._size.slice(0);
  };
  SparseMatrix.prototype.map = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke map on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    var args = maxArgumentCount(callback);
    var invoke = function invoke(v, i, j) {
      if (args === 1)
        return callback(v);
      if (args === 2)
        return callback(v, [i, j]);
      return callback(v, [i, j], me);
    };
    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
  };
  function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
    var values = [];
    var index = [];
    var ptr = [];
    var eq = equalScalar;
    var zero = 0;
    if (isString(matrix._datatype)) {
      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;
      zero = typed.convert(0, matrix._datatype);
    }
    var invoke = function invoke(v, x, y) {
      v = callback(v, x, y);
      if (!eq(v, zero)) {
        values.push(v);
        index.push(x);
      }
    };
    for (var j = minColumn;j <= maxColumn; j++) {
      ptr.push(values.length);
      var k0 = matrix._ptr[j];
      var k1 = matrix._ptr[j + 1];
      if (skipZeros) {
        for (var k = k0;k < k1; k++) {
          var i = matrix._index[k];
          if (i >= minRow && i <= maxRow) {
            invoke(matrix._values[k], i - minRow, j - minColumn);
          }
        }
      } else {
        var _values = {};
        for (var _k = k0;_k < k1; _k++) {
          var _i4 = matrix._index[_k];
          _values[_i4] = matrix._values[_k];
        }
        for (var _i5 = minRow;_i5 <= maxRow; _i5++) {
          var value = _i5 in _values ? _values[_i5] : 0;
          invoke(value, _i5 - minRow, j - minColumn);
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix({
      values,
      index,
      ptr,
      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
    });
  }
  SparseMatrix.prototype.forEach = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke forEach on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    for (var j = 0;j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      if (skipZeros) {
        for (var k = k0;k < k1; k++) {
          var i = this._index[k];
          callback(this._values[k], [i, j], me);
        }
      } else {
        var values = {};
        for (var _k2 = k0;_k2 < k1; _k2++) {
          var _i6 = this._index[_k2];
          values[_i6] = this._values[_k2];
        }
        for (var _i7 = 0;_i7 < rows; _i7++) {
          var value = _i7 in values ? values[_i7] : 0;
          callback(value, [_i7, j], me);
        }
      }
    }
  };
  SparseMatrix.prototype[Symbol.iterator] = function* () {
    if (!this._values) {
      throw new Error("Cannot iterate a Pattern only matrix");
    }
    var columns = this._size[1];
    for (var j = 0;j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k = k0;k < k1; k++) {
        var i = this._index[k];
        yield {
          value: this._values[k],
          index: [i, j]
        };
      }
    }
  };
  SparseMatrix.prototype.toArray = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, true);
  };
  SparseMatrix.prototype.valueOf = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, false);
  };
  function _toArray(values, index, ptr, size, copy) {
    var rows = size[0];
    var columns = size[1];
    var a = [];
    var i, j;
    for (i = 0;i < rows; i++) {
      a[i] = [];
      for (j = 0;j < columns; j++) {
        a[i][j] = 0;
      }
    }
    for (j = 0;j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (var k = k0;k < k1; k++) {
        i = index[k];
        a[i][j] = values ? copy ? clone(values[k]) : values[k] : 1;
      }
    }
    return a;
  }
  SparseMatrix.prototype.format = function(options) {
    var rows = this._size[0];
    var columns = this._size[1];
    var density = this.density();
    var str = "Sparse Matrix [" + format3(rows, options) + " x " + format3(columns, options) + "] density: " + format3(density, options) + "\n";
    for (var j = 0;j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k = k0;k < k1; k++) {
        var i = this._index[k];
        str += "\n    (" + format3(i, options) + ", " + format3(j, options) + ") ==> " + (this._values ? format3(this._values[k], options) : "X");
      }
    }
    return str;
  };
  SparseMatrix.prototype.toString = function() {
    return format3(this.toArray());
  };
  SparseMatrix.prototype.toJSON = function() {
    return {
      mathjs: "SparseMatrix",
      values: this._values,
      index: this._index,
      ptr: this._ptr,
      size: this._size,
      datatype: this._datatype
    };
  };
  SparseMatrix.prototype.diagonal = function(k) {
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var values = [];
    var index = [];
    var ptr = [];
    ptr[0] = 0;
    for (var j = kSuper;j < columns && values.length < n; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var x = k0;x < k1; x++) {
        var i = this._index[x];
        if (i === j - kSuper + kSub) {
          values.push(this._values[x]);
          index[values.length - 1] = i - kSub;
          break;
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix({
      values,
      index,
      ptr,
      size: [n, 1]
    });
  };
  SparseMatrix.fromJSON = function(json) {
    return new SparseMatrix(json);
  };
  SparseMatrix.diagonal = function(size, value, k, defaultValue, datatype) {
    if (!isArray(size)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size = size.map(function(s) {
      if (isBigNumber(s)) {
        s = s.toNumber();
      }
      if (!isNumber(s) || !isInteger(s) || s < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s;
    });
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var eq = equalScalar;
    var zero = 0;
    if (isString(datatype)) {
      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;
      zero = typed.convert(0, datatype);
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = size[0];
    var columns = size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value(i2) {
        return value[i2];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value(i2) {
        return value.get([i2]);
      };
    } else {
      _value = function _value() {
        return value;
      };
    }
    var values = [];
    var index = [];
    var ptr = [];
    for (var j = 0;j < columns; j++) {
      ptr.push(values.length);
      var i = j - kSuper;
      if (i >= 0 && i < n) {
        var v = _value(i);
        if (!eq(v, zero)) {
          index.push(i + kSub);
          values.push(v);
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix({
      values,
      index,
      ptr,
      size: [rows, columns]
    });
  };
  SparseMatrix.prototype.swapRows = function(i, j) {
    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i, this._size[0]);
    validateIndex(j, this._size[0]);
    SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr);
    return this;
  };
  SparseMatrix._forEachRow = function(j, values, index, ptr, callback) {
    var k0 = ptr[j];
    var k1 = ptr[j + 1];
    for (var k = k0;k < k1; k++) {
      callback(index[k], values[k]);
    }
  };
  SparseMatrix._swapRows = function(x, y, columns, values, index, ptr) {
    for (var j = 0;j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      var kx = _getValueIndex(x, k0, k1, index);
      var ky = _getValueIndex(y, k0, k1, index);
      if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
        if (values) {
          var v = values[kx];
          values[kx] = values[ky];
          values[ky] = v;
        }
        continue;
      }
      if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
        var vx = values ? values[kx] : undefined;
        index.splice(ky, 0, y);
        if (values) {
          values.splice(ky, 0, vx);
        }
        index.splice(ky <= kx ? kx + 1 : kx, 1);
        if (values) {
          values.splice(ky <= kx ? kx + 1 : kx, 1);
        }
        continue;
      }
      if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
        var vy = values ? values[ky] : undefined;
        index.splice(kx, 0, x);
        if (values) {
          values.splice(kx, 0, vy);
        }
        index.splice(kx <= ky ? ky + 1 : ky, 1);
        if (values) {
          values.splice(kx <= ky ? ky + 1 : ky, 1);
        }
      }
    }
  };
  return SparseMatrix;
}, {
  isClass: true
});
// ../../node_modules/mathjs/lib/esm/type/number.js
var getNonDecimalNumberParts = function(input) {
  var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
  if (nonDecimalWithRadixMatch) {
    var radix = {
      "0b": 2,
      "0o": 8,
      "0x": 16
    }[nonDecimalWithRadixMatch[1]];
    var integerPart = nonDecimalWithRadixMatch[2];
    var fractionalPart = nonDecimalWithRadixMatch[3];
    return {
      input,
      radix,
      integerPart,
      fractionalPart
    };
  } else {
    return null;
  }
};
var makeNumberFromNonDecimalParts = function(parts) {
  var n = parseInt(parts.integerPart, parts.radix);
  var f = 0;
  for (var i = 0;i < parts.fractionalPart.length; i++) {
    var digitValue = parseInt(parts.fractionalPart[i], parts.radix);
    f += digitValue / Math.pow(parts.radix, i + 1);
  }
  var result = n + f;
  if (isNaN(result)) {
    throw new SyntaxError('String "' + parts.input + '" is no valid number');
  }
  return result;
};
var name19 = "number";
var dependencies20 = ["typed"];
var createNumber = factory(name19, dependencies20, (_ref) => {
  var {
    typed
  } = _ref;
  var number22 = typed("number", {
    "": function _() {
      return 0;
    },
    number: function number(x) {
      return x;
    },
    string: function string(x) {
      if (x === "NaN")
        return NaN;
      var nonDecimalNumberParts = getNonDecimalNumberParts(x);
      if (nonDecimalNumberParts) {
        return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
      }
      var size = 0;
      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (wordSizeSuffixMatch) {
        size = Number(wordSizeSuffixMatch[2]);
        x = wordSizeSuffixMatch[1];
      }
      var num = Number(x);
      if (isNaN(num)) {
        throw new SyntaxError('String "' + x + '" is no valid number');
      }
      if (wordSizeSuffixMatch) {
        if (num > 2 ** size - 1) {
          throw new SyntaxError("String \"".concat(x, "\" is out of range"));
        }
        if (num >= 2 ** (size - 1)) {
          num = num - 2 ** size;
        }
      }
      return num;
    },
    BigNumber: function BigNumber(x) {
      return x.toNumber();
    },
    Fraction: function Fraction(x) {
      return x.valueOf();
    },
    Unit: function Unit(x) {
      throw new Error("Second argument with valueless unit expected");
    },
    null: function _null(x) {
      return 0;
    },
    "Unit, string | Unit": function UnitStringUnit(unit, valuelessUnit) {
      return unit.toNumber(valuelessUnit);
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
  number22.fromJSON = function(json) {
    return parseFloat(json.value);
  };
  return number22;
});
// ../../node_modules/mathjs/lib/esm/type/string.js
var name20 = "string";
var dependencies21 = ["typed"];
var createString = factory(name20, dependencies21, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name20, {
    "": function _() {
      return "";
    },
    number: format,
    null: function _null(x) {
      return "null";
    },
    boolean: function boolean(x) {
      return x + "";
    },
    string: function string(x) {
      return x;
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2)),
    any: function any(x) {
      return String(x);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/type/boolean.js
var name21 = "boolean";
var dependencies22 = ["typed"];
var createBoolean = factory(name21, dependencies22, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name21, {
    "": function _() {
      return false;
    },
    boolean: function boolean(x) {
      return x;
    },
    number: function number(x) {
      return !!x;
    },
    null: function _null(x) {
      return false;
    },
    BigNumber: function BigNumber(x) {
      return !x.isZero();
    },
    string: function string(x) {
      var lcase = x.toLowerCase();
      if (lcase === "true") {
        return true;
      } else if (lcase === "false") {
        return false;
      }
      var num = Number(x);
      if (x !== "" && !isNaN(num)) {
        return !!num;
      }
      throw new Error('Cannot convert "' + x + '" to a boolean');
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/type/bignumber/function/bignumber.js
var name22 = "bignumber";
var dependencies23 = ["typed", "BigNumber"];
var createBignumber = factory(name22, dependencies23, (_ref) => {
  var {
    typed,
    BigNumber
  } = _ref;
  return typed("bignumber", {
    "": function _() {
      return new BigNumber(0);
    },
    number: function number(x) {
      return new BigNumber(x + "");
    },
    string: function string(x) {
      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (wordSizeSuffixMatch) {
        var size = wordSizeSuffixMatch[2];
        var n = BigNumber(wordSizeSuffixMatch[1]);
        var twoPowSize = new BigNumber(2).pow(Number(size));
        if (n.gt(twoPowSize.sub(1))) {
          throw new SyntaxError("String \"".concat(x, "\" is out of range"));
        }
        var twoPowSizeSubOne = new BigNumber(2).pow(Number(size) - 1);
        if (n.gte(twoPowSizeSubOne)) {
          return n.sub(twoPowSize);
        } else {
          return n;
        }
      }
      return new BigNumber(x);
    },
    BigNumber: function BigNumber(x) {
      return x;
    },
    Fraction: function Fraction(x) {
      return new BigNumber(x.n).div(x.d).times(x.s);
    },
    null: function _null(x) {
      return new BigNumber(0);
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/type/complex/function/complex.js
var name23 = "complex";
var dependencies24 = ["typed", "Complex"];
var createComplex = factory(name23, dependencies24, (_ref) => {
  var {
    typed,
    Complex: Complex2
  } = _ref;
  return typed("complex", {
    "": function _() {
      return Complex2.ZERO;
    },
    number: function number(x) {
      return new Complex2(x, 0);
    },
    "number, number": function numberNumber(re, im) {
      return new Complex2(re, im);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(re, im) {
      return new Complex2(re.toNumber(), im.toNumber());
    },
    Fraction: function Fraction(x) {
      return new Complex2(x.valueOf(), 0);
    },
    Complex: function Complex(x) {
      return x.clone();
    },
    string: function string(x) {
      return Complex2(x);
    },
    null: function _null(x) {
      return Complex2(0);
    },
    Object: function Object(x) {
      if ("re" in x && "im" in x) {
        return new Complex2(x.re, x.im);
      }
      if ("r" in x && "phi" in x || "abs" in x && "arg" in x) {
        return new Complex2(x);
      }
      throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/type/fraction/function/fraction.js
var name24 = "fraction";
var dependencies25 = ["typed", "Fraction"];
var createFraction = factory(name24, dependencies25, (_ref) => {
  var {
    typed,
    Fraction: Fraction2
  } = _ref;
  return typed("fraction", {
    number: function number(x) {
      if (!isFinite(x) || isNaN(x)) {
        throw new Error(x + " cannot be represented as a fraction");
      }
      return new Fraction2(x);
    },
    string: function string(x) {
      return new Fraction2(x);
    },
    "number, number": function numberNumber(numerator, denominator) {
      return new Fraction2(numerator, denominator);
    },
    null: function _null(x) {
      return new Fraction2(0);
    },
    BigNumber: function BigNumber(x) {
      return new Fraction2(x.toString());
    },
    Fraction: function Fraction(x) {
      return x;
    },
    Object: function Object(x) {
      return new Fraction2(x);
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/type/matrix/function/matrix.js
var name25 = "matrix";
var dependencies26 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
var createMatrix = factory(name25, dependencies26, (_ref) => {
  var {
    typed,
    Matrix,
    DenseMatrix,
    SparseMatrix
  } = _ref;
  return typed(name25, {
    "": function _() {
      return _create([]);
    },
    string: function string(format4) {
      return _create([], format4);
    },
    "string, string": function stringString(format4, datatype) {
      return _create([], format4, datatype);
    },
    Array: function Array(data) {
      return _create(data);
    },
    Matrix: function Matrix(data) {
      return _create(data, data.storage());
    },
    "Array | Matrix, string": _create,
    "Array | Matrix, string, string": _create
  });
  function _create(data, format4, datatype) {
    if (format4 === "dense" || format4 === "default" || format4 === undefined) {
      return new DenseMatrix(data, datatype);
    }
    if (format4 === "sparse") {
      return new SparseMatrix(data, datatype);
    }
    throw new TypeError("Unknown matrix type " + JSON.stringify(format4) + ".");
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js
var name26 = "matrixFromFunction";
var dependencies27 = ["typed", "matrix", "isZero"];
var createMatrixFromFunction = factory(name26, dependencies27, (_ref) => {
  var {
    typed,
    matrix,
    isZero
  } = _ref;
  return typed(name26, {
    "Array | Matrix, function, string, string": function ArrayMatrixFunctionStringString(size, fn, format4, datatype) {
      return _create(size, fn, format4, datatype);
    },
    "Array | Matrix, function, string": function ArrayMatrixFunctionString(size, fn, format4) {
      return _create(size, fn, format4);
    },
    "Matrix, function": function MatrixFunction(size, fn) {
      return _create(size, fn, "dense");
    },
    "Array, function": function ArrayFunction(size, fn) {
      return _create(size, fn, "dense").toArray();
    },
    "Array | Matrix, string, function": function ArrayMatrixStringFunction(size, format4, fn) {
      return _create(size, fn, format4);
    },
    "Array | Matrix, string, string, function": function ArrayMatrixStringStringFunction(size, format4, datatype, fn) {
      return _create(size, fn, format4, datatype);
    }
  });
  function _create(size, fn, format4, datatype) {
    var m;
    if (datatype !== undefined) {
      m = matrix(format4, datatype);
    } else {
      m = matrix(format4);
    }
    m.resize(size);
    m.forEach(function(_, index) {
      var val = fn(index);
      if (isZero(val))
        return;
      m.set(index, val);
    });
    return m;
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/matrixFromRows.js
var name27 = "matrixFromRows";
var dependencies28 = ["typed", "matrix", "flatten", "size"];
var createMatrixFromRows = factory(name27, dependencies28, (_ref) => {
  var {
    typed,
    matrix,
    flatten: flatten2,
    size
  } = _ref;
  return typed(name27, {
    "...Array": function Array(arr) {
      return _createArray(arr);
    },
    "...Matrix": function Matrix(arr) {
      return matrix(_createArray(arr.map((m) => m.toArray())));
    }
  });
  function _createArray(arr) {
    if (arr.length === 0)
      throw new TypeError("At least one row is needed to construct a matrix.");
    var N = checkVectorTypeAndReturnLength(arr[0]);
    var result = [];
    for (var row of arr) {
      var rowLength = checkVectorTypeAndReturnLength(row);
      if (rowLength !== N) {
        throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (rowLength | 0));
      }
      result.push(flatten2(row));
    }
    return result;
  }
  function checkVectorTypeAndReturnLength(vec) {
    var s = size(vec);
    if (s.length === 1) {
      return s[0];
    } else if (s.length === 2) {
      if (s[0] === 1) {
        return s[1];
      } else if (s[1] === 1) {
        return s[0];
      } else {
        throw new TypeError("At least one of the arguments is not a vector.");
      }
    } else {
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/matrixFromColumns.js
var name28 = "matrixFromColumns";
var dependencies29 = ["typed", "matrix", "flatten", "size"];
var createMatrixFromColumns = factory(name28, dependencies29, (_ref) => {
  var {
    typed,
    matrix,
    flatten: flatten2,
    size
  } = _ref;
  return typed(name28, {
    "...Array": function Array(arr) {
      return _createArray(arr);
    },
    "...Matrix": function Matrix(arr) {
      return matrix(_createArray(arr.map((m) => m.toArray())));
    }
  });
  function _createArray(arr) {
    if (arr.length === 0)
      throw new TypeError("At least one column is needed to construct a matrix.");
    var N = checkVectorTypeAndReturnLength(arr[0]);
    var result = [];
    for (var i = 0;i < N; i++) {
      result[i] = [];
    }
    for (var col of arr) {
      var colLength = checkVectorTypeAndReturnLength(col);
      if (colLength !== N) {
        throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (colLength | 0));
      }
      var f = flatten2(col);
      for (var _i = 0;_i < N; _i++) {
        result[_i].push(f[_i]);
      }
    }
    return result;
  }
  function checkVectorTypeAndReturnLength(vec) {
    var s = size(vec);
    if (s.length === 1) {
      return s[0];
    } else if (s.length === 2) {
      if (s[0] === 1) {
        return s[1];
      } else if (s[1] === 1) {
        return s[0];
      } else {
        throw new TypeError("At least one of the arguments is not a vector.");
      }
    } else {
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
    }
  }
});
// ../../node_modules/mathjs/lib/esm/type/unit/function/splitUnit.js
var name29 = "splitUnit";
var dependencies30 = ["typed"];
var createSplitUnit = factory(name29, dependencies30, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name29, {
    "Unit, Array": function UnitArray(unit, parts) {
      return unit.splitUnit(parts);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js
var name30 = "unaryMinus";
var dependencies31 = ["typed"];
var createUnaryMinus = factory(name30, dependencies31, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name30, {
    number: unaryMinusNumber,
    "Complex | BigNumber | Fraction": (x) => x.neg(),
    Unit: typed.referToSelf((self2) => (x) => {
      var res = x.clone();
      res.value = typed.find(self2, res.valueType())(x.value);
      return res;
    }),
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2, true))
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/unaryPlus.js
var name31 = "unaryPlus";
var dependencies32 = ["typed", "config", "BigNumber"];
var createUnaryPlus = factory(name31, dependencies32, (_ref) => {
  var {
    typed,
    config: config6,
    BigNumber
  } = _ref;
  return typed(name31, {
    number: unaryPlusNumber,
    Complex: function Complex(x) {
      return x;
    },
    BigNumber: function BigNumber(x) {
      return x;
    },
    Fraction: function Fraction(x) {
      return x;
    },
    Unit: function Unit(x) {
      return x.clone();
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2, true)),
    "boolean | string": function booleanString(x) {
      return config6.number === "BigNumber" ? new BigNumber(+x) : +x;
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/abs.js
var name32 = "abs";
var dependencies33 = ["typed"];
var createAbs = factory(name32, dependencies33, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name32, {
    number: absNumber,
    "Complex | BigNumber | Fraction | Unit": (x) => x.abs(),
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2, true))
  });
});
// ../../node_modules/mathjs/lib/esm/function/matrix/apply.js
var _apply = function(mat, dim, callback) {
  var i, ret, tran;
  if (dim <= 0) {
    if (!Array.isArray(mat[0])) {
      return callback(mat);
    } else {
      tran = _switch2(mat);
      ret = [];
      for (i = 0;i < tran.length; i++) {
        ret[i] = _apply(tran[i], dim - 1, callback);
      }
      return ret;
    }
  } else {
    ret = [];
    for (i = 0;i < mat.length; i++) {
      ret[i] = _apply(mat[i], dim - 1, callback);
    }
    return ret;
  }
};
var _switch2 = function(mat) {
  var I = mat.length;
  var J = mat[0].length;
  var i, j;
  var ret = [];
  for (j = 0;j < J; j++) {
    var tmp = [];
    for (i = 0;i < I; i++) {
      tmp.push(mat[i][j]);
    }
    ret.push(tmp);
  }
  return ret;
};
var name33 = "apply";
var dependencies34 = ["typed", "isInteger"];
var createApply = factory(name33, dependencies34, (_ref) => {
  var {
    typed,
    isInteger: isInteger2
  } = _ref;
  return typed(name33, {
    "Array | Matrix, number | BigNumber, function": function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {
      if (!isInteger2(dim)) {
        throw new TypeError("Integer number expected for dimension");
      }
      var size = Array.isArray(mat) ? arraySize(mat) : mat.size();
      if (dim < 0 || dim >= size.length) {
        throw new IndexError(dim, size.length);
      }
      if (isMatrix(mat)) {
        return mat.create(_apply(mat.valueOf(), dim, callback));
      } else {
        return _apply(mat, dim, callback);
      }
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js
var name34 = "addScalar";
var dependencies35 = ["typed"];
var createAddScalar = factory(name34, dependencies35, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name34, {
    "number, number": addNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.add(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.plus(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.add(y);
    },
    "Unit, Unit": typed.referToSelf((self2) => (x, y) => {
      if (x.value === null || x.value === undefined) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y.value === null || y.value === undefined) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x.equalBase(y))
        throw new Error("Units do not match");
      var res = x.clone();
      res.value = typed.find(self2, [res.valueType(), y.valueType()])(res.value, y.value);
      res.fixPrefix = false;
      return res;
    })
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/cbrt.js
var name35 = "cbrt";
var dependencies36 = ["config", "typed", "isNegative", "unaryMinus", "matrix", "Complex", "BigNumber", "Fraction"];
var createCbrt = factory(name35, dependencies36, (_ref) => {
  var {
    config: config6,
    typed,
    isNegative,
    unaryMinus,
    matrix,
    Complex: Complex2,
    BigNumber,
    Fraction: Fraction2
  } = _ref;
  return typed(name35, {
    number: cbrtNumber,
    Complex: _cbrtComplex,
    "Complex, boolean": _cbrtComplex,
    BigNumber: function BigNumber(x) {
      return x.cbrt();
    },
    Unit: _cbrtUnit
  });
  function _cbrtComplex(x, allRoots) {
    var arg3 = x.arg() / 3;
    var abs2 = x.abs();
    var principal = new Complex2(cbrtNumber(abs2), 0).mul(new Complex2(0, arg3).exp());
    if (allRoots) {
      var all = [principal, new Complex2(cbrtNumber(abs2), 0).mul(new Complex2(0, arg3 + Math.PI * 2 / 3).exp()), new Complex2(cbrtNumber(abs2), 0).mul(new Complex2(0, arg3 - Math.PI * 2 / 3).exp())];
      return config6.matrix === "Array" ? all : matrix(all);
    } else {
      return principal;
    }
  }
  function _cbrtUnit(x) {
    if (x.value && isComplex(x.value)) {
      var result = x.clone();
      result.value = 1;
      result = result.pow(1 / 3);
      result.value = _cbrtComplex(x.value);
      return result;
    } else {
      var negate = isNegative(x.value);
      if (negate) {
        x.value = unaryMinus(x.value);
      }
      var third;
      if (isBigNumber(x.value)) {
        third = new BigNumber(1).div(3);
      } else if (isFraction(x.value)) {
        third = new Fraction2(1, 3);
      } else {
        third = 1 / 3;
      }
      var _result = x.pow(third);
      if (negate) {
        _result.value = unaryMinus(_result.value);
      }
      return _result;
    }
  }
});
// ../../node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js
var name36 = "matAlgo11xS0s";
var dependencies37 = ["typed", "equalScalar"];
var createMatAlgo11xS0s = factory(name36, dependencies37, (_ref) => {
  var {
    typed,
    equalScalar
  } = _ref;
  return function matAlgo11xS0s(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      eq = typed.find(equalScalar, [dt, dt]);
      zero = typed.convert(0, dt);
      b = typed.convert(b, dt);
      cf = typed.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    for (var j = 0;j < columns; j++) {
      cptr[j] = cindex.length;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0;k < k1; k++) {
        var i = aindex[k];
        var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
        if (!eq(v, zero)) {
          cindex.push(i);
          cvalues.push(v);
        }
      }
    }
    cptr[columns] = cindex.length;
    return s.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// ../../node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js
var name37 = "matAlgo12xSfs";
var dependencies38 = ["typed", "DenseMatrix"];
var createMatAlgo12xSfs = factory(name37, dependencies38, (_ref) => {
  var {
    typed,
    DenseMatrix
  } = _ref;
  return function matAlgo12xSfs(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed.convert(b, dt);
      cf = typed.find(callback, [dt, dt]);
    }
    var cdata = [];
    var x = [];
    var w = [];
    for (var j = 0;j < columns; j++) {
      var mark = j + 1;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0;k < k1; k++) {
        var r = aindex[k];
        x[r] = avalues[k];
        w[r] = mark;
      }
      for (var i = 0;i < rows; i++) {
        if (j === 0) {
          cdata[i] = [];
        }
        if (w[i] === mark) {
          cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
        } else {
          cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
        }
      }
    }
    return new DenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// ../../node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js
var name38 = "matAlgo14xDs";
var dependencies39 = ["typed"];
var createMatAlgo14xDs = factory(name38, dependencies39, (_ref) => {
  var {
    typed
  } = _ref;
  return function matAlgo14xDs(a, b, callback, inverse) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed.convert(b, dt);
      cf = typed.find(callback, [dt, dt]);
    }
    var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];
    return a.createDenseMatrix({
      data: cdata,
      size: clone(asize),
      datatype: dt
    });
  };
  function _iterate(f, level, s, n, av, bv, inverse) {
    var cv = [];
    if (level === s.length - 1) {
      for (var i = 0;i < n; i++) {
        cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
      }
    } else {
      for (var j = 0;j < n; j++) {
        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
      }
    }
    return cv;
  }
});

// ../../node_modules/mathjs/lib/esm/function/arithmetic/ceil.js
var name39 = "ceil";
var dependencies40 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var createCeilNumber = factory(name39, ["typed", "config", "round"], (_ref) => {
  var {
    typed,
    config: config6,
    round: round2
  } = _ref;
  return typed(name39, {
    number: function number(x) {
      if (nearlyEqual(x, round2(x), config6.epsilon)) {
        return round2(x);
      } else {
        return Math.ceil(x);
      }
    },
    "number, number": function numberNumber(x, n) {
      if (nearlyEqual(x, round2(x, n), config6.epsilon)) {
        return round2(x, n);
      } else {
        var [number29, exponent] = "".concat(x, "e").split("e");
        var result = Math.ceil(Number("".concat(number29, "e").concat(Number(exponent) + n)));
        [number29, exponent] = "".concat(result, "e").split("e");
        return Number("".concat(number29, "e").concat(Number(exponent) - n));
      }
    }
  });
});
var createCeil = factory(name39, dependencies40, (_ref2) => {
  var {
    typed,
    config: config6,
    round: round2,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix
  } = _ref2;
  var matAlgo11xS0s2 = createMatAlgo11xS0s({
    typed,
    equalScalar
  });
  var matAlgo12xSfs2 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matAlgo14xDs2 = createMatAlgo14xDs({
    typed
  });
  var ceilNumber = createCeilNumber({
    typed,
    config: config6,
    round: round2
  });
  return typed("ceil", {
    number: ceilNumber.signatures.number,
    "number,number": ceilNumber.signatures["number,number"],
    Complex: function Complex(x) {
      return x.ceil();
    },
    "Complex, number": function ComplexNumber(x, n) {
      return x.ceil(n);
    },
    "Complex, BigNumber": function ComplexBigNumber(x, n) {
      return x.ceil(n.toNumber());
    },
    BigNumber: function BigNumber(x) {
      if (nearlyEqual2(x, round2(x), config6.epsilon)) {
        return round2(x);
      } else {
        return x.ceil();
      }
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
      if (nearlyEqual2(x, round2(x, n), config6.epsilon)) {
        return round2(x, n);
      } else {
        return x.toDecimalPlaces(n.toNumber(), decimal_default.ROUND_CEIL);
      }
    },
    Fraction: function Fraction(x) {
      return x.ceil();
    },
    "Fraction, number": function FractionNumber(x, n) {
      return x.ceil(n);
    },
    "Fraction, BigNumber": function FractionBigNumber(x, n) {
      return x.ceil(n.toNumber());
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => {
      return deepMap(x, self2, true);
    }),
    "Array, number | BigNumber": typed.referToSelf((self2) => (x, n) => {
      return deepMap(x, (i) => self2(i, n), true);
    }),
    "SparseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
      return matAlgo11xS0s2(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs2(x, y, self2, false);
    }),
    "number | Complex | Fraction | BigNumber, Array": typed.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs2(matrix(y), x, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0))
        return zeros2(y.size(), y.storage());
      if (y.storage() === "dense") {
        return matAlgo14xDs2(y, x, self2, true);
      }
      return matAlgo12xSfs2(y, x, self2, true);
    })
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/cube.js
var name40 = "cube";
var dependencies41 = ["typed"];
var createCube = factory(name40, dependencies41, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name40, {
    number: cubeNumber,
    Complex: function Complex(x) {
      return x.mul(x).mul(x);
    },
    BigNumber: function BigNumber(x) {
      return x.times(x).times(x);
    },
    Fraction: function Fraction(x) {
      return x.pow(3);
    },
    Unit: function Unit(x) {
      return x.pow(3);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/exp.js
var name41 = "exp";
var dependencies42 = ["typed"];
var createExp = factory(name41, dependencies42, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name41, {
    number: expNumber,
    Complex: function Complex(x) {
      return x.exp();
    },
    BigNumber: function BigNumber(x) {
      return x.exp();
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/expm1.js
var name42 = "expm1";
var dependencies43 = ["typed", "Complex"];
var createExpm1 = factory(name42, dependencies43, (_ref) => {
  var {
    typed,
    Complex: _Complex
  } = _ref;
  return typed(name42, {
    number: expm1Number,
    Complex: function Complex(x) {
      var r = Math.exp(x.re);
      return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
    },
    BigNumber: function BigNumber(x) {
      return x.exp().minus(1);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/fix.js
var name43 = "fix";
var dependencies44 = ["typed", "Complex", "matrix", "ceil", "floor", "equalScalar", "zeros", "DenseMatrix"];
var createFixNumber = factory(name43, ["typed", "ceil", "floor"], (_ref) => {
  var {
    typed,
    ceil: ceil2,
    floor: floor2
  } = _ref;
  return typed(name43, {
    number: function number(x) {
      return x > 0 ? floor2(x) : ceil2(x);
    },
    "number, number": function numberNumber(x, n) {
      return x > 0 ? floor2(x, n) : ceil2(x, n);
    }
  });
});
var createFix = factory(name43, dependencies44, (_ref2) => {
  var {
    typed,
    Complex: _Complex,
    matrix,
    ceil: ceil2,
    floor: floor2,
    equalScalar,
    zeros: zeros2,
    DenseMatrix
  } = _ref2;
  var matAlgo12xSfs3 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matAlgo14xDs3 = createMatAlgo14xDs({
    typed
  });
  var fixNumber = createFixNumber({
    typed,
    ceil: ceil2,
    floor: floor2
  });
  return typed("fix", {
    number: fixNumber.signatures.number,
    "number, number | BigNumber": fixNumber.signatures["number,number"],
    Complex: function Complex(x) {
      return new _Complex(x.re > 0 ? Math.floor(x.re) : Math.ceil(x.re), x.im > 0 ? Math.floor(x.im) : Math.ceil(x.im));
    },
    "Complex, number": function ComplexNumber(x, n) {
      return new _Complex(x.re > 0 ? floor2(x.re, n) : ceil2(x.re, n), x.im > 0 ? floor2(x.im, n) : ceil2(x.im, n));
    },
    "Complex, BigNumber": function ComplexBigNumber(x, bn) {
      var n = bn.toNumber();
      return new _Complex(x.re > 0 ? floor2(x.re, n) : ceil2(x.re, n), x.im > 0 ? floor2(x.im, n) : ceil2(x.im, n));
    },
    BigNumber: function BigNumber(x) {
      return x.isNegative() ? ceil2(x) : floor2(x);
    },
    "BigNumber, number | BigNumber": function BigNumberNumberBigNumber(x, n) {
      return x.isNegative() ? ceil2(x, n) : floor2(x, n);
    },
    Fraction: function Fraction(x) {
      return x.s < 0 ? x.ceil() : x.floor();
    },
    "Fraction, number | BigNumber": function FractionNumberBigNumber(x, n) {
      return x.s < 0 ? ceil2(x, n) : floor2(x, n);
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => {
      return deepMap(x, self2, true);
    }),
    "Array | Matrix, number | BigNumber": typed.referToSelf((self2) => (x, n) => {
      return deepMap(x, (i) => self2(i, n), true);
    }),
    "number | Complex | Fraction | BigNumber, Array": typed.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs3(matrix(y), x, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0))
        return zeros2(y.size(), y.storage());
      if (y.storage() === "dense") {
        return matAlgo14xDs3(y, x, self2, true);
      }
      return matAlgo12xSfs3(y, x, self2, true);
    })
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/floor.js
var name44 = "floor";
var dependencies45 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var createFloorNumber = factory(name44, ["typed", "config", "round"], (_ref) => {
  var {
    typed,
    config: config6,
    round: round2
  } = _ref;
  return typed(name44, {
    number: function number(x) {
      if (nearlyEqual(x, round2(x), config6.epsilon)) {
        return round2(x);
      } else {
        return Math.floor(x);
      }
    },
    "number, number": function numberNumber(x, n) {
      if (nearlyEqual(x, round2(x, n), config6.epsilon)) {
        return round2(x, n);
      } else {
        var [number33, exponent] = "".concat(x, "e").split("e");
        var result = Math.floor(Number("".concat(number33, "e").concat(Number(exponent) + n)));
        [number33, exponent] = "".concat(result, "e").split("e");
        return Number("".concat(number33, "e").concat(Number(exponent) - n));
      }
    }
  });
});
var createFloor = factory(name44, dependencies45, (_ref2) => {
  var {
    typed,
    config: config6,
    round: round2,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix
  } = _ref2;
  var matAlgo11xS0s3 = createMatAlgo11xS0s({
    typed,
    equalScalar
  });
  var matAlgo12xSfs4 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matAlgo14xDs4 = createMatAlgo14xDs({
    typed
  });
  var floorNumber = createFloorNumber({
    typed,
    config: config6,
    round: round2
  });
  return typed("floor", {
    number: floorNumber.signatures.number,
    "number,number": floorNumber.signatures["number,number"],
    Complex: function Complex(x) {
      return x.floor();
    },
    "Complex, number": function ComplexNumber(x, n) {
      return x.floor(n);
    },
    "Complex, BigNumber": function ComplexBigNumber(x, n) {
      return x.floor(n.toNumber());
    },
    BigNumber: function BigNumber(x) {
      if (nearlyEqual2(x, round2(x), config6.epsilon)) {
        return round2(x);
      } else {
        return x.floor();
      }
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
      if (nearlyEqual2(x, round2(x, n), config6.epsilon)) {
        return round2(x, n);
      } else {
        return x.toDecimalPlaces(n.toNumber(), decimal_default.ROUND_FLOOR);
      }
    },
    Fraction: function Fraction(x) {
      return x.floor();
    },
    "Fraction, number": function FractionNumber(x, n) {
      return x.floor(n);
    },
    "Fraction, BigNumber": function FractionBigNumber(x, n) {
      return x.floor(n.toNumber());
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => {
      return deepMap(x, self2, true);
    }),
    "Array, number | BigNumber": typed.referToSelf((self2) => (x, n) => {
      return deepMap(x, (i) => self2(i, n), true);
    }),
    "SparseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
      return matAlgo11xS0s3(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs4(x, y, self2, false);
    }),
    "number | Complex | Fraction | BigNumber, Array": typed.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs4(matrix(y), x, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0))
        return zeros2(y.size(), y.storage());
      if (y.storage() === "dense") {
        return matAlgo14xDs4(y, x, self2, true);
      }
      return matAlgo12xSfs4(y, x, self2, true);
    })
  });
});
// ../../node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js
var name45 = "matAlgo01xDSid";
var dependencies46 = ["typed"];
var createMatAlgo01xDSid = factory(name45, dependencies46, (_ref) => {
  var {
    typed
  } = _ref;
  return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt = typeof adt === "string" && adt === bdt ? adt : undefined;
    var cf = dt ? typed.find(callback, [dt, dt]) : callback;
    var i, j;
    var cdata = [];
    for (i = 0;i < rows; i++) {
      cdata[i] = [];
    }
    var x = [];
    var w = [];
    for (j = 0;j < columns; j++) {
      var mark = j + 1;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0;k < k1; k++) {
        i = bindex[k];
        x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
        w[i] = mark;
      }
      for (i = 0;i < rows; i++) {
        if (w[i] === mark) {
          cdata[i][j] = x[i];
        } else {
          cdata[i][j] = adata[i][j];
        }
      }
    }
    return denseMatrix.createDenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// ../../node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo04xSidSid.js
var name46 = "matAlgo04xSidSid";
var dependencies47 = ["typed", "equalScalar"];
var createMatAlgo04xSidSid = factory(name46, dependencies47, (_ref) => {
  var {
    typed,
    equalScalar
  } = _ref;
  return function matAlgo04xSidSid(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed.find(equalScalar, [dt, dt]);
      zero = typed.convert(0, dt);
      cf = typed.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : undefined;
    var cindex = [];
    var cptr = [];
    var xa = avalues && bvalues ? [] : undefined;
    var xb = avalues && bvalues ? [] : undefined;
    var wa = [];
    var wb = [];
    var i, j, k, k0, k1;
    for (j = 0;j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0;k < k1; k++) {
        i = aindex[k];
        cindex.push(i);
        wa[i] = mark;
        if (xa) {
          xa[i] = avalues[k];
        }
      }
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0;k < k1; k++) {
        i = bindex[k];
        if (wa[i] === mark) {
          if (xa) {
            var v = cf(xa[i], bvalues[k]);
            if (!eq(v, zero)) {
              xa[i] = v;
            } else {
              wa[i] = null;
            }
          }
        } else {
          cindex.push(i);
          wb[i] = mark;
          if (xb) {
            xb[i] = bvalues[k];
          }
        }
      }
      if (xa && xb) {
        k = cptr[j];
        while (k < cindex.length) {
          i = cindex[k];
          if (wa[i] === mark) {
            cvalues[k] = xa[i];
            k++;
          } else if (wb[i] === mark) {
            cvalues[k] = xb[i];
            k++;
          } else {
            cindex.splice(k, 1);
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// ../../node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js
var name47 = "matAlgo10xSids";
var dependencies48 = ["typed", "DenseMatrix"];
var createMatAlgo10xSids = factory(name47, dependencies48, (_ref) => {
  var {
    typed,
    DenseMatrix
  } = _ref;
  return function matAlgo10xSids(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed.convert(b, dt);
      cf = typed.find(callback, [dt, dt]);
    }
    var cdata = [];
    var x = [];
    var w = [];
    for (var j = 0;j < columns; j++) {
      var mark = j + 1;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0;k < k1; k++) {
        var r = aindex[k];
        x[r] = avalues[k];
        w[r] = mark;
      }
      for (var i = 0;i < rows; i++) {
        if (j === 0) {
          cdata[i] = [];
        }
        if (w[i] === mark) {
          cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
        } else {
          cdata[i][j] = b;
        }
      }
    }
    return new DenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// ../../node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo13xDD.js
var name48 = "matAlgo13xDD";
var dependencies49 = ["typed"];
var createMatAlgo13xDD = factory(name48, dependencies49, (_ref) => {
  var {
    typed
  } = _ref;
  return function matAlgo13xDD(a, b, callback) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var csize = [];
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    for (var s = 0;s < asize.length; s++) {
      if (asize[s] !== bsize[s]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      csize[s] = asize[s];
    }
    var dt;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      cf = typed.find(callback, [dt, dt]);
    }
    var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
    return a.createDenseMatrix({
      data: cdata,
      size: csize,
      datatype: dt
    });
  };
  function _iterate(f, level, s, n, av, bv) {
    var cv = [];
    if (level === s.length - 1) {
      for (var i = 0;i < n; i++) {
        cv[i] = f(av[i], bv[i]);
      }
    } else {
      for (var j = 0;j < n; j++) {
        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
      }
    }
    return cv;
  }
});

// ../../node_modules/mathjs/lib/esm/type/matrix/utils/broadcast.js
var name49 = "broadcast";
var dependancies = ["concat"];
var createBroadcast = factory(name49, dependancies, (_ref) => {
  var {
    concat
  } = _ref;
  return function(A, B) {
    var N = Math.max(A._size.length, B._size.length);
    if (A._size.length === B._size.length) {
      if (A._size.every((dim2, i) => dim2 === B._size[i])) {
        return [A, B];
      }
    }
    var sizeA = _padLeft(A._size, N, 0);
    var sizeB = _padLeft(B._size, N, 0);
    var sizeMax = [];
    for (var dim = 0;dim < N; dim++) {
      sizeMax[dim] = Math.max(sizeA[dim], sizeB[dim]);
    }
    for (var _dim = 0;_dim < N; _dim++) {
      _checkRules(sizeA, sizeMax, _dim);
      _checkRules(sizeB, sizeMax, _dim);
    }
    var AA = A.clone();
    var BB = B.clone();
    if (AA._size.length < N) {
      AA.reshape(_padLeft(AA._size, N, 1));
    } else if (BB._size.length < N) {
      BB.reshape(_padLeft(BB._size, N, 1));
    }
    for (var _dim2 = 0;_dim2 < N; _dim2++) {
      if (AA._size[_dim2] < sizeMax[_dim2]) {
        AA = _stretch(AA, sizeMax[_dim2], _dim2);
      }
      if (BB._size[_dim2] < sizeMax[_dim2]) {
        BB = _stretch(BB, sizeMax[_dim2], _dim2);
      }
    }
    return [AA, BB];
  };
  function _padLeft(shape, N, filler) {
    return [...Array(N - shape.length).fill(filler), ...shape];
  }
  function _stretch(arrayToStretch, sizeToStretch, dimToStretch) {
    return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);
  }
  function _checkRules(shape, sizeMax, dim) {
    if (shape[dim] < sizeMax[dim] & shape[dim] > 1) {
      throw new Error("shape missmatch: missmatch is found in arg with shape (".concat(shape, ") not possible to broadcast dimension ").concat(dim, " with size ").concat(shape[dim], " to size ").concat(sizeMax[dim]));
    }
  }
});

// ../../node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js
var name50 = "matrixAlgorithmSuite";
var dependencies50 = ["typed", "matrix", "concat"];
var createMatrixAlgorithmSuite = factory(name50, dependencies50, (_ref) => {
  var {
    typed,
    matrix,
    concat
  } = _ref;
  var matAlgo13xDD2 = createMatAlgo13xDD({
    typed
  });
  var matAlgo14xDs5 = createMatAlgo14xDs({
    typed
  });
  var broadcast2 = createBroadcast({
    concat
  });
  return function matrixAlgorithmSuite(options) {
    var elop = options.elop;
    var SD = options.SD || options.DS;
    var matrixSignatures;
    if (elop) {
      matrixSignatures = {
        "DenseMatrix, DenseMatrix": (x, y) => matAlgo13xDD2(...broadcast2(x, y), elop),
        "Array, Array": (x, y) => matAlgo13xDD2(...broadcast2(matrix(x), matrix(y)), elop).valueOf(),
        "Array, DenseMatrix": (x, y) => matAlgo13xDD2(...broadcast2(matrix(x), y), elop),
        "DenseMatrix, Array": (x, y) => matAlgo13xDD2(...broadcast2(x, matrix(y)), elop)
      };
      if (options.SS) {
        matrixSignatures["SparseMatrix, SparseMatrix"] = (x, y) => options.SS(...broadcast2(x, y), elop, false);
      }
      if (options.DS) {
        matrixSignatures["DenseMatrix, SparseMatrix"] = (x, y) => options.DS(...broadcast2(x, y), elop, false);
        matrixSignatures["Array, SparseMatrix"] = (x, y) => options.DS(...broadcast2(matrix(x), y), elop, false);
      }
      if (SD) {
        matrixSignatures["SparseMatrix, DenseMatrix"] = (x, y) => SD(...broadcast2(y, x), elop, true);
        matrixSignatures["SparseMatrix, Array"] = (x, y) => SD(...broadcast2(matrix(y), x), elop, true);
      }
    } else {
      matrixSignatures = {
        "DenseMatrix, DenseMatrix": typed.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD2(...broadcast2(x, y), self2);
        }),
        "Array, Array": typed.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD2(...broadcast2(matrix(x), matrix(y)), self2).valueOf();
        }),
        "Array, DenseMatrix": typed.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD2(...broadcast2(matrix(x), y), self2);
        }),
        "DenseMatrix, Array": typed.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD2(...broadcast2(x, matrix(y)), self2);
        })
      };
      if (options.SS) {
        matrixSignatures["SparseMatrix, SparseMatrix"] = typed.referToSelf((self2) => (x, y) => {
          return options.SS(...broadcast2(x, y), self2, false);
        });
      }
      if (options.DS) {
        matrixSignatures["DenseMatrix, SparseMatrix"] = typed.referToSelf((self2) => (x, y) => {
          return options.DS(...broadcast2(x, y), self2, false);
        });
        matrixSignatures["Array, SparseMatrix"] = typed.referToSelf((self2) => (x, y) => {
          return options.DS(...broadcast2(matrix(x), y), self2, false);
        });
      }
      if (SD) {
        matrixSignatures["SparseMatrix, DenseMatrix"] = typed.referToSelf((self2) => (x, y) => {
          return SD(...broadcast2(y, x), self2, true);
        });
        matrixSignatures["SparseMatrix, Array"] = typed.referToSelf((self2) => (x, y) => {
          return SD(...broadcast2(matrix(y), x), self2, true);
        });
      }
    }
    var scalar = options.scalar || "any";
    var Ds = options.Ds || options.Ss;
    if (Ds) {
      if (elop) {
        matrixSignatures["DenseMatrix," + scalar] = (x, y) => matAlgo14xDs5(x, y, elop, false);
        matrixSignatures[scalar + ", DenseMatrix"] = (x, y) => matAlgo14xDs5(y, x, elop, true);
        matrixSignatures["Array," + scalar] = (x, y) => matAlgo14xDs5(matrix(x), y, elop, false).valueOf();
        matrixSignatures[scalar + ", Array"] = (x, y) => matAlgo14xDs5(matrix(y), x, elop, true).valueOf();
      } else {
        matrixSignatures["DenseMatrix," + scalar] = typed.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs5(x, y, self2, false);
        });
        matrixSignatures[scalar + ", DenseMatrix"] = typed.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs5(y, x, self2, true);
        });
        matrixSignatures["Array," + scalar] = typed.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs5(matrix(x), y, self2, false).valueOf();
        });
        matrixSignatures[scalar + ", Array"] = typed.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs5(matrix(y), x, self2, true).valueOf();
        });
      }
    }
    var sS = options.sS !== undefined ? options.sS : options.Ss;
    if (elop) {
      if (options.Ss) {
        matrixSignatures["SparseMatrix," + scalar] = (x, y) => options.Ss(x, y, elop, false);
      }
      if (sS) {
        matrixSignatures[scalar + ", SparseMatrix"] = (x, y) => sS(y, x, elop, true);
      }
    } else {
      if (options.Ss) {
        matrixSignatures["SparseMatrix," + scalar] = typed.referToSelf((self2) => (x, y) => {
          return options.Ss(x, y, self2, false);
        });
      }
      if (sS) {
        matrixSignatures[scalar + ", SparseMatrix"] = typed.referToSelf((self2) => (x, y) => {
          return sS(y, x, self2, true);
        });
      }
    }
    if (elop && elop.signatures) {
      extend(matrixSignatures, elop.signatures);
    }
    return matrixSignatures;
  };
});

// ../../node_modules/mathjs/lib/esm/error/ArgumentsError.js
function ArgumentsError(fn, count, min2, max2) {
  if (!(this instanceof ArgumentsError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.fn = fn;
  this.count = count;
  this.min = min2;
  this.max = max2;
  this.message = "Wrong number of arguments in function " + fn + " (" + count + " provided, " + min2 + (max2 !== undefined && max2 !== null ? "-" + max2 : "") + " expected)";
  this.stack = new Error().stack;
}
ArgumentsError.prototype = new Error;
ArgumentsError.prototype.constructor = Error;
ArgumentsError.prototype.name = "ArgumentsError";
ArgumentsError.prototype.isArgumentsError = true;

// ../../node_modules/mathjs/lib/esm/function/arithmetic/gcd.js
var is1d = function(array5) {
  return !array5.some((element) => Array.isArray(element));
};
var name51 = "gcd";
var dependencies51 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix", "concat"];
var gcdTypes = "number | BigNumber | Fraction | Matrix | Array";
var gcdManyTypesSignature = "".concat(gcdTypes, ", ").concat(gcdTypes, ", ...").concat(gcdTypes);
var createGcd = factory(name51, dependencies51, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    BigNumber,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo01xDSid2 = createMatAlgo01xDSid({
    typed
  });
  var matAlgo04xSidSid2 = createMatAlgo04xSidSid({
    typed,
    equalScalar
  });
  var matAlgo10xSids2 = createMatAlgo10xSids({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite2 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name51, {
    "number, number": gcdNumber,
    "BigNumber, BigNumber": _gcdBigNumber,
    "Fraction, Fraction": (x, y) => x.gcd(y)
  }, matrixAlgorithmSuite2({
    SS: matAlgo04xSidSid2,
    DS: matAlgo01xDSid2,
    Ss: matAlgo10xSids2
  }), {
    [gcdManyTypesSignature]: typed.referToSelf((self2) => (a, b, args) => {
      var res = self2(a, b);
      for (var i = 0;i < args.length; i++) {
        res = self2(res, args[i]);
      }
      return res;
    }),
    Array: typed.referToSelf((self2) => (array5) => {
      if (array5.length === 1 && Array.isArray(array5[0]) && is1d(array5[0])) {
        return self2(...array5[0]);
      }
      if (is1d(array5)) {
        return self2(...array5);
      }
      throw new ArgumentsError("gcd() supports only 1d matrices!");
    }),
    Matrix: typed.referToSelf((self2) => (matrix2) => {
      return self2(matrix2.toArray());
    })
  });
  function _gcdBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var zero = new BigNumber(0);
    while (!b.isZero()) {
      var r = a.mod(b);
      a = b;
      b = r;
    }
    return a.lt(zero) ? a.neg() : a;
  }
});
// ../../node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js
var name52 = "matAlgo02xDS0";
var dependencies52 = ["typed", "equalScalar"];
var createMatAlgo02xDS0 = factory(name52, dependencies52, (_ref) => {
  var {
    typed,
    equalScalar
  } = _ref;
  return function matAlgo02xDS0(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed.find(equalScalar, [dt, dt]);
      zero = typed.convert(0, dt);
      cf = typed.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    for (var j = 0;j < columns; j++) {
      cptr[j] = cindex.length;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0;k < k1; k++) {
        var i = bindex[k];
        var cij = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
        if (!eq(cij, zero)) {
          cindex.push(i);
          cvalues.push(cij);
        }
      }
    }
    cptr[columns] = cindex.length;
    return sparseMatrix.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// ../../node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js
var name53 = "matAlgo06xS0S0";
var dependencies53 = ["typed", "equalScalar"];
var createMatAlgo06xS0S0 = factory(name53, dependencies53, (_ref) => {
  var {
    typed,
    equalScalar
  } = _ref;
  return function matAlgo06xS0S0(a, b, callback) {
    var avalues = a._values;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed.find(equalScalar, [dt, dt]);
      zero = typed.convert(0, dt);
      cf = typed.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : undefined;
    var cindex = [];
    var cptr = [];
    var x = cvalues ? [] : undefined;
    var w = [];
    var u = [];
    for (var j = 0;j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      scatter(a, j, w, x, u, mark, cindex, cf);
      scatter(b, j, w, x, u, mark, cindex, cf);
      if (x) {
        var k = cptr[j];
        while (k < cindex.length) {
          var i = cindex[k];
          if (u[i] === mark) {
            var v = x[i];
            if (!eq(v, zero)) {
              cvalues.push(v);
              k++;
            } else {
              cindex.splice(k, 1);
            }
          } else {
            cindex.splice(k, 1);
          }
        }
      } else {
        var p = cptr[j];
        while (p < cindex.length) {
          var r = cindex[p];
          if (u[r] !== mark) {
            cindex.splice(p, 1);
          } else {
            p++;
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// ../../node_modules/mathjs/lib/esm/function/arithmetic/lcm.js
var name54 = "lcm";
var dependencies54 = ["typed", "matrix", "equalScalar", "concat"];
var createLcm = factory(name54, dependencies54, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    concat
  } = _ref;
  var matAlgo02xDS02 = createMatAlgo02xDS0({
    typed,
    equalScalar
  });
  var matAlgo06xS0S02 = createMatAlgo06xS0S0({
    typed,
    equalScalar
  });
  var matAlgo11xS0s4 = createMatAlgo11xS0s({
    typed,
    equalScalar
  });
  var matrixAlgorithmSuite3 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  var lcmTypes = "number | BigNumber | Fraction | Matrix | Array";
  var lcmManySignature = {};
  lcmManySignature["".concat(lcmTypes, ", ").concat(lcmTypes, ", ...").concat(lcmTypes)] = typed.referToSelf((self2) => (a, b, args) => {
    var res = self2(a, b);
    for (var i = 0;i < args.length; i++) {
      res = self2(res, args[i]);
    }
    return res;
  });
  return typed(name54, {
    "number, number": lcmNumber,
    "BigNumber, BigNumber": _lcmBigNumber,
    "Fraction, Fraction": (x, y) => x.lcm(y)
  }, matrixAlgorithmSuite3({
    SS: matAlgo06xS0S02,
    DS: matAlgo02xDS02,
    Ss: matAlgo11xS0s4
  }), lcmManySignature);
  function _lcmBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function lcm must be integer numbers");
    }
    if (a.isZero()) {
      return a;
    }
    if (b.isZero()) {
      return b;
    }
    var prod = a.times(b);
    while (!b.isZero()) {
      var t = b;
      b = a.mod(t);
      a = t;
    }
    return prod.div(a).abs();
  }
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/log10.js
var name55 = "log10";
var dependencies55 = ["typed", "config", "Complex"];
var createLog10 = factory(name55, dependencies55, (_ref) => {
  var {
    typed,
    config: config6,
    Complex: _Complex
  } = _ref;
  return typed(name55, {
    number: function number(x) {
      if (x >= 0 || config6.predictable) {
        return log10Number(x);
      } else {
        return new _Complex(x, 0).log().div(Math.LN10);
      }
    },
    Complex: function Complex(x) {
      return new _Complex(x).log().div(Math.LN10);
    },
    BigNumber: function BigNumber(x) {
      if (!x.isNegative() || config6.predictable) {
        return x.log();
      } else {
        return new _Complex(x.toNumber(), 0).log().div(Math.LN10);
      }
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/log2.js
var name56 = "log2";
var dependencies56 = ["typed", "config", "Complex"];
var createLog2 = factory(name56, dependencies56, (_ref) => {
  var {
    typed,
    config: config6,
    Complex: Complex2
  } = _ref;
  return typed(name56, {
    number: function number(x) {
      if (x >= 0 || config6.predictable) {
        return log2Number(x);
      } else {
        return _log2Complex(new Complex2(x, 0));
      }
    },
    Complex: _log2Complex,
    BigNumber: function BigNumber(x) {
      if (!x.isNegative() || config6.predictable) {
        return x.log(2);
      } else {
        return _log2Complex(new Complex2(x.toNumber(), 0));
      }
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
  function _log2Complex(x) {
    var newX = Math.sqrt(x.re * x.re + x.im * x.im);
    return new Complex2(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);
  }
});
// ../../node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js
var name57 = "matAlgo03xDSf";
var dependencies57 = ["typed"];
var createMatAlgo03xDSf = factory(name57, dependencies57, (_ref) => {
  var {
    typed
  } = _ref;
  return function matAlgo03xDSf(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      zero = typed.convert(0, dt);
      cf = typed.find(callback, [dt, dt]);
    }
    var cdata = [];
    for (var z2 = 0;z2 < rows; z2++) {
      cdata[z2] = [];
    }
    var x = [];
    var w = [];
    for (var j = 0;j < columns; j++) {
      var mark = j + 1;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0;k < k1; k++) {
        var i = bindex[k];
        x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
        w[i] = mark;
      }
      for (var y = 0;y < rows; y++) {
        if (w[y] === mark) {
          cdata[y][j] = x[y];
        } else {
          cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
        }
      }
    }
    return denseMatrix.createDenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// ../../node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo05xSfSf.js
var name58 = "matAlgo05xSfSf";
var dependencies58 = ["typed", "equalScalar"];
var createMatAlgo05xSfSf = factory(name58, dependencies58, (_ref) => {
  var {
    typed,
    equalScalar
  } = _ref;
  return function matAlgo05xSfSf(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed.find(equalScalar, [dt, dt]);
      zero = typed.convert(0, dt);
      cf = typed.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : undefined;
    var cindex = [];
    var cptr = [];
    var xa = cvalues ? [] : undefined;
    var xb = cvalues ? [] : undefined;
    var wa = [];
    var wb = [];
    var i, j, k, k1;
    for (j = 0;j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k = aptr[j], k1 = aptr[j + 1];k < k1; k++) {
        i = aindex[k];
        cindex.push(i);
        wa[i] = mark;
        if (xa) {
          xa[i] = avalues[k];
        }
      }
      for (k = bptr[j], k1 = bptr[j + 1];k < k1; k++) {
        i = bindex[k];
        if (wa[i] !== mark) {
          cindex.push(i);
        }
        wb[i] = mark;
        if (xb) {
          xb[i] = bvalues[k];
        }
      }
      if (cvalues) {
        k = cptr[j];
        while (k < cindex.length) {
          i = cindex[k];
          var wai = wa[i];
          var wbi = wb[i];
          if (wai === mark || wbi === mark) {
            var va = wai === mark ? xa[i] : zero;
            var vb = wbi === mark ? xb[i] : zero;
            var vc = cf(va, vb);
            if (!eq(vc, zero)) {
              cvalues.push(vc);
              k++;
            } else {
              cindex.splice(k, 1);
            }
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// ../../node_modules/mathjs/lib/esm/function/arithmetic/mod.js
var name59 = "mod";
var dependencies59 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createMod = factory(name59, dependencies59, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo02xDS03 = createMatAlgo02xDS0({
    typed,
    equalScalar
  });
  var matAlgo03xDSf2 = createMatAlgo03xDSf({
    typed
  });
  var matAlgo05xSfSf2 = createMatAlgo05xSfSf({
    typed,
    equalScalar
  });
  var matAlgo11xS0s5 = createMatAlgo11xS0s({
    typed,
    equalScalar
  });
  var matAlgo12xSfs5 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite4 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name59, {
    "number, number": modNumber,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      if (y.isNeg()) {
        throw new Error("Cannot calculate mod for a negative divisor");
      }
      return y.isZero() ? x : x.mod(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      if (y.compare(0) < 0) {
        throw new Error("Cannot calculate mod for a negative divisor");
      }
      return x.compare(0) >= 0 ? x.mod(y) : x.mod(y).add(y).mod(y);
    }
  }, matrixAlgorithmSuite4({
    SS: matAlgo05xSfSf2,
    DS: matAlgo03xDSf2,
    SD: matAlgo02xDS03,
    Ss: matAlgo11xS0s5,
    sS: matAlgo12xSfs5
  }));
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js
var name60 = "multiplyScalar";
var dependencies60 = ["typed"];
var createMultiplyScalar = factory(name60, dependencies60, (_ref) => {
  var {
    typed
  } = _ref;
  return typed("multiplyScalar", {
    "number, number": multiplyNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.mul(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.times(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.mul(y);
    },
    "number | Fraction | BigNumber | Complex, Unit": (x, y) => y.multiply(x),
    "Unit, number | Fraction | BigNumber | Complex | Unit": (x, y) => x.multiply(y)
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/multiply.js
var name61 = "multiply";
var dependencies61 = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
var createMultiply = factory(name61, dependencies61, (_ref) => {
  var {
    typed,
    matrix,
    addScalar,
    multiplyScalar,
    equalScalar,
    dot
  } = _ref;
  var matAlgo11xS0s6 = createMatAlgo11xS0s({
    typed,
    equalScalar
  });
  var matAlgo14xDs6 = createMatAlgo14xDs({
    typed
  });
  function _validateMatrixDimensions(size1, size2) {
    switch (size1.length) {
      case 1:
        switch (size2.length) {
          case 1:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
            }
            break;
          case 2:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      case 2:
        switch (size2.length) {
          case 1:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
            }
            break;
          case 2:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      default:
        throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
    }
  }
  function _multiplyVectorVector(a, b, n) {
    if (n === 0) {
      throw new Error("Cannot multiply two empty vectors");
    }
    return dot(a, b);
  }
  function _multiplyVectorMatrix(a, b) {
    if (b.storage() !== "dense") {
      throw new Error("Support for SparseMatrix not implemented");
    }
    return _multiplyVectorDenseMatrix(a, b);
  }
  function _multiplyVectorDenseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var alength = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
    }
    var c = [];
    for (var j = 0;j < bcolumns; j++) {
      var sum2 = mf(adata[0], bdata[0][j]);
      for (var i = 1;i < alength; i++) {
        sum2 = af(sum2, mf(adata[i], bdata[i][j]));
      }
      c[j] = sum2;
    }
    return a.createDenseMatrix({
      data: c,
      size: [bcolumns],
      datatype: dt
    });
  }
  var _multiplyMatrixVector = typed("_multiplyMatrixVector", {
    "DenseMatrix, any": _multiplyDenseMatrixVector,
    "SparseMatrix, any": _multiplySparseMatrixVector
  });
  var _multiplyMatrixMatrix = typed("_multiplyMatrixMatrix", {
    "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
    "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
    "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
    "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
  });
  function _multiplyDenseMatrixVector(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bdt = b._datatype;
    var arows = asize[0];
    var acolumns = asize[1];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
    }
    var c = [];
    for (var i = 0;i < arows; i++) {
      var row = adata[i];
      var sum2 = mf(row[0], bdata[0]);
      for (var j = 1;j < acolumns; j++) {
        sum2 = af(sum2, mf(row[j], bdata[j]));
      }
      c[i] = sum2;
    }
    return a.createDenseMatrix({
      data: c,
      size: [arows],
      datatype: dt
    });
  }
  function _multiplyDenseMatrixDenseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var arows = asize[0];
    var acolumns = asize[1];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
    }
    var c = [];
    for (var i = 0;i < arows; i++) {
      var row = adata[i];
      c[i] = [];
      for (var j = 0;j < bcolumns; j++) {
        var sum2 = mf(row[0], bdata[0][j]);
        for (var x = 1;x < acolumns; x++) {
          sum2 = af(sum2, mf(row[x], bdata[x][j]));
        }
        c[i][j] = sum2;
      }
    }
    return a.createDenseMatrix({
      data: c,
      size: [arows, bcolumns],
      datatype: dt
    });
  }
  function _multiplyDenseMatrixSparseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (!bvalues) {
      throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
    }
    var arows = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    var eq = equalScalar;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
      eq = typed.find(equalScalar, [dt, dt]);
      zero = typed.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c = b.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });
    for (var jb = 0;jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var kb0 = bptr[jb];
      var kb1 = bptr[jb + 1];
      if (kb1 > kb0) {
        var last = 0;
        for (var i = 0;i < arows; i++) {
          var mark = i + 1;
          var cij = undefined;
          for (var kb = kb0;kb < kb1; kb++) {
            var ib = bindex[kb];
            if (last !== mark) {
              cij = mf(adata[i][ib], bvalues[kb]);
              last = mark;
            } else {
              cij = af(cij, mf(adata[i][ib], bvalues[kb]));
            }
          }
          if (last === mark && !eq(cij, zero)) {
            cindex.push(i);
            cvalues.push(cij);
          }
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  function _multiplySparseMatrixVector(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype;
    var arows = a._size[0];
    var brows = b._size[0];
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    var eq = equalScalar;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
      eq = typed.find(equalScalar, [dt, dt]);
      zero = typed.convert(0, dt);
    }
    var x = [];
    var w = [];
    cptr[0] = 0;
    for (var ib = 0;ib < brows; ib++) {
      var vbi = bdata[ib];
      if (!eq(vbi, zero)) {
        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0;ka < ka1; ka++) {
          var ia = aindex[ka];
          if (!w[ia]) {
            w[ia] = true;
            cindex.push(ia);
            x[ia] = mf(vbi, avalues[ka]);
          } else {
            x[ia] = af(x[ia], mf(vbi, avalues[ka]));
          }
        }
      }
    }
    for (var p1 = cindex.length, p = 0;p < p1; p++) {
      var ic = cindex[p];
      cvalues[p] = x[ic];
    }
    cptr[1] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, 1],
      datatype: dt
    });
  }
  function _multiplySparseMatrixDenseMatrix(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype;
    var arows = a._size[0];
    var brows = b._size[0];
    var bcolumns = b._size[1];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    var eq = equalScalar;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
      eq = typed.find(equalScalar, [dt, dt]);
      zero = typed.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c = a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });
    var x = [];
    var w = [];
    for (var jb = 0;jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (var ib = 0;ib < brows; ib++) {
        var vbij = bdata[ib][jb];
        if (!eq(vbij, zero)) {
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0;ka < ka1; ka++) {
            var ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x[ia] = mf(vbij, avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(vbij, avalues[ka]));
            }
          }
        }
      }
      for (var p0 = cptr[jb], p1 = cindex.length, p = p0;p < p1; p++) {
        var ic = cindex[p];
        cvalues[p] = x[ic];
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  function _multiplySparseMatrixSparseMatrix(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bdt = b._datatype;
    var arows = a._size[0];
    var bcolumns = b._size[1];
    var values = avalues && bvalues;
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
    }
    var cvalues = values ? [] : undefined;
    var cindex = [];
    var cptr = [];
    var c = a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });
    var x = values ? [] : undefined;
    var w = [];
    var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
    for (var jb = 0;jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0;kb < kb1; kb++) {
        ib = bindex[kb];
        if (values) {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0;ka < ka1; ka++) {
            ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x[ia] = mf(bvalues[kb], avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
            }
          }
        } else {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0;ka < ka1; ka++) {
            ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
            }
          }
        }
      }
      if (values) {
        for (var p0 = cptr[jb], p1 = cindex.length, p = p0;p < p1; p++) {
          var ic = cindex[p];
          cvalues[p] = x[ic];
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  return typed(name61, multiplyScalar, {
    "Array, Array": typed.referTo("Matrix, Matrix", (selfMM) => (x, y) => {
      _validateMatrixDimensions(arraySize(x), arraySize(y));
      var m = selfMM(matrix(x), matrix(y));
      return isMatrix(m) ? m.valueOf() : m;
    }),
    "Matrix, Matrix": function MatrixMatrix(x, y) {
      var xsize = x.size();
      var ysize = y.size();
      _validateMatrixDimensions(xsize, ysize);
      if (xsize.length === 1) {
        if (ysize.length === 1) {
          return _multiplyVectorVector(x, y, xsize[0]);
        }
        return _multiplyVectorMatrix(x, y);
      }
      if (ysize.length === 1) {
        return _multiplyMatrixVector(x, y);
      }
      return _multiplyMatrixMatrix(x, y);
    },
    "Matrix, Array": typed.referTo("Matrix,Matrix", (selfMM) => (x, y) => selfMM(x, matrix(y))),
    "Array, Matrix": typed.referToSelf((self2) => (x, y) => {
      return self2(matrix(x, y.storage()), y);
    }),
    "SparseMatrix, any": function SparseMatrixAny(x, y) {
      return matAlgo11xS0s6(x, y, multiplyScalar, false);
    },
    "DenseMatrix, any": function DenseMatrixAny(x, y) {
      return matAlgo14xDs6(x, y, multiplyScalar, false);
    },
    "any, SparseMatrix": function anySparseMatrix(x, y) {
      return matAlgo11xS0s6(y, x, multiplyScalar, true);
    },
    "any, DenseMatrix": function anyDenseMatrix(x, y) {
      return matAlgo14xDs6(y, x, multiplyScalar, true);
    },
    "Array, any": function ArrayAny(x, y) {
      return matAlgo14xDs6(matrix(x), y, multiplyScalar, false).valueOf();
    },
    "any, Array": function anyArray(x, y) {
      return matAlgo14xDs6(matrix(y), x, multiplyScalar, true).valueOf();
    },
    "any, any": multiplyScalar,
    "any, any, ...any": typed.referToSelf((self2) => (x, y, rest) => {
      var result = self2(x, y);
      for (var i = 0;i < rest.length; i++) {
        result = self2(result, rest[i]);
      }
      return result;
    })
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/nthRoot.js
var name62 = "nthRoot";
var dependencies62 = ["typed", "matrix", "equalScalar", "BigNumber", "concat"];
var createNthRoot = factory(name62, dependencies62, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    BigNumber: _BigNumber,
    concat
  } = _ref;
  var matAlgo01xDSid3 = createMatAlgo01xDSid({
    typed
  });
  var matAlgo02xDS04 = createMatAlgo02xDS0({
    typed,
    equalScalar
  });
  var matAlgo06xS0S03 = createMatAlgo06xS0S0({
    typed,
    equalScalar
  });
  var matAlgo11xS0s7 = createMatAlgo11xS0s({
    typed,
    equalScalar
  });
  var matrixAlgorithmSuite5 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  function complexErr() {
    throw new Error("Complex number not supported in function nthRoot. Use nthRoots instead.");
  }
  return typed(name62, {
    number: nthRootNumber,
    "number, number": nthRootNumber,
    BigNumber: (x) => _bigNthRoot(x, new _BigNumber(2)),
    "BigNumber, BigNumber": _bigNthRoot,
    Complex: complexErr,
    "Complex, number": complexErr,
    Array: typed.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(matrix(x), 2).valueOf()),
    DenseMatrix: typed.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(x, 2)),
    SparseMatrix: typed.referTo("SparseMatrix,number", (selfSn) => (x) => selfSn(x, 2)),
    "SparseMatrix, SparseMatrix": typed.referToSelf((self2) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo06xS0S03(x, y, self2);
      } else {
        throw new Error("Root must be non-zero");
      }
    }),
    "DenseMatrix, SparseMatrix": typed.referToSelf((self2) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo01xDSid3(x, y, self2, false);
      } else {
        throw new Error("Root must be non-zero");
      }
    }),
    "Array, SparseMatrix": typed.referTo("DenseMatrix,SparseMatrix", (selfDS) => (x, y) => selfDS(matrix(x), y)),
    "number | BigNumber, SparseMatrix": typed.referToSelf((self2) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo11xS0s7(y, x, self2, true);
      } else {
        throw new Error("Root must be non-zero");
      }
    })
  }, matrixAlgorithmSuite5({
    scalar: "number | BigNumber",
    SD: matAlgo02xDS04,
    Ss: matAlgo11xS0s7,
    sS: false
  }));
  function _bigNthRoot(a, root) {
    var precision = _BigNumber.precision;
    var Big = _BigNumber.clone({
      precision: precision + 2
    });
    var zero = new _BigNumber(0);
    var one = new Big(1);
    var inv = root.isNegative();
    if (inv) {
      root = root.neg();
    }
    if (root.isZero()) {
      throw new Error("Root must be non-zero");
    }
    if (a.isNegative() && !root.abs().mod(2).equals(1)) {
      throw new Error("Root must be odd when a is negative.");
    }
    if (a.isZero()) {
      return inv ? new Big(Infinity) : 0;
    }
    if (!a.isFinite()) {
      return inv ? zero : a;
    }
    var x = a.abs().pow(one.div(root));
    x = a.isNeg() ? x.neg() : x;
    return new _BigNumber((inv ? one.div(x) : x).toPrecision(precision));
  }
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/sign.js
var name63 = "sign";
var dependencies63 = ["typed", "BigNumber", "Fraction", "complex"];
var createSign = factory(name63, dependencies63, (_ref) => {
  var {
    typed,
    BigNumber: _BigNumber,
    complex: complex2,
    Fraction: _Fraction
  } = _ref;
  return typed(name63, {
    number: signNumber,
    Complex: function Complex(x) {
      return x.im === 0 ? complex2(signNumber(x.re)) : x.sign();
    },
    BigNumber: function BigNumber(x) {
      return new _BigNumber(x.cmp(0));
    },
    Fraction: function Fraction(x) {
      return new _Fraction(x.s, 1);
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2, true)),
    Unit: typed.referToSelf((self2) => (x) => {
      if (!x._isDerived() && x.units[0].unit.offset !== 0) {
        throw new TypeError("sign is ambiguous for units with offset");
      }
      return typed.find(self2, x.valueType())(x.value);
    })
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js
var name64 = "sqrt";
var dependencies64 = ["config", "typed", "Complex"];
var createSqrt = factory(name64, dependencies64, (_ref) => {
  var {
    config: config6,
    typed,
    Complex: Complex2
  } = _ref;
  return typed("sqrt", {
    number: _sqrtNumber,
    Complex: function Complex(x) {
      return x.sqrt();
    },
    BigNumber: function BigNumber(x) {
      if (!x.isNegative() || config6.predictable) {
        return x.sqrt();
      } else {
        return _sqrtNumber(x.toNumber());
      }
    },
    Unit: function Unit(x) {
      return x.pow(0.5);
    }
  });
  function _sqrtNumber(x) {
    if (isNaN(x)) {
      return NaN;
    } else if (x >= 0 || config6.predictable) {
      return Math.sqrt(x);
    } else {
      return new Complex2(x, 0).sqrt();
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/square.js
var name65 = "square";
var dependencies65 = ["typed"];
var createSquare = factory(name65, dependencies65, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name65, {
    number: squareNumber,
    Complex: function Complex(x) {
      return x.mul(x);
    },
    BigNumber: function BigNumber(x) {
      return x.times(x);
    },
    Fraction: function Fraction(x) {
      return x.mul(x);
    },
    Unit: function Unit(x) {
      return x.pow(2);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/subtract.js
var name66 = "subtract";
var dependencies66 = ["typed", "matrix", "equalScalar", "addScalar", "unaryMinus", "DenseMatrix", "concat"];
var createSubtract = factory(name66, dependencies66, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    addScalar,
    unaryMinus,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo01xDSid4 = createMatAlgo01xDSid({
    typed
  });
  var matAlgo03xDSf3 = createMatAlgo03xDSf({
    typed
  });
  var matAlgo05xSfSf3 = createMatAlgo05xSfSf({
    typed,
    equalScalar
  });
  var matAlgo10xSids3 = createMatAlgo10xSids({
    typed,
    DenseMatrix
  });
  var matAlgo12xSfs6 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite6 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name66, {
    "number, number": (x, y) => x - y,
    "Complex, Complex": (x, y) => x.sub(y),
    "BigNumber, BigNumber": (x, y) => x.minus(y),
    "Fraction, Fraction": (x, y) => x.sub(y),
    "Unit, Unit": typed.referToSelf((self2) => (x, y) => {
      if (x.value === null) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y.value === null) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x.equalBase(y)) {
        throw new Error("Units do not match");
      }
      var res = x.clone();
      res.value = typed.find(self2, [res.valueType(), y.valueType()])(res.value, y.value);
      res.fixPrefix = false;
      return res;
    })
  }, matrixAlgorithmSuite6({
    SS: matAlgo05xSfSf3,
    DS: matAlgo01xDSid4,
    SD: matAlgo03xDSf3,
    Ss: matAlgo12xSfs6,
    sS: matAlgo10xSids3
  }));
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/xgcd.js
var name67 = "xgcd";
var dependencies67 = ["typed", "config", "matrix", "BigNumber"];
var createXgcd = factory(name67, dependencies67, (_ref) => {
  var {
    typed,
    config: config6,
    matrix,
    BigNumber
  } = _ref;
  return typed(name67, {
    "number, number": function numberNumber(a, b) {
      var res = xgcdNumber(a, b);
      return config6.matrix === "Array" ? res : matrix(res);
    },
    "BigNumber, BigNumber": _xgcdBigNumber
  });
  function _xgcdBigNumber(a, b) {
    var t;
    var q;
    var r;
    var zero = new BigNumber(0);
    var one = new BigNumber(1);
    var x = zero;
    var lastx = one;
    var y = one;
    var lasty = zero;
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function xgcd must be integer numbers");
    }
    while (!b.isZero()) {
      q = a.div(b).floor();
      r = a.mod(b);
      t = x;
      x = lastx.minus(q.times(x));
      lastx = t;
      t = y;
      y = lasty.minus(q.times(y));
      lasty = t;
      a = b;
      b = r;
    }
    var res;
    if (a.lt(zero)) {
      res = [a.neg(), lastx.neg(), lasty.neg()];
    } else {
      res = [a, !a.isZero() ? lastx : 0, lasty];
    }
    return config6.matrix === "Array" ? res : matrix(res);
  }
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/invmod.js
var name68 = "invmod";
var dependencies68 = ["typed", "config", "BigNumber", "xgcd", "equal", "smaller", "mod", "add", "isInteger"];
var createInvmod = factory(name68, dependencies68, (_ref) => {
  var {
    typed,
    config: config6,
    BigNumber,
    xgcd,
    equal,
    smaller,
    mod: mod2,
    add: add2,
    isInteger: isInteger2
  } = _ref;
  return typed(name68, {
    "number, number": invmod,
    "BigNumber, BigNumber": invmod
  });
  function invmod(a, b) {
    if (!isInteger2(a) || !isInteger2(b))
      throw new Error("Parameters in function invmod must be integer numbers");
    a = mod2(a, b);
    if (equal(b, 0))
      throw new Error("Divisor must be non zero");
    var res = xgcd(a, b);
    res = res.valueOf();
    var [gcd, inv] = res;
    if (!equal(gcd, BigNumber(1)))
      return NaN;
    inv = mod2(inv, b);
    if (smaller(inv, BigNumber(0)))
      inv = add2(inv, b);
    return inv;
  }
});
// ../../node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo09xS0Sf.js
var name69 = "matAlgo09xS0Sf";
var dependencies69 = ["typed", "equalScalar"];
var createMatAlgo09xS0Sf = factory(name69, dependencies69, (_ref) => {
  var {
    typed,
    equalScalar
  } = _ref;
  return function matAlgo09xS0Sf(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed.find(equalScalar, [dt, dt]);
      zero = typed.convert(0, dt);
      cf = typed.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : undefined;
    var cindex = [];
    var cptr = [];
    var x = cvalues ? [] : undefined;
    var w = [];
    var i, j, k, k0, k1;
    for (j = 0;j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      if (x) {
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0;k < k1; k++) {
          i = bindex[k];
          w[i] = mark;
          x[i] = bvalues[k];
        }
      }
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0;k < k1; k++) {
        i = aindex[k];
        if (x) {
          var vb = w[i] === mark ? x[i] : zero;
          var vc = cf(avalues[k], vb);
          if (!eq(vc, zero)) {
            cindex.push(i);
            cvalues.push(vc);
          }
        } else {
          cindex.push(i);
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// ../../node_modules/mathjs/lib/esm/function/arithmetic/dotMultiply.js
var name70 = "dotMultiply";
var dependencies70 = ["typed", "matrix", "equalScalar", "multiplyScalar", "concat"];
var createDotMultiply = factory(name70, dependencies70, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    multiplyScalar,
    concat
  } = _ref;
  var matAlgo02xDS05 = createMatAlgo02xDS0({
    typed,
    equalScalar
  });
  var matAlgo09xS0Sf2 = createMatAlgo09xS0Sf({
    typed,
    equalScalar
  });
  var matAlgo11xS0s8 = createMatAlgo11xS0s({
    typed,
    equalScalar
  });
  var matrixAlgorithmSuite7 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name70, matrixAlgorithmSuite7({
    elop: multiplyScalar,
    SS: matAlgo09xS0Sf2,
    DS: matAlgo02xDS05,
    Ss: matAlgo11xS0s8
  }));
});
// ../../node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js
function bitAndBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitAnd");
  }
  var BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber(NaN);
  }
  if (x.isZero() || y.eq(-1) || x.eq(y)) {
    return x;
  }
  if (y.isZero() || x.eq(-1)) {
    return y;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      if (x.isNegative() === y.isNegative()) {
        return x;
      }
      return new BigNumber(0);
    }
    if (!x.isFinite()) {
      if (y.isNegative()) {
        return x;
      }
      if (x.isNegative()) {
        return new BigNumber(0);
      }
      return y;
    }
    if (!y.isFinite()) {
      if (x.isNegative()) {
        return y;
      }
      if (y.isNegative()) {
        return new BigNumber(0);
      }
      return x;
    }
  }
  return bitwise(x, y, function(a, b) {
    return a & b;
  });
}
function bitNotBigNumber(x) {
  if (x.isFinite() && !x.isInteger()) {
    throw new Error("Integer expected in function bitNot");
  }
  var BigNumber = x.constructor;
  var prevPrec = BigNumber.precision;
  BigNumber.config({
    precision: 1e9
  });
  var result = x.plus(new BigNumber(1));
  result.s = -result.s || null;
  BigNumber.config({
    precision: prevPrec
  });
  return result;
}
function bitOrBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitOr");
  }
  var BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber(NaN);
  }
  var negOne = new BigNumber(-1);
  if (x.isZero() || y.eq(negOne) || x.eq(y)) {
    return y;
  }
  if (y.isZero() || x.eq(negOne)) {
    return x;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !x.isNegative() && y.isNegative() || x.isNegative() && !y.isNegative() && !y.isFinite()) {
      return negOne;
    }
    if (x.isNegative() && y.isNegative()) {
      return x.isFinite() ? x : y;
    }
    return x.isFinite() ? y : x;
  }
  return bitwise(x, y, function(a, b) {
    return a | b;
  });
}
function bitwise(x, y, func) {
  var BigNumber = x.constructor;
  var xBits, yBits;
  var xSign = +(x.s < 0);
  var ySign = +(y.s < 0);
  if (xSign) {
    xBits = decCoefficientToBinaryString(bitNotBigNumber(x));
    for (var i = 0;i < xBits.length; ++i) {
      xBits[i] ^= 1;
    }
  } else {
    xBits = decCoefficientToBinaryString(x);
  }
  if (ySign) {
    yBits = decCoefficientToBinaryString(bitNotBigNumber(y));
    for (var _i = 0;_i < yBits.length; ++_i) {
      yBits[_i] ^= 1;
    }
  } else {
    yBits = decCoefficientToBinaryString(y);
  }
  var minBits, maxBits, minSign;
  if (xBits.length <= yBits.length) {
    minBits = xBits;
    maxBits = yBits;
    minSign = xSign;
  } else {
    minBits = yBits;
    maxBits = xBits;
    minSign = ySign;
  }
  var shortLen = minBits.length;
  var longLen = maxBits.length;
  var expFuncVal = func(xSign, ySign) ^ 1;
  var outVal = new BigNumber(expFuncVal ^ 1);
  var twoPower = new BigNumber(1);
  var two = new BigNumber(2);
  var prevPrec = BigNumber.precision;
  BigNumber.config({
    precision: 1e9
  });
  while (shortLen > 0) {
    if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  while (longLen > 0) {
    if (func(minSign, maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  BigNumber.config({
    precision: prevPrec
  });
  if (expFuncVal === 0) {
    outVal.s = -outVal.s;
  }
  return outVal;
}
var decCoefficientToBinaryString = function(x) {
  var a = x.d;
  var r = a[0] + "";
  for (var i = 1;i < a.length; ++i) {
    var s = a[i] + "";
    for (var z2 = 7 - s.length;z2--; ) {
      s = "0" + s;
    }
    r += s;
  }
  var j = r.length;
  while (r.charAt(j) === "0") {
    j--;
  }
  var xe = x.e;
  var str = r.slice(0, j + 1 || 1);
  var strL = str.length;
  if (xe > 0) {
    if (++xe > strL) {
      xe -= strL;
      while (xe--) {
        str += "0";
      }
    } else if (xe < strL) {
      str = str.slice(0, xe) + "." + str.slice(xe);
    }
  }
  var arr = [0];
  for (var _i2 = 0;_i2 < str.length; ) {
    var arrL = arr.length;
    while (arrL--) {
      arr[arrL] *= 10;
    }
    arr[0] += parseInt(str.charAt(_i2++));
    for (var _j = 0;_j < arr.length; ++_j) {
      if (arr[_j] > 1) {
        if (arr[_j + 1] === null || arr[_j + 1] === undefined) {
          arr[_j + 1] = 0;
        }
        arr[_j + 1] += arr[_j] >> 1;
        arr[_j] &= 1;
      }
    }
  }
  return arr.reverse();
};
function bitXor(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitXor");
  }
  var BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber(NaN);
  }
  if (x.isZero()) {
    return y;
  }
  if (y.isZero()) {
    return x;
  }
  if (x.eq(y)) {
    return new BigNumber(0);
  }
  var negOne = new BigNumber(-1);
  if (x.eq(negOne)) {
    return bitNotBigNumber(y);
  }
  if (y.eq(negOne)) {
    return bitNotBigNumber(x);
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      return negOne;
    }
    return new BigNumber(x.isNegative() === y.isNegative() ? Infinity : -Infinity);
  }
  return bitwise(x, y, function(a, b) {
    return a ^ b;
  });
}
function leftShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function leftShift");
  }
  var BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!x.isFinite() && !y.isFinite()) {
    return new BigNumber(NaN);
  }
  if (y.lt(55)) {
    return x.times(Math.pow(2, y.toNumber()) + "");
  }
  return x.times(new BigNumber(2).pow(y));
}
function rightArithShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function rightArithShift");
  }
  var BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!y.isFinite()) {
    if (x.isNegative()) {
      return new BigNumber(-1);
    }
    if (!x.isFinite()) {
      return new BigNumber(NaN);
    }
    return new BigNumber(0);
  }
  if (y.lt(55)) {
    return x.div(Math.pow(2, y.toNumber()) + "").floor();
  }
  return x.div(new BigNumber(2).pow(y)).floor();
}

// ../../node_modules/mathjs/lib/esm/function/bitwise/bitAnd.js
var name71 = "bitAnd";
var dependencies71 = ["typed", "matrix", "equalScalar", "concat"];
var createBitAnd = factory(name71, dependencies71, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    concat
  } = _ref;
  var matAlgo02xDS06 = createMatAlgo02xDS0({
    typed,
    equalScalar
  });
  var matAlgo06xS0S04 = createMatAlgo06xS0S0({
    typed,
    equalScalar
  });
  var matAlgo11xS0s9 = createMatAlgo11xS0s({
    typed,
    equalScalar
  });
  var matrixAlgorithmSuite8 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name71, {
    "number, number": bitAndNumber,
    "BigNumber, BigNumber": bitAndBigNumber
  }, matrixAlgorithmSuite8({
    SS: matAlgo06xS0S04,
    DS: matAlgo02xDS06,
    Ss: matAlgo11xS0s9
  }));
});
// ../../node_modules/mathjs/lib/esm/function/bitwise/bitNot.js
var name72 = "bitNot";
var dependencies72 = ["typed"];
var createBitNot = factory(name72, dependencies72, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name72, {
    number: bitNotNumber,
    BigNumber: bitNotBigNumber,
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/function/bitwise/bitOr.js
var name73 = "bitOr";
var dependencies73 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createBitOr = factory(name73, dependencies73, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo01xDSid5 = createMatAlgo01xDSid({
    typed
  });
  var matAlgo04xSidSid3 = createMatAlgo04xSidSid({
    typed,
    equalScalar
  });
  var matAlgo10xSids4 = createMatAlgo10xSids({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite9 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name73, {
    "number, number": bitOrNumber,
    "BigNumber, BigNumber": bitOrBigNumber
  }, matrixAlgorithmSuite9({
    SS: matAlgo04xSidSid3,
    DS: matAlgo01xDSid5,
    Ss: matAlgo10xSids4
  }));
});
// ../../node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js
var name74 = "matAlgo07xSSf";
var dependencies74 = ["typed", "DenseMatrix"];
var createMatAlgo07xSSf = factory(name74, dependencies74, (_ref) => {
  var {
    typed,
    DenseMatrix
  } = _ref;
  return function matAlgo07xSSf(a, b, callback) {
    var asize = a._size;
    var adt = a._datatype;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      zero = typed.convert(0, dt);
      cf = typed.find(callback, [dt, dt]);
    }
    var i, j;
    var cdata = [];
    for (i = 0;i < rows; i++) {
      cdata[i] = [];
    }
    var xa = [];
    var xb = [];
    var wa = [];
    var wb = [];
    for (j = 0;j < columns; j++) {
      var mark = j + 1;
      _scatter(a, j, wa, xa, mark);
      _scatter(b, j, wb, xb, mark);
      for (i = 0;i < rows; i++) {
        var va = wa[i] === mark ? xa[i] : zero;
        var vb = wb[i] === mark ? xb[i] : zero;
        cdata[i][j] = cf(va, vb);
      }
    }
    return new DenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
  function _scatter(m, j, w, x, mark) {
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    for (var k = ptr[j], k1 = ptr[j + 1];k < k1; k++) {
      var i = index[k];
      w[i] = mark;
      x[i] = values[k];
    }
  }
});

// ../../node_modules/mathjs/lib/esm/function/bitwise/bitXor.js
var name75 = "bitXor";
var dependencies75 = ["typed", "matrix", "DenseMatrix", "concat"];
var createBitXor = factory(name75, dependencies75, (_ref) => {
  var {
    typed,
    matrix,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo03xDSf4 = createMatAlgo03xDSf({
    typed
  });
  var matAlgo07xSSf2 = createMatAlgo07xSSf({
    typed,
    DenseMatrix
  });
  var matAlgo12xSfs7 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite10 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name75, {
    "number, number": bitXorNumber,
    "BigNumber, BigNumber": bitXor
  }, matrixAlgorithmSuite10({
    SS: matAlgo07xSSf2,
    DS: matAlgo03xDSf4,
    Ss: matAlgo12xSfs7
  }));
});
// ../../node_modules/mathjs/lib/esm/function/complex/arg.js
var name76 = "arg";
var dependencies76 = ["typed"];
var createArg = factory(name76, dependencies76, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name76, {
    number: function number(x) {
      return Math.atan2(0, x);
    },
    BigNumber: function BigNumber(x) {
      return x.constructor.atan2(0, x);
    },
    Complex: function Complex(x) {
      return x.arg();
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/function/complex/conj.js
var name77 = "conj";
var dependencies77 = ["typed"];
var createConj = factory(name77, dependencies77, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name77, {
    "number | BigNumber | Fraction": (x) => x,
    Complex: (x) => x.conjugate(),
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/function/complex/im.js
var name78 = "im";
var dependencies78 = ["typed"];
var createIm = factory(name78, dependencies78, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name78, {
    number: () => 0,
    "BigNumber | Fraction": (x) => x.mul(0),
    Complex: (x) => x.im,
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/function/complex/re.js
var name79 = "re";
var dependencies79 = ["typed"];
var createRe = factory(name79, dependencies79, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name79, {
    "number | BigNumber | Fraction": (x) => x,
    Complex: (x) => x.re,
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/function/logical/not.js
var name80 = "not";
var dependencies80 = ["typed"];
var createNot = factory(name80, dependencies80, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name80, {
    "null | undefined": () => true,
    number: notNumber,
    Complex: function Complex(x) {
      return x.re === 0 && x.im === 0;
    },
    BigNumber: function BigNumber(x) {
      return x.isZero() || x.isNaN();
    },
    Unit: typed.referToSelf((self2) => (x) => typed.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/function/logical/or.js
var name81 = "or";
var dependencies81 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createOr = factory(name81, dependencies81, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo03xDSf5 = createMatAlgo03xDSf({
    typed
  });
  var matAlgo05xSfSf4 = createMatAlgo05xSfSf({
    typed,
    equalScalar
  });
  var matAlgo12xSfs8 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite11 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name81, {
    "number, number": orNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.re !== 0 || x.im !== 0 || y.re !== 0 || y.im !== 0;
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return !x.isZero() && !x.isNaN() || !y.isZero() && !y.isNaN();
    },
    "Unit, Unit": typed.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0))
  }, matrixAlgorithmSuite11({
    SS: matAlgo05xSfSf4,
    DS: matAlgo03xDSf5,
    Ss: matAlgo12xSfs8
  }));
});
// ../../node_modules/mathjs/lib/esm/function/logical/xor.js
var name82 = "xor";
var dependencies82 = ["typed", "matrix", "DenseMatrix", "concat"];
var createXor = factory(name82, dependencies82, (_ref) => {
  var {
    typed,
    matrix,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo03xDSf6 = createMatAlgo03xDSf({
    typed
  });
  var matAlgo07xSSf3 = createMatAlgo07xSSf({
    typed,
    DenseMatrix
  });
  var matAlgo12xSfs9 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite12 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name82, {
    "number, number": xorNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return (x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return (!x.isZero() && !x.isNaN()) !== (!y.isZero() && !y.isNaN());
    },
    "Unit, Unit": typed.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0))
  }, matrixAlgorithmSuite12({
    SS: matAlgo07xSSf3,
    DS: matAlgo03xDSf6,
    Ss: matAlgo12xSfs9
  }));
});
// ../../node_modules/mathjs/lib/esm/function/matrix/concat.js
var _concat = function(a, b, concatDim, dim) {
  if (dim < concatDim) {
    if (a.length !== b.length) {
      throw new DimensionError(a.length, b.length);
    }
    var c = [];
    for (var i = 0;i < a.length; i++) {
      c[i] = _concat(a[i], b[i], concatDim, dim + 1);
    }
    return c;
  } else {
    return a.concat(b);
  }
};
var name83 = "concat";
var dependencies83 = ["typed", "matrix", "isInteger"];
var createConcat = factory(name83, dependencies83, (_ref) => {
  var {
    typed,
    matrix,
    isInteger: isInteger2
  } = _ref;
  return typed(name83, {
    "...Array | Matrix | number | BigNumber": function ArrayMatrixNumberBigNumber(args) {
      var i;
      var len = args.length;
      var dim = -1;
      var prevDim;
      var asMatrix = false;
      var matrices = [];
      for (i = 0;i < len; i++) {
        var arg = args[i];
        if (isMatrix(arg)) {
          asMatrix = true;
        }
        if (isNumber(arg) || isBigNumber(arg)) {
          if (i !== len - 1) {
            throw new Error("Dimension must be specified as last argument");
          }
          prevDim = dim;
          dim = arg.valueOf();
          if (!isInteger2(dim)) {
            throw new TypeError("Integer number expected for dimension");
          }
          if (dim < 0 || i > 0 && dim > prevDim) {
            throw new IndexError(dim, prevDim + 1);
          }
        } else {
          var m = clone(arg).valueOf();
          var size = arraySize(m);
          matrices[i] = m;
          prevDim = dim;
          dim = size.length - 1;
          if (i > 0 && dim !== prevDim) {
            throw new DimensionError(prevDim + 1, dim + 1);
          }
        }
      }
      if (matrices.length === 0) {
        throw new SyntaxError("At least one matrix expected");
      }
      var res = matrices.shift();
      while (matrices.length) {
        res = _concat(res, matrices.shift(), dim, 0);
      }
      return asMatrix ? matrix(res) : res;
    },
    "...string": function string(args) {
      return args.join("");
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/matrix/column.js
var name84 = "column";
var dependencies84 = ["typed", "Index", "matrix", "range"];
var createColumn = factory(name84, dependencies84, (_ref) => {
  var {
    typed,
    Index,
    matrix,
    range
  } = _ref;
  return typed(name84, {
    "Matrix, number": _column,
    "Array, number": function ArrayNumber(value, column) {
      return _column(matrix(clone(value)), column).valueOf();
    }
  });
  function _column(value, column) {
    if (value.size().length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(column, value.size()[1]);
    var rowRange = range(0, value.size()[0]);
    var index = new Index(rowRange, column);
    var result = value.subset(index);
    return isMatrix(result) ? result : matrix([[result]]);
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/count.js
var name85 = "count";
var dependencies85 = ["typed", "size", "prod"];
var createCount = factory(name85, dependencies85, (_ref) => {
  var {
    typed,
    size,
    prod
  } = _ref;
  return typed(name85, {
    string: function string(x) {
      return x.length;
    },
    "Matrix | Array": function MatrixArray(x) {
      return prod(size(x));
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/matrix/cross.js
var name86 = "cross";
var dependencies86 = ["typed", "matrix", "subtract", "multiply"];
var createCross = factory(name86, dependencies86, (_ref) => {
  var {
    typed,
    matrix,
    subtract,
    multiply
  } = _ref;
  return typed(name86, {
    "Matrix, Matrix": function MatrixMatrix(x, y) {
      return matrix(_cross(x.toArray(), y.toArray()));
    },
    "Matrix, Array": function MatrixArray(x, y) {
      return matrix(_cross(x.toArray(), y));
    },
    "Array, Matrix": function ArrayMatrix(x, y) {
      return matrix(_cross(x, y.toArray()));
    },
    "Array, Array": _cross
  });
  function _cross(x, y) {
    var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);
    x = squeeze(x);
    y = squeeze(y);
    var xSize = arraySize(x);
    var ySize = arraySize(y);
    if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
      throw new RangeError("Vectors with length 3 expected " + "(Size A = [" + xSize.join(", ") + "], B = [" + ySize.join(", ") + "])");
    }
    var product5 = [subtract(multiply(x[1], y[2]), multiply(x[2], y[1])), subtract(multiply(x[2], y[0]), multiply(x[0], y[2])), subtract(multiply(x[0], y[1]), multiply(x[1], y[0]))];
    if (highestDimension > 1) {
      return [product5];
    } else {
      return product5;
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/diag.js
var name87 = "diag";
var dependencies87 = ["typed", "matrix", "DenseMatrix", "SparseMatrix"];
var createDiag = factory(name87, dependencies87, (_ref) => {
  var {
    typed,
    matrix,
    DenseMatrix,
    SparseMatrix
  } = _ref;
  return typed(name87, {
    Array: function Array(x) {
      return _diag(x, 0, arraySize(x), null);
    },
    "Array, number": function ArrayNumber(x, k) {
      return _diag(x, k, arraySize(x), null);
    },
    "Array, BigNumber": function ArrayBigNumber(x, k) {
      return _diag(x, k.toNumber(), arraySize(x), null);
    },
    "Array, string": function ArrayString(x, format4) {
      return _diag(x, 0, arraySize(x), format4);
    },
    "Array, number, string": function ArrayNumberString(x, k, format4) {
      return _diag(x, k, arraySize(x), format4);
    },
    "Array, BigNumber, string": function ArrayBigNumberString(x, k, format4) {
      return _diag(x, k.toNumber(), arraySize(x), format4);
    },
    Matrix: function Matrix(x) {
      return _diag(x, 0, x.size(), x.storage());
    },
    "Matrix, number": function MatrixNumber(x, k) {
      return _diag(x, k, x.size(), x.storage());
    },
    "Matrix, BigNumber": function MatrixBigNumber(x, k) {
      return _diag(x, k.toNumber(), x.size(), x.storage());
    },
    "Matrix, string": function MatrixString(x, format4) {
      return _diag(x, 0, x.size(), format4);
    },
    "Matrix, number, string": function MatrixNumberString(x, k, format4) {
      return _diag(x, k, x.size(), format4);
    },
    "Matrix, BigNumber, string": function MatrixBigNumberString(x, k, format4) {
      return _diag(x, k.toNumber(), x.size(), format4);
    }
  });
  function _diag(x, k, size, format4) {
    if (!isInteger(k)) {
      throw new TypeError("Second parameter in function diag must be an integer");
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    switch (size.length) {
      case 1:
        return _createDiagonalMatrix(x, k, format4, size[0], kSub, kSuper);
      case 2:
        return _getDiagonal(x, k, format4, size, kSub, kSuper);
    }
    throw new RangeError("Matrix for function diag must be 2 dimensional");
  }
  function _createDiagonalMatrix(x, k, format4, l, kSub, kSuper) {
    var ms = [l + kSub, l + kSuper];
    if (format4 && format4 !== "sparse" && format4 !== "dense") {
      throw new TypeError("Unknown matrix type ".concat(format4, "\""));
    }
    var m = format4 === "sparse" ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k);
    return format4 !== null ? m : m.valueOf();
  }
  function _getDiagonal(x, k, format4, s, kSub, kSuper) {
    if (isMatrix(x)) {
      var dm = x.diagonal(k);
      if (format4 !== null) {
        if (format4 !== dm.storage()) {
          return matrix(dm, format4);
        }
        return dm;
      }
      return dm.valueOf();
    }
    var n = Math.min(s[0] - kSub, s[1] - kSuper);
    var vector = [];
    for (var i = 0;i < n; i++) {
      vector[i] = x[i + kSub][i + kSuper];
    }
    return format4 !== null ? matrix(vector) : vector;
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/filter.js
var _filterCallback = function(x, callback) {
  var args = maxArgumentCount(callback);
  return filter(x, function(value, index, array11) {
    if (args === 1) {
      return callback(value);
    } else if (args === 2) {
      return callback(value, [index]);
    } else {
      return callback(value, [index], array11);
    }
  });
};
var name88 = "filter";
var dependencies88 = ["typed"];
var createFilter = factory(name88, dependencies88, (_ref) => {
  var {
    typed
  } = _ref;
  return typed("filter", {
    "Array, function": _filterCallback,
    "Matrix, function": function MatrixFunction(x, test) {
      return x.create(_filterCallback(x.toArray(), test));
    },
    "Array, RegExp": filterRegExp,
    "Matrix, RegExp": function MatrixRegExp(x, test) {
      return x.create(filterRegExp(x.toArray(), test));
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/matrix/flatten.js
var name89 = "flatten";
var dependencies89 = ["typed", "matrix"];
var createFlatten = factory(name89, dependencies89, (_ref) => {
  var {
    typed,
    matrix
  } = _ref;
  return typed(name89, {
    Array: function Array(x) {
      return flatten(x);
    },
    Matrix: function Matrix(x) {
      var flat = flatten(x.toArray());
      return matrix(flat);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/matrix/forEach.js
var _forEach = function(array13, callback) {
  var args = maxArgumentCount(callback);
  var recurse = function recurse(value, index) {
    if (Array.isArray(value)) {
      forEach(value, function(child, i) {
        recurse(child, index.concat(i));
      });
    } else {
      if (args === 1) {
        callback(value);
      } else if (args === 2) {
        callback(value, index);
      } else {
        callback(value, index, array13);
      }
    }
  };
  recurse(array13, []);
};
var name90 = "forEach";
var dependencies90 = ["typed"];
var createForEach = factory(name90, dependencies90, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name90, {
    "Array, function": _forEach,
    "Matrix, function": function MatrixFunction(x, callback) {
      x.forEach(callback);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/matrix/getMatrixDataType.js
var name91 = "getMatrixDataType";
var dependencies91 = ["typed"];
var createGetMatrixDataType = factory(name91, dependencies91, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name91, {
    Array: function Array(x) {
      return getArrayDataType(x, typeOf);
    },
    Matrix: function Matrix(x) {
      return x.getDataType();
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/matrix/identity.js
var name92 = "identity";
var dependencies92 = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"];
var createIdentity = factory(name92, dependencies92, (_ref) => {
  var {
    typed,
    config: config6,
    matrix,
    BigNumber,
    DenseMatrix,
    SparseMatrix
  } = _ref;
  return typed(name92, {
    "": function _() {
      return config6.matrix === "Matrix" ? matrix([]) : [];
    },
    string: function string(format4) {
      return matrix(format4);
    },
    "number | BigNumber": function numberBigNumber(rows) {
      return _identity(rows, rows, config6.matrix === "Matrix" ? "dense" : undefined);
    },
    "number | BigNumber, string": function numberBigNumberString(rows, format4) {
      return _identity(rows, rows, format4);
    },
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(rows, cols) {
      return _identity(rows, cols, config6.matrix === "Matrix" ? "dense" : undefined);
    },
    "number | BigNumber, number | BigNumber, string": function numberBigNumberNumberBigNumberString(rows, cols, format4) {
      return _identity(rows, cols, format4);
    },
    Array: function Array(size) {
      return _identityVector(size);
    },
    "Array, string": function ArrayString(size, format4) {
      return _identityVector(size, format4);
    },
    Matrix: function Matrix(size) {
      return _identityVector(size.valueOf(), size.storage());
    },
    "Matrix, string": function MatrixString(size, format4) {
      return _identityVector(size.valueOf(), format4);
    }
  });
  function _identityVector(size, format4) {
    switch (size.length) {
      case 0:
        return format4 ? matrix(format4) : [];
      case 1:
        return _identity(size[0], size[0], format4);
      case 2:
        return _identity(size[0], size[1], format4);
      default:
        throw new Error("Vector containing two values expected");
    }
  }
  function _identity(rows, cols, format4) {
    var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber : null;
    if (isBigNumber(rows))
      rows = rows.toNumber();
    if (isBigNumber(cols))
      cols = cols.toNumber();
    if (!isInteger(rows) || rows < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    if (!isInteger(cols) || cols < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    var one = Big ? new BigNumber(1) : 1;
    var defaultValue = Big ? new Big(0) : 0;
    var size = [rows, cols];
    if (format4) {
      if (format4 === "sparse") {
        return SparseMatrix.diagonal(size, one, 0, defaultValue);
      }
      if (format4 === "dense") {
        return DenseMatrix.diagonal(size, one, 0, defaultValue);
      }
      throw new TypeError("Unknown matrix type \"".concat(format4, "\""));
    }
    var res = resize([], size, defaultValue);
    var minimum = rows < cols ? rows : cols;
    for (var d = 0;d < minimum; d++) {
      res[d][d] = one;
    }
    return res;
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/kron.js
var name93 = "kron";
var dependencies93 = ["typed", "matrix", "multiplyScalar"];
var createKron = factory(name93, dependencies93, (_ref) => {
  var {
    typed,
    matrix,
    multiplyScalar
  } = _ref;
  return typed(name93, {
    "Matrix, Matrix": function MatrixMatrix(x, y) {
      return matrix(_kron(x.toArray(), y.toArray()));
    },
    "Matrix, Array": function MatrixArray(x, y) {
      return matrix(_kron(x.toArray(), y));
    },
    "Array, Matrix": function ArrayMatrix(x, y) {
      return matrix(_kron(x, y.toArray()));
    },
    "Array, Array": _kron
  });
  function _kron(a, b) {
    if (arraySize(a).length === 1) {
      a = [a];
    }
    if (arraySize(b).length === 1) {
      b = [b];
    }
    if (arraySize(a).length > 2 || arraySize(b).length > 2) {
      throw new RangeError("Vectors with dimensions greater then 2 are not supported expected " + "(Size x = " + JSON.stringify(a.length) + ", y = " + JSON.stringify(b.length) + ")");
    }
    var t = [];
    var r = [];
    return a.map(function(a2) {
      return b.map(function(b2) {
        r = [];
        t.push(r);
        return a2.map(function(y) {
          return b2.map(function(x) {
            return r.push(multiplyScalar(y, x));
          });
        });
      });
    }) && t;
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/map.js
var _map = function(array16, callback) {
  var args = maxArgumentCount(callback);
  var recurse = function recurse(value, index) {
    if (Array.isArray(value)) {
      return value.map(function(child, i) {
        return recurse(child, index.concat(i));
      });
    } else {
      try {
        if (args === 1) {
          return callback(value);
        } else if (args === 2) {
          return callback(value, index);
        } else {
          return callback(value, index, array16);
        }
      } catch (err) {
        if (err instanceof TypeError && "data" in err && err.data.category === "wrongType") {
          var newmsg = "map attempted to call '".concat(err.data.fn, "(").concat(value);
          var indexString = JSON.stringify(index);
          if (args === 2) {
            newmsg += "," + indexString;
          } else if (args !== 1) {
            newmsg += ",".concat(indexString, ",").concat(array16);
          }
          newmsg += ")' but argument ".concat(err.data.index + 1, " of type ");
          newmsg += "".concat(err.data.actual, " does not match expected type ");
          newmsg += err.data.expected.join(" or ");
          throw new TypeError(newmsg);
        }
        throw err;
      }
    }
  };
  return recurse(array16, []);
};
var name94 = "map";
var dependencies94 = ["typed"];
var createMap2 = factory(name94, dependencies94, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name94, {
    "Array, function": _map,
    "Matrix, function": function MatrixFunction(x, callback) {
      return x.map(callback);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/matrix/diff.js
var name95 = "diff";
var dependencies95 = ["typed", "matrix", "subtract", "number"];
var createDiff = factory(name95, dependencies95, (_ref) => {
  var {
    typed,
    matrix,
    subtract,
    number: number53
  } = _ref;
  return typed(name95, {
    "Array | Matrix": function ArrayMatrix(arr) {
      if (isMatrix(arr)) {
        return matrix(_diff(arr.toArray()));
      } else {
        return _diff(arr);
      }
    },
    "Array | Matrix, number": function ArrayMatrixNumber(arr, dim) {
      if (!isInteger(dim))
        throw new RangeError("Dimension must be a whole number");
      if (isMatrix(arr)) {
        return matrix(_recursive(arr.toArray(), dim));
      } else {
        return _recursive(arr, dim);
      }
    },
    "Array, BigNumber": typed.referTo("Array,number", (selfAn) => (arr, dim) => selfAn(arr, number53(dim))),
    "Matrix, BigNumber": typed.referTo("Matrix,number", (selfMn) => (arr, dim) => selfMn(arr, number53(dim)))
  });
  function _recursive(arr, dim) {
    if (isMatrix(arr)) {
      arr = arr.toArray();
    }
    if (!Array.isArray(arr)) {
      throw RangeError("Array/Matrix does not have that many dimensions");
    }
    if (dim > 0) {
      var result = [];
      arr.forEach((element) => {
        result.push(_recursive(element, dim - 1));
      });
      return result;
    } else if (dim === 0) {
      return _diff(arr);
    } else {
      throw RangeError("Cannot have negative dimension");
    }
  }
  function _diff(arr) {
    var result = [];
    var size = arr.length;
    for (var i = 1;i < size; i++) {
      result.push(_ElementDiff(arr[i - 1], arr[i]));
    }
    return result;
  }
  function _ElementDiff(obj1, obj2) {
    if (isMatrix(obj1))
      obj1 = obj1.toArray();
    if (isMatrix(obj2))
      obj2 = obj2.toArray();
    var obj1IsArray = Array.isArray(obj1);
    var obj2IsArray = Array.isArray(obj2);
    if (obj1IsArray && obj2IsArray) {
      return _ArrayDiff(obj1, obj2);
    }
    if (!obj1IsArray && !obj2IsArray) {
      return subtract(obj2, obj1);
    }
    throw TypeError("Cannot calculate difference between 1 array and 1 non-array");
  }
  function _ArrayDiff(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      throw RangeError("Not all sub-arrays have the same length");
    }
    var result = [];
    var size = arr1.length;
    for (var i = 0;i < size; i++) {
      result.push(_ElementDiff(arr1[i], arr2[i]));
    }
    return result;
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/ones.js
var name96 = "ones";
var dependencies96 = ["typed", "config", "matrix", "BigNumber"];
var createOnes = factory(name96, dependencies96, (_ref) => {
  var {
    typed,
    config: config6,
    matrix,
    BigNumber
  } = _ref;
  return typed("ones", {
    "": function _() {
      return config6.matrix === "Array" ? _ones([]) : _ones([], "default");
    },
    "...number | BigNumber | string": function numberBigNumberString(size) {
      var last = size[size.length - 1];
      if (typeof last === "string") {
        var format4 = size.pop();
        return _ones(size, format4);
      } else if (config6.matrix === "Array") {
        return _ones(size);
      } else {
        return _ones(size, "default");
      }
    },
    Array: _ones,
    Matrix: function Matrix(size) {
      var format4 = size.storage();
      return _ones(size.valueOf(), format4);
    },
    "Array | Matrix, string": function ArrayMatrixString(size, format4) {
      return _ones(size.valueOf(), format4);
    }
  });
  function _ones(size, format4) {
    var hasBigNumbers = _normalize(size);
    var defaultValue = hasBigNumbers ? new BigNumber(1) : 1;
    _validate2(size);
    if (format4) {
      var m = matrix(format4);
      if (size.length > 0) {
        return m.resize(size, defaultValue);
      }
      return m;
    } else {
      var arr = [];
      if (size.length > 0) {
        return resize(arr, size, defaultValue);
      }
      return arr;
    }
  }
  function _normalize(size) {
    var hasBigNumbers = false;
    size.forEach(function(value, index, arr) {
      if (isBigNumber(value)) {
        hasBigNumbers = true;
        arr[index] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }
  function _validate2(size) {
    size.forEach(function(value) {
      if (typeof value !== "number" || !isInteger(value) || value < 0) {
        throw new Error("Parameters in function ones must be positive integers");
      }
    });
  }
});
// ../../node_modules/mathjs/lib/esm/utils/noop.js
function noBignumber() {
  throw new Error('No "bignumber" implementation available');
}
function noFraction() {
  throw new Error('No "fraction" implementation available');
}
function noMatrix() {
  throw new Error('No "matrix" implementation available');
}

// ../../node_modules/mathjs/lib/esm/function/matrix/range.js
var name97 = "range";
var dependencies97 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq"];
var createRange = factory(name97, dependencies97, (_ref) => {
  var {
    typed,
    config: config6,
    matrix,
    bignumber,
    smaller,
    smallerEq,
    larger,
    largerEq
  } = _ref;
  return typed(name97, {
    string: _strRange,
    "string, boolean": _strRange,
    "number, number": function numberNumber(start, end) {
      return _out(_rangeEx(start, end, 1));
    },
    "number, number, number": function numberNumberNumber(start, end, step) {
      return _out(_rangeEx(start, end, step));
    },
    "number, number, boolean": function numberNumberBoolean(start, end, includeEnd) {
      return includeEnd ? _out(_rangeInc(start, end, 1)) : _out(_rangeEx(start, end, 1));
    },
    "number, number, number, boolean": function numberNumberNumberBoolean(start, end, step, includeEnd) {
      return includeEnd ? _out(_rangeInc(start, end, step)) : _out(_rangeEx(start, end, step));
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(start, end) {
      var BigNumber = start.constructor;
      return _out(_bigRangeEx(start, end, new BigNumber(1)));
    },
    "BigNumber, BigNumber, BigNumber": function BigNumberBigNumberBigNumber(start, end, step) {
      return _out(_bigRangeEx(start, end, step));
    },
    "BigNumber, BigNumber, boolean": function BigNumberBigNumberBoolean(start, end, includeEnd) {
      var BigNumber = start.constructor;
      return includeEnd ? _out(_bigRangeInc(start, end, new BigNumber(1))) : _out(_bigRangeEx(start, end, new BigNumber(1)));
    },
    "BigNumber, BigNumber, BigNumber, boolean": function BigNumberBigNumberBigNumberBoolean(start, end, step, includeEnd) {
      return includeEnd ? _out(_bigRangeInc(start, end, step)) : _out(_bigRangeEx(start, end, step));
    }
  });
  function _out(arr) {
    if (config6.matrix === "Matrix") {
      return matrix ? matrix(arr) : noMatrix();
    }
    return arr;
  }
  function _strRange(str, includeEnd) {
    var r = _parse(str);
    if (!r) {
      throw new SyntaxError('String "' + str + '" is no valid range');
    }
    var fn;
    if (config6.number === "BigNumber") {
      if (bignumber === undefined) {
        noBignumber();
      }
      fn = includeEnd ? _bigRangeInc : _bigRangeEx;
      return _out(fn(bignumber(r.start), bignumber(r.end), bignumber(r.step)));
    } else {
      fn = includeEnd ? _rangeInc : _rangeEx;
      return _out(fn(r.start, r.end, r.step));
    }
  }
  function _rangeEx(start, end, step) {
    var array17 = [];
    var x = start;
    if (step > 0) {
      while (smaller(x, end)) {
        array17.push(x);
        x += step;
      }
    } else if (step < 0) {
      while (larger(x, end)) {
        array17.push(x);
        x += step;
      }
    }
    return array17;
  }
  function _rangeInc(start, end, step) {
    var array17 = [];
    var x = start;
    if (step > 0) {
      while (smallerEq(x, end)) {
        array17.push(x);
        x += step;
      }
    } else if (step < 0) {
      while (largerEq(x, end)) {
        array17.push(x);
        x += step;
      }
    }
    return array17;
  }
  function _bigRangeEx(start, end, step) {
    var zero = bignumber(0);
    var array17 = [];
    var x = start;
    if (step.gt(zero)) {
      while (smaller(x, end)) {
        array17.push(x);
        x = x.plus(step);
      }
    } else if (step.lt(zero)) {
      while (larger(x, end)) {
        array17.push(x);
        x = x.plus(step);
      }
    }
    return array17;
  }
  function _bigRangeInc(start, end, step) {
    var zero = bignumber(0);
    var array17 = [];
    var x = start;
    if (step.gt(zero)) {
      while (smallerEq(x, end)) {
        array17.push(x);
        x = x.plus(step);
      }
    } else if (step.lt(zero)) {
      while (largerEq(x, end)) {
        array17.push(x);
        x = x.plus(step);
      }
    }
    return array17;
  }
  function _parse(str) {
    var args = str.split(":");
    var nums = args.map(function(arg) {
      return Number(arg);
    });
    var invalid = nums.some(function(num) {
      return isNaN(num);
    });
    if (invalid) {
      return null;
    }
    switch (nums.length) {
      case 2:
        return {
          start: nums[0],
          end: nums[1],
          step: 1
        };
      case 3:
        return {
          start: nums[0],
          end: nums[2],
          step: nums[1]
        };
      default:
        return null;
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/reshape.js
var name98 = "reshape";
var dependencies98 = ["typed", "isInteger", "matrix"];
var createReshape = factory(name98, dependencies98, (_ref) => {
  var {
    typed,
    isInteger: isInteger2
  } = _ref;
  return typed(name98, {
    "Matrix, Array": function MatrixArray(x, sizes) {
      return x.reshape(sizes, true);
    },
    "Array, Array": function ArrayArray(x, sizes) {
      sizes.forEach(function(size) {
        if (!isInteger2(size)) {
          throw new TypeError("Invalid size for dimension: " + size);
        }
      });
      return reshape(x, sizes);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/matrix/resize.js
var name99 = "resize";
var dependencies99 = ["config", "matrix"];
var createResize = factory(name99, dependencies99, (_ref) => {
  var {
    config: config6,
    matrix
  } = _ref;
  return function resize(x, size, defaultValue) {
    if (arguments.length !== 2 && arguments.length !== 3) {
      throw new ArgumentsError("resize", arguments.length, 2, 3);
    }
    if (isMatrix(size)) {
      size = size.valueOf();
    }
    if (isBigNumber(size[0])) {
      size = size.map(function(value) {
        return !isBigNumber(value) ? value : value.toNumber();
      });
    }
    if (isMatrix(x)) {
      return x.resize(size, defaultValue, true);
    }
    if (typeof x === "string") {
      return _resizeString(x, size, defaultValue);
    }
    var asMatrix = Array.isArray(x) ? false : config6.matrix !== "Array";
    if (size.length === 0) {
      while (Array.isArray(x)) {
        x = x[0];
      }
      return clone(x);
    } else {
      if (!Array.isArray(x)) {
        x = [x];
      }
      x = clone(x);
      var res = resize(x, size, defaultValue);
      return asMatrix ? matrix(res) : res;
    }
  };
  function _resizeString(str, size, defaultChar) {
    if (defaultChar !== undefined) {
      if (typeof defaultChar !== "string" || defaultChar.length !== 1) {
        throw new TypeError("Single character expected as defaultValue");
      }
    } else {
      defaultChar = " ";
    }
    if (size.length !== 1) {
      throw new DimensionError(size.length, 1);
    }
    var len = size[0];
    if (typeof len !== "number" || !isInteger(len)) {
      throw new TypeError("Invalid size, must contain positive integers " + "(size: " + format3(size) + ")");
    }
    if (str.length > len) {
      return str.substring(0, len);
    } else if (str.length < len) {
      var res = str;
      for (var i = 0, ii = len - str.length;i < ii; i++) {
        res += defaultChar;
      }
      return res;
    } else {
      return str;
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/rotate.js
var name100 = "rotate";
var dependencies100 = ["typed", "multiply", "rotationMatrix"];
var createRotate = factory(name100, dependencies100, (_ref) => {
  var {
    typed,
    multiply,
    rotationMatrix
  } = _ref;
  return typed(name100, {
    "Array , number | BigNumber | Complex | Unit": function ArrayNumberBigNumberComplexUnit(w, theta) {
      _validateSize(w, 2);
      var matrixRes = multiply(rotationMatrix(theta), w);
      return matrixRes.toArray();
    },
    "Matrix , number | BigNumber | Complex | Unit": function MatrixNumberBigNumberComplexUnit(w, theta) {
      _validateSize(w, 2);
      return multiply(rotationMatrix(theta), w);
    },
    "Array, number | BigNumber | Complex | Unit, Array | Matrix": function ArrayNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
      _validateSize(w, 3);
      var matrixRes = multiply(rotationMatrix(theta, v), w);
      return matrixRes;
    },
    "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function MatrixNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
      _validateSize(w, 3);
      return multiply(rotationMatrix(theta, v), w);
    }
  });
  function _validateSize(v, expectedSize) {
    var actualSize = Array.isArray(v) ? arraySize(v) : v.size();
    if (actualSize.length > 2) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
    if (actualSize.length === 2 && actualSize[1] !== 1) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
    if (actualSize[0] !== expectedSize) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/rotationMatrix.js
var name101 = "rotationMatrix";
var dependencies101 = ["typed", "config", "multiplyScalar", "addScalar", "unaryMinus", "norm", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix", "cos", "sin"];
var createRotationMatrix = factory(name101, dependencies101, (_ref) => {
  var {
    typed,
    config: config6,
    multiplyScalar,
    addScalar,
    unaryMinus,
    norm,
    BigNumber,
    matrix,
    DenseMatrix,
    SparseMatrix,
    cos: cos2,
    sin: sin2
  } = _ref;
  return typed(name101, {
    "": function _() {
      return config6.matrix === "Matrix" ? matrix([]) : [];
    },
    string: function string(format4) {
      return matrix(format4);
    },
    "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(theta) {
      return _rotationMatrix2x2(theta, config6.matrix === "Matrix" ? "dense" : undefined);
    },
    "number | BigNumber | Complex | Unit, string": function numberBigNumberComplexUnitString(theta, format4) {
      return _rotationMatrix2x2(theta, format4);
    },
    "number | BigNumber | Complex | Unit, Array": function numberBigNumberComplexUnitArray(theta, v) {
      var matrixV = matrix(v);
      _validateVector(matrixV);
      return _rotationMatrix3x3(theta, matrixV, undefined);
    },
    "number | BigNumber | Complex | Unit, Matrix": function numberBigNumberComplexUnitMatrix(theta, v) {
      _validateVector(v);
      var storageType = v.storage() || (config6.matrix === "Matrix" ? "dense" : undefined);
      return _rotationMatrix3x3(theta, v, storageType);
    },
    "number | BigNumber | Complex | Unit, Array, string": function numberBigNumberComplexUnitArrayString(theta, v, format4) {
      var matrixV = matrix(v);
      _validateVector(matrixV);
      return _rotationMatrix3x3(theta, matrixV, format4);
    },
    "number | BigNumber | Complex | Unit, Matrix, string": function numberBigNumberComplexUnitMatrixString(theta, v, format4) {
      _validateVector(v);
      return _rotationMatrix3x3(theta, v, format4);
    }
  });
  function _rotationMatrix2x2(theta, format4) {
    var Big = isBigNumber(theta);
    var minusOne = Big ? new BigNumber(-1) : -1;
    var cosTheta = cos2(theta);
    var sinTheta = sin2(theta);
    var data = [[cosTheta, multiplyScalar(minusOne, sinTheta)], [sinTheta, cosTheta]];
    return _convertToFormat(data, format4);
  }
  function _validateVector(v) {
    var size = v.size();
    if (size.length < 1 || size[0] !== 3) {
      throw new RangeError("Vector must be of dimensions 1x3");
    }
  }
  function _mul(array20) {
    return array20.reduce((p, curr) => multiplyScalar(p, curr));
  }
  function _convertToFormat(data, format4) {
    if (format4) {
      if (format4 === "sparse") {
        return new SparseMatrix(data);
      }
      if (format4 === "dense") {
        return new DenseMatrix(data);
      }
      throw new TypeError("Unknown matrix type \"".concat(format4, "\""));
    }
    return data;
  }
  function _rotationMatrix3x3(theta, v, format4) {
    var normV = norm(v);
    if (normV === 0) {
      throw new RangeError("Rotation around zero vector");
    }
    var Big = isBigNumber(theta) ? BigNumber : null;
    var one = Big ? new Big(1) : 1;
    var minusOne = Big ? new Big(-1) : -1;
    var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;
    var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;
    var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;
    var c = cos2(theta);
    var oneMinusC = addScalar(one, unaryMinus(c));
    var s = sin2(theta);
    var r11 = addScalar(c, _mul([vx, vx, oneMinusC]));
    var r12 = addScalar(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));
    var r13 = addScalar(_mul([vx, vz, oneMinusC]), _mul([vy, s]));
    var r21 = addScalar(_mul([vx, vy, oneMinusC]), _mul([vz, s]));
    var r22 = addScalar(c, _mul([vy, vy, oneMinusC]));
    var r23 = addScalar(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));
    var r31 = addScalar(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));
    var r32 = addScalar(_mul([vy, vz, oneMinusC]), _mul([vx, s]));
    var r33 = addScalar(c, _mul([vz, vz, oneMinusC]));
    var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];
    return _convertToFormat(data, format4);
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/row.js
var name102 = "row";
var dependencies102 = ["typed", "Index", "matrix", "range"];
var createRow = factory(name102, dependencies102, (_ref) => {
  var {
    typed,
    Index,
    matrix,
    range
  } = _ref;
  return typed(name102, {
    "Matrix, number": _row,
    "Array, number": function ArrayNumber(value, row) {
      return _row(matrix(clone(value)), row).valueOf();
    }
  });
  function _row(value, row) {
    if (value.size().length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(row, value.size()[0]);
    var columnRange = range(0, value.size()[1]);
    var index = new Index(row, columnRange);
    var result = value.subset(index);
    return isMatrix(result) ? result : matrix([[result]]);
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/size.js
var name103 = "size";
var dependencies103 = ["typed", "config", "?matrix"];
var createSize = factory(name103, dependencies103, (_ref) => {
  var {
    typed,
    config: config6,
    matrix
  } = _ref;
  return typed(name103, {
    Matrix: function Matrix(x) {
      return x.create(x.size());
    },
    Array: arraySize,
    string: function string(x) {
      return config6.matrix === "Array" ? [x.length] : matrix([x.length]);
    },
    "number | Complex | BigNumber | Unit | boolean | null": function numberComplexBigNumberUnitBooleanNull(x) {
      return config6.matrix === "Array" ? [] : matrix ? matrix([]) : noMatrix();
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/matrix/squeeze.js
var name104 = "squeeze";
var dependencies104 = ["typed", "matrix"];
var createSqueeze = factory(name104, dependencies104, (_ref) => {
  var {
    typed,
    matrix
  } = _ref;
  return typed(name104, {
    Array: function Array(x) {
      return squeeze(clone(x));
    },
    Matrix: function Matrix(x) {
      var res = squeeze(x.toArray());
      return Array.isArray(res) ? matrix(res) : res;
    },
    any: function any(x) {
      return clone(x);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/matrix/subset.js
var _getSubstring = function(str, index) {
  if (!isIndex(index)) {
    throw new TypeError("Index expected");
  }
  if (index.size().length !== 1) {
    throw new DimensionError(index.size().length, 1);
  }
  var strLen = str.length;
  validateIndex(index.min()[0], strLen);
  validateIndex(index.max()[0], strLen);
  var range = index.dimension(0);
  var substr = "";
  range.forEach(function(v) {
    substr += str.charAt(v);
  });
  return substr;
};
var _setSubstring = function(str, index, replacement, defaultValue) {
  if (!index || index.isIndex !== true) {
    throw new TypeError("Index expected");
  }
  if (index.size().length !== 1) {
    throw new DimensionError(index.size().length, 1);
  }
  if (defaultValue !== undefined) {
    if (typeof defaultValue !== "string" || defaultValue.length !== 1) {
      throw new TypeError("Single character expected as defaultValue");
    }
  } else {
    defaultValue = " ";
  }
  var range = index.dimension(0);
  var len = range.size()[0];
  if (len !== replacement.length) {
    throw new DimensionError(range.size()[0], replacement.length);
  }
  var strLen = str.length;
  validateIndex(index.min()[0]);
  validateIndex(index.max()[0]);
  var chars = [];
  for (var i = 0;i < strLen; i++) {
    chars[i] = str.charAt(i);
  }
  range.forEach(function(v, i2) {
    chars[v] = replacement.charAt(i2[0]);
  });
  if (chars.length > strLen) {
    for (var _i = strLen - 1, _len = chars.length;_i < _len; _i++) {
      if (!chars[_i]) {
        chars[_i] = defaultValue;
      }
    }
  }
  return chars.join("");
};
var _getObjectProperty = function(object14, index) {
  if (index.size().length !== 1) {
    throw new DimensionError(index.size(), 1);
  }
  var key = index.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  return getSafeProperty(object14, key);
};
var _setObjectProperty = function(object14, index, replacement) {
  if (index.size().length !== 1) {
    throw new DimensionError(index.size(), 1);
  }
  var key = index.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  var updated = clone(object14);
  setSafeProperty(updated, key, replacement);
  return updated;
};
var name105 = "subset";
var dependencies105 = ["typed", "matrix"];
var createSubset = factory(name105, dependencies105, (_ref) => {
  var {
    typed,
    matrix
  } = _ref;
  return typed(name105, {
    "Array, Index": function ArrayIndex(value, index) {
      var m = matrix(value);
      var subset = m.subset(index);
      return index.isScalar() ? subset : subset.valueOf();
    },
    "Matrix, Index": function MatrixIndex(value, index) {
      return value.subset(index);
    },
    "Object, Index": _getObjectProperty,
    "string, Index": _getSubstring,
    "Array, Index, any": function ArrayIndexAny(value, index, replacement) {
      return matrix(clone(value)).subset(index, replacement, undefined).valueOf();
    },
    "Array, Index, any, any": function ArrayIndexAnyAny(value, index, replacement, defaultValue) {
      return matrix(clone(value)).subset(index, replacement, defaultValue).valueOf();
    },
    "Matrix, Index, any": function MatrixIndexAny(value, index, replacement) {
      return value.clone().subset(index, replacement);
    },
    "Matrix, Index, any, any": function MatrixIndexAnyAny(value, index, replacement, defaultValue) {
      return value.clone().subset(index, replacement, defaultValue);
    },
    "string, Index, string": _setSubstring,
    "string, Index, string, string": _setSubstring,
    "Object, Index, any": _setObjectProperty
  });
});
// ../../node_modules/mathjs/lib/esm/function/matrix/transpose.js
var name106 = "transpose";
var dependencies106 = ["typed", "matrix"];
var createTranspose = factory(name106, dependencies106, (_ref) => {
  var {
    typed,
    matrix
  } = _ref;
  return typed(name106, {
    Array: (x) => transposeMatrix(matrix(x)).valueOf(),
    Matrix: transposeMatrix,
    any: clone
  });
  function transposeMatrix(x) {
    var size = x.size();
    var c;
    switch (size.length) {
      case 1:
        c = x.clone();
        break;
      case 2:
        {
          var rows = size[0];
          var columns = size[1];
          if (columns === 0) {
            throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + format3(size) + ")");
          }
          switch (x.storage()) {
            case "dense":
              c = _denseTranspose(x, rows, columns);
              break;
            case "sparse":
              c = _sparseTranspose(x, rows, columns);
              break;
          }
        }
        break;
      default:
        throw new RangeError("Matrix must be a vector or two dimensional (size: " + format3(size) + ")");
    }
    return c;
  }
  function _denseTranspose(m, rows, columns) {
    var data = m._data;
    var transposed = [];
    var transposedRow;
    for (var j = 0;j < columns; j++) {
      transposedRow = transposed[j] = [];
      for (var i = 0;i < rows; i++) {
        transposedRow[i] = clone(data[i][j]);
      }
    }
    return m.createDenseMatrix({
      data: transposed,
      size: [columns, rows],
      datatype: m._datatype
    });
  }
  function _sparseTranspose(m, rows, columns) {
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var cvalues = values ? [] : undefined;
    var cindex = [];
    var cptr = [];
    var w = [];
    for (var x = 0;x < rows; x++) {
      w[x] = 0;
    }
    var p, l, j;
    for (p = 0, l = index.length;p < l; p++) {
      w[index[p]]++;
    }
    var sum2 = 0;
    for (var i = 0;i < rows; i++) {
      cptr.push(sum2);
      sum2 += w[i];
      w[i] = cptr[i];
    }
    cptr.push(sum2);
    for (j = 0;j < columns; j++) {
      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0;k < k1; k++) {
        var q = w[index[k]]++;
        cindex[q] = j;
        if (values) {
          cvalues[q] = clone(values[k]);
        }
      }
    }
    return m.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [columns, rows],
      datatype: m._datatype
    });
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/ctranspose.js
var name107 = "ctranspose";
var dependencies107 = ["typed", "transpose", "conj"];
var createCtranspose = factory(name107, dependencies107, (_ref) => {
  var {
    typed,
    transpose,
    conj
  } = _ref;
  return typed(name107, {
    any: function any(x) {
      return conj(transpose(x));
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/matrix/zeros.js
var name108 = "zeros";
var dependencies108 = ["typed", "config", "matrix", "BigNumber"];
var createZeros = factory(name108, dependencies108, (_ref) => {
  var {
    typed,
    config: config6,
    matrix,
    BigNumber
  } = _ref;
  return typed(name108, {
    "": function _() {
      return config6.matrix === "Array" ? _zeros([]) : _zeros([], "default");
    },
    "...number | BigNumber | string": function numberBigNumberString(size) {
      var last = size[size.length - 1];
      if (typeof last === "string") {
        var format4 = size.pop();
        return _zeros(size, format4);
      } else if (config6.matrix === "Array") {
        return _zeros(size);
      } else {
        return _zeros(size, "default");
      }
    },
    Array: _zeros,
    Matrix: function Matrix(size) {
      var format4 = size.storage();
      return _zeros(size.valueOf(), format4);
    },
    "Array | Matrix, string": function ArrayMatrixString(size, format4) {
      return _zeros(size.valueOf(), format4);
    }
  });
  function _zeros(size, format4) {
    var hasBigNumbers = _normalize(size);
    var defaultValue = hasBigNumbers ? new BigNumber(0) : 0;
    _validate2(size);
    if (format4) {
      var m = matrix(format4);
      if (size.length > 0) {
        return m.resize(size, defaultValue);
      }
      return m;
    } else {
      var arr = [];
      if (size.length > 0) {
        return resize(arr, size, defaultValue);
      }
      return arr;
    }
  }
  function _normalize(size) {
    var hasBigNumbers = false;
    size.forEach(function(value, index, arr) {
      if (isBigNumber(value)) {
        hasBigNumbers = true;
        arr[index] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }
  function _validate2(size) {
    size.forEach(function(value) {
      if (typeof value !== "number" || !isInteger(value) || value < 0) {
        throw new Error("Parameters in function zeros must be positive integers");
      }
    });
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/fft.js
var name109 = "fft";
var dependencies109 = ["typed", "matrix", "addScalar", "multiplyScalar", "divideScalar", "exp", "tau", "i", "dotDivide", "conj", "pow", "ceil", "log2"];
var createFft = factory(name109, dependencies109, (_ref) => {
  var {
    typed,
    matrix,
    addScalar,
    multiplyScalar,
    divideScalar,
    exp: exp2,
    tau: tau2,
    i: I,
    dotDivide,
    conj,
    pow: pow2,
    ceil: ceil2,
    log2: log24
  } = _ref;
  return typed(name109, {
    Array: _ndFft,
    Matrix: function Matrix(matrix2) {
      return matrix2.create(_ndFft(matrix2.toArray()));
    }
  });
  function _ndFft(arr) {
    var size = arraySize(arr);
    if (size.length === 1)
      return _fft(arr, size[0]);
    return _1dFft(arr.map((slice) => _ndFft(slice, size.slice(1))), 0);
  }
  function _1dFft(arr, dim) {
    var size = arraySize(arr);
    if (dim !== 0)
      return new Array(size[0]).fill(0).map((_, i) => _1dFft(arr[i], dim - 1));
    if (size.length === 1)
      return _fft(arr);
    function _transpose(arr2) {
      var size2 = arraySize(arr2);
      return new Array(size2[1]).fill(0).map((_, j) => new Array(size2[0]).fill(0).map((_2, i) => arr2[i][j]));
    }
    return _transpose(_1dFft(_transpose(arr), 1));
  }
  function _czt(arr) {
    var n = arr.length;
    var w = exp2(divideScalar(multiplyScalar(-1, multiplyScalar(I, tau2)), n));
    var chirp = [];
    for (var i = 1 - n;i < n; i++) {
      chirp.push(pow2(w, divideScalar(pow2(i, 2), 2)));
    }
    var N2 = pow2(2, ceil2(log24(n + n - 1)));
    var xp = [...new Array(n).fill(0).map((_, i2) => multiplyScalar(arr[i2], chirp[n - 1 + i2])), ...new Array(N2 - n).fill(0)];
    var ichirp = [...new Array(n + n - 1).fill(0).map((_, i2) => divideScalar(1, chirp[i2])), ...new Array(N2 - (n + n - 1)).fill(0)];
    var fftXp = _fft(xp);
    var fftIchirp = _fft(ichirp);
    var fftProduct = new Array(N2).fill(0).map((_, i2) => multiplyScalar(fftXp[i2], fftIchirp[i2]));
    var ifftProduct = dotDivide(conj(_ndFft(conj(fftProduct))), N2);
    var ret = [];
    for (var _i = n - 1;_i < n + n - 1; _i++) {
      ret.push(multiplyScalar(ifftProduct[_i], chirp[_i]));
    }
    return ret;
  }
  function _fft(arr) {
    var len = arr.length;
    if (len === 1)
      return [arr[0]];
    if (len % 2 === 0) {
      var ret = [..._fft(arr.filter((_, i) => i % 2 === 0), len / 2), ..._fft(arr.filter((_, i) => i % 2 === 1), len / 2)];
      for (var k = 0;k < len / 2; k++) {
        var p = ret[k];
        var q = multiplyScalar(ret[k + len / 2], exp2(multiplyScalar(multiplyScalar(tau2, I), divideScalar(-k, len))));
        ret[k] = addScalar(p, q);
        ret[k + len / 2] = addScalar(p, multiplyScalar(-1, q));
      }
      return ret;
    } else {
      return _czt(arr);
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/ifft.js
var name110 = "ifft";
var dependencies110 = ["typed", "fft", "dotDivide", "conj"];
var createIfft = factory(name110, dependencies110, (_ref) => {
  var {
    typed,
    fft,
    dotDivide,
    conj
  } = _ref;
  return typed(name110, {
    "Array | Matrix": function ArrayMatrix(arr) {
      var size = isMatrix(arr) ? arr.size() : arraySize(arr);
      return dotDivide(conj(fft(conj(arr))), size.reduce((acc, curr) => acc * curr, 1));
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/special/erf.js
var name111 = "erf";
var dependencies111 = ["typed"];
var createErf = factory(name111, dependencies111, (_ref) => {
  var {
    typed
  } = _ref;
  return typed("name", {
    number: function number(x) {
      var y = Math.abs(x);
      if (y >= MAX_NUM) {
        return sign(x);
      }
      if (y <= THRESH) {
        return sign(x) * erf1(y);
      }
      if (y <= 4) {
        return sign(x) * (1 - erfc2(y));
      }
      return sign(x) * (1 - erfc3(y));
    },
    "Array | Matrix": typed.referToSelf((self2) => (n) => deepMap(n, self2))
  });
  function erf1(y) {
    var ysq = y * y;
    var xnum = P2[0][4] * ysq;
    var xden = ysq;
    var i;
    for (i = 0;i < 3; i += 1) {
      xnum = (xnum + P2[0][i]) * ysq;
      xden = (xden + Q[0][i]) * ysq;
    }
    return y * (xnum + P2[0][3]) / (xden + Q[0][3]);
  }
  function erfc2(y) {
    var xnum = P2[1][8] * y;
    var xden = y;
    var i;
    for (i = 0;i < 7; i += 1) {
      xnum = (xnum + P2[1][i]) * y;
      xden = (xden + Q[1][i]) * y;
    }
    var result = (xnum + P2[1][7]) / (xden + Q[1][7]);
    var ysq = parseInt(y * 16) / 16;
    var del = (y - ysq) * (y + ysq);
    return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
  }
  function erfc3(y) {
    var ysq = 1 / (y * y);
    var xnum = P2[2][5] * ysq;
    var xden = ysq;
    var i;
    for (i = 0;i < 4; i += 1) {
      xnum = (xnum + P2[2][i]) * ysq;
      xden = (xden + Q[2][i]) * ysq;
    }
    var result = ysq * (xnum + P2[2][4]) / (xden + Q[2][4]);
    result = (SQRPI - result) / y;
    ysq = parseInt(y * 16) / 16;
    var del = (y - ysq) * (y + ysq);
    return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
  }
});
var THRESH = 0.46875;
var SQRPI = 0.5641895835477563;
var P2 = [[3.1611237438705655, 113.86415415105016, 377.485237685302, 3209.3775891384694, 0.18577770618460315], [0.5641884969886701, 8.883149794388377, 66.11919063714163, 298.6351381974001, 881.952221241769, 1712.0476126340707, 2051.0783778260716, 1230.3393547979972, 0.000000021531153547440383], [0.30532663496123236, 0.36034489994980445, 0.12578172611122926, 0.016083785148742275, 0.0006587491615298378, 0.016315387137302097]];
var Q = [[23.601290952344122, 244.02463793444417, 1282.6165260773723, 2844.236833439171], [15.744926110709835, 117.6939508913125, 537.1811018620099, 1621.3895745666903, 3290.7992357334597, 4362.619090143247, 3439.3676741437216, 1230.3393548037495], [2.568520192289822, 1.8729528499234604, 0.5279051029514285, 0.06051834131244132, 0.0023352049762686918]];
var MAX_NUM = Math.pow(2, 53);
// ../../node_modules/mathjs/lib/esm/function/statistics/mode.js
var name112 = "mode";
var dependencies112 = ["typed", "isNaN", "isNumeric"];
var createMode = factory(name112, dependencies112, (_ref) => {
  var {
    typed,
    isNaN: isNaN2,
    isNumeric
  } = _ref;
  return typed(name112, {
    "Array | Matrix": _mode,
    "...": function _(args) {
      return _mode(args);
    }
  });
  function _mode(values) {
    values = flatten(values.valueOf());
    var num = values.length;
    if (num === 0) {
      throw new Error("Cannot calculate mode of an empty array");
    }
    var count = {};
    var mode = [];
    var max2 = 0;
    for (var i = 0;i < values.length; i++) {
      var value = values[i];
      if (isNumeric(value) && isNaN2(value)) {
        throw new Error("Cannot calculate mode of an array containing NaN values");
      }
      if (!(value in count)) {
        count[value] = 0;
      }
      count[value]++;
      if (count[value] === max2) {
        mode.push(value);
      } else if (count[value] > max2) {
        max2 = count[value];
        mode = [value];
      }
    }
    return mode;
  }
});
// ../../node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js
function improveErrorMessage(err, fnName, value) {
  var details;
  if (String(err).indexOf("Unexpected type") !== -1) {
    details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : " (type: " + err.data.actual + ")";
    return new TypeError("Cannot calculate " + fnName + ", unexpected type of argument" + details);
  }
  if (String(err).indexOf("complex numbers") !== -1) {
    details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : "";
    return new TypeError("Cannot calculate " + fnName + ", no ordering relation is defined for complex numbers" + details);
  }
  return err;
}

// ../../node_modules/mathjs/lib/esm/function/statistics/prod.js
var name113 = "prod";
var dependencies113 = ["typed", "config", "multiplyScalar", "numeric"];
var createProd = factory(name113, dependencies113, (_ref) => {
  var {
    typed,
    config: config6,
    multiplyScalar,
    numeric
  } = _ref;
  return typed(name113, {
    "Array | Matrix": _prod,
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array28, dim) {
      throw new Error("prod(A, dim) is not yet supported");
    },
    "...": function _(args) {
      return _prod(args);
    }
  });
  function _prod(array28) {
    var prod;
    deepForEach(array28, function(value) {
      try {
        prod = prod === undefined ? value : multiplyScalar(prod, value);
      } catch (err) {
        throw improveErrorMessage(err, "prod", value);
      }
    });
    if (typeof prod === "string") {
      prod = numeric(prod, config6.number);
    }
    if (prod === undefined) {
      throw new Error("Cannot calculate prod of an empty array");
    }
    return prod;
  }
});
// ../../node_modules/mathjs/lib/esm/function/string/format.js
var name114 = "format";
var dependencies114 = ["typed"];
var createFormat = factory(name114, dependencies114, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name114, {
    any: format3,
    "any, Object | function | number": format3
  });
});
// ../../node_modules/mathjs/lib/esm/function/string/bin.js
var name115 = "bin";
var dependencies115 = ["typed", "format"];
var createBin = factory(name115, dependencies115, (_ref) => {
  var {
    typed,
    format: format4
  } = _ref;
  return typed(name115, {
    "number | BigNumber": function numberBigNumber(n) {
      return format4(n, {
        notation: "bin"
      });
    },
    "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
      return format4(n, {
        notation: "bin",
        wordSize
      });
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/string/oct.js
var name116 = "oct";
var dependencies116 = ["typed", "format"];
var createOct = factory(name116, dependencies116, (_ref) => {
  var {
    typed,
    format: format4
  } = _ref;
  return typed(name116, {
    "number | BigNumber": function numberBigNumber(n) {
      return format4(n, {
        notation: "oct"
      });
    },
    "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
      return format4(n, {
        notation: "oct",
        wordSize
      });
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/string/hex.js
var name117 = "hex";
var dependencies117 = ["typed", "format"];
var createHex = factory(name117, dependencies117, (_ref) => {
  var {
    typed,
    format: format4
  } = _ref;
  return typed(name117, {
    "number | BigNumber": function numberBigNumber(n) {
      return format4(n, {
        notation: "hex"
      });
    },
    "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
      return format4(n, {
        notation: "hex",
        wordSize
      });
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/string/print.js
var _print = function(template, values, options) {
  return template.replace(/\$([\w.]+)/g, function(original, key) {
    var keys = key.split(".");
    var value = values[keys.shift()];
    while (keys.length && value !== undefined) {
      var k = keys.shift();
      value = k ? value[k] : value + ".";
    }
    if (value !== undefined) {
      if (!isString(value)) {
        return format3(value, options);
      } else {
        return value;
      }
    }
    return original;
  });
};
var name118 = "print";
var dependencies118 = ["typed"];
var createPrint = factory(name118, dependencies118, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name118, {
    "string, Object | Array": _print,
    "string, Object | Array, number | Object": _print
  });
});
// ../../node_modules/mathjs/lib/esm/function/unit/to.js
var name119 = "to";
var dependencies119 = ["typed", "matrix", "concat"];
var createTo = factory(name119, dependencies119, (_ref) => {
  var {
    typed,
    matrix,
    concat
  } = _ref;
  var matrixAlgorithmSuite13 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name119, {
    "Unit, Unit | string": (x, unit) => x.to(unit)
  }, matrixAlgorithmSuite13({
    Ds: true
  }));
});
// ../../node_modules/mathjs/lib/esm/function/utils/isPrime.js
var name120 = "isPrime";
var dependencies120 = ["typed"];
var createIsPrime = factory(name120, dependencies120, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name120, {
    number: function number(x) {
      if (x * 0 !== 0) {
        return false;
      }
      if (x <= 3) {
        return x > 1;
      }
      if (x % 2 === 0 || x % 3 === 0) {
        return false;
      }
      for (var i = 5;i * i <= x; i += 6) {
        if (x % i === 0 || x % (i + 2) === 0) {
          return false;
        }
      }
      return true;
    },
    BigNumber: function BigNumber(n) {
      if (n.toNumber() * 0 !== 0) {
        return false;
      }
      if (n.lte(3))
        return n.gt(1);
      if (n.mod(2).eq(0) || n.mod(3).eq(0))
        return false;
      if (n.lt(Math.pow(2, 32))) {
        var x = n.toNumber();
        for (var i = 5;i * i <= x; i += 6) {
          if (x % i === 0 || x % (i + 2) === 0) {
            return false;
          }
        }
        return true;
      }
      function modPow(base, exponent, modulus) {
        var accumulator = 1;
        while (!exponent.eq(0)) {
          if (exponent.mod(2).eq(0)) {
            exponent = exponent.div(2);
            base = base.mul(base).mod(modulus);
          } else {
            exponent = exponent.sub(1);
            accumulator = base.mul(accumulator).mod(modulus);
          }
        }
        return accumulator;
      }
      var Decimal2 = n.constructor.clone({
        precision: n.toFixed(0).length * 2
      });
      n = new Decimal2(n);
      var r = 0;
      var d = n.sub(1);
      while (d.mod(2).eq(0)) {
        d = d.div(2);
        r += 1;
      }
      var bases = null;
      if (n.lt("3317044064679887385961981")) {
        bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter((x2) => x2 < n);
      } else {
        var max2 = Math.min(n.toNumber() - 2, Math.floor(2 * Math.pow(n.toFixed(0).length * Math.log(10), 2)));
        bases = [];
        for (var _i = 2;_i <= max2; _i += 1) {
          bases.push(max2);
        }
      }
      for (var _i2 = 0;_i2 < bases.length; _i2 += 1) {
        var a = bases[_i2];
        var adn = modPow(n.sub(n).add(a), d, n);
        if (!adn.eq(1)) {
          for (var _i3 = 0, _x = adn;!_x.eq(n.sub(1)); _i3 += 1, _x = _x.mul(_x).mod(n)) {
            if (_i3 === r - 1) {
              return false;
            }
          }
        }
      }
      return true;
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/function/utils/numeric.js
var name121 = "numeric";
var dependencies121 = ["number", "?bignumber", "?fraction"];
var createNumeric = factory(name121, dependencies121, (_ref) => {
  var {
    number: _number,
    bignumber,
    fraction
  } = _ref;
  var validInputTypes = {
    string: true,
    number: true,
    BigNumber: true,
    Fraction: true
  };
  var validOutputTypes = {
    number: (x) => _number(x),
    BigNumber: bignumber ? (x) => bignumber(x) : noBignumber,
    Fraction: fraction ? (x) => fraction(x) : noFraction
  };
  return function numeric(value) {
    var outputType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "number";
    var check = arguments.length > 2 ? arguments[2] : undefined;
    if (check !== undefined) {
      throw new SyntaxError("numeric() takes one or two arguments");
    }
    var inputType = typeOf(value);
    if (!(inputType in validInputTypes)) {
      throw new TypeError("Cannot convert " + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(", "));
    }
    if (!(outputType in validOutputTypes)) {
      throw new TypeError("Cannot convert " + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(", "));
    }
    if (outputType === inputType) {
      return value;
    } else {
      return validOutputTypes[outputType](value);
    }
  };
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js
var name122 = "divideScalar";
var dependencies122 = ["typed", "numeric"];
var createDivideScalar = factory(name122, dependencies122, (_ref) => {
  var {
    typed,
    numeric
  } = _ref;
  return typed(name122, {
    "number, number": function numberNumber(x, y) {
      return x / y;
    },
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.div(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.div(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.div(y);
    },
    "Unit, number | Complex | Fraction | BigNumber | Unit": (x, y) => x.divide(y),
    "number | Fraction | Complex | BigNumber, Unit": (x, y) => y.divideInto(x)
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/pow.js
var name123 = "pow";
var dependencies123 = ["typed", "config", "identity", "multiply", "matrix", "inv", "fraction", "number", "Complex"];
var createPow = factory(name123, dependencies123, (_ref) => {
  var {
    typed,
    config: config6,
    identity,
    multiply,
    matrix,
    inv,
    number: number59,
    fraction,
    Complex: Complex2
  } = _ref;
  return typed(name123, {
    "number, number": _pow,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.pow(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      if (y.isInteger() || x >= 0 || config6.predictable) {
        return x.pow(y);
      } else {
        return new Complex2(x.toNumber(), 0).pow(y.toNumber(), 0);
      }
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      var result = x.pow(y);
      if (result != null) {
        return result;
      }
      if (config6.predictable) {
        throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");
      } else {
        return _pow(x.valueOf(), y.valueOf());
      }
    },
    "Array, number": _powArray,
    "Array, BigNumber": function ArrayBigNumber(x, y) {
      return _powArray(x, y.toNumber());
    },
    "Matrix, number": _powMatrix,
    "Matrix, BigNumber": function MatrixBigNumber(x, y) {
      return _powMatrix(x, y.toNumber());
    },
    "Unit, number | BigNumber": function UnitNumberBigNumber(x, y) {
      return x.pow(y);
    }
  });
  function _pow(x, y) {
    if (config6.predictable && !isInteger(y) && x < 0) {
      try {
        var yFrac = fraction(y);
        var yNum = number59(yFrac);
        if (y === yNum || Math.abs((y - yNum) / y) < 0.00000000000001) {
          if (yFrac.d % 2 === 1) {
            return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
          }
        }
      } catch (ex) {
      }
    }
    if (config6.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
      return NaN;
    }
    if (isInteger(y) || x >= 0 || config6.predictable) {
      return powNumber(x, y);
    } else {
      if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
        return 0;
      }
      return new Complex2(x, 0).pow(y, 0);
    }
  }
  function _powArray(x, y) {
    if (!isInteger(y)) {
      throw new TypeError("For A^b, b must be an integer (value is " + y + ")");
    }
    var s = arraySize(x);
    if (s.length !== 2) {
      throw new Error("For A^b, A must be 2 dimensional (A has " + s.length + " dimensions)");
    }
    if (s[0] !== s[1]) {
      throw new Error("For A^b, A must be square (size is " + s[0] + "x" + s[1] + ")");
    }
    if (y < 0) {
      try {
        return _powArray(inv(x), -y);
      } catch (error) {
        if (error.message === "Cannot calculate inverse, determinant is zero") {
          throw new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is " + y + ")");
        }
        throw error;
      }
    }
    var res = identity(s[0]).valueOf();
    var px = x;
    while (y >= 1) {
      if ((y & 1) === 1) {
        res = multiply(px, res);
      }
      y >>= 1;
      px = multiply(px, px);
    }
    return res;
  }
  function _powMatrix(x, y) {
    return matrix(_powArray(x.valueOf(), y));
  }
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/round.js
var NO_INT = "Number of decimals in function round must be an integer";
var name124 = "round";
var dependencies124 = ["typed", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"];
var createRound = factory(name124, dependencies124, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    zeros: zeros2,
    BigNumber,
    DenseMatrix
  } = _ref;
  var matAlgo11xS0s10 = createMatAlgo11xS0s({
    typed,
    equalScalar
  });
  var matAlgo12xSfs10 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matAlgo14xDs7 = createMatAlgo14xDs({
    typed
  });
  return typed(name124, {
    number: roundNumber,
    "number, number": roundNumber,
    "number, BigNumber": function numberBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return new BigNumber(x).toDecimalPlaces(n.toNumber());
    },
    Complex: function Complex(x) {
      return x.round();
    },
    "Complex, number": function ComplexNumber(x, n) {
      if (n % 1) {
        throw new TypeError(NO_INT);
      }
      return x.round(n);
    },
    "Complex, BigNumber": function ComplexBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      var _n = n.toNumber();
      return x.round(_n);
    },
    BigNumber: function BigNumber(x) {
      return x.toDecimalPlaces(0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return x.toDecimalPlaces(n.toNumber());
    },
    Fraction: function Fraction(x) {
      return x.round();
    },
    "Fraction, number": function FractionNumber(x, n) {
      if (n % 1) {
        throw new TypeError(NO_INT);
      }
      return x.round(n);
    },
    "Fraction, BigNumber": function FractionBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return x.round(n.toNumber());
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2, true)),
    "SparseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
      return matAlgo11xS0s10(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs7(x, y, self2, false);
    }),
    "Array, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs7(matrix(x), y, self2, false).valueOf();
    }),
    "number | Complex | BigNumber | Fraction, SparseMatrix": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo12xSfs10(y, x, self2, true);
    }),
    "number | Complex | BigNumber | Fraction, DenseMatrix": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs7(y, x, self2, true);
    }),
    "number | Complex | BigNumber | Fraction, Array": typed.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs7(matrix(y), x, self2, true).valueOf();
    })
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/log.js
var name125 = "log";
var dependencies125 = ["config", "typed", "divideScalar", "Complex"];
var createLog = factory(name125, dependencies125, (_ref) => {
  var {
    typed,
    config: config6,
    divideScalar,
    Complex: Complex2
  } = _ref;
  return typed(name125, {
    number: function number(x) {
      if (x >= 0 || config6.predictable) {
        return logNumber(x);
      } else {
        return new Complex2(x, 0).log();
      }
    },
    Complex: function Complex(x) {
      return x.log();
    },
    BigNumber: function BigNumber(x) {
      if (!x.isNegative() || config6.predictable) {
        return x.ln();
      } else {
        return new Complex2(x.toNumber(), 0).log();
      }
    },
    "any, any": typed.referToSelf((self2) => (x, base) => {
      return divideScalar(self2(x), self2(base));
    })
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/log1p.js
var name126 = "log1p";
var dependencies126 = ["typed", "config", "divideScalar", "log", "Complex"];
var createLog1p = factory(name126, dependencies126, (_ref) => {
  var {
    typed,
    config: config6,
    divideScalar,
    log: log3,
    Complex: Complex2
  } = _ref;
  return typed(name126, {
    number: function number(x) {
      if (x >= -1 || config6.predictable) {
        return log1p(x);
      } else {
        return _log1pComplex(new Complex2(x, 0));
      }
    },
    Complex: _log1pComplex,
    BigNumber: function BigNumber(x) {
      var y = x.plus(1);
      if (!y.isNegative() || config6.predictable) {
        return y.ln();
      } else {
        return _log1pComplex(new Complex2(x.toNumber(), 0));
      }
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2)),
    "any, any": typed.referToSelf((self2) => (x, base) => {
      return divideScalar(self2(x), log3(base));
    })
  });
  function _log1pComplex(x) {
    var xRe1p = x.re + 1;
    return new Complex2(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));
  }
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js
var name127 = "nthRoots";
var dependencies127 = ["config", "typed", "divideScalar", "Complex"];
var createNthRoots = factory(name127, dependencies127, (_ref) => {
  var {
    typed,
    config: config6,
    divideScalar,
    Complex: Complex2
  } = _ref;
  var _calculateExactResult = [function realPos(val) {
    return new Complex2(val, 0);
  }, function imagPos(val) {
    return new Complex2(0, val);
  }, function realNeg(val) {
    return new Complex2(-val, 0);
  }, function imagNeg(val) {
    return new Complex2(0, -val);
  }];
  function _nthComplexRoots(a, root) {
    if (root < 0)
      throw new Error("Root must be greater than zero");
    if (root === 0)
      throw new Error("Root must be non-zero");
    if (root % 1 !== 0)
      throw new Error("Root must be an integer");
    if (a === 0 || a.abs() === 0)
      return [new Complex2(0, 0)];
    var aIsNumeric = typeof a === "number";
    var offset;
    if (aIsNumeric || a.re === 0 || a.im === 0) {
      if (aIsNumeric) {
        offset = 2 * +(a < 0);
      } else if (a.im === 0) {
        offset = 2 * +(a.re < 0);
      } else {
        offset = 2 * +(a.im < 0) + 1;
      }
    }
    var arg = a.arg();
    var abs2 = a.abs();
    var roots = [];
    var r = Math.pow(abs2, 1 / root);
    for (var k = 0;k < root; k++) {
      var halfPiFactor = (offset + 4 * k) / root;
      if (halfPiFactor === Math.round(halfPiFactor)) {
        roots.push(_calculateExactResult[halfPiFactor % 4](r));
        continue;
      }
      roots.push(new Complex2({
        r,
        phi: (arg + 2 * Math.PI * k) / root
      }));
    }
    return roots;
  }
  return typed(name127, {
    Complex: function Complex(x) {
      return _nthComplexRoots(x, 2);
    },
    "Complex, number": _nthComplexRoots
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/dotPow.js
var name128 = "dotPow";
var dependencies128 = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix", "concat"];
var createDotPow = factory(name128, dependencies128, (_ref) => {
  var {
    typed,
    equalScalar,
    matrix,
    pow: pow2,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo03xDSf7 = createMatAlgo03xDSf({
    typed
  });
  var matAlgo07xSSf4 = createMatAlgo07xSSf({
    typed,
    DenseMatrix
  });
  var matAlgo11xS0s11 = createMatAlgo11xS0s({
    typed,
    equalScalar
  });
  var matAlgo12xSfs11 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite14 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  var powScalarSignatures = {};
  for (var signature in pow2.signatures) {
    if (Object.prototype.hasOwnProperty.call(pow2.signatures, signature)) {
      if (!signature.includes("Matrix") && !signature.includes("Array")) {
        powScalarSignatures[signature] = pow2.signatures[signature];
      }
    }
  }
  var powScalar = typed(powScalarSignatures);
  return typed(name128, matrixAlgorithmSuite14({
    elop: powScalar,
    SS: matAlgo07xSSf4,
    DS: matAlgo03xDSf7,
    Ss: matAlgo11xS0s11,
    sS: matAlgo12xSfs11
  }));
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/dotDivide.js
var name129 = "dotDivide";
var dependencies129 = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix", "concat"];
var createDotDivide = factory(name129, dependencies129, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    divideScalar,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo02xDS07 = createMatAlgo02xDS0({
    typed,
    equalScalar
  });
  var matAlgo03xDSf8 = createMatAlgo03xDSf({
    typed
  });
  var matAlgo07xSSf5 = createMatAlgo07xSSf({
    typed,
    DenseMatrix
  });
  var matAlgo11xS0s12 = createMatAlgo11xS0s({
    typed,
    equalScalar
  });
  var matAlgo12xSfs12 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite15 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name129, matrixAlgorithmSuite15({
    elop: divideScalar,
    SS: matAlgo07xSSf5,
    DS: matAlgo03xDSf8,
    SD: matAlgo02xDS07,
    Ss: matAlgo11xS0s12,
    sS: matAlgo12xSfs12
  }));
});
// ../../node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js
function createSolveValidation(_ref) {
  var {
    DenseMatrix
  } = _ref;
  return function solveValidation(m, b, copy) {
    var mSize = m.size();
    if (mSize.length !== 2) {
      throw new RangeError("Matrix must be two dimensional (size: " + format3(mSize) + ")");
    }
    var rows = mSize[0];
    var columns = mSize[1];
    if (rows !== columns) {
      throw new RangeError("Matrix must be square (size: " + format3(mSize) + ")");
    }
    var data = [];
    if (isMatrix(b)) {
      var bSize = b.size();
      var bdata = b._data;
      if (bSize.length === 1) {
        if (bSize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var i = 0;i < rows; i++) {
          data[i] = [bdata[i]];
        }
        return new DenseMatrix({
          data,
          size: [rows, 1],
          datatype: b._datatype
        });
      }
      if (bSize.length === 2) {
        if (bSize[0] !== rows || bSize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        if (isDenseMatrix(b)) {
          if (copy) {
            data = [];
            for (var _i = 0;_i < rows; _i++) {
              data[_i] = [bdata[_i][0]];
            }
            return new DenseMatrix({
              data,
              size: [rows, 1],
              datatype: b._datatype
            });
          }
          return b;
        }
        if (isSparseMatrix(b)) {
          for (var _i2 = 0;_i2 < rows; _i2++) {
            data[_i2] = [0];
          }
          var values = b._values;
          var index = b._index;
          var ptr = b._ptr;
          for (var k1 = ptr[1], k = ptr[0];k < k1; k++) {
            var _i3 = index[k];
            data[_i3][0] = values[k];
          }
          return new DenseMatrix({
            data,
            size: [rows, 1],
            datatype: b._datatype
          });
        }
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
    if (isArray(b)) {
      var bsize = arraySize(b);
      if (bsize.length === 1) {
        if (bsize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i4 = 0;_i4 < rows; _i4++) {
          data[_i4] = [b[_i4]];
        }
        return new DenseMatrix({
          data,
          size: [rows, 1]
        });
      }
      if (bsize.length === 2) {
        if (bsize[0] !== rows || bsize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i5 = 0;_i5 < rows; _i5++) {
          data[_i5] = [b[_i5][0]];
        }
        return new DenseMatrix({
          data,
          size: [rows, 1]
        });
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
  };
}

// ../../node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js
var name130 = "lsolve";
var dependencies130 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
var createLsolve = factory(name130, dependencies130, (_ref) => {
  var {
    typed,
    matrix,
    divideScalar,
    multiplyScalar,
    subtract,
    equalScalar,
    DenseMatrix
  } = _ref;
  var solveValidation2 = createSolveValidation({
    DenseMatrix
  });
  return typed(name130, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseForwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseForwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix(a);
      var r = _denseForwardSubstitution(m, b);
      return r.valueOf();
    }
  });
  function _denseForwardSubstitution(m, b) {
    b = solveValidation2(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var x = [];
    var mdata = m._data;
    for (var j = 0;j < columns; j++) {
      var bj = bdata[j][0] || 0;
      var xj = undefined;
      if (!equalScalar(bj, 0)) {
        var vjj = mdata[j][j];
        if (equalScalar(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        xj = divideScalar(bj, vjj);
        for (var i = j + 1;i < rows; i++) {
          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];
        }
      } else {
        xj = 0;
      }
      x[j] = [xj];
    }
    return new DenseMatrix({
      data: x,
      size: [rows, 1]
    });
  }
  function _sparseForwardSubstitution(m, b) {
    b = solveValidation2(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var x = [];
    for (var j = 0;j < columns; j++) {
      var bj = bdata[j][0] || 0;
      if (!equalScalar(bj, 0)) {
        var vjj = 0;
        var jValues = [];
        var jIndices = [];
        var firstIndex = ptr[j];
        var lastIndex = ptr[j + 1];
        for (var k = firstIndex;k < lastIndex; k++) {
          var i = index[k];
          if (i === j) {
            vjj = values[k];
          } else if (i > j) {
            jValues.push(values[k]);
            jIndices.push(i);
          }
        }
        if (equalScalar(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        var xj = divideScalar(bj, vjj);
        for (var _k = 0, l = jIndices.length;_k < l; _k++) {
          var _i = jIndices[_k];
          bdata[_i] = [subtract(bdata[_i][0] || 0, multiplyScalar(xj, jValues[_k]))];
        }
        x[j] = [xj];
      } else {
        x[j] = [0];
      }
    }
    return new DenseMatrix({
      data: x,
      size: [rows, 1]
    });
  }
});
// ../../node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js
var name131 = "usolve";
var dependencies131 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
var createUsolve = factory(name131, dependencies131, (_ref) => {
  var {
    typed,
    matrix,
    divideScalar,
    multiplyScalar,
    subtract,
    equalScalar,
    DenseMatrix
  } = _ref;
  var solveValidation3 = createSolveValidation({
    DenseMatrix
  });
  return typed(name131, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseBackwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseBackwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix(a);
      var r = _denseBackwardSubstitution(m, b);
      return r.valueOf();
    }
  });
  function _denseBackwardSubstitution(m, b) {
    b = solveValidation3(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var x = [];
    var mdata = m._data;
    for (var j = columns - 1;j >= 0; j--) {
      var bj = bdata[j][0] || 0;
      var xj = undefined;
      if (!equalScalar(bj, 0)) {
        var vjj = mdata[j][j];
        if (equalScalar(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        xj = divideScalar(bj, vjj);
        for (var i = j - 1;i >= 0; i--) {
          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];
        }
      } else {
        xj = 0;
      }
      x[j] = [xj];
    }
    return new DenseMatrix({
      data: x,
      size: [rows, 1]
    });
  }
  function _sparseBackwardSubstitution(m, b) {
    b = solveValidation3(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var x = [];
    for (var j = columns - 1;j >= 0; j--) {
      var bj = bdata[j][0] || 0;
      if (!equalScalar(bj, 0)) {
        var vjj = 0;
        var jValues = [];
        var jIndices = [];
        var firstIndex = ptr[j];
        var lastIndex = ptr[j + 1];
        for (var k = lastIndex - 1;k >= firstIndex; k--) {
          var i = index[k];
          if (i === j) {
            vjj = values[k];
          } else if (i < j) {
            jValues.push(values[k]);
            jIndices.push(i);
          }
        }
        if (equalScalar(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        var xj = divideScalar(bj, vjj);
        for (var _k = 0, _lastIndex = jIndices.length;_k < _lastIndex; _k++) {
          var _i = jIndices[_k];
          bdata[_i] = [subtract(bdata[_i][0], multiplyScalar(xj, jValues[_k]))];
        }
        x[j] = [xj];
      } else {
        x[j] = [0];
      }
    }
    return new DenseMatrix({
      data: x,
      size: [rows, 1]
    });
  }
});
// ../../node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js
var name132 = "lsolveAll";
var dependencies132 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
var createLsolveAll = factory(name132, dependencies132, (_ref) => {
  var {
    typed,
    matrix,
    divideScalar,
    multiplyScalar,
    subtract,
    equalScalar,
    DenseMatrix
  } = _ref;
  var solveValidation4 = createSolveValidation({
    DenseMatrix
  });
  return typed(name132, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseForwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseForwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix(a);
      var R = _denseForwardSubstitution(m, b);
      return R.map((r) => r.valueOf());
    }
  });
  function _denseForwardSubstitution(m, b_) {
    var B = [solveValidation4(m, b_, true)._data.map((e2) => e2[0])];
    var M = m._data;
    var rows = m._size[0];
    var columns = m._size[1];
    for (var i = 0;i < columns; i++) {
      var L = B.length;
      for (var k = 0;k < L; k++) {
        var b = B[k];
        if (!equalScalar(M[i][i], 0)) {
          b[i] = divideScalar(b[i], M[i][i]);
          for (var j = i + 1;j < columns; j++) {
            b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));
          }
        } else if (!equalScalar(b[i], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i] = 1;
          for (var _j = i + 1;_j < columns; _j++) {
            bNew[_j] = subtract(bNew[_j], M[_j][i]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
  function _sparseForwardSubstitution(m, b_) {
    var B = [solveValidation4(m, b_, true)._data.map((e2) => e2[0])];
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    for (var i = 0;i < columns; i++) {
      var L = B.length;
      for (var k = 0;k < L; k++) {
        var b = B[k];
        var iValues = [];
        var iIndices = [];
        var firstIndex = ptr[i];
        var lastIndex = ptr[i + 1];
        var Mii = 0;
        for (var j = firstIndex;j < lastIndex; j++) {
          var J = index[j];
          if (J === i) {
            Mii = values[j];
          } else if (J > i) {
            iValues.push(values[j]);
            iIndices.push(J);
          }
        }
        if (!equalScalar(Mii, 0)) {
          b[i] = divideScalar(b[i], Mii);
          for (var _j2 = 0, _lastIndex = iIndices.length;_j2 < _lastIndex; _j2++) {
            var _J = iIndices[_j2];
            b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));
          }
        } else if (!equalScalar(b[i], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i] = 1;
          for (var _j3 = 0, _lastIndex2 = iIndices.length;_j3 < _lastIndex2; _j3++) {
            var _J2 = iIndices[_j3];
            bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
});
// ../../node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js
var name133 = "usolveAll";
var dependencies133 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
var createUsolveAll = factory(name133, dependencies133, (_ref) => {
  var {
    typed,
    matrix,
    divideScalar,
    multiplyScalar,
    subtract,
    equalScalar,
    DenseMatrix
  } = _ref;
  var solveValidation5 = createSolveValidation({
    DenseMatrix
  });
  return typed(name133, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseBackwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseBackwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix(a);
      var R = _denseBackwardSubstitution(m, b);
      return R.map((r) => r.valueOf());
    }
  });
  function _denseBackwardSubstitution(m, b_) {
    var B = [solveValidation5(m, b_, true)._data.map((e2) => e2[0])];
    var M = m._data;
    var rows = m._size[0];
    var columns = m._size[1];
    for (var i = columns - 1;i >= 0; i--) {
      var L = B.length;
      for (var k = 0;k < L; k++) {
        var b = B[k];
        if (!equalScalar(M[i][i], 0)) {
          b[i] = divideScalar(b[i], M[i][i]);
          for (var j = i - 1;j >= 0; j--) {
            b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));
          }
        } else if (!equalScalar(b[i], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i] = 1;
          for (var _j = i - 1;_j >= 0; _j--) {
            bNew[_j] = subtract(bNew[_j], M[_j][i]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
  function _sparseBackwardSubstitution(m, b_) {
    var B = [solveValidation5(m, b_, true)._data.map((e2) => e2[0])];
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    for (var i = columns - 1;i >= 0; i--) {
      var L = B.length;
      for (var k = 0;k < L; k++) {
        var b = B[k];
        var iValues = [];
        var iIndices = [];
        var firstIndex = ptr[i];
        var lastIndex = ptr[i + 1];
        var Mii = 0;
        for (var j = lastIndex - 1;j >= firstIndex; j--) {
          var J = index[j];
          if (J === i) {
            Mii = values[j];
          } else if (J < i) {
            iValues.push(values[j]);
            iIndices.push(J);
          }
        }
        if (!equalScalar(Mii, 0)) {
          b[i] = divideScalar(b[i], Mii);
          for (var _j2 = 0, _lastIndex = iIndices.length;_j2 < _lastIndex; _j2++) {
            var _J = iIndices[_j2];
            b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));
          }
        } else if (!equalScalar(b[i], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i] = 1;
          for (var _j3 = 0, _lastIndex2 = iIndices.length;_j3 < _lastIndex2; _j3++) {
            var _J2 = iIndices[_j3];
            bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
});
// ../../node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo08xS0Sid.js
var name134 = "matAlgo08xS0Sid";
var dependencies134 = ["typed", "equalScalar"];
var createMatAlgo08xS0Sid = factory(name134, dependencies134, (_ref) => {
  var {
    typed,
    equalScalar
  } = _ref;
  return function matAlgo08xS0Sid(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!avalues || !bvalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrices");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed.find(equalScalar, [dt, dt]);
      zero = typed.convert(0, dt);
      cf = typed.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var x = [];
    var w = [];
    var k, k0, k1, i;
    for (var j = 0;j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0;k < k1; k++) {
        i = aindex[k];
        w[i] = mark;
        x[i] = avalues[k];
        cindex.push(i);
      }
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0;k < k1; k++) {
        i = bindex[k];
        if (w[i] === mark) {
          x[i] = cf(x[i], bvalues[k]);
        }
      }
      k = cptr[j];
      while (k < cindex.length) {
        i = cindex[k];
        var v = x[i];
        if (!eq(v, zero)) {
          cvalues.push(v);
          k++;
        } else {
          cindex.splice(k, 1);
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// ../../node_modules/mathjs/lib/esm/function/bitwise/useMatrixForArrayScalar.js
var createUseMatrixForArrayScalar = factory("useMatrixForArrayScalar", ["typed", "matrix"], (_ref) => {
  var {
    typed,
    matrix
  } = _ref;
  return {
    "Array, number": typed.referTo("DenseMatrix, number", (selfDn) => (x, y) => selfDn(matrix(x), y).valueOf()),
    "Array, BigNumber": typed.referTo("DenseMatrix, BigNumber", (selfDB) => (x, y) => selfDB(matrix(x), y).valueOf()),
    "number, Array": typed.referTo("number, DenseMatrix", (selfnD) => (x, y) => selfnD(x, matrix(y)).valueOf()),
    "BigNumber, Array": typed.referTo("BigNumber, DenseMatrix", (selfBD) => (x, y) => selfBD(x, matrix(y)).valueOf())
  };
});

// ../../node_modules/mathjs/lib/esm/function/bitwise/leftShift.js
var name135 = "leftShift";
var dependencies135 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createLeftShift = factory(name135, dependencies135, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo01xDSid6 = createMatAlgo01xDSid({
    typed
  });
  var matAlgo02xDS08 = createMatAlgo02xDS0({
    typed,
    equalScalar
  });
  var matAlgo08xS0Sid2 = createMatAlgo08xS0Sid({
    typed,
    equalScalar
  });
  var matAlgo10xSids5 = createMatAlgo10xSids({
    typed,
    DenseMatrix
  });
  var matAlgo11xS0s13 = createMatAlgo11xS0s({
    typed,
    equalScalar
  });
  var matAlgo14xDs8 = createMatAlgo14xDs({
    typed
  });
  var matrixAlgorithmSuite16 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  var useMatrixForArrayScalar2 = createUseMatrixForArrayScalar({
    typed,
    matrix
  });
  return typed(name135, {
    "number, number": leftShiftNumber,
    "BigNumber, BigNumber": leftShiftBigNumber,
    "SparseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s13(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs8(x, y, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids5(y, x, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs8(y, x, self2, true);
    })
  }, useMatrixForArrayScalar2, matrixAlgorithmSuite16({
    SS: matAlgo08xS0Sid2,
    DS: matAlgo01xDSid6,
    SD: matAlgo02xDS08
  }));
});
// ../../node_modules/mathjs/lib/esm/function/bitwise/rightArithShift.js
var name136 = "rightArithShift";
var dependencies136 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createRightArithShift = factory(name136, dependencies136, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo01xDSid7 = createMatAlgo01xDSid({
    typed
  });
  var matAlgo02xDS09 = createMatAlgo02xDS0({
    typed,
    equalScalar
  });
  var matAlgo08xS0Sid3 = createMatAlgo08xS0Sid({
    typed,
    equalScalar
  });
  var matAlgo10xSids6 = createMatAlgo10xSids({
    typed,
    DenseMatrix
  });
  var matAlgo11xS0s14 = createMatAlgo11xS0s({
    typed,
    equalScalar
  });
  var matAlgo14xDs9 = createMatAlgo14xDs({
    typed
  });
  var matrixAlgorithmSuite17 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  var useMatrixForArrayScalar3 = createUseMatrixForArrayScalar({
    typed,
    matrix
  });
  return typed(name136, {
    "number, number": rightArithShiftNumber,
    "BigNumber, BigNumber": rightArithShiftBigNumber,
    "SparseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s14(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs9(x, y, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids6(y, x, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs9(y, x, self2, true);
    })
  }, useMatrixForArrayScalar3, matrixAlgorithmSuite17({
    SS: matAlgo08xS0Sid3,
    DS: matAlgo01xDSid7,
    SD: matAlgo02xDS09
  }));
});
// ../../node_modules/mathjs/lib/esm/function/bitwise/rightLogShift.js
var name137 = "rightLogShift";
var dependencies137 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createRightLogShift = factory(name137, dependencies137, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo01xDSid8 = createMatAlgo01xDSid({
    typed
  });
  var matAlgo02xDS010 = createMatAlgo02xDS0({
    typed,
    equalScalar
  });
  var matAlgo08xS0Sid4 = createMatAlgo08xS0Sid({
    typed,
    equalScalar
  });
  var matAlgo10xSids7 = createMatAlgo10xSids({
    typed,
    DenseMatrix
  });
  var matAlgo11xS0s15 = createMatAlgo11xS0s({
    typed,
    equalScalar
  });
  var matAlgo14xDs10 = createMatAlgo14xDs({
    typed
  });
  var matrixAlgorithmSuite18 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  var useMatrixForArrayScalar4 = createUseMatrixForArrayScalar({
    typed,
    matrix
  });
  return typed(name137, {
    "number, number": rightLogShiftNumber,
    "SparseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s15(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs10(x, y, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids7(y, x, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs10(y, x, self2, true);
    })
  }, useMatrixForArrayScalar4, matrixAlgorithmSuite18({
    SS: matAlgo08xS0Sid4,
    DS: matAlgo01xDSid8,
    SD: matAlgo02xDS010
  }));
});
// ../../node_modules/mathjs/lib/esm/function/logical/and.js
var name138 = "and";
var dependencies138 = ["typed", "matrix", "equalScalar", "zeros", "not", "concat"];
var createAnd = factory(name138, dependencies138, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    zeros: zeros2,
    not,
    concat
  } = _ref;
  var matAlgo02xDS011 = createMatAlgo02xDS0({
    typed,
    equalScalar
  });
  var matAlgo06xS0S05 = createMatAlgo06xS0S0({
    typed,
    equalScalar
  });
  var matAlgo11xS0s16 = createMatAlgo11xS0s({
    typed,
    equalScalar
  });
  var matAlgo14xDs11 = createMatAlgo14xDs({
    typed
  });
  var matrixAlgorithmSuite19 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name138, {
    "number, number": andNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return (x.re !== 0 || x.im !== 0) && (y.re !== 0 || y.im !== 0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return !x.isZero() && !y.isZero() && !x.isNaN() && !y.isNaN();
    },
    "Unit, Unit": typed.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0)),
    "SparseMatrix, any": typed.referToSelf((self2) => (x, y) => {
      if (not(y)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo11xS0s16(x, y, self2, false);
    }),
    "DenseMatrix, any": typed.referToSelf((self2) => (x, y) => {
      if (not(y)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo14xDs11(x, y, self2, false);
    }),
    "any, SparseMatrix": typed.referToSelf((self2) => (x, y) => {
      if (not(x)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo11xS0s16(y, x, self2, true);
    }),
    "any, DenseMatrix": typed.referToSelf((self2) => (x, y) => {
      if (not(x)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo14xDs11(y, x, self2, true);
    }),
    "Array, any": typed.referToSelf((self2) => (x, y) => {
      return self2(matrix(x), y).valueOf();
    }),
    "any, Array": typed.referToSelf((self2) => (x, y) => {
      return self2(x, matrix(y)).valueOf();
    })
  }, matrixAlgorithmSuite19({
    SS: matAlgo06xS0S05,
    DS: matAlgo02xDS011
  }));
});
// ../../node_modules/mathjs/lib/esm/function/relational/compare.js
var name139 = "compare";
var dependencies139 = ["typed", "config", "matrix", "equalScalar", "BigNumber", "Fraction", "DenseMatrix", "concat"];
var createCompare = factory(name139, dependencies139, (_ref) => {
  var {
    typed,
    config: config6,
    equalScalar,
    matrix,
    BigNumber,
    Fraction: Fraction2,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo03xDSf9 = createMatAlgo03xDSf({
    typed
  });
  var matAlgo05xSfSf5 = createMatAlgo05xSfSf({
    typed,
    equalScalar
  });
  var matAlgo12xSfs13 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite20 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  var compareUnits3 = createCompareUnits({
    typed
  });
  return typed(name139, createCompareNumber({
    typed,
    config: config6
  }), {
    "boolean, boolean": function booleanBoolean(x, y) {
      return x === y ? 0 : x > y ? 1 : -1;
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return nearlyEqual2(x, y, config6.epsilon) ? new BigNumber(0) : new BigNumber(x.cmp(y));
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return new Fraction2(x.compare(y));
    },
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits3, matrixAlgorithmSuite20({
    SS: matAlgo05xSfSf5,
    DS: matAlgo03xDSf9,
    Ss: matAlgo12xSfs13
  }));
});
var createCompareNumber = factory(name139, ["typed", "config"], (_ref2) => {
  var {
    typed,
    config: config6
  } = _ref2;
  return typed(name139, {
    "number, number": function numberNumber(x, y) {
      return nearlyEqual(x, y, config6.epsilon) ? 0 : x > y ? 1 : -1;
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/relational/compareNatural.js
var import_javascript_natural_sort = __toESM(require_naturalSort(), 1);
var compareComplexNumbers = function(x, y) {
  if (x.re > y.re) {
    return 1;
  }
  if (x.re < y.re) {
    return -1;
  }
  if (x.im > y.im) {
    return 1;
  }
  if (x.im < y.im) {
    return -1;
  }
  return 0;
};
var name140 = "compareNatural";
var dependencies140 = ["typed", "compare"];
var createCompareNatural = factory(name140, dependencies140, (_ref) => {
  var {
    typed,
    compare
  } = _ref;
  var compareBooleans = compare.signatures["boolean,boolean"];
  return typed(name140, {
    "any, any": _compareNatural
  });
  function _compareNatural(x, y) {
    var typeX = typeOf(x);
    var typeY = typeOf(y);
    var c;
    if ((typeX === "number" || typeX === "BigNumber" || typeX === "Fraction") && (typeY === "number" || typeY === "BigNumber" || typeY === "Fraction")) {
      c = compare(x, y);
      if (c.toString() !== "0") {
        return c > 0 ? 1 : -1;
      } else {
        return import_javascript_natural_sort.default(typeX, typeY);
      }
    }
    var matTypes = ["Array", "DenseMatrix", "SparseMatrix"];
    if (matTypes.includes(typeX) || matTypes.includes(typeY)) {
      c = compareMatricesAndArrays(_compareNatural, x, y);
      if (c !== 0) {
        return c;
      } else {
        return import_javascript_natural_sort.default(typeX, typeY);
      }
    }
    if (typeX !== typeY) {
      return import_javascript_natural_sort.default(typeX, typeY);
    }
    if (typeX === "Complex") {
      return compareComplexNumbers(x, y);
    }
    if (typeX === "Unit") {
      if (x.equalBase(y)) {
        return _compareNatural(x.value, y.value);
      }
      return compareArrays(_compareNatural, x.formatUnits(), y.formatUnits());
    }
    if (typeX === "boolean") {
      return compareBooleans(x, y);
    }
    if (typeX === "string") {
      return import_javascript_natural_sort.default(x, y);
    }
    if (typeX === "Object") {
      return compareObjects(_compareNatural, x, y);
    }
    if (typeX === "null") {
      return 0;
    }
    if (typeX === "undefined") {
      return 0;
    }
    throw new TypeError('Unsupported type of value "' + typeX + '"');
  }
  function compareMatricesAndArrays(compareNatural, x, y) {
    if (isSparseMatrix(x) && isSparseMatrix(y)) {
      return compareArrays(compareNatural, x.toJSON().values, y.toJSON().values);
    }
    if (isSparseMatrix(x)) {
      return compareMatricesAndArrays(compareNatural, x.toArray(), y);
    }
    if (isSparseMatrix(y)) {
      return compareMatricesAndArrays(compareNatural, x, y.toArray());
    }
    if (isDenseMatrix(x)) {
      return compareMatricesAndArrays(compareNatural, x.toJSON().data, y);
    }
    if (isDenseMatrix(y)) {
      return compareMatricesAndArrays(compareNatural, x, y.toJSON().data);
    }
    if (!Array.isArray(x)) {
      return compareMatricesAndArrays(compareNatural, [x], y);
    }
    if (!Array.isArray(y)) {
      return compareMatricesAndArrays(compareNatural, x, [y]);
    }
    return compareArrays(compareNatural, x, y);
  }
  function compareArrays(compareNatural, x, y) {
    for (var i = 0, ii = Math.min(x.length, y.length);i < ii; i++) {
      var v = compareNatural(x[i], y[i]);
      if (v !== 0) {
        return v;
      }
    }
    if (x.length > y.length) {
      return 1;
    }
    if (x.length < y.length) {
      return -1;
    }
    return 0;
  }
  function compareObjects(compareNatural, x, y) {
    var keysX = Object.keys(x);
    var keysY = Object.keys(y);
    keysX.sort(import_javascript_natural_sort.default);
    keysY.sort(import_javascript_natural_sort.default);
    var c = compareArrays(compareNatural, keysX, keysY);
    if (c !== 0) {
      return c;
    }
    for (var i = 0;i < keysX.length; i++) {
      var v = compareNatural(x[keysX[i]], y[keysY[i]]);
      if (v !== 0) {
        return v;
      }
    }
    return 0;
  }
});
// ../../node_modules/mathjs/lib/esm/function/relational/compareText.js
var name141 = "compareText";
var dependencies141 = ["typed", "matrix", "concat"];
compareText.signature = "any, any";
var createCompareText = factory(name141, dependencies141, (_ref) => {
  var {
    typed,
    matrix,
    concat
  } = _ref;
  var matrixAlgorithmSuite21 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name141, compareText, matrixAlgorithmSuite21({
    elop: compareText,
    Ds: true
  }));
});
// ../../node_modules/mathjs/lib/esm/function/relational/equal.js
var name142 = "equal";
var dependencies142 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createEqual = factory(name142, dependencies142, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo03xDSf10 = createMatAlgo03xDSf({
    typed
  });
  var matAlgo07xSSf6 = createMatAlgo07xSSf({
    typed,
    DenseMatrix
  });
  var matAlgo12xSfs14 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite22 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name142, createEqualNumber({
    typed,
    equalScalar
  }), matrixAlgorithmSuite22({
    elop: equalScalar,
    SS: matAlgo07xSSf6,
    DS: matAlgo03xDSf10,
    Ss: matAlgo12xSfs14
  }));
});
var createEqualNumber = factory(name142, ["typed", "equalScalar"], (_ref2) => {
  var {
    typed,
    equalScalar
  } = _ref2;
  return typed(name142, {
    "any, any": function anyAny(x, y) {
      if (x === null) {
        return y === null;
      }
      if (y === null) {
        return x === null;
      }
      if (x === undefined) {
        return y === undefined;
      }
      if (y === undefined) {
        return x === undefined;
      }
      return equalScalar(x, y);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/relational/equalText.js
var name143 = "equalText";
var dependencies143 = ["typed", "compareText", "isZero"];
var createEqualText = factory(name143, dependencies143, (_ref) => {
  var {
    typed,
    compareText: compareText2,
    isZero
  } = _ref;
  return typed(name143, {
    "any, any": function anyAny(x, y) {
      return isZero(compareText2(x, y));
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/relational/smaller.js
var name144 = "smaller";
var dependencies144 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
var createSmaller = factory(name144, dependencies144, (_ref) => {
  var {
    typed,
    config: config6,
    matrix,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo03xDSf11 = createMatAlgo03xDSf({
    typed
  });
  var matAlgo07xSSf7 = createMatAlgo07xSSf({
    typed,
    DenseMatrix
  });
  var matAlgo12xSfs15 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite23 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  var compareUnits4 = createCompareUnits({
    typed
  });
  return typed(name144, createSmallerNumber({
    typed,
    config: config6
  }), {
    "boolean, boolean": (x, y) => x < y,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.lt(y) && !nearlyEqual2(x, y, config6.epsilon);
    },
    "Fraction, Fraction": (x, y) => x.compare(y) === -1,
    "Complex, Complex": function ComplexComplex(x, y) {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits4, matrixAlgorithmSuite23({
    SS: matAlgo07xSSf7,
    DS: matAlgo03xDSf11,
    Ss: matAlgo12xSfs15
  }));
});
var createSmallerNumber = factory(name144, ["typed", "config"], (_ref2) => {
  var {
    typed,
    config: config6
  } = _ref2;
  return typed(name144, {
    "number, number": function numberNumber(x, y) {
      return x < y && !nearlyEqual(x, y, config6.epsilon);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/relational/smallerEq.js
var name145 = "smallerEq";
var dependencies145 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
var createSmallerEq = factory(name145, dependencies145, (_ref) => {
  var {
    typed,
    config: config6,
    matrix,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo03xDSf12 = createMatAlgo03xDSf({
    typed
  });
  var matAlgo07xSSf8 = createMatAlgo07xSSf({
    typed,
    DenseMatrix
  });
  var matAlgo12xSfs16 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite24 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  var compareUnits5 = createCompareUnits({
    typed
  });
  return typed(name145, createSmallerEqNumber({
    typed,
    config: config6
  }), {
    "boolean, boolean": (x, y) => x <= y,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.lte(y) || nearlyEqual2(x, y, config6.epsilon);
    },
    "Fraction, Fraction": (x, y) => x.compare(y) !== 1,
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits5, matrixAlgorithmSuite24({
    SS: matAlgo07xSSf8,
    DS: matAlgo03xDSf12,
    Ss: matAlgo12xSfs16
  }));
});
var createSmallerEqNumber = factory(name145, ["typed", "config"], (_ref2) => {
  var {
    typed,
    config: config6
  } = _ref2;
  return typed(name145, {
    "number, number": function numberNumber(x, y) {
      return x <= y || nearlyEqual(x, y, config6.epsilon);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/relational/larger.js
var name146 = "larger";
var dependencies146 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
var createLarger = factory(name146, dependencies146, (_ref) => {
  var {
    typed,
    config: config6,
    matrix,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo03xDSf13 = createMatAlgo03xDSf({
    typed
  });
  var matAlgo07xSSf9 = createMatAlgo07xSSf({
    typed,
    DenseMatrix
  });
  var matAlgo12xSfs17 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite25 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  var compareUnits6 = createCompareUnits({
    typed
  });
  return typed(name146, createLargerNumber({
    typed,
    config: config6
  }), {
    "boolean, boolean": (x, y) => x > y,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.gt(y) && !nearlyEqual2(x, y, config6.epsilon);
    },
    "Fraction, Fraction": (x, y) => x.compare(y) === 1,
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits6, matrixAlgorithmSuite25({
    SS: matAlgo07xSSf9,
    DS: matAlgo03xDSf13,
    Ss: matAlgo12xSfs17
  }));
});
var createLargerNumber = factory(name146, ["typed", "config"], (_ref2) => {
  var {
    typed,
    config: config6
  } = _ref2;
  return typed(name146, {
    "number, number": function numberNumber(x, y) {
      return x > y && !nearlyEqual(x, y, config6.epsilon);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/relational/largerEq.js
var name147 = "largerEq";
var dependencies147 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
var createLargerEq = factory(name147, dependencies147, (_ref) => {
  var {
    typed,
    config: config6,
    matrix,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo03xDSf14 = createMatAlgo03xDSf({
    typed
  });
  var matAlgo07xSSf10 = createMatAlgo07xSSf({
    typed,
    DenseMatrix
  });
  var matAlgo12xSfs18 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite26 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  var compareUnits7 = createCompareUnits({
    typed
  });
  return typed(name147, createLargerEqNumber({
    typed,
    config: config6
  }), {
    "boolean, boolean": (x, y) => x >= y,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.gte(y) || nearlyEqual2(x, y, config6.epsilon);
    },
    "Fraction, Fraction": (x, y) => x.compare(y) !== -1,
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits7, matrixAlgorithmSuite26({
    SS: matAlgo07xSSf10,
    DS: matAlgo03xDSf14,
    Ss: matAlgo12xSfs18
  }));
});
var createLargerEqNumber = factory(name147, ["typed", "config"], (_ref2) => {
  var {
    typed,
    config: config6
  } = _ref2;
  return typed(name147, {
    "number, number": function numberNumber(x, y) {
      return x >= y || nearlyEqual(x, y, config6.epsilon);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/relational/deepEqual.js
var name148 = "deepEqual";
var dependencies148 = ["typed", "equal"];
var createDeepEqual = factory(name148, dependencies148, (_ref) => {
  var {
    typed,
    equal
  } = _ref;
  return typed(name148, {
    "any, any": function anyAny(x, y) {
      return _deepEqual(x.valueOf(), y.valueOf());
    }
  });
  function _deepEqual(x, y) {
    if (Array.isArray(x)) {
      if (Array.isArray(y)) {
        var len = x.length;
        if (len !== y.length) {
          return false;
        }
        for (var i = 0;i < len; i++) {
          if (!_deepEqual(x[i], y[i])) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    } else {
      if (Array.isArray(y)) {
        return false;
      } else {
        return equal(x, y);
      }
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/relational/unequal.js
var name149 = "unequal";
var dependencies149 = ["typed", "config", "equalScalar", "matrix", "DenseMatrix", "concat"];
var createUnequal = factory(name149, dependencies149, (_ref) => {
  var {
    typed,
    config: config6,
    equalScalar,
    matrix,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo03xDSf15 = createMatAlgo03xDSf({
    typed
  });
  var matAlgo07xSSf11 = createMatAlgo07xSSf({
    typed,
    DenseMatrix
  });
  var matAlgo12xSfs19 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite27 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name149, createUnequalNumber({
    typed,
    equalScalar
  }), matrixAlgorithmSuite27({
    elop: _unequal,
    SS: matAlgo07xSSf11,
    DS: matAlgo03xDSf15,
    Ss: matAlgo12xSfs19
  }));
  function _unequal(x, y) {
    return !equalScalar(x, y);
  }
});
var createUnequalNumber = factory(name149, ["typed", "equalScalar"], (_ref2) => {
  var {
    typed,
    equalScalar
  } = _ref2;
  return typed(name149, {
    "any, any": function anyAny(x, y) {
      if (x === null) {
        return y !== null;
      }
      if (y === null) {
        return x !== null;
      }
      if (x === undefined) {
        return y !== undefined;
      }
      if (y === undefined) {
        return x !== undefined;
      }
      return !equalScalar(x, y);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/matrix/partitionSelect.js
var name150 = "partitionSelect";
var dependencies150 = ["typed", "isNumeric", "isNaN", "compare"];
var createPartitionSelect = factory(name150, dependencies150, (_ref) => {
  var {
    typed,
    isNumeric,
    isNaN: isNaN2,
    compare
  } = _ref;
  var asc = compare;
  var desc = (a, b) => -compare(a, b);
  return typed(name150, {
    "Array | Matrix, number": function ArrayMatrixNumber(x, k) {
      return _partitionSelect(x, k, asc);
    },
    "Array | Matrix, number, string": function ArrayMatrixNumberString(x, k, compare2) {
      if (compare2 === "asc") {
        return _partitionSelect(x, k, asc);
      } else if (compare2 === "desc") {
        return _partitionSelect(x, k, desc);
      } else {
        throw new Error('Compare string must be "asc" or "desc"');
      }
    },
    "Array | Matrix, number, function": _partitionSelect
  });
  function _partitionSelect(x, k, compare2) {
    if (!isInteger(k) || k < 0) {
      throw new Error("k must be a non-negative integer");
    }
    if (isMatrix(x)) {
      var size = x.size();
      if (size.length > 1) {
        throw new Error("Only one dimensional matrices supported");
      }
      return quickSelect(x.valueOf(), k, compare2);
    }
    if (Array.isArray(x)) {
      return quickSelect(x, k, compare2);
    }
  }
  function quickSelect(arr, k, compare2) {
    if (k >= arr.length) {
      throw new Error("k out of bounds");
    }
    for (var i = 0;i < arr.length; i++) {
      if (isNumeric(arr[i]) && isNaN2(arr[i])) {
        return arr[i];
      }
    }
    var from = 0;
    var to = arr.length - 1;
    while (from < to) {
      var r = from;
      var w = to;
      var pivot = arr[Math.floor(Math.random() * (to - from + 1)) + from];
      while (r < w) {
        if (compare2(arr[r], pivot) >= 0) {
          var tmp = arr[w];
          arr[w] = arr[r];
          arr[r] = tmp;
          --w;
        } else {
          ++r;
        }
      }
      if (compare2(arr[r], pivot) > 0) {
        --r;
      }
      if (k <= r) {
        to = r;
      } else {
        from = r + 1;
      }
    }
    return arr[k];
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/sort.js
var name151 = "sort";
var dependencies151 = ["typed", "matrix", "compare", "compareNatural"];
var createSort = factory(name151, dependencies151, (_ref) => {
  var {
    typed,
    matrix,
    compare,
    compareNatural
  } = _ref;
  var compareAsc = compare;
  var compareDesc = (a, b) => -compare(a, b);
  return typed(name151, {
    Array: function Array(x) {
      _arrayIsVector(x);
      return x.sort(compareAsc);
    },
    Matrix: function Matrix(x) {
      _matrixIsVector(x);
      return matrix(x.toArray().sort(compareAsc), x.storage());
    },
    "Array, function": function ArrayFunction(x, _comparator2) {
      _arrayIsVector(x);
      return x.sort(_comparator2);
    },
    "Matrix, function": function MatrixFunction(x, _comparator2) {
      _matrixIsVector(x);
      return matrix(x.toArray().sort(_comparator2), x.storage());
    },
    "Array, string": function ArrayString(x, order) {
      _arrayIsVector(x);
      return x.sort(_comparator(order));
    },
    "Matrix, string": function MatrixString(x, order) {
      _matrixIsVector(x);
      return matrix(x.toArray().sort(_comparator(order)), x.storage());
    }
  });
  function _comparator(order) {
    if (order === "asc") {
      return compareAsc;
    } else if (order === "desc") {
      return compareDesc;
    } else if (order === "natural") {
      return compareNatural;
    } else {
      throw new Error('String "asc", "desc", or "natural" expected');
    }
  }
  function _arrayIsVector(array31) {
    if (arraySize(array31).length !== 1) {
      throw new Error("One dimensional array expected");
    }
  }
  function _matrixIsVector(matrix2) {
    if (matrix2.size().length !== 1) {
      throw new Error("One dimensional matrix expected");
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/statistics/max.js
var name152 = "max";
var dependencies152 = ["typed", "config", "numeric", "larger"];
var createMax = factory(name152, dependencies152, (_ref) => {
  var {
    typed,
    config: config6,
    numeric,
    larger
  } = _ref;
  return typed(name152, {
    "Array | Matrix": _max,
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array31, dim) {
      return reduce(array31, dim.valueOf(), _largest);
    },
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function max");
      }
      return _max(args);
    }
  });
  function _largest(x, y) {
    try {
      return larger(x, y) ? x : y;
    } catch (err) {
      throw improveErrorMessage(err, "max", y);
    }
  }
  function _max(array31) {
    var res;
    deepForEach(array31, function(value) {
      try {
        if (isNaN(value) && typeof value === "number") {
          res = NaN;
        } else if (res === undefined || larger(value, res)) {
          res = value;
        }
      } catch (err) {
        throw improveErrorMessage(err, "max", value);
      }
    });
    if (res === undefined) {
      throw new Error("Cannot calculate max of an empty array");
    }
    if (typeof res === "string") {
      res = numeric(res, config6.number);
    }
    return res;
  }
});
// ../../node_modules/mathjs/lib/esm/function/statistics/min.js
var name153 = "min";
var dependencies153 = ["typed", "config", "numeric", "smaller"];
var createMin = factory(name153, dependencies153, (_ref) => {
  var {
    typed,
    config: config6,
    numeric,
    smaller
  } = _ref;
  return typed(name153, {
    "Array | Matrix": _min,
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array31, dim) {
      return reduce(array31, dim.valueOf(), _smallest);
    },
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function min");
      }
      return _min(args);
    }
  });
  function _smallest(x, y) {
    try {
      return smaller(x, y) ? x : y;
    } catch (err) {
      throw improveErrorMessage(err, "min", y);
    }
  }
  function _min(array31) {
    var min2;
    deepForEach(array31, function(value) {
      try {
        if (isNaN(value) && typeof value === "number") {
          min2 = NaN;
        } else if (min2 === undefined || smaller(value, min2)) {
          min2 = value;
        }
      } catch (err) {
        throw improveErrorMessage(err, "min", value);
      }
    });
    if (min2 === undefined) {
      throw new Error("Cannot calculate min of an empty array");
    }
    if (typeof min2 === "string") {
      min2 = numeric(min2, config6.number);
    }
    return min2;
  }
});
// ../../node_modules/mathjs/lib/esm/type/matrix/ImmutableDenseMatrix.js
var name154 = "ImmutableDenseMatrix";
var dependencies154 = ["smaller", "DenseMatrix"];
var createImmutableDenseMatrixClass = factory(name154, dependencies154, (_ref) => {
  var {
    smaller,
    DenseMatrix
  } = _ref;
  function ImmutableDenseMatrix(data, datatype) {
    if (!(this instanceof ImmutableDenseMatrix)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data) || isArray(data)) {
      var matrix = new DenseMatrix(data, datatype);
      this._data = matrix._data;
      this._size = matrix._size;
      this._datatype = matrix._datatype;
      this._min = null;
      this._max = null;
    } else if (data && isArray(data.data) && isArray(data.size)) {
      this._data = data.data;
      this._size = data.size;
      this._datatype = data.datatype;
      this._min = typeof data.min !== "undefined" ? data.min : null;
      this._max = typeof data.max !== "undefined" ? data.max : null;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
      this._min = null;
      this._max = null;
    }
  }
  ImmutableDenseMatrix.prototype = new DenseMatrix;
  ImmutableDenseMatrix.prototype.type = "ImmutableDenseMatrix";
  ImmutableDenseMatrix.prototype.isImmutableDenseMatrix = true;
  ImmutableDenseMatrix.prototype.subset = function(index) {
    switch (arguments.length) {
      case 1: {
        var m = DenseMatrix.prototype.subset.call(this, index);
        if (isMatrix(m)) {
          return new ImmutableDenseMatrix({
            data: m._data,
            size: m._size,
            datatype: m._datatype
          });
        }
        return m;
      }
      case 2:
      case 3:
        throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  ImmutableDenseMatrix.prototype.set = function() {
    throw new Error("Cannot invoke set on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix.prototype.resize = function() {
    throw new Error("Cannot invoke resize on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix.prototype.reshape = function() {
    throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix.prototype.clone = function() {
    return new ImmutableDenseMatrix({
      data: clone(this._data),
      size: clone(this._size),
      datatype: this._datatype
    });
  };
  ImmutableDenseMatrix.prototype.toJSON = function() {
    return {
      mathjs: "ImmutableDenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  ImmutableDenseMatrix.fromJSON = function(json) {
    return new ImmutableDenseMatrix(json);
  };
  ImmutableDenseMatrix.prototype.swapRows = function() {
    throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix.prototype.min = function() {
    if (this._min === null) {
      var m = null;
      this.forEach(function(v) {
        if (m === null || smaller(v, m)) {
          m = v;
        }
      });
      this._min = m !== null ? m : undefined;
    }
    return this._min;
  };
  ImmutableDenseMatrix.prototype.max = function() {
    if (this._max === null) {
      var m = null;
      this.forEach(function(v) {
        if (m === null || smaller(m, v)) {
          m = v;
        }
      });
      this._max = m !== null ? m : undefined;
    }
    return this._max;
  };
  return ImmutableDenseMatrix;
}, {
  isClass: true
});
// ../../node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js
var name155 = "Index";
var dependencies155 = ["ImmutableDenseMatrix"];
var createIndexClass = factory(name155, dependencies155, (_ref) => {
  var {
    ImmutableDenseMatrix
  } = _ref;
  function Index(ranges) {
    if (!(this instanceof Index)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._dimensions = [];
    this._isScalar = true;
    for (var i = 0, ii = arguments.length;i < ii; i++) {
      var arg = arguments[i];
      if (isRange(arg)) {
        this._dimensions.push(arg);
        this._isScalar = false;
      } else if (Array.isArray(arg) || isMatrix(arg)) {
        var m = _createImmutableMatrix(arg.valueOf());
        this._dimensions.push(m);
        var size = m.size();
        if (size.length !== 1 || size[0] !== 1) {
          this._isScalar = false;
        }
      } else if (typeof arg === "number") {
        this._dimensions.push(_createImmutableMatrix([arg]));
      } else if (typeof arg === "string") {
        this._dimensions.push(arg);
      } else {
        throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      }
    }
  }
  Index.prototype.type = "Index";
  Index.prototype.isIndex = true;
  function _createImmutableMatrix(arg) {
    for (var i = 0, l = arg.length;i < l; i++) {
      if (typeof arg[i] !== "number" || !isInteger(arg[i])) {
        throw new TypeError("Index parameters must be positive integer numbers");
      }
    }
    return new ImmutableDenseMatrix(arg);
  }
  Index.prototype.clone = function() {
    var index = new Index;
    index._dimensions = clone(this._dimensions);
    index._isScalar = this._isScalar;
    return index;
  };
  Index.create = function(ranges) {
    var index = new Index;
    Index.apply(index, ranges);
    return index;
  };
  Index.prototype.size = function() {
    var size = [];
    for (var i = 0, ii = this._dimensions.length;i < ii; i++) {
      var d = this._dimensions[i];
      size[i] = typeof d === "string" ? 1 : d.size()[0];
    }
    return size;
  };
  Index.prototype.max = function() {
    var values = [];
    for (var i = 0, ii = this._dimensions.length;i < ii; i++) {
      var range = this._dimensions[i];
      values[i] = typeof range === "string" ? range : range.max();
    }
    return values;
  };
  Index.prototype.min = function() {
    var values = [];
    for (var i = 0, ii = this._dimensions.length;i < ii; i++) {
      var range = this._dimensions[i];
      values[i] = typeof range === "string" ? range : range.min();
    }
    return values;
  };
  Index.prototype.forEach = function(callback) {
    for (var i = 0, ii = this._dimensions.length;i < ii; i++) {
      callback(this._dimensions[i], i, this);
    }
  };
  Index.prototype.dimension = function(dim) {
    return this._dimensions[dim] || null;
  };
  Index.prototype.isObjectProperty = function() {
    return this._dimensions.length === 1 && typeof this._dimensions[0] === "string";
  };
  Index.prototype.getObjectProperty = function() {
    return this.isObjectProperty() ? this._dimensions[0] : null;
  };
  Index.prototype.isScalar = function() {
    return this._isScalar;
  };
  Index.prototype.toArray = function() {
    var array31 = [];
    for (var i = 0, ii = this._dimensions.length;i < ii; i++) {
      var dimension = this._dimensions[i];
      array31.push(typeof dimension === "string" ? dimension : dimension.toArray());
    }
    return array31;
  };
  Index.prototype.valueOf = Index.prototype.toArray;
  Index.prototype.toString = function() {
    var strings = [];
    for (var i = 0, ii = this._dimensions.length;i < ii; i++) {
      var dimension = this._dimensions[i];
      if (typeof dimension === "string") {
        strings.push(JSON.stringify(dimension));
      } else {
        strings.push(dimension.toString());
      }
    }
    return "[" + strings.join(", ") + "]";
  };
  Index.prototype.toJSON = function() {
    return {
      mathjs: "Index",
      dimensions: this._dimensions
    };
  };
  Index.fromJSON = function(json) {
    return Index.create(json.dimensions);
  };
  return Index;
}, {
  isClass: true
});
// ../../node_modules/mathjs/lib/esm/type/matrix/FibonacciHeap.js
var name156 = "FibonacciHeap";
var dependencies156 = ["smaller", "larger"];
var createFibonacciHeapClass = factory(name156, dependencies156, (_ref) => {
  var {
    smaller,
    larger
  } = _ref;
  var oneOverLogPhi = 1 / Math.log((1 + Math.sqrt(5)) / 2);
  function FibonacciHeap() {
    if (!(this instanceof FibonacciHeap)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._minimum = null;
    this._size = 0;
  }
  FibonacciHeap.prototype.type = "FibonacciHeap";
  FibonacciHeap.prototype.isFibonacciHeap = true;
  FibonacciHeap.prototype.insert = function(key, value) {
    var node = {
      key,
      value,
      degree: 0
    };
    if (this._minimum) {
      var minimum = this._minimum;
      node.left = minimum;
      node.right = minimum.right;
      minimum.right = node;
      node.right.left = node;
      if (smaller(key, minimum.key)) {
        this._minimum = node;
      }
    } else {
      node.left = node;
      node.right = node;
      this._minimum = node;
    }
    this._size++;
    return node;
  };
  FibonacciHeap.prototype.size = function() {
    return this._size;
  };
  FibonacciHeap.prototype.clear = function() {
    this._minimum = null;
    this._size = 0;
  };
  FibonacciHeap.prototype.isEmpty = function() {
    return this._size === 0;
  };
  FibonacciHeap.prototype.extractMinimum = function() {
    var node = this._minimum;
    if (node === null) {
      return node;
    }
    var minimum = this._minimum;
    var numberOfChildren = node.degree;
    var x = node.child;
    while (numberOfChildren > 0) {
      var tempRight = x.right;
      x.left.right = x.right;
      x.right.left = x.left;
      x.left = minimum;
      x.right = minimum.right;
      minimum.right = x;
      x.right.left = x;
      x.parent = null;
      x = tempRight;
      numberOfChildren--;
    }
    node.left.right = node.right;
    node.right.left = node.left;
    if (node === node.right) {
      minimum = null;
    } else {
      minimum = node.right;
      minimum = _findMinimumNode(minimum, this._size);
    }
    this._size--;
    this._minimum = minimum;
    return node;
  };
  FibonacciHeap.prototype.remove = function(node) {
    this._minimum = _decreaseKey(this._minimum, node, -1);
    this.extractMinimum();
  };
  function _decreaseKey(minimum, node, key) {
    node.key = key;
    var parent = node.parent;
    if (parent && smaller(node.key, parent.key)) {
      _cut(minimum, node, parent);
      _cascadingCut(minimum, parent);
    }
    if (smaller(node.key, minimum.key)) {
      minimum = node;
    }
    return minimum;
  }
  function _cut(minimum, node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    parent.degree--;
    if (parent.child === node) {
      parent.child = node.right;
    }
    if (parent.degree === 0) {
      parent.child = null;
    }
    node.left = minimum;
    node.right = minimum.right;
    minimum.right = node;
    node.right.left = node;
    node.parent = null;
    node.mark = false;
  }
  function _cascadingCut(minimum, node) {
    var parent = node.parent;
    if (!parent) {
      return;
    }
    if (!node.mark) {
      node.mark = true;
    } else {
      _cut(minimum, node, parent);
      _cascadingCut(parent);
    }
  }
  var _linkNodes = function _linkNodes(node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    node.parent = parent;
    if (!parent.child) {
      parent.child = node;
      node.right = node;
      node.left = node;
    } else {
      node.left = parent.child;
      node.right = parent.child.right;
      parent.child.right = node;
      node.right.left = node;
    }
    parent.degree++;
    node.mark = false;
  };
  function _findMinimumNode(minimum, size) {
    var arraySize2 = Math.floor(Math.log(size) * oneOverLogPhi) + 1;
    var array31 = new Array(arraySize2);
    var numRoots = 0;
    var x = minimum;
    if (x) {
      numRoots++;
      x = x.right;
      while (x !== minimum) {
        numRoots++;
        x = x.right;
      }
    }
    var y;
    while (numRoots > 0) {
      var d = x.degree;
      var next = x.right;
      while (true) {
        y = array31[d];
        if (!y) {
          break;
        }
        if (larger(x.key, y.key)) {
          var temp = y;
          y = x;
          x = temp;
        }
        _linkNodes(y, x);
        array31[d] = null;
        d++;
      }
      array31[d] = x;
      x = next;
      numRoots--;
    }
    minimum = null;
    for (var i = 0;i < arraySize2; i++) {
      y = array31[i];
      if (!y) {
        continue;
      }
      if (minimum) {
        y.left.right = y.right;
        y.right.left = y.left;
        y.left = minimum;
        y.right = minimum.right;
        minimum.right = y;
        y.right.left = y;
        if (smaller(y.key, minimum.key)) {
          minimum = y;
        }
      } else {
        minimum = y;
      }
    }
    return minimum;
  }
  return FibonacciHeap;
}, {
  isClass: true
});
// ../../node_modules/mathjs/lib/esm/type/matrix/Spa.js
var name157 = "Spa";
var dependencies157 = ["addScalar", "equalScalar", "FibonacciHeap"];
var createSpaClass = factory(name157, dependencies157, (_ref) => {
  var {
    addScalar,
    equalScalar,
    FibonacciHeap
  } = _ref;
  function Spa() {
    if (!(this instanceof Spa)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._values = [];
    this._heap = new FibonacciHeap;
  }
  Spa.prototype.type = "Spa";
  Spa.prototype.isSpa = true;
  Spa.prototype.set = function(i, v) {
    if (!this._values[i]) {
      var node = this._heap.insert(i, v);
      this._values[i] = node;
    } else {
      this._values[i].value = v;
    }
  };
  Spa.prototype.get = function(i) {
    var node = this._values[i];
    if (node) {
      return node.value;
    }
    return 0;
  };
  Spa.prototype.accumulate = function(i, v) {
    var node = this._values[i];
    if (!node) {
      node = this._heap.insert(i, v);
      this._values[i] = node;
    } else {
      node.value = addScalar(node.value, v);
    }
  };
  Spa.prototype.forEach = function(from, to, callback) {
    var heap = this._heap;
    var values = this._values;
    var nodes = [];
    var node = heap.extractMinimum();
    if (node) {
      nodes.push(node);
    }
    while (node && node.key <= to) {
      if (node.key >= from) {
        if (!equalScalar(node.value, 0)) {
          callback(node.key, node.value, this);
        }
      }
      node = heap.extractMinimum();
      if (node) {
        nodes.push(node);
      }
    }
    for (var i = 0;i < nodes.length; i++) {
      var n = nodes[i];
      node = heap.insert(n.key, n.value);
      values[node.key] = node;
    }
  };
  Spa.prototype.swap = function(i, j) {
    var nodei = this._values[i];
    var nodej = this._values[j];
    if (!nodei && nodej) {
      nodei = this._heap.insert(i, nodej.value);
      this._heap.remove(nodej);
      this._values[i] = nodei;
      this._values[j] = undefined;
    } else if (nodei && !nodej) {
      nodej = this._heap.insert(j, nodei.value);
      this._heap.remove(nodei);
      this._values[j] = nodej;
      this._values[i] = undefined;
    } else if (nodei && nodej) {
      var v = nodei.value;
      nodei.value = nodej.value;
      nodej.value = v;
    }
  };
  return Spa;
}, {
  isClass: true
});
// ../../node_modules/mathjs/lib/esm/type/unit/Unit.js
var defineProperty = __toESM(require_defineProperty(), 1);
var extends3 = __toESM(require_extends(), 1);
var ownKeys = function(object17, enumerableOnly) {
  var keys = Object.keys(object17);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object17);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object17, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
};
var _objectSpread = function(target) {
  for (var i = 1;i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      defineProperty.default(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
};

// ../../node_modules/mathjs/lib/esm/utils/bignumber/constants.js
var hasher = function(args) {
  return args[0].precision;
};
var createBigNumberE = memoize(function(BigNumber) {
  return new BigNumber(1).exp();
}, {
  hasher
});
var createBigNumberPhi = memoize(function(BigNumber) {
  return new BigNumber(1).plus(new BigNumber(5).sqrt()).div(2);
}, {
  hasher
});
var createBigNumberPi = memoize(function(BigNumber) {
  return BigNumber.acos(-1);
}, {
  hasher
});
var createBigNumberTau = memoize(function(BigNumber) {
  return createBigNumberPi(BigNumber).times(2);
}, {
  hasher
});

// ../../node_modules/mathjs/lib/esm/type/unit/Unit.js
var name158 = "Unit";
var dependencies158 = ["?on", "config", "addScalar", "subtract", "multiplyScalar", "divideScalar", "pow", "abs", "fix", "round", "equal", "isNumeric", "format", "number", "Complex", "BigNumber", "Fraction"];
var createUnitClass = factory(name158, dependencies158, (_ref) => {
  var {
    on,
    config: config6,
    addScalar,
    subtract,
    multiplyScalar,
    divideScalar,
    pow: pow2,
    abs: abs2,
    fix,
    round: round2,
    equal,
    isNumeric,
    format: format4,
    number: number73,
    Complex: Complex2,
    BigNumber: _BigNumber,
    Fraction: _Fraction
  } = _ref;
  var toNumber = number73;
  function Unit(value, valuelessUnit) {
    if (!(this instanceof Unit)) {
      throw new Error("Constructor must be called with the new operator");
    }
    if (!(value === null || value === undefined || isNumeric(value) || isComplex(value))) {
      throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");
    }
    this.fixPrefix = false;
    this.skipAutomaticSimplification = true;
    if (valuelessUnit === undefined) {
      this.units = [];
      this.dimensions = BASE_DIMENSIONS.map((x) => 0);
    } else if (typeof valuelessUnit === "string") {
      var u = Unit.parse(valuelessUnit);
      this.units = u.units;
      this.dimensions = u.dimensions;
    } else if (isUnit(valuelessUnit) && valuelessUnit.value === null) {
      this.fixPrefix = valuelessUnit.fixPrefix;
      this.skipAutomaticSimplification = valuelessUnit.skipAutomaticSimplification;
      this.dimensions = valuelessUnit.dimensions.slice(0);
      this.units = valuelessUnit.units.map((u2) => extends3.default({}, u2));
    } else {
      throw new TypeError("Second parameter in Unit constructor must be a string or valueless Unit");
    }
    this.value = this._normalize(value);
  }
  Object.defineProperty(Unit, "name", {
    value: "Unit"
  });
  Unit.prototype.constructor = Unit;
  Unit.prototype.type = "Unit";
  Unit.prototype.isUnit = true;
  var text, index, c;
  function skipWhitespace() {
    while (c === " " || c === "\t") {
      next();
    }
  }
  function isDigitDot(c2) {
    return c2 >= "0" && c2 <= "9" || c2 === ".";
  }
  function isDigit(c2) {
    return c2 >= "0" && c2 <= "9";
  }
  function next() {
    index++;
    c = text.charAt(index);
  }
  function revert(oldIndex) {
    index = oldIndex;
    c = text.charAt(index);
  }
  function parseNumber() {
    var number74 = "";
    var oldIndex = index;
    if (c === "+") {
      next();
    } else if (c === "-") {
      number74 += c;
      next();
    }
    if (!isDigitDot(c)) {
      revert(oldIndex);
      return null;
    }
    if (c === ".") {
      number74 += c;
      next();
      if (!isDigit(c)) {
        revert(oldIndex);
        return null;
      }
    } else {
      while (isDigit(c)) {
        number74 += c;
        next();
      }
      if (c === ".") {
        number74 += c;
        next();
      }
    }
    while (isDigit(c)) {
      number74 += c;
      next();
    }
    if (c === "E" || c === "e") {
      var tentativeNumber = "";
      var tentativeIndex = index;
      tentativeNumber += c;
      next();
      if (c === "+" || c === "-") {
        tentativeNumber += c;
        next();
      }
      if (!isDigit(c)) {
        revert(tentativeIndex);
        return number74;
      }
      number74 = number74 + tentativeNumber;
      while (isDigit(c)) {
        number74 += c;
        next();
      }
    }
    return number74;
  }
  function parseUnit() {
    var unitName = "";
    while (isDigit(c) || Unit.isValidAlpha(c)) {
      unitName += c;
      next();
    }
    var firstC = unitName.charAt(0);
    if (Unit.isValidAlpha(firstC)) {
      return unitName;
    } else {
      return null;
    }
  }
  function parseCharacter(toFind) {
    if (c === toFind) {
      next();
      return toFind;
    } else {
      return null;
    }
  }
  Unit.parse = function(str, options) {
    options = options || {};
    text = str;
    index = -1;
    c = "";
    if (typeof text !== "string") {
      throw new TypeError("Invalid argument in Unit.parse, string expected");
    }
    var unit2 = new Unit;
    unit2.units = [];
    var powerMultiplierCurrent = 1;
    var expectingUnit = false;
    next();
    skipWhitespace();
    var valueStr = parseNumber();
    var value = null;
    if (valueStr) {
      if (config6.number === "BigNumber") {
        value = new _BigNumber(valueStr);
      } else if (config6.number === "Fraction") {
        try {
          value = new _Fraction(valueStr);
        } catch (err) {
          value = parseFloat(valueStr);
        }
      } else {
        value = parseFloat(valueStr);
      }
      skipWhitespace();
      if (parseCharacter("*")) {
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      } else if (parseCharacter("/")) {
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      }
    }
    var powerMultiplierStack = [];
    var powerMultiplierStackProduct = 1;
    while (true) {
      skipWhitespace();
      while (c === "(") {
        powerMultiplierStack.push(powerMultiplierCurrent);
        powerMultiplierStackProduct *= powerMultiplierCurrent;
        powerMultiplierCurrent = 1;
        next();
        skipWhitespace();
      }
      var uStr = undefined;
      if (c) {
        var oldC = c;
        uStr = parseUnit();
        if (uStr === null) {
          throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index.toString());
        }
      } else {
        break;
      }
      var res = _findUnit(uStr);
      if (res === null) {
        throw new SyntaxError('Unit "' + uStr + '" not found.');
      }
      var power = powerMultiplierCurrent * powerMultiplierStackProduct;
      skipWhitespace();
      if (parseCharacter("^")) {
        skipWhitespace();
        var p = parseNumber();
        if (p === null) {
          throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
        }
        power *= p;
      }
      unit2.units.push({
        unit: res.unit,
        prefix: res.prefix,
        power
      });
      for (var i = 0;i < BASE_DIMENSIONS.length; i++) {
        unit2.dimensions[i] += (res.unit.dimensions[i] || 0) * power;
      }
      skipWhitespace();
      while (c === ")") {
        if (powerMultiplierStack.length === 0) {
          throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index.toString());
        }
        powerMultiplierStackProduct /= powerMultiplierStack.pop();
        next();
        skipWhitespace();
      }
      expectingUnit = false;
      if (parseCharacter("*")) {
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      } else if (parseCharacter("/")) {
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      } else {
        powerMultiplierCurrent = 1;
      }
      if (res.unit.base) {
        var baseDim = res.unit.base.key;
        UNIT_SYSTEMS.auto[baseDim] = {
          unit: res.unit,
          prefix: res.prefix
        };
      }
    }
    skipWhitespace();
    if (c) {
      throw new SyntaxError('Could not parse: "' + str + '"');
    }
    if (expectingUnit) {
      throw new SyntaxError('Trailing characters: "' + str + '"');
    }
    if (powerMultiplierStack.length !== 0) {
      throw new SyntaxError('Unmatched "(" in "' + text + '"');
    }
    if (unit2.units.length === 0 && !options.allowNoUnits) {
      throw new SyntaxError('"' + str + '" contains no units');
    }
    unit2.value = value !== undefined ? unit2._normalize(value) : null;
    return unit2;
  };
  Unit.prototype.clone = function() {
    var unit2 = new Unit;
    unit2.fixPrefix = this.fixPrefix;
    unit2.skipAutomaticSimplification = this.skipAutomaticSimplification;
    unit2.value = clone(this.value);
    unit2.dimensions = this.dimensions.slice(0);
    unit2.units = [];
    for (var i = 0;i < this.units.length; i++) {
      unit2.units[i] = {};
      for (var p in this.units[i]) {
        if (hasOwnProperty2(this.units[i], p)) {
          unit2.units[i][p] = this.units[i][p];
        }
      }
    }
    return unit2;
  };
  Unit.prototype.valueType = function() {
    return typeOf(this.value);
  };
  Unit.prototype._isDerived = function() {
    if (this.units.length === 0) {
      return false;
    }
    return this.units.length > 1 || Math.abs(this.units[0].power - 1) > 0.000000000000001;
  };
  Unit.prototype._normalize = function(value) {
    if (value === null || value === undefined || this.units.length === 0) {
      return value;
    }
    var res = value;
    var convert = Unit._getNumberConverter(typeOf(value));
    for (var i = 0;i < this.units.length; i++) {
      var unitValue = convert(this.units[i].unit.value);
      var unitPrefixValue = convert(this.units[i].prefix.value);
      var unitPower = convert(this.units[i].power);
      res = multiplyScalar(res, pow2(multiplyScalar(unitValue, unitPrefixValue), unitPower));
    }
    return res;
  };
  Unit.prototype._denormalize = function(value, prefixValue) {
    if (value === null || value === undefined || this.units.length === 0) {
      return value;
    }
    var res = value;
    var convert = Unit._getNumberConverter(typeOf(value));
    for (var i = 0;i < this.units.length; i++) {
      var unitValue = convert(this.units[i].unit.value);
      var unitPrefixValue = convert(this.units[i].prefix.value);
      var unitPower = convert(this.units[i].power);
      res = divideScalar(res, pow2(multiplyScalar(unitValue, unitPrefixValue), unitPower));
    }
    return res;
  };
  var _findUnit = memoize((str) => {
    if (hasOwnProperty2(UNITS, str)) {
      var unit2 = UNITS[str];
      var prefix = unit2.prefixes[""];
      return {
        unit: unit2,
        prefix
      };
    }
    for (var _name in UNITS) {
      if (hasOwnProperty2(UNITS, _name)) {
        if (endsWith(str, _name)) {
          var _unit = UNITS[_name];
          var prefixLen = str.length - _name.length;
          var prefixName = str.substring(0, prefixLen);
          var _prefix = hasOwnProperty2(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : undefined;
          if (_prefix !== undefined) {
            return {
              unit: _unit,
              prefix: _prefix
            };
          }
        }
      }
    }
    return null;
  }, {
    hasher: (args) => args[0],
    limit: 100
  });
  Unit.isValuelessUnit = function(name159) {
    return _findUnit(name159) !== null;
  };
  Unit.prototype.hasBase = function(base) {
    if (typeof base === "string") {
      base = BASE_UNITS[base];
    }
    if (!base) {
      return false;
    }
    for (var i = 0;i < BASE_DIMENSIONS.length; i++) {
      if (Math.abs((this.dimensions[i] || 0) - (base.dimensions[i] || 0)) > 0.000000000001) {
        return false;
      }
    }
    return true;
  };
  Unit.prototype.equalBase = function(other) {
    for (var i = 0;i < BASE_DIMENSIONS.length; i++) {
      if (Math.abs((this.dimensions[i] || 0) - (other.dimensions[i] || 0)) > 0.000000000001) {
        return false;
      }
    }
    return true;
  };
  Unit.prototype.equals = function(other) {
    return this.equalBase(other) && equal(this.value, other.value);
  };
  Unit.prototype.multiply = function(_other) {
    var res = this.clone();
    var other = isUnit(_other) ? _other : new Unit(_other);
    for (var i = 0;i < BASE_DIMENSIONS.length; i++) {
      res.dimensions[i] = (this.dimensions[i] || 0) + (other.dimensions[i] || 0);
    }
    for (var _i = 0;_i < other.units.length; _i++) {
      var inverted = _objectSpread({}, other.units[_i]);
      res.units.push(inverted);
    }
    if (this.value !== null || other.value !== null) {
      var valThis = this.value === null ? this._normalize(1) : this.value;
      var valOther = other.value === null ? other._normalize(1) : other.value;
      res.value = multiplyScalar(valThis, valOther);
    } else {
      res.value = null;
    }
    if (isUnit(_other)) {
      res.skipAutomaticSimplification = false;
    }
    return getNumericIfUnitless(res);
  };
  Unit.prototype.divideInto = function(numerator) {
    return new Unit(numerator).divide(this);
  };
  Unit.prototype.divide = function(_other) {
    var res = this.clone();
    var other = isUnit(_other) ? _other : new Unit(_other);
    for (var i = 0;i < BASE_DIMENSIONS.length; i++) {
      res.dimensions[i] = (this.dimensions[i] || 0) - (other.dimensions[i] || 0);
    }
    for (var _i2 = 0;_i2 < other.units.length; _i2++) {
      var inverted = _objectSpread(_objectSpread({}, other.units[_i2]), {}, {
        power: -other.units[_i2].power
      });
      res.units.push(inverted);
    }
    if (this.value !== null || other.value !== null) {
      var valThis = this.value === null ? this._normalize(1) : this.value;
      var valOther = other.value === null ? other._normalize(1) : other.value;
      res.value = divideScalar(valThis, valOther);
    } else {
      res.value = null;
    }
    if (isUnit(_other)) {
      res.skipAutomaticSimplification = false;
    }
    return getNumericIfUnitless(res);
  };
  Unit.prototype.pow = function(p) {
    var res = this.clone();
    for (var i = 0;i < BASE_DIMENSIONS.length; i++) {
      res.dimensions[i] = (this.dimensions[i] || 0) * p;
    }
    for (var _i3 = 0;_i3 < res.units.length; _i3++) {
      res.units[_i3].power *= p;
    }
    if (res.value !== null) {
      res.value = pow2(res.value, p);
    } else {
      res.value = null;
    }
    res.skipAutomaticSimplification = false;
    return getNumericIfUnitless(res);
  };
  function getNumericIfUnitless(unit2) {
    if (unit2.equalBase(BASE_UNITS.NONE) && unit2.value !== null && !config6.predictable) {
      return unit2.value;
    } else {
      return unit2;
    }
  }
  Unit.prototype.abs = function() {
    var ret = this.clone();
    if (ret.value !== null) {
      if (ret._isDerived() || ret.units[0].unit.offset === 0) {
        ret.value = abs2(ret.value);
      } else {
        var convert = ret._numberConverter();
        var unitValue = convert(ret.units[0].unit.value);
        var nominalOffset = convert(ret.units[0].unit.offset);
        var unitOffset = multiplyScalar(unitValue, nominalOffset);
        ret.value = subtract(abs2(addScalar(ret.value, unitOffset)), unitOffset);
      }
    }
    for (var i in ret.units) {
      if (ret.units[i].unit.name === "VA" || ret.units[i].unit.name === "VAR") {
        ret.units[i].unit = UNITS.W;
      }
    }
    return ret;
  };
  Unit.prototype.to = function(valuelessUnit) {
    var value = this.value === null ? this._normalize(1) : this.value;
    var other;
    if (typeof valuelessUnit === "string") {
      other = Unit.parse(valuelessUnit);
    } else if (isUnit(valuelessUnit)) {
      other = valuelessUnit.clone();
    } else {
      throw new Error("String or Unit expected as parameter");
    }
    if (!this.equalBase(other)) {
      throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
    }
    if (other.value !== null) {
      throw new Error("Cannot convert to a unit with a value");
    }
    if (this.value === null || this._isDerived() || this.units[0].unit.offset === other.units[0].unit.offset) {
      other.value = clone(value);
    } else {
      var convert = Unit._getNumberConverter(typeOf(value));
      var thisUnitValue = convert(this.units[0].unit.value);
      var thisNominalOffset = convert(this.units[0].unit.offset);
      var thisUnitOffset = multiplyScalar(thisUnitValue, thisNominalOffset);
      var otherUnitValue = convert(other.units[0].unit.value);
      var otherNominalOffset = convert(other.units[0].unit.offset);
      var otherUnitOffset = multiplyScalar(otherUnitValue, otherNominalOffset);
      other.value = subtract(addScalar(value, thisUnitOffset), otherUnitOffset);
    }
    other.fixPrefix = true;
    other.skipAutomaticSimplification = true;
    return other;
  };
  Unit.prototype.toNumber = function(valuelessUnit) {
    return toNumber(this.toNumeric(valuelessUnit));
  };
  Unit.prototype.toNumeric = function(valuelessUnit) {
    var other;
    if (valuelessUnit) {
      other = this.to(valuelessUnit);
    } else {
      other = this.clone();
    }
    if (other._isDerived() || other.units.length === 0) {
      return other._denormalize(other.value);
    } else {
      return other._denormalize(other.value, other.units[0].prefix.value);
    }
  };
  Unit.prototype.toString = function() {
    return this.format();
  };
  Unit.prototype.toJSON = function() {
    return {
      mathjs: "Unit",
      value: this._denormalize(this.value),
      unit: this.formatUnits(),
      fixPrefix: this.fixPrefix
    };
  };
  Unit.fromJSON = function(json) {
    var unit2 = new Unit(json.value, json.unit);
    unit2.fixPrefix = json.fixPrefix || false;
    return unit2;
  };
  Unit.prototype.valueOf = Unit.prototype.toString;
  Unit.prototype.simplify = function() {
    var ret = this.clone();
    var proposedUnitList = [];
    var matchingBase;
    for (var key2 in currentUnitSystem) {
      if (hasOwnProperty2(currentUnitSystem, key2)) {
        if (ret.hasBase(BASE_UNITS[key2])) {
          matchingBase = key2;
          break;
        }
      }
    }
    if (matchingBase === "NONE") {
      ret.units = [];
    } else {
      var matchingUnit;
      if (matchingBase) {
        if (hasOwnProperty2(currentUnitSystem, matchingBase)) {
          matchingUnit = currentUnitSystem[matchingBase];
        }
      }
      if (matchingUnit) {
        ret.units = [{
          unit: matchingUnit.unit,
          prefix: matchingUnit.prefix,
          power: 1
        }];
      } else {
        var missingBaseDim = false;
        for (var i = 0;i < BASE_DIMENSIONS.length; i++) {
          var baseDim = BASE_DIMENSIONS[i];
          if (Math.abs(ret.dimensions[i] || 0) > 0.000000000001) {
            if (hasOwnProperty2(currentUnitSystem, baseDim)) {
              proposedUnitList.push({
                unit: currentUnitSystem[baseDim].unit,
                prefix: currentUnitSystem[baseDim].prefix,
                power: ret.dimensions[i] || 0
              });
            } else {
              missingBaseDim = true;
            }
          }
        }
        if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
          ret.units = proposedUnitList;
        }
      }
    }
    return ret;
  };
  Unit.prototype.toSI = function() {
    var ret = this.clone();
    var proposedUnitList = [];
    for (var i = 0;i < BASE_DIMENSIONS.length; i++) {
      var baseDim = BASE_DIMENSIONS[i];
      if (Math.abs(ret.dimensions[i] || 0) > 0.000000000001) {
        if (hasOwnProperty2(UNIT_SYSTEMS.si, baseDim)) {
          proposedUnitList.push({
            unit: UNIT_SYSTEMS.si[baseDim].unit,
            prefix: UNIT_SYSTEMS.si[baseDim].prefix,
            power: ret.dimensions[i] || 0
          });
        } else {
          throw new Error("Cannot express custom unit " + baseDim + " in SI units");
        }
      }
    }
    ret.units = proposedUnitList;
    ret.fixPrefix = true;
    ret.skipAutomaticSimplification = true;
    return ret;
  };
  Unit.prototype.formatUnits = function() {
    var strNum = "";
    var strDen = "";
    var nNum = 0;
    var nDen = 0;
    for (var i = 0;i < this.units.length; i++) {
      if (this.units[i].power > 0) {
        nNum++;
        strNum += " " + this.units[i].prefix.name + this.units[i].unit.name;
        if (Math.abs(this.units[i].power - 1) > 0.000000000000001) {
          strNum += "^" + this.units[i].power;
        }
      } else if (this.units[i].power < 0) {
        nDen++;
      }
    }
    if (nDen > 0) {
      for (var _i4 = 0;_i4 < this.units.length; _i4++) {
        if (this.units[_i4].power < 0) {
          if (nNum > 0) {
            strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
            if (Math.abs(this.units[_i4].power + 1) > 0.000000000000001) {
              strDen += "^" + -this.units[_i4].power;
            }
          } else {
            strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
            strDen += "^" + this.units[_i4].power;
          }
        }
      }
    }
    strNum = strNum.substr(1);
    strDen = strDen.substr(1);
    if (nNum > 1 && nDen > 0) {
      strNum = "(" + strNum + ")";
    }
    if (nDen > 1 && nNum > 0) {
      strDen = "(" + strDen + ")";
    }
    var str = strNum;
    if (nNum > 0 && nDen > 0) {
      str += " / ";
    }
    str += strDen;
    return str;
  };
  Unit.prototype.format = function(options) {
    var simp = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify();
    var isImaginary = false;
    if (typeof simp.value !== "undefined" && simp.value !== null && isComplex(simp.value)) {
      isImaginary = Math.abs(simp.value.re) < 0.00000000000001;
    }
    for (var i in simp.units) {
      if (hasOwnProperty2(simp.units, i)) {
        if (simp.units[i].unit) {
          if (simp.units[i].unit.name === "VA" && isImaginary) {
            simp.units[i].unit = UNITS.VAR;
          } else if (simp.units[i].unit.name === "VAR" && !isImaginary) {
            simp.units[i].unit = UNITS.VA;
          }
        }
      }
    }
    if (simp.units.length === 1 && !simp.fixPrefix) {
      if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 0.00000000000001) {
        simp.units[0].prefix = simp._bestPrefix();
      }
    }
    var value = simp._denormalize(simp.value);
    var str = simp.value !== null ? format4(value, options || {}) : "";
    var unitStr = simp.formatUnits();
    if (simp.value && isComplex(simp.value)) {
      str = "(" + str + ")";
    }
    if (unitStr.length > 0 && str.length > 0) {
      str += " ";
    }
    str += unitStr;
    return str;
  };
  Unit.prototype._bestPrefix = function() {
    if (this.units.length !== 1) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 0.00000000000001) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    var absValue = this.value !== null ? abs2(this.value) : 0;
    var absUnitValue = abs2(this.units[0].unit.value);
    var bestPrefix = this.units[0].prefix;
    if (absValue === 0) {
      return bestPrefix;
    }
    var power = this.units[0].power;
    var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
    if (bestDiff > -2.200001 && bestDiff < 1.800001)
      return bestPrefix;
    bestDiff = Math.abs(bestDiff);
    var prefixes = this.units[0].unit.prefixes;
    for (var p in prefixes) {
      if (hasOwnProperty2(prefixes, p)) {
        var prefix = prefixes[p];
        if (prefix.scientific) {
          var diff = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);
          if (diff < bestDiff || diff === bestDiff && prefix.name.length < bestPrefix.name.length) {
            bestPrefix = prefix;
            bestDiff = diff;
          }
        }
      }
    }
    return bestPrefix;
  };
  Unit.prototype.splitUnit = function(parts) {
    var x = this.clone();
    var ret = [];
    for (var i = 0;i < parts.length; i++) {
      x = x.to(parts[i]);
      if (i === parts.length - 1)
        break;
      var xNumeric = x.toNumeric();
      var xRounded = round2(xNumeric);
      var xFixed = undefined;
      var isNearlyEqual = equal(xRounded, xNumeric);
      if (isNearlyEqual) {
        xFixed = xRounded;
      } else {
        xFixed = fix(x.toNumeric());
      }
      var y = new Unit(xFixed, parts[i].toString());
      ret.push(y);
      x = subtract(x, y);
    }
    var testSum = 0;
    for (var _i5 = 0;_i5 < ret.length; _i5++) {
      testSum = addScalar(testSum, ret[_i5].value);
    }
    if (equal(testSum, this.value)) {
      x.value = 0;
    }
    ret.push(x);
    return ret;
  };
  var PREFIXES = {
    NONE: {
      "": {
        name: "",
        value: 1,
        scientific: true
      }
    },
    SHORT: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 10,
        scientific: false
      },
      h: {
        name: "h",
        value: 100,
        scientific: false
      },
      k: {
        name: "k",
        value: 1000,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: true
      },
      T: {
        name: "T",
        value: 1000000000000,
        scientific: true
      },
      P: {
        name: "P",
        value: 1000000000000000,
        scientific: true
      },
      E: {
        name: "E",
        value: 1000000000000000000,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1000000000000000000000,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1000000000000000000000000,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.1,
        scientific: false
      },
      c: {
        name: "c",
        value: 0.01,
        scientific: false
      },
      m: {
        name: "m",
        value: 0.001,
        scientific: true
      },
      u: {
        name: "u",
        value: 0.000001,
        scientific: true
      },
      n: {
        name: "n",
        value: 0.000000001,
        scientific: true
      },
      p: {
        name: "p",
        value: 0.000000000001,
        scientific: true
      },
      f: {
        name: "f",
        value: 0.000000000000001,
        scientific: true
      },
      a: {
        name: "a",
        value: 0.000000000000000001,
        scientific: true
      },
      z: {
        name: "z",
        value: 0.000000000000000000001,
        scientific: true
      },
      y: {
        name: "y",
        value: 0.000000000000000000000001,
        scientific: true
      }
    },
    LONG: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      deca: {
        name: "deca",
        value: 10,
        scientific: false
      },
      hecto: {
        name: "hecto",
        value: 100,
        scientific: false
      },
      kilo: {
        name: "kilo",
        value: 1000,
        scientific: true
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: true
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: true
      },
      tera: {
        name: "tera",
        value: 1000000000000,
        scientific: true
      },
      peta: {
        name: "peta",
        value: 1000000000000000,
        scientific: true
      },
      exa: {
        name: "exa",
        value: 1000000000000000000,
        scientific: true
      },
      zetta: {
        name: "zetta",
        value: 1000000000000000000000,
        scientific: true
      },
      yotta: {
        name: "yotta",
        value: 1000000000000000000000000,
        scientific: true
      },
      deci: {
        name: "deci",
        value: 0.1,
        scientific: false
      },
      centi: {
        name: "centi",
        value: 0.01,
        scientific: false
      },
      milli: {
        name: "milli",
        value: 0.001,
        scientific: true
      },
      micro: {
        name: "micro",
        value: 0.000001,
        scientific: true
      },
      nano: {
        name: "nano",
        value: 0.000000001,
        scientific: true
      },
      pico: {
        name: "pico",
        value: 0.000000000001,
        scientific: true
      },
      femto: {
        name: "femto",
        value: 0.000000000000001,
        scientific: true
      },
      atto: {
        name: "atto",
        value: 0.000000000000000001,
        scientific: true
      },
      zepto: {
        name: "zepto",
        value: 0.000000000000000000001,
        scientific: true
      },
      yocto: {
        name: "yocto",
        value: 0.000000000000000000000001,
        scientific: true
      }
    },
    SQUARED: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 100,
        scientific: false
      },
      h: {
        name: "h",
        value: 1e4,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e6,
        scientific: true
      },
      M: {
        name: "M",
        value: 1000000000000,
        scientific: true
      },
      G: {
        name: "G",
        value: 1000000000000000000,
        scientific: true
      },
      T: {
        name: "T",
        value: 1000000000000000000000000,
        scientific: true
      },
      P: {
        name: "P",
        value: 1000000000000000000000000000000,
        scientific: true
      },
      E: {
        name: "E",
        value: 1000000000000000000000000000000000000,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1000000000000000000000000000000000000000000,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1000000000000000000000000000000000000000000000000,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.01,
        scientific: false
      },
      c: {
        name: "c",
        value: 0.0001,
        scientific: false
      },
      m: {
        name: "m",
        value: 0.000001,
        scientific: true
      },
      u: {
        name: "u",
        value: 0.000000000001,
        scientific: true
      },
      n: {
        name: "n",
        value: 0.000000000000000001,
        scientific: true
      },
      p: {
        name: "p",
        value: 0.000000000000000000000001,
        scientific: true
      },
      f: {
        name: "f",
        value: 0.000000000000000000000000000001,
        scientific: true
      },
      a: {
        name: "a",
        value: 0.000000000000000000000000000000000001,
        scientific: true
      },
      z: {
        name: "z",
        value: 0.000000000000000000000000000000000000000001,
        scientific: true
      },
      y: {
        name: "y",
        value: 0.000000000000000000000000000000000000000000000001,
        scientific: true
      }
    },
    CUBIC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 1000,
        scientific: false
      },
      h: {
        name: "h",
        value: 1e6,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e9,
        scientific: true
      },
      M: {
        name: "M",
        value: 1000000000000000000,
        scientific: true
      },
      G: {
        name: "G",
        value: 1000000000000000000000000000,
        scientific: true
      },
      T: {
        name: "T",
        value: 1000000000000000000000000000000000000,
        scientific: true
      },
      P: {
        name: "P",
        value: 1000000000000000000000000000000000000000000000,
        scientific: true
      },
      E: {
        name: "E",
        value: 1000000000000000000000000000000000000000000000000000000,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1000000000000000000000000000000000000000000000000000000000000000,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1000000000000000000000000000000000000000000000000000000000000000000000000,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.001,
        scientific: false
      },
      c: {
        name: "c",
        value: 0.000001,
        scientific: false
      },
      m: {
        name: "m",
        value: 0.000000001,
        scientific: true
      },
      u: {
        name: "u",
        value: 0.000000000000000001,
        scientific: true
      },
      n: {
        name: "n",
        value: 0.000000000000000000000000001,
        scientific: true
      },
      p: {
        name: "p",
        value: 0.000000000000000000000000000000000001,
        scientific: true
      },
      f: {
        name: "f",
        value: 0.000000000000000000000000000000000000000000001,
        scientific: true
      },
      a: {
        name: "a",
        value: 0.000000000000000000000000000000000000000000000000000001,
        scientific: true
      },
      z: {
        name: "z",
        value: 0.000000000000000000000000000000000000000000000000000000000000001,
        scientific: true
      },
      y: {
        name: "y",
        value: 0.000000000000000000000000000000000000000000000000000000000000000000000001,
        scientific: true
      }
    },
    BINARY_SHORT_SI: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      k: {
        name: "k",
        value: 1000,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: true
      },
      T: {
        name: "T",
        value: 1000000000000,
        scientific: true
      },
      P: {
        name: "P",
        value: 1000000000000000,
        scientific: true
      },
      E: {
        name: "E",
        value: 1000000000000000000,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1000000000000000000000,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1000000000000000000000000,
        scientific: true
      }
    },
    BINARY_SHORT_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      Ki: {
        name: "Ki",
        value: 1024,
        scientific: true
      },
      Mi: {
        name: "Mi",
        value: Math.pow(1024, 2),
        scientific: true
      },
      Gi: {
        name: "Gi",
        value: Math.pow(1024, 3),
        scientific: true
      },
      Ti: {
        name: "Ti",
        value: Math.pow(1024, 4),
        scientific: true
      },
      Pi: {
        name: "Pi",
        value: Math.pow(1024, 5),
        scientific: true
      },
      Ei: {
        name: "Ei",
        value: Math.pow(1024, 6),
        scientific: true
      },
      Zi: {
        name: "Zi",
        value: Math.pow(1024, 7),
        scientific: true
      },
      Yi: {
        name: "Yi",
        value: Math.pow(1024, 8),
        scientific: true
      }
    },
    BINARY_LONG_SI: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      kilo: {
        name: "kilo",
        value: 1000,
        scientific: true
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: true
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: true
      },
      tera: {
        name: "tera",
        value: 1000000000000,
        scientific: true
      },
      peta: {
        name: "peta",
        value: 1000000000000000,
        scientific: true
      },
      exa: {
        name: "exa",
        value: 1000000000000000000,
        scientific: true
      },
      zetta: {
        name: "zetta",
        value: 1000000000000000000000,
        scientific: true
      },
      yotta: {
        name: "yotta",
        value: 1000000000000000000000000,
        scientific: true
      }
    },
    BINARY_LONG_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      kibi: {
        name: "kibi",
        value: 1024,
        scientific: true
      },
      mebi: {
        name: "mebi",
        value: Math.pow(1024, 2),
        scientific: true
      },
      gibi: {
        name: "gibi",
        value: Math.pow(1024, 3),
        scientific: true
      },
      tebi: {
        name: "tebi",
        value: Math.pow(1024, 4),
        scientific: true
      },
      pebi: {
        name: "pebi",
        value: Math.pow(1024, 5),
        scientific: true
      },
      exi: {
        name: "exi",
        value: Math.pow(1024, 6),
        scientific: true
      },
      zebi: {
        name: "zebi",
        value: Math.pow(1024, 7),
        scientific: true
      },
      yobi: {
        name: "yobi",
        value: Math.pow(1024, 8),
        scientific: true
      }
    },
    BTU: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      MM: {
        name: "MM",
        value: 1e6,
        scientific: true
      }
    }
  };
  PREFIXES.SHORTLONG = extends3.default({}, PREFIXES.SHORT, PREFIXES.LONG);
  PREFIXES.BINARY_SHORT = extends3.default({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
  PREFIXES.BINARY_LONG = extends3.default({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);
  var BASE_DIMENSIONS = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"];
  var BASE_UNITS = {
    NONE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    MASS: {
      dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    LENGTH: {
      dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
    },
    TIME: {
      dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
    },
    CURRENT: {
      dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
    },
    TEMPERATURE: {
      dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
    },
    LUMINOUS_INTENSITY: {
      dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
    },
    AMOUNT_OF_SUBSTANCE: {
      dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
    },
    FORCE: {
      dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
    },
    SURFACE: {
      dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
    },
    VOLUME: {
      dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
    },
    ENERGY: {
      dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
    },
    POWER: {
      dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
    },
    PRESSURE: {
      dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CHARGE: {
      dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CAPACITANCE: {
      dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_POTENTIAL: {
      dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_RESISTANCE: {
      dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_INDUCTANCE: {
      dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CONDUCTANCE: {
      dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX: {
      dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX_DENSITY: {
      dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
    },
    FREQUENCY: {
      dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
    },
    ANGLE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
    },
    BIT: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
    }
  };
  for (var key in BASE_UNITS) {
    if (hasOwnProperty2(BASE_UNITS, key)) {
      BASE_UNITS[key].key = key;
    }
  }
  var BASE_UNIT_NONE = {};
  var UNIT_NONE = {
    name: "",
    base: BASE_UNIT_NONE,
    value: 1,
    offset: 0,
    dimensions: BASE_DIMENSIONS.map((x) => 0)
  };
  var UNITS = {
    meter: {
      name: "meter",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    inch: {
      name: "inch",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    foot: {
      name: "foot",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yard: {
      name: "yard",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mile: {
      name: "mile",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    link: {
      name: "link",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rod: {
      name: "rod",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.0292,
      offset: 0
    },
    chain: {
      name: "chain",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    angstrom: {
      name: "angstrom",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0000000001,
      offset: 0
    },
    m: {
      name: "m",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    in: {
      name: "in",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    ft: {
      name: "ft",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yd: {
      name: "yd",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mi: {
      name: "mi",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    li: {
      name: "li",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rd: {
      name: "rd",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.02921,
      offset: 0
    },
    ch: {
      name: "ch",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    mil: {
      name: "mil",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0000254,
      offset: 0
    },
    m2: {
      name: "m2",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.SQUARED,
      value: 1,
      offset: 0
    },
    sqin: {
      name: "sqin",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.00064516,
      offset: 0
    },
    sqft: {
      name: "sqft",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.09290304,
      offset: 0
    },
    sqyd: {
      name: "sqyd",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.83612736,
      offset: 0
    },
    sqmi: {
      name: "sqmi",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 2589988.110336,
      offset: 0
    },
    sqrd: {
      name: "sqrd",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 25.29295,
      offset: 0
    },
    sqch: {
      name: "sqch",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 404.6873,
      offset: 0
    },
    sqmil: {
      name: "sqmil",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.00000000064516,
      offset: 0
    },
    acre: {
      name: "acre",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 4046.86,
      offset: 0
    },
    hectare: {
      name: "hectare",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 1e4,
      offset: 0
    },
    m3: {
      name: "m3",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.CUBIC,
      value: 1,
      offset: 0
    },
    L: {
      name: "L",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 0.001,
      offset: 0
    },
    l: {
      name: "l",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 0.001,
      offset: 0
    },
    litre: {
      name: "litre",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.LONG,
      value: 0.001,
      offset: 0
    },
    cuin: {
      name: "cuin",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.000016387064,
      offset: 0
    },
    cuft: {
      name: "cuft",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.028316846592,
      offset: 0
    },
    cuyd: {
      name: "cuyd",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.764554857984,
      offset: 0
    },
    teaspoon: {
      name: "teaspoon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.000005,
      offset: 0
    },
    tablespoon: {
      name: "tablespoon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.000015,
      offset: 0
    },
    drop: {
      name: "drop",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.00000005,
      offset: 0
    },
    gtt: {
      name: "gtt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.00000005,
      offset: 0
    },
    minim: {
      name: "minim",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.00000006161152,
      offset: 0
    },
    fluiddram: {
      name: "fluiddram",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0000036966911,
      offset: 0
    },
    fluidounce: {
      name: "fluidounce",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.00002957353,
      offset: 0
    },
    gill: {
      name: "gill",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0001182941,
      offset: 0
    },
    cc: {
      name: "cc",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.000001,
      offset: 0
    },
    cup: {
      name: "cup",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0002365882,
      offset: 0
    },
    pint: {
      name: "pint",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0004731765,
      offset: 0
    },
    quart: {
      name: "quart",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0009463529,
      offset: 0
    },
    gallon: {
      name: "gallon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.003785412,
      offset: 0
    },
    beerbarrel: {
      name: "beerbarrel",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1173478,
      offset: 0
    },
    oilbarrel: {
      name: "oilbarrel",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1589873,
      offset: 0
    },
    hogshead: {
      name: "hogshead",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.238481,
      offset: 0
    },
    fldr: {
      name: "fldr",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0000036966911,
      offset: 0
    },
    floz: {
      name: "floz",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.00002957353,
      offset: 0
    },
    gi: {
      name: "gi",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0001182941,
      offset: 0
    },
    cp: {
      name: "cp",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0002365882,
      offset: 0
    },
    pt: {
      name: "pt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0004731765,
      offset: 0
    },
    qt: {
      name: "qt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0009463529,
      offset: 0
    },
    gal: {
      name: "gal",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.003785412,
      offset: 0
    },
    bbl: {
      name: "bbl",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1173478,
      offset: 0
    },
    obl: {
      name: "obl",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1589873,
      offset: 0
    },
    g: {
      name: "g",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 0.001,
      offset: 0
    },
    gram: {
      name: "gram",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 0.001,
      offset: 0
    },
    ton: {
      name: "ton",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 907.18474,
      offset: 0
    },
    t: {
      name: "t",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 1000,
      offset: 0
    },
    tonne: {
      name: "tonne",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 1000,
      offset: 0
    },
    grain: {
      name: "grain",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.00006479891,
      offset: 0
    },
    dram: {
      name: "dram",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    ounce: {
      name: "ounce",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.028349523125,
      offset: 0
    },
    poundmass: {
      name: "poundmass",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.45359237,
      offset: 0
    },
    hundredweight: {
      name: "hundredweight",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    stick: {
      name: "stick",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.115,
      offset: 0
    },
    stone: {
      name: "stone",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6.35029318,
      offset: 0
    },
    gr: {
      name: "gr",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.00006479891,
      offset: 0
    },
    dr: {
      name: "dr",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    oz: {
      name: "oz",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.028349523125,
      offset: 0
    },
    lbm: {
      name: "lbm",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.45359237,
      offset: 0
    },
    cwt: {
      name: "cwt",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    s: {
      name: "s",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    min: {
      name: "min",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    h: {
      name: "h",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    second: {
      name: "second",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    sec: {
      name: "sec",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    minute: {
      name: "minute",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    hour: {
      name: "hour",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    day: {
      name: "day",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 86400,
      offset: 0
    },
    week: {
      name: "week",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 7 * 86400,
      offset: 0
    },
    month: {
      name: "month",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 2629800,
      offset: 0
    },
    year: {
      name: "year",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 31557600,
      offset: 0
    },
    decade: {
      name: "decade",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576000,
      offset: 0
    },
    century: {
      name: "century",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3155760000,
      offset: 0
    },
    millennium: {
      name: "millennium",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 31557600000,
      offset: 0
    },
    hertz: {
      name: "Hertz",
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    Hz: {
      name: "Hz",
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    rad: {
      name: "rad",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    radian: {
      name: "radian",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    deg: {
      name: "deg",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: null,
      offset: 0
    },
    degree: {
      name: "degree",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null,
      offset: 0
    },
    grad: {
      name: "grad",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: null,
      offset: 0
    },
    gradian: {
      name: "gradian",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null,
      offset: 0
    },
    cycle: {
      name: "cycle",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      offset: 0
    },
    arcsec: {
      name: "arcsec",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      offset: 0
    },
    arcmin: {
      name: "arcmin",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      offset: 0
    },
    A: {
      name: "A",
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    ampere: {
      name: "ampere",
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    K: {
      name: "K",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    degC: {
      name: "degC",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 273.15
    },
    degF: {
      name: "degF",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1 / 1.8,
      offset: 459.67
    },
    degR: {
      name: "degR",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1 / 1.8,
      offset: 0
    },
    kelvin: {
      name: "kelvin",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    celsius: {
      name: "celsius",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 273.15
    },
    fahrenheit: {
      name: "fahrenheit",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1 / 1.8,
      offset: 459.67
    },
    rankine: {
      name: "rankine",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1 / 1.8,
      offset: 0
    },
    mol: {
      name: "mol",
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    mole: {
      name: "mole",
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    cd: {
      name: "cd",
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    candela: {
      name: "candela",
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    N: {
      name: "N",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    newton: {
      name: "newton",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    dyn: {
      name: "dyn",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 0.00001,
      offset: 0
    },
    dyne: {
      name: "dyne",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 0.00001,
      offset: 0
    },
    lbf: {
      name: "lbf",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    poundforce: {
      name: "poundforce",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    kip: {
      name: "kip",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 4448.2216,
      offset: 0
    },
    kilogramforce: {
      name: "kilogramforce",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    J: {
      name: "J",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    joule: {
      name: "joule",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    erg: {
      name: "erg",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.NONE,
      value: 0.0000001,
      offset: 0
    },
    Wh: {
      name: "Wh",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 3600,
      offset: 0
    },
    BTU: {
      name: "BTU",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.BTU,
      value: 1055.05585262,
      offset: 0
    },
    eV: {
      name: "eV",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 0.0000000000000000001602176565,
      offset: 0
    },
    electronvolt: {
      name: "electronvolt",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.LONG,
      value: 0.0000000000000000001602176565,
      offset: 0
    },
    W: {
      name: "W",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    watt: {
      name: "watt",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    hp: {
      name: "hp",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.NONE,
      value: 745.6998715386,
      offset: 0
    },
    VAR: {
      name: "VAR",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: Complex2.I,
      offset: 0
    },
    VA: {
      name: "VA",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    Pa: {
      name: "Pa",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    psi: {
      name: "psi",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 6894.75729276459,
      offset: 0
    },
    atm: {
      name: "atm",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 101325,
      offset: 0
    },
    bar: {
      name: "bar",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORTLONG,
      value: 1e5,
      offset: 0
    },
    torr: {
      name: "torr",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmHg: {
      name: "mmHg",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmH2O: {
      name: "mmH2O",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    cmH2O: {
      name: "cmH2O",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 98.0665,
      offset: 0
    },
    coulomb: {
      name: "coulomb",
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    C: {
      name: "C",
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    farad: {
      name: "farad",
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    F: {
      name: "F",
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    volt: {
      name: "volt",
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    V: {
      name: "V",
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    ohm: {
      name: "ohm",
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORTLONG,
      value: 1,
      offset: 0
    },
    henry: {
      name: "henry",
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    H: {
      name: "H",
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    siemens: {
      name: "siemens",
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    S: {
      name: "S",
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    weber: {
      name: "weber",
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    Wb: {
      name: "Wb",
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    tesla: {
      name: "tesla",
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    T: {
      name: "T",
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    b: {
      name: "b",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 1,
      offset: 0
    },
    bits: {
      name: "bits",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 1,
      offset: 0
    },
    B: {
      name: "B",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 8,
      offset: 0
    },
    bytes: {
      name: "bytes",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 8,
      offset: 0
    }
  };
  var ALIASES = {
    meters: "meter",
    inches: "inch",
    feet: "foot",
    yards: "yard",
    miles: "mile",
    links: "link",
    rods: "rod",
    chains: "chain",
    angstroms: "angstrom",
    lt: "l",
    litres: "litre",
    liter: "litre",
    liters: "litre",
    teaspoons: "teaspoon",
    tablespoons: "tablespoon",
    minims: "minim",
    fluiddrams: "fluiddram",
    fluidounces: "fluidounce",
    gills: "gill",
    cups: "cup",
    pints: "pint",
    quarts: "quart",
    gallons: "gallon",
    beerbarrels: "beerbarrel",
    oilbarrels: "oilbarrel",
    hogsheads: "hogshead",
    gtts: "gtt",
    grams: "gram",
    tons: "ton",
    tonnes: "tonne",
    grains: "grain",
    drams: "dram",
    ounces: "ounce",
    poundmasses: "poundmass",
    hundredweights: "hundredweight",
    sticks: "stick",
    lb: "lbm",
    lbs: "lbm",
    kips: "kip",
    kgf: "kilogramforce",
    acres: "acre",
    hectares: "hectare",
    sqfeet: "sqft",
    sqyard: "sqyd",
    sqmile: "sqmi",
    sqmiles: "sqmi",
    mmhg: "mmHg",
    mmh2o: "mmH2O",
    cmh2o: "cmH2O",
    seconds: "second",
    secs: "second",
    minutes: "minute",
    mins: "minute",
    hours: "hour",
    hr: "hour",
    hrs: "hour",
    days: "day",
    weeks: "week",
    months: "month",
    years: "year",
    decades: "decade",
    centuries: "century",
    millennia: "millennium",
    hertz: "hertz",
    radians: "radian",
    degrees: "degree",
    gradians: "gradian",
    cycles: "cycle",
    arcsecond: "arcsec",
    arcseconds: "arcsec",
    arcminute: "arcmin",
    arcminutes: "arcmin",
    BTUs: "BTU",
    watts: "watt",
    joules: "joule",
    amperes: "ampere",
    amps: "ampere",
    amp: "ampere",
    coulombs: "coulomb",
    volts: "volt",
    ohms: "ohm",
    farads: "farad",
    webers: "weber",
    teslas: "tesla",
    electronvolts: "electronvolt",
    moles: "mole",
    bit: "bits",
    byte: "bytes"
  };
  function calculateAngleValues(config7) {
    if (config7.number === "BigNumber") {
      var pi2 = createBigNumberPi(_BigNumber);
      UNITS.rad.value = new _BigNumber(1);
      UNITS.deg.value = pi2.div(180);
      UNITS.grad.value = pi2.div(200);
      UNITS.cycle.value = pi2.times(2);
      UNITS.arcsec.value = pi2.div(648000);
      UNITS.arcmin.value = pi2.div(10800);
    } else {
      UNITS.rad.value = 1;
      UNITS.deg.value = Math.PI / 180;
      UNITS.grad.value = Math.PI / 200;
      UNITS.cycle.value = Math.PI * 2;
      UNITS.arcsec.value = Math.PI / 648000;
      UNITS.arcmin.value = Math.PI / 10800;
    }
    UNITS.radian.value = UNITS.rad.value;
    UNITS.degree.value = UNITS.deg.value;
    UNITS.gradian.value = UNITS.grad.value;
  }
  calculateAngleValues(config6);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.number !== prev.number) {
        calculateAngleValues(curr);
      }
    });
  }
  var UNIT_SYSTEMS = {
    si: {
      NONE: {
        unit: UNIT_NONE,
        prefix: PREFIXES.NONE[""]
      },
      LENGTH: {
        unit: UNITS.m,
        prefix: PREFIXES.SHORT[""]
      },
      MASS: {
        unit: UNITS.g,
        prefix: PREFIXES.SHORT.k
      },
      TIME: {
        unit: UNITS.s,
        prefix: PREFIXES.SHORT[""]
      },
      CURRENT: {
        unit: UNITS.A,
        prefix: PREFIXES.SHORT[""]
      },
      TEMPERATURE: {
        unit: UNITS.K,
        prefix: PREFIXES.SHORT[""]
      },
      LUMINOUS_INTENSITY: {
        unit: UNITS.cd,
        prefix: PREFIXES.SHORT[""]
      },
      AMOUNT_OF_SUBSTANCE: {
        unit: UNITS.mol,
        prefix: PREFIXES.SHORT[""]
      },
      ANGLE: {
        unit: UNITS.rad,
        prefix: PREFIXES.SHORT[""]
      },
      BIT: {
        unit: UNITS.bits,
        prefix: PREFIXES.SHORT[""]
      },
      FORCE: {
        unit: UNITS.N,
        prefix: PREFIXES.SHORT[""]
      },
      ENERGY: {
        unit: UNITS.J,
        prefix: PREFIXES.SHORT[""]
      },
      POWER: {
        unit: UNITS.W,
        prefix: PREFIXES.SHORT[""]
      },
      PRESSURE: {
        unit: UNITS.Pa,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CHARGE: {
        unit: UNITS.C,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CAPACITANCE: {
        unit: UNITS.F,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_POTENTIAL: {
        unit: UNITS.V,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_RESISTANCE: {
        unit: UNITS.ohm,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_INDUCTANCE: {
        unit: UNITS.H,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CONDUCTANCE: {
        unit: UNITS.S,
        prefix: PREFIXES.SHORT[""]
      },
      MAGNETIC_FLUX: {
        unit: UNITS.Wb,
        prefix: PREFIXES.SHORT[""]
      },
      MAGNETIC_FLUX_DENSITY: {
        unit: UNITS.T,
        prefix: PREFIXES.SHORT[""]
      },
      FREQUENCY: {
        unit: UNITS.Hz,
        prefix: PREFIXES.SHORT[""]
      }
    }
  };
  UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.cgs.LENGTH = {
    unit: UNITS.m,
    prefix: PREFIXES.SHORT.c
  };
  UNIT_SYSTEMS.cgs.MASS = {
    unit: UNITS.g,
    prefix: PREFIXES.SHORT[""]
  };
  UNIT_SYSTEMS.cgs.FORCE = {
    unit: UNITS.dyn,
    prefix: PREFIXES.SHORT[""]
  };
  UNIT_SYSTEMS.cgs.ENERGY = {
    unit: UNITS.erg,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.us.LENGTH = {
    unit: UNITS.ft,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.MASS = {
    unit: UNITS.lbm,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.TEMPERATURE = {
    unit: UNITS.degF,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.FORCE = {
    unit: UNITS.lbf,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.ENERGY = {
    unit: UNITS.BTU,
    prefix: PREFIXES.BTU[""]
  };
  UNIT_SYSTEMS.us.POWER = {
    unit: UNITS.hp,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.PRESSURE = {
    unit: UNITS.psi,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  var currentUnitSystem = UNIT_SYSTEMS.auto;
  Unit.setUnitSystem = function(name159) {
    if (hasOwnProperty2(UNIT_SYSTEMS, name159)) {
      currentUnitSystem = UNIT_SYSTEMS[name159];
    } else {
      throw new Error("Unit system " + name159 + " does not exist. Choices are: " + Object.keys(UNIT_SYSTEMS).join(", "));
    }
  };
  Unit.getUnitSystem = function() {
    for (var _key in UNIT_SYSTEMS) {
      if (hasOwnProperty2(UNIT_SYSTEMS, _key)) {
        if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
          return _key;
        }
      }
    }
  };
  Unit.typeConverters = {
    BigNumber: function BigNumber(x) {
      return new _BigNumber(x + "");
    },
    Fraction: function Fraction(x) {
      return new _Fraction(x);
    },
    Complex: function Complex(x) {
      return x;
    },
    number: function number(x) {
      return x;
    }
  };
  Unit.prototype._numberConverter = function() {
    var convert = Unit.typeConverters[this.valueType()];
    if (convert) {
      return convert;
    }
    throw new TypeError('Unsupported Unit value type "' + this.valueType() + '"');
  };
  Unit._getNumberConverter = function(type) {
    if (!Unit.typeConverters[type]) {
      throw new TypeError('Unsupported type "' + type + '"');
    }
    return Unit.typeConverters[type];
  };
  for (var _key2 in UNITS) {
    if (hasOwnProperty2(UNITS, _key2)) {
      var unit = UNITS[_key2];
      unit.dimensions = unit.base.dimensions;
    }
  }
  for (var _name2 in ALIASES) {
    if (hasOwnProperty2(ALIASES, _name2)) {
      var _unit2 = UNITS[ALIASES[_name2]];
      var alias = {};
      for (var _key3 in _unit2) {
        if (hasOwnProperty2(_unit2, _key3)) {
          alias[_key3] = _unit2[_key3];
        }
      }
      alias.name = _name2;
      UNITS[_name2] = alias;
    }
  }
  Unit.isValidAlpha = function isValidAlpha(c2) {
    return /^[a-zA-Z]$/.test(c2);
  };
  function assertUnitNameIsValid(name159) {
    for (var i = 0;i < name159.length; i++) {
      c = name159.charAt(i);
      if (i === 0 && !Unit.isValidAlpha(c)) {
        throw new Error('Invalid unit name (must begin with alpha character): "' + name159 + '"');
      }
      if (i > 0 && !(Unit.isValidAlpha(c) || isDigit(c))) {
        throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name159 + '"');
      }
    }
  }
  Unit.createUnit = function(obj, options) {
    if (typeof obj !== "object") {
      throw new TypeError("createUnit expects first parameter to be of type 'Object'");
    }
    if (options && options.override) {
      for (var _key4 in obj) {
        if (hasOwnProperty2(obj, _key4)) {
          Unit.deleteUnit(_key4);
        }
        if (obj[_key4].aliases) {
          for (var i = 0;i < obj[_key4].aliases.length; i++) {
            Unit.deleteUnit(obj[_key4].aliases[i]);
          }
        }
      }
    }
    var lastUnit;
    for (var _key5 in obj) {
      if (hasOwnProperty2(obj, _key5)) {
        lastUnit = Unit.createUnitSingle(_key5, obj[_key5]);
      }
    }
    return lastUnit;
  };
  Unit.createUnitSingle = function(name159, obj) {
    if (typeof obj === "undefined" || obj === null) {
      obj = {};
    }
    if (typeof name159 !== "string") {
      throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
    }
    if (hasOwnProperty2(UNITS, name159)) {
      throw new Error('Cannot create unit "' + name159 + '": a unit with that name already exists');
    }
    assertUnitNameIsValid(name159);
    var defUnit = null;
    var aliases = [];
    var offset = 0;
    var definition;
    var prefixes;
    var baseName;
    if (obj && obj.type === "Unit") {
      defUnit = obj.clone();
    } else if (typeof obj === "string") {
      if (obj !== "") {
        definition = obj;
      }
    } else if (typeof obj === "object") {
      definition = obj.definition;
      prefixes = obj.prefixes;
      offset = obj.offset;
      baseName = obj.baseName;
      if (obj.aliases) {
        aliases = obj.aliases.valueOf();
      }
    } else {
      throw new TypeError('Cannot create unit "' + name159 + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
    }
    if (aliases) {
      for (var i = 0;i < aliases.length; i++) {
        if (hasOwnProperty2(UNITS, aliases[i])) {
          throw new Error('Cannot create alias "' + aliases[i] + '": a unit with that name already exists');
        }
      }
    }
    if (definition && typeof definition === "string" && !defUnit) {
      try {
        defUnit = Unit.parse(definition, {
          allowNoUnits: true
        });
      } catch (ex) {
        ex.message = 'Could not create unit "' + name159 + '" from "' + definition + '": ' + ex.message;
        throw ex;
      }
    } else if (definition && definition.type === "Unit") {
      defUnit = definition.clone();
    }
    aliases = aliases || [];
    offset = offset || 0;
    if (prefixes && prefixes.toUpperCase) {
      prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
    } else {
      prefixes = PREFIXES.NONE;
    }
    var newUnit = {};
    if (!defUnit) {
      baseName = baseName || name159 + "_STUFF";
      if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
        throw new Error('Cannot create new base unit "' + name159 + '": a base unit with that name already exists (and cannot be overridden)');
      }
      BASE_DIMENSIONS.push(baseName);
      for (var b in BASE_UNITS) {
        if (hasOwnProperty2(BASE_UNITS, b)) {
          BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
        }
      }
      var newBaseUnit = {
        dimensions: []
      };
      for (var _i6 = 0;_i6 < BASE_DIMENSIONS.length; _i6++) {
        newBaseUnit.dimensions[_i6] = 0;
      }
      newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
      newBaseUnit.key = baseName;
      BASE_UNITS[baseName] = newBaseUnit;
      newUnit = {
        name: name159,
        value: 1,
        dimensions: BASE_UNITS[baseName].dimensions.slice(0),
        prefixes,
        offset,
        base: BASE_UNITS[baseName]
      };
      currentUnitSystem[baseName] = {
        unit: newUnit,
        prefix: PREFIXES.NONE[""]
      };
    } else {
      newUnit = {
        name: name159,
        value: defUnit.value,
        dimensions: defUnit.dimensions.slice(0),
        prefixes,
        offset
      };
      var anyMatch = false;
      for (var _i7 in BASE_UNITS) {
        if (hasOwnProperty2(BASE_UNITS, _i7)) {
          var match = true;
          for (var j = 0;j < BASE_DIMENSIONS.length; j++) {
            if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[_i7].dimensions[j] || 0)) > 0.000000000001) {
              match = false;
              break;
            }
          }
          if (match) {
            anyMatch = true;
            newUnit.base = BASE_UNITS[_i7];
            break;
          }
        }
      }
      if (!anyMatch) {
        baseName = baseName || name159 + "_STUFF";
        var _newBaseUnit = {
          dimensions: defUnit.dimensions.slice(0)
        };
        _newBaseUnit.key = baseName;
        BASE_UNITS[baseName] = _newBaseUnit;
        currentUnitSystem[baseName] = {
          unit: newUnit,
          prefix: PREFIXES.NONE[""]
        };
        newUnit.base = BASE_UNITS[baseName];
      }
    }
    Unit.UNITS[name159] = newUnit;
    for (var _i8 = 0;_i8 < aliases.length; _i8++) {
      var aliasName = aliases[_i8];
      var _alias = {};
      for (var _key6 in newUnit) {
        if (hasOwnProperty2(newUnit, _key6)) {
          _alias[_key6] = newUnit[_key6];
        }
      }
      _alias.name = aliasName;
      Unit.UNITS[aliasName] = _alias;
    }
    delete _findUnit.cache;
    return new Unit(null, name159);
  };
  Unit.deleteUnit = function(name159) {
    delete Unit.UNITS[name159];
  };
  Unit.PREFIXES = PREFIXES;
  Unit.BASE_DIMENSIONS = BASE_DIMENSIONS;
  Unit.BASE_UNITS = BASE_UNITS;
  Unit.UNIT_SYSTEMS = UNIT_SYSTEMS;
  Unit.UNITS = UNITS;
  return Unit;
}, {
  isClass: true
});
// ../../node_modules/mathjs/lib/esm/type/unit/function/unit.js
var name159 = "unit";
var dependencies159 = ["typed", "Unit"];
var createUnitFunction = factory(name159, dependencies159, (_ref) => {
  var {
    typed,
    Unit
  } = _ref;
  return typed(name159, {
    Unit: function Unit(x) {
      return x.clone();
    },
    string: function string(x) {
      if (Unit.isValuelessUnit(x)) {
        return new Unit(null, x);
      }
      return Unit.parse(x, {
        allowNoUnits: true
      });
    },
    "number | BigNumber | Fraction | Complex, string | Unit": function numberBigNumberFractionComplexStringUnit(value, unit) {
      return new Unit(value, unit);
    },
    "number | BigNumber | Fraction": function numberBigNumberFraction(value) {
      return new Unit(value);
    },
    "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/type/matrix/function/sparse.js
var name160 = "sparse";
var dependencies160 = ["typed", "SparseMatrix"];
var createSparse = factory(name160, dependencies160, (_ref) => {
  var {
    typed,
    SparseMatrix
  } = _ref;
  return typed(name160, {
    "": function _() {
      return new SparseMatrix([]);
    },
    string: function string(datatype) {
      return new SparseMatrix([], datatype);
    },
    "Array | Matrix": function ArrayMatrix(data) {
      return new SparseMatrix(data);
    },
    "Array | Matrix, string": function ArrayMatrixString(data, datatype) {
      return new SparseMatrix(data, datatype);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/type/unit/function/createUnit.js
var name161 = "createUnit";
var dependencies161 = ["typed", "Unit"];
var createCreateUnit = factory(name161, dependencies161, (_ref) => {
  var {
    typed,
    Unit
  } = _ref;
  return typed(name161, {
    "Object, Object": function ObjectObject(obj, options) {
      return Unit.createUnit(obj, options);
    },
    Object: function Object(obj) {
      return Unit.createUnit(obj, {});
    },
    "string, Unit | string | Object, Object": function stringUnitStringObjectObject(name162, def, options) {
      var obj = {};
      obj[name162] = def;
      return Unit.createUnit(obj, options);
    },
    "string, Unit | string | Object": function stringUnitStringObject(name162, def) {
      var obj = {};
      obj[name162] = def;
      return Unit.createUnit(obj, {});
    },
    string: function string(name162) {
      var obj = {};
      obj[name162] = {};
      return Unit.createUnit(obj, {});
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/acos.js
var name162 = "acos";
var dependencies162 = ["typed", "config", "Complex"];
var createAcos = factory(name162, dependencies162, (_ref) => {
  var {
    typed,
    config: config6,
    Complex: Complex2
  } = _ref;
  return typed(name162, {
    number: function number(x) {
      if (x >= -1 && x <= 1 || config6.predictable) {
        return Math.acos(x);
      } else {
        return new Complex2(x, 0).acos();
      }
    },
    Complex: function Complex(x) {
      return x.acos();
    },
    BigNumber: function BigNumber(x) {
      return x.acos();
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/acosh.js
var name163 = "acosh";
var dependencies163 = ["typed", "config", "Complex"];
var createAcosh = factory(name163, dependencies163, (_ref) => {
  var {
    typed,
    config: config6,
    Complex: Complex2
  } = _ref;
  return typed(name163, {
    number: function number(x) {
      if (x >= 1 || config6.predictable) {
        return acoshNumber(x);
      }
      if (x <= -1) {
        return new Complex2(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);
      }
      return new Complex2(x, 0).acosh();
    },
    Complex: function Complex(x) {
      return x.acosh();
    },
    BigNumber: function BigNumber(x) {
      return x.acosh();
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/acot.js
var name164 = "acot";
var dependencies164 = ["typed", "BigNumber"];
var createAcot = factory(name164, dependencies164, (_ref) => {
  var {
    typed,
    BigNumber: _BigNumber
  } = _ref;
  return typed(name164, {
    number: acotNumber,
    Complex: function Complex(x) {
      return x.acot();
    },
    BigNumber: function BigNumber(x) {
      return new _BigNumber(1).div(x).atan();
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/acoth.js
var name165 = "acoth";
var dependencies165 = ["typed", "config", "Complex", "BigNumber"];
var createAcoth = factory(name165, dependencies165, (_ref) => {
  var {
    typed,
    config: config6,
    Complex: Complex2,
    BigNumber: _BigNumber
  } = _ref;
  return typed(name165, {
    number: function number(x) {
      if (x >= 1 || x <= -1 || config6.predictable) {
        return acothNumber(x);
      }
      return new Complex2(x, 0).acoth();
    },
    Complex: function Complex(x) {
      return x.acoth();
    },
    BigNumber: function BigNumber(x) {
      return new _BigNumber(1).div(x).atanh();
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/acsc.js
var name166 = "acsc";
var dependencies166 = ["typed", "config", "Complex", "BigNumber"];
var createAcsc = factory(name166, dependencies166, (_ref) => {
  var {
    typed,
    config: config6,
    Complex: Complex2,
    BigNumber: _BigNumber
  } = _ref;
  return typed(name166, {
    number: function number(x) {
      if (x <= -1 || x >= 1 || config6.predictable) {
        return acscNumber(x);
      }
      return new Complex2(x, 0).acsc();
    },
    Complex: function Complex(x) {
      return x.acsc();
    },
    BigNumber: function BigNumber(x) {
      return new _BigNumber(1).div(x).asin();
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/acsch.js
var name167 = "acsch";
var dependencies167 = ["typed", "BigNumber"];
var createAcsch = factory(name167, dependencies167, (_ref) => {
  var {
    typed,
    BigNumber: _BigNumber
  } = _ref;
  return typed(name167, {
    number: acschNumber,
    Complex: function Complex(x) {
      return x.acsch();
    },
    BigNumber: function BigNumber(x) {
      return new _BigNumber(1).div(x).asinh();
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/asec.js
var name168 = "asec";
var dependencies168 = ["typed", "config", "Complex", "BigNumber"];
var createAsec = factory(name168, dependencies168, (_ref) => {
  var {
    typed,
    config: config6,
    Complex: Complex2,
    BigNumber: _BigNumber
  } = _ref;
  return typed(name168, {
    number: function number(x) {
      if (x <= -1 || x >= 1 || config6.predictable) {
        return asecNumber(x);
      }
      return new Complex2(x, 0).asec();
    },
    Complex: function Complex(x) {
      return x.asec();
    },
    BigNumber: function BigNumber(x) {
      return new _BigNumber(1).div(x).acos();
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/asech.js
var name169 = "asech";
var dependencies169 = ["typed", "config", "Complex", "BigNumber"];
var createAsech = factory(name169, dependencies169, (_ref) => {
  var {
    typed,
    config: config6,
    Complex: Complex2,
    BigNumber: _BigNumber
  } = _ref;
  return typed(name169, {
    number: function number(x) {
      if (x <= 1 && x >= -1 || config6.predictable) {
        var xInv = 1 / x;
        if (xInv > 0 || config6.predictable) {
          return asechNumber(x);
        }
        var ret = Math.sqrt(xInv * xInv - 1);
        return new Complex2(Math.log(ret - xInv), Math.PI);
      }
      return new Complex2(x, 0).asech();
    },
    Complex: function Complex(x) {
      return x.asech();
    },
    BigNumber: function BigNumber(x) {
      return new _BigNumber(1).div(x).acosh();
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/asin.js
var name170 = "asin";
var dependencies170 = ["typed", "config", "Complex"];
var createAsin = factory(name170, dependencies170, (_ref) => {
  var {
    typed,
    config: config6,
    Complex: Complex2
  } = _ref;
  return typed(name170, {
    number: function number(x) {
      if (x >= -1 && x <= 1 || config6.predictable) {
        return Math.asin(x);
      } else {
        return new Complex2(x, 0).asin();
      }
    },
    Complex: function Complex(x) {
      return x.asin();
    },
    BigNumber: function BigNumber(x) {
      return x.asin();
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/asinh.js
var name171 = "asinh";
var dependencies171 = ["typed"];
var createAsinh = factory(name171, dependencies171, (_ref) => {
  var {
    typed
  } = _ref;
  return typed("asinh", {
    number: asinhNumber,
    Complex: function Complex(x) {
      return x.asinh();
    },
    BigNumber: function BigNumber(x) {
      return x.asinh();
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/atan.js
var name172 = "atan";
var dependencies172 = ["typed"];
var createAtan = factory(name172, dependencies172, (_ref) => {
  var {
    typed
  } = _ref;
  return typed("atan", {
    number: function number(x) {
      return Math.atan(x);
    },
    Complex: function Complex(x) {
      return x.atan();
    },
    BigNumber: function BigNumber(x) {
      return x.atan();
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/atan2.js
var name173 = "atan2";
var dependencies173 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix", "concat"];
var createAtan2 = factory(name173, dependencies173, (_ref) => {
  var {
    typed,
    matrix,
    equalScalar,
    BigNumber,
    DenseMatrix,
    concat
  } = _ref;
  var matAlgo02xDS012 = createMatAlgo02xDS0({
    typed,
    equalScalar
  });
  var matAlgo03xDSf16 = createMatAlgo03xDSf({
    typed
  });
  var matAlgo09xS0Sf3 = createMatAlgo09xS0Sf({
    typed,
    equalScalar
  });
  var matAlgo11xS0s17 = createMatAlgo11xS0s({
    typed,
    equalScalar
  });
  var matAlgo12xSfs20 = createMatAlgo12xSfs({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite28 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name173, {
    "number, number": Math.atan2,
    "BigNumber, BigNumber": (y, x) => BigNumber.atan2(y, x)
  }, matrixAlgorithmSuite28({
    scalar: "number | BigNumber",
    SS: matAlgo09xS0Sf3,
    DS: matAlgo03xDSf16,
    SD: matAlgo02xDS012,
    Ss: matAlgo11xS0s17,
    sS: matAlgo12xSfs20
  }));
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/atanh.js
var name174 = "atanh";
var dependencies174 = ["typed", "config", "Complex"];
var createAtanh = factory(name174, dependencies174, (_ref) => {
  var {
    typed,
    config: config6,
    Complex: Complex2
  } = _ref;
  return typed(name174, {
    number: function number(x) {
      if (x <= 1 && x >= -1 || config6.predictable) {
        return atanhNumber(x);
      }
      return new Complex2(x, 0).atanh();
    },
    Complex: function Complex(x) {
      return x.atanh();
    },
    BigNumber: function BigNumber(x) {
      return x.atanh();
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js
var createTrigUnit = factory("trigUnit", ["typed"], (_ref) => {
  var {
    typed
  } = _ref;
  return {
    Unit: typed.referToSelf((self2) => (x) => {
      if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
        throw new TypeError("Unit in function cot is no angle");
      }
      return typed.find(self2, x.valueType())(x.value);
    })
  };
});

// ../../node_modules/mathjs/lib/esm/function/trigonometry/cos.js
var name175 = "cos";
var dependencies175 = ["typed"];
var createCos = factory(name175, dependencies175, (_ref) => {
  var {
    typed
  } = _ref;
  var trigUnit2 = createTrigUnit({
    typed
  });
  return typed(name175, {
    number: Math.cos,
    "Complex | BigNumber": (x) => x.cos()
  }, trigUnit2);
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/cosh.js
var name176 = "cosh";
var dependencies176 = ["typed"];
var createCosh = factory(name176, dependencies176, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name176, {
    number: cosh,
    "Complex | BigNumber": (x) => x.cosh()
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/cot.js
var name177 = "cot";
var dependencies177 = ["typed", "BigNumber"];
var createCot = factory(name177, dependencies177, (_ref) => {
  var {
    typed,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit3 = createTrigUnit({
    typed
  });
  return typed(name177, {
    number: cotNumber,
    Complex: (x) => x.cot(),
    BigNumber: (x) => new _BigNumber(1).div(x.tan())
  }, trigUnit3);
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/coth.js
var name178 = "coth";
var dependencies178 = ["typed", "BigNumber"];
var createCoth = factory(name178, dependencies178, (_ref) => {
  var {
    typed,
    BigNumber: _BigNumber
  } = _ref;
  return typed(name178, {
    number: cothNumber,
    Complex: (x) => x.coth(),
    BigNumber: (x) => new _BigNumber(1).div(x.tanh())
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/csc.js
var name179 = "csc";
var dependencies179 = ["typed", "BigNumber"];
var createCsc = factory(name179, dependencies179, (_ref) => {
  var {
    typed,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit4 = createTrigUnit({
    typed
  });
  return typed(name179, {
    number: cscNumber,
    Complex: (x) => x.csc(),
    BigNumber: (x) => new _BigNumber(1).div(x.sin())
  }, trigUnit4);
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/csch.js
var name180 = "csch";
var dependencies180 = ["typed", "BigNumber"];
var createCsch = factory(name180, dependencies180, (_ref) => {
  var {
    typed,
    BigNumber: _BigNumber
  } = _ref;
  return typed(name180, {
    number: cschNumber,
    Complex: (x) => x.csch(),
    BigNumber: (x) => new _BigNumber(1).div(x.sinh())
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/sec.js
var name181 = "sec";
var dependencies181 = ["typed", "BigNumber"];
var createSec = factory(name181, dependencies181, (_ref) => {
  var {
    typed,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit5 = createTrigUnit({
    typed
  });
  return typed(name181, {
    number: secNumber,
    Complex: (x) => x.sec(),
    BigNumber: (x) => new _BigNumber(1).div(x.cos())
  }, trigUnit5);
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/sech.js
var name182 = "sech";
var dependencies182 = ["typed", "BigNumber"];
var createSech = factory(name182, dependencies182, (_ref) => {
  var {
    typed,
    BigNumber: _BigNumber
  } = _ref;
  return typed(name182, {
    number: sechNumber,
    Complex: (x) => x.sech(),
    BigNumber: (x) => new _BigNumber(1).div(x.cosh())
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/sin.js
var name183 = "sin";
var dependencies183 = ["typed"];
var createSin = factory(name183, dependencies183, (_ref) => {
  var {
    typed
  } = _ref;
  var trigUnit6 = createTrigUnit({
    typed
  });
  return typed(name183, {
    number: Math.sin,
    "Complex | BigNumber": (x) => x.sin()
  }, trigUnit6);
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/sinh.js
var name184 = "sinh";
var dependencies184 = ["typed"];
var createSinh = factory(name184, dependencies184, (_ref) => {
  var {
    typed
  } = _ref;
  return typed(name184, {
    number: sinhNumber,
    "Complex | BigNumber": (x) => x.sinh()
  });
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/tan.js
var name185 = "tan";
var dependencies185 = ["typed"];
var createTan = factory(name185, dependencies185, (_ref) => {
  var {
    typed
  } = _ref;
  var trigUnit7 = createTrigUnit({
    typed
  });
  return typed(name185, {
    number: Math.tan,
    "Complex | BigNumber": (x) => x.tan()
  }, trigUnit7);
});
// ../../node_modules/mathjs/lib/esm/function/trigonometry/tanh.js
var name186 = "tanh";
var dependencies186 = ["typed"];
var createTanh = factory(name186, dependencies186, (_ref) => {
  var {
    typed
  } = _ref;
  return typed("tanh", {
    number: tanh,
    "Complex | BigNumber": (x) => x.tanh()
  });
});
// ../../node_modules/mathjs/lib/esm/function/set/setCartesian.js
var name187 = "setCartesian";
var dependencies187 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetCartesian = factory(name187, dependencies187, (_ref) => {
  var {
    typed,
    size,
    subset,
    compareNatural,
    Index,
    DenseMatrix
  } = _ref;
  return typed(name187, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result = [];
      if (subset(size(a1), new Index(0)) !== 0 && subset(size(a2), new Index(0)) !== 0) {
        var b1 = flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural);
        var b2 = flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural);
        result = [];
        for (var i = 0;i < b1.length; i++) {
          for (var j = 0;j < b2.length; j++) {
            result.push([b1[i], b2[j]]);
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return result;
      }
      return new DenseMatrix(result);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/set/setDifference.js
var name188 = "setDifference";
var dependencies188 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetDifference = factory(name188, dependencies188, (_ref) => {
  var {
    typed,
    size,
    subset,
    compareNatural,
    Index,
    DenseMatrix
  } = _ref;
  return typed(name188, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result;
      if (subset(size(a1), new Index(0)) === 0) {
        result = [];
      } else if (subset(size(a2), new Index(0)) === 0) {
        return flatten(a1.toArray());
      } else {
        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
        result = [];
        var inb2;
        for (var i = 0;i < b1.length; i++) {
          inb2 = false;
          for (var j = 0;j < b2.length; j++) {
            if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
              inb2 = true;
              break;
            }
          }
          if (!inb2) {
            result.push(b1[i]);
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return generalize(result);
      }
      return new DenseMatrix(generalize(result));
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/set/setDistinct.js
var name189 = "setDistinct";
var dependencies189 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetDistinct = factory(name189, dependencies189, (_ref) => {
  var {
    typed,
    size,
    subset,
    compareNatural,
    Index,
    DenseMatrix
  } = _ref;
  return typed(name189, {
    "Array | Matrix": function ArrayMatrix(a) {
      var result;
      if (subset(size(a), new Index(0)) === 0) {
        result = [];
      } else {
        var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
        result = [];
        result.push(b[0]);
        for (var i = 1;i < b.length; i++) {
          if (compareNatural(b[i], b[i - 1]) !== 0) {
            result.push(b[i]);
          }
        }
      }
      if (Array.isArray(a)) {
        return result;
      }
      return new DenseMatrix(result);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/set/setIntersect.js
var name190 = "setIntersect";
var dependencies190 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetIntersect = factory(name190, dependencies190, (_ref) => {
  var {
    typed,
    size,
    subset,
    compareNatural,
    Index,
    DenseMatrix
  } = _ref;
  return typed(name190, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result;
      if (subset(size(a1), new Index(0)) === 0 || subset(size(a2), new Index(0)) === 0) {
        result = [];
      } else {
        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
        result = [];
        for (var i = 0;i < b1.length; i++) {
          for (var j = 0;j < b2.length; j++) {
            if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
              result.push(b1[i]);
              break;
            }
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return generalize(result);
      }
      return new DenseMatrix(generalize(result));
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/set/setIsSubset.js
var name191 = "setIsSubset";
var dependencies191 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetIsSubset = factory(name191, dependencies191, (_ref) => {
  var {
    typed,
    size,
    subset,
    compareNatural,
    Index
  } = _ref;
  return typed(name191, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset(size(a1), new Index(0)) === 0) {
        return true;
      } else if (subset(size(a2), new Index(0)) === 0) {
        return false;
      }
      var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
      var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
      var inb2;
      for (var i = 0;i < b1.length; i++) {
        inb2 = false;
        for (var j = 0;j < b2.length; j++) {
          if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
            inb2 = true;
            break;
          }
        }
        if (inb2 === false) {
          return false;
        }
      }
      return true;
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/set/setMultiplicity.js
var name192 = "setMultiplicity";
var dependencies192 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetMultiplicity = factory(name192, dependencies192, (_ref) => {
  var {
    typed,
    size,
    subset,
    compareNatural,
    Index
  } = _ref;
  return typed(name192, {
    "number | BigNumber | Fraction | Complex, Array | Matrix": function numberBigNumberFractionComplexArrayMatrix(e2, a) {
      if (subset(size(a), new Index(0)) === 0) {
        return 0;
      }
      var b = flatten(Array.isArray(a) ? a : a.toArray());
      var count = 0;
      for (var i = 0;i < b.length; i++) {
        if (compareNatural(b[i], e2) === 0) {
          count++;
        }
      }
      return count;
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/set/setPowerset.js
var name193 = "setPowerset";
var dependencies193 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetPowerset = factory(name193, dependencies193, (_ref) => {
  var {
    typed,
    size,
    subset,
    compareNatural,
    Index
  } = _ref;
  return typed(name193, {
    "Array | Matrix": function ArrayMatrix(a) {
      if (subset(size(a), new Index(0)) === 0) {
        return [];
      }
      var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
      var result = [];
      var number91 = 0;
      while (number91.toString(2).length <= b.length) {
        result.push(_subset(b, number91.toString(2).split("").reverse()));
        number91++;
      }
      return _sort(result);
    }
  });
  function _subset(array38, bitarray) {
    var result = [];
    for (var i = 0;i < bitarray.length; i++) {
      if (bitarray[i] === "1") {
        result.push(array38[i]);
      }
    }
    return result;
  }
  function _sort(array38) {
    var temp = [];
    for (var i = array38.length - 1;i > 0; i--) {
      for (var j = 0;j < i; j++) {
        if (array38[j].length > array38[j + 1].length) {
          temp = array38[j];
          array38[j] = array38[j + 1];
          array38[j + 1] = temp;
        }
      }
    }
    return array38;
  }
});
// ../../node_modules/mathjs/lib/esm/function/set/setSize.js
var name194 = "setSize";
var dependencies194 = ["typed", "compareNatural"];
var createSetSize = factory(name194, dependencies194, (_ref) => {
  var {
    typed,
    compareNatural
  } = _ref;
  return typed(name194, {
    "Array | Matrix": function ArrayMatrix(a) {
      return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
    },
    "Array | Matrix, boolean": function ArrayMatrixBoolean(a, unique) {
      if (unique === false || a.length === 0) {
        return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
      } else {
        var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
        var count = 1;
        for (var i = 1;i < b.length; i++) {
          if (compareNatural(b[i], b[i - 1]) !== 0) {
            count++;
          }
        }
        return count;
      }
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/set/setSymDifference.js
var name195 = "setSymDifference";
var dependencies195 = ["typed", "size", "concat", "subset", "setDifference", "Index"];
var createSetSymDifference = factory(name195, dependencies195, (_ref) => {
  var {
    typed,
    size,
    concat,
    subset,
    setDifference,
    Index
  } = _ref;
  return typed(name195, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset(size(a1), new Index(0)) === 0) {
        return flatten(a2);
      } else if (subset(size(a2), new Index(0)) === 0) {
        return flatten(a1);
      }
      var b1 = flatten(a1);
      var b2 = flatten(a2);
      return concat(setDifference(b1, b2), setDifference(b2, b1));
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/set/setUnion.js
var name196 = "setUnion";
var dependencies196 = ["typed", "size", "concat", "subset", "setIntersect", "setSymDifference", "Index"];
var createSetUnion = factory(name196, dependencies196, (_ref) => {
  var {
    typed,
    size,
    concat,
    subset,
    setIntersect,
    setSymDifference,
    Index
  } = _ref;
  return typed(name196, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset(size(a1), new Index(0)) === 0) {
        return flatten(a2);
      } else if (subset(size(a2), new Index(0)) === 0) {
        return flatten(a1);
      }
      var b1 = flatten(a1);
      var b2 = flatten(a2);
      return concat(setSymDifference(b1, b2), setIntersect(b1, b2));
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/add.js
var name197 = "add";
var dependencies197 = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix", "concat"];
var createAdd = factory(name197, dependencies197, (_ref) => {
  var {
    typed,
    matrix,
    addScalar,
    equalScalar,
    DenseMatrix,
    SparseMatrix,
    concat
  } = _ref;
  var matAlgo01xDSid9 = createMatAlgo01xDSid({
    typed
  });
  var matAlgo04xSidSid4 = createMatAlgo04xSidSid({
    typed,
    equalScalar
  });
  var matAlgo10xSids8 = createMatAlgo10xSids({
    typed,
    DenseMatrix
  });
  var matrixAlgorithmSuite29 = createMatrixAlgorithmSuite({
    typed,
    matrix,
    concat
  });
  return typed(name197, {
    "any, any": addScalar,
    "any, any, ...any": typed.referToSelf((self2) => (x, y, rest) => {
      var result = self2(x, y);
      for (var i = 0;i < rest.length; i++) {
        result = self2(result, rest[i]);
      }
      return result;
    })
  }, matrixAlgorithmSuite29({
    elop: addScalar,
    DS: matAlgo01xDSid9,
    SS: matAlgo04xSidSid4,
    Ss: matAlgo10xSids8
  }));
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/hypot.js
var name198 = "hypot";
var dependencies198 = ["typed", "abs", "addScalar", "divideScalar", "multiplyScalar", "sqrt", "smaller", "isPositive"];
var createHypot = factory(name198, dependencies198, (_ref) => {
  var {
    typed,
    abs: abs2,
    addScalar,
    divideScalar,
    multiplyScalar,
    sqrt: sqrt2,
    smaller,
    isPositive
  } = _ref;
  return typed(name198, {
    "... number | BigNumber": _hypot,
    Array: _hypot,
    Matrix: (M) => _hypot(flatten(M.toArray()))
  });
  function _hypot(args) {
    var result = 0;
    var largest = 0;
    for (var i = 0;i < args.length; i++) {
      if (isComplex(args[i])) {
        throw new TypeError("Unexpected type of argument to hypot");
      }
      var value = abs2(args[i]);
      if (smaller(largest, value)) {
        result = multiplyScalar(result, multiplyScalar(divideScalar(largest, value), divideScalar(largest, value)));
        result = addScalar(result, 1);
        largest = value;
      } else {
        result = addScalar(result, isPositive(value) ? multiplyScalar(divideScalar(value, largest), divideScalar(value, largest)) : value);
      }
    }
    return multiplyScalar(largest, sqrt2(result));
  }
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/norm.js
var name199 = "norm";
var dependencies199 = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"];
var createNorm = factory(name199, dependencies199, (_ref) => {
  var {
    typed,
    abs: abs2,
    add: add2,
    pow: pow2,
    conj,
    sqrt: sqrt2,
    multiply,
    equalScalar,
    larger,
    smaller,
    matrix,
    ctranspose,
    eigs
  } = _ref;
  return typed(name199, {
    number: Math.abs,
    Complex: function Complex(x) {
      return x.abs();
    },
    BigNumber: function BigNumber(x) {
      return x.abs();
    },
    boolean: function boolean(x) {
      return Math.abs(x);
    },
    Array: function Array(x) {
      return _norm(matrix(x), 2);
    },
    Matrix: function Matrix(x) {
      return _norm(x, 2);
    },
    "Array, number | BigNumber | string": function ArrayNumberBigNumberString(x, p) {
      return _norm(matrix(x), p);
    },
    "Matrix, number | BigNumber | string": function MatrixNumberBigNumberString(x, p) {
      return _norm(x, p);
    }
  });
  function _vectorNormPlusInfinity(x) {
    var pinf = 0;
    x.forEach(function(value) {
      var v = abs2(value);
      if (larger(v, pinf)) {
        pinf = v;
      }
    }, true);
    return pinf;
  }
  function _vectorNormMinusInfinity(x) {
    var ninf;
    x.forEach(function(value) {
      var v = abs2(value);
      if (!ninf || smaller(v, ninf)) {
        ninf = v;
      }
    }, true);
    return ninf || 0;
  }
  function _vectorNorm(x, p) {
    if (p === Number.POSITIVE_INFINITY || p === "inf") {
      return _vectorNormPlusInfinity(x);
    }
    if (p === Number.NEGATIVE_INFINITY || p === "-inf") {
      return _vectorNormMinusInfinity(x);
    }
    if (p === "fro") {
      return _norm(x, 2);
    }
    if (typeof p === "number" && !isNaN(p)) {
      if (!equalScalar(p, 0)) {
        var n = 0;
        x.forEach(function(value) {
          n = add2(pow2(abs2(value), p), n);
        }, true);
        return pow2(n, 1 / p);
      }
      return Number.POSITIVE_INFINITY;
    }
    throw new Error("Unsupported parameter value");
  }
  function _matrixNormFrobenius(x) {
    var fro = 0;
    x.forEach(function(value, index) {
      fro = add2(fro, multiply(value, conj(value)));
    });
    return abs2(sqrt2(fro));
  }
  function _matrixNormOne(x) {
    var c = [];
    var maxc = 0;
    x.forEach(function(value, index) {
      var j = index[1];
      var cj = add2(c[j] || 0, abs2(value));
      if (larger(cj, maxc)) {
        maxc = cj;
      }
      c[j] = cj;
    }, true);
    return maxc;
  }
  function _matrixNormTwo(x) {
    var sizeX = x.size();
    if (sizeX[0] !== sizeX[1]) {
      throw new RangeError("Invalid matrix dimensions");
    }
    var tx = ctranspose(x);
    var squaredX = multiply(tx, x);
    var eigenVals = eigs(squaredX).values.toArray();
    var rho = eigenVals[eigenVals.length - 1];
    return abs2(sqrt2(rho));
  }
  function _matrixNormInfinity(x) {
    var r = [];
    var maxr = 0;
    x.forEach(function(value, index) {
      var i = index[0];
      var ri = add2(r[i] || 0, abs2(value));
      if (larger(ri, maxr)) {
        maxr = ri;
      }
      r[i] = ri;
    }, true);
    return maxr;
  }
  function _matrixNorm(x, p) {
    if (p === 1) {
      return _matrixNormOne(x);
    }
    if (p === Number.POSITIVE_INFINITY || p === "inf") {
      return _matrixNormInfinity(x);
    }
    if (p === "fro") {
      return _matrixNormFrobenius(x);
    }
    if (p === 2) {
      return _matrixNormTwo(x);
    }
    throw new Error("Unsupported parameter value " + p);
  }
  function _norm(x, p) {
    var sizeX = x.size();
    if (sizeX.length === 1) {
      return _vectorNorm(x, p);
    }
    if (sizeX.length === 2) {
      if (sizeX[0] && sizeX[1]) {
        return _matrixNorm(x, p);
      } else {
        throw new RangeError("Invalid matrix dimensions");
      }
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/dot.js
var name200 = "dot";
var dependencies200 = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
var createDot = factory(name200, dependencies200, (_ref) => {
  var {
    typed,
    addScalar,
    multiplyScalar,
    conj,
    size
  } = _ref;
  return typed(name200, {
    "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
    "SparseMatrix, SparseMatrix": _sparseDot
  });
  function _validateDim(x, y) {
    var xSize = _size(x);
    var ySize = _size(y);
    var xLen, yLen;
    if (xSize.length === 1) {
      xLen = xSize[0];
    } else if (xSize.length === 2 && xSize[1] === 1) {
      xLen = xSize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
    }
    if (ySize.length === 1) {
      yLen = ySize[0];
    } else if (ySize.length === 2 && ySize[1] === 1) {
      yLen = ySize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
    }
    if (xLen !== yLen)
      throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
    if (xLen === 0)
      throw new RangeError("Cannot calculate the dot product of empty vectors");
    return xLen;
  }
  function _denseDot(a, b) {
    var N = _validateDim(a, b);
    var adata = isMatrix(a) ? a._data : a;
    var adt = isMatrix(a) ? a._datatype : undefined;
    var bdata = isMatrix(b) ? b._data : b;
    var bdt = isMatrix(b) ? b._datatype : undefined;
    var aIsColumn = _size(a).length === 2;
    var bIsColumn = _size(b).length === 2;
    var add2 = addScalar;
    var mul2 = multiplyScalar;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      var dt = adt;
      add2 = typed.find(addScalar, [dt, dt]);
      mul2 = typed.find(multiplyScalar, [dt, dt]);
    }
    if (!aIsColumn && !bIsColumn) {
      var c = mul2(conj(adata[0]), bdata[0]);
      for (var i = 1;i < N; i++) {
        c = add2(c, mul2(conj(adata[i]), bdata[i]));
      }
      return c;
    }
    if (!aIsColumn && bIsColumn) {
      var _c = mul2(conj(adata[0]), bdata[0][0]);
      for (var _i = 1;_i < N; _i++) {
        _c = add2(_c, mul2(conj(adata[_i]), bdata[_i][0]));
      }
      return _c;
    }
    if (aIsColumn && !bIsColumn) {
      var _c2 = mul2(conj(adata[0][0]), bdata[0]);
      for (var _i2 = 1;_i2 < N; _i2++) {
        _c2 = add2(_c2, mul2(conj(adata[_i2][0]), bdata[_i2]));
      }
      return _c2;
    }
    if (aIsColumn && bIsColumn) {
      var _c3 = mul2(conj(adata[0][0]), bdata[0][0]);
      for (var _i3 = 1;_i3 < N; _i3++) {
        _c3 = add2(_c3, mul2(conj(adata[_i3][0]), bdata[_i3][0]));
      }
      return _c3;
    }
  }
  function _sparseDot(x, y) {
    _validateDim(x, y);
    var xindex = x._index;
    var xvalues = x._values;
    var yindex = y._index;
    var yvalues = y._values;
    var c = 0;
    var add2 = addScalar;
    var mul2 = multiplyScalar;
    var i = 0;
    var j = 0;
    while (i < xindex.length && j < yindex.length) {
      var I = xindex[i];
      var J = yindex[j];
      if (I < J) {
        i++;
        continue;
      }
      if (I > J) {
        j++;
        continue;
      }
      if (I === J) {
        c = add2(c, mul2(xvalues[i], yvalues[j]));
        i++;
        j++;
      }
    }
    return c;
  }
  function _size(x) {
    return isMatrix(x) ? x.size() : size(x);
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/trace.js
var name201 = "trace";
var dependencies201 = ["typed", "matrix", "add"];
var createTrace = factory(name201, dependencies201, (_ref) => {
  var {
    typed,
    matrix,
    add: add2
  } = _ref;
  return typed("trace", {
    Array: function _arrayTrace(x) {
      return _denseTrace(matrix(x));
    },
    SparseMatrix: _sparseTrace,
    DenseMatrix: _denseTrace,
    any: clone
  });
  function _denseTrace(m) {
    var size = m._size;
    var data = m._data;
    switch (size.length) {
      case 1:
        if (size[0] === 1) {
          return clone(data[0]);
        }
        throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
      case 2: {
        var rows = size[0];
        var cols = size[1];
        if (rows === cols) {
          var sum2 = 0;
          for (var i = 0;i < rows; i++) {
            sum2 = add2(sum2, data[i][i]);
          }
          return sum2;
        } else {
          throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
        }
      }
      default:
        throw new RangeError("Matrix must be two dimensional (size: " + format3(size) + ")");
    }
  }
  function _sparseTrace(m) {
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var size = m._size;
    var rows = size[0];
    var columns = size[1];
    if (rows === columns) {
      var sum2 = 0;
      if (values.length > 0) {
        for (var j = 0;j < columns; j++) {
          var k0 = ptr[j];
          var k1 = ptr[j + 1];
          for (var k = k0;k < k1; k++) {
            var i = index[k];
            if (i === j) {
              sum2 = add2(sum2, values[k]);
              break;
            }
            if (i > j) {
              break;
            }
          }
        }
      }
      return sum2;
    }
    throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
  }
});
// ../../node_modules/mathjs/lib/esm/type/matrix/function/index.js
var name202 = "index";
var dependencies202 = ["typed", "Index"];
var createIndex = factory(name202, dependencies202, (_ref) => {
  var {
    typed,
    Index
  } = _ref;
  return typed(name202, {
    "...number | string | BigNumber | Range | Array | Matrix": function numberStringBigNumberRangeArrayMatrix(args) {
      var ranges = args.map(function(arg) {
        if (isBigNumber(arg)) {
          return arg.toNumber();
        } else if (Array.isArray(arg) || isMatrix(arg)) {
          return arg.map(function(elem) {
            return isBigNumber(elem) ? elem.toNumber() : elem;
          });
        } else {
          return arg;
        }
      });
      var res = new Index;
      Index.apply(res, ranges);
      return res;
    }
  });
});
// ../../node_modules/mathjs/lib/esm/expression/keywords.js
var keywords = new Set(["end"]);

// ../../node_modules/mathjs/lib/esm/expression/node/Node.js
var name203 = "Node";
var dependencies203 = ["mathWithTransform"];
var createNode = factory(name203, dependencies203, (_ref) => {
  var {
    mathWithTransform
  } = _ref;
  function _validateScope(scope) {
    for (var symbol of [...keywords]) {
      if (scope.has(symbol)) {
        throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
      }
    }
  }

  class Node {
    get type() {
      return "Node";
    }
    get isNode() {
      return true;
    }
    evaluate(scope) {
      return this.compile().evaluate(scope);
    }
    compile() {
      var expr = this._compile(mathWithTransform, {});
      var args = {};
      var context2 = null;
      function evaluate(scope) {
        var s = createMap(scope);
        _validateScope(s);
        return expr(s, args, context2);
      }
      return {
        evaluate
      };
    }
    _compile(math, argNames) {
      throw new Error("Method _compile must be implemented by type " + this.type);
    }
    forEach(callback) {
      throw new Error("Cannot run forEach on a Node interface");
    }
    map(callback) {
      throw new Error("Cannot run map on a Node interface");
    }
    _ifNode(node) {
      if (!isNode(node)) {
        throw new TypeError("Callback function must return a Node");
      }
      return node;
    }
    traverse(callback) {
      callback(this, null, null);
      function _traverse(node, callback2) {
        node.forEach(function(child, path, parent) {
          callback2(child, path, parent);
          _traverse(child, callback2);
        });
      }
      _traverse(this, callback);
    }
    transform(callback) {
      function _transform(child, path, parent) {
        var replacement = callback(child, path, parent);
        if (replacement !== child) {
          return replacement;
        }
        return child.map(_transform);
      }
      return _transform(this, null, null);
    }
    filter(callback) {
      var nodes = [];
      this.traverse(function(node, path, parent) {
        if (callback(node, path, parent)) {
          nodes.push(node);
        }
      });
      return nodes;
    }
    clone() {
      throw new Error("Cannot clone a Node interface");
    }
    cloneDeep() {
      return this.map(function(node) {
        return node.cloneDeep();
      });
    }
    equals(other) {
      return other ? this.type === other.type && deepStrictEqual(this, other) : false;
    }
    toString(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toString(options);
    }
    toJSON() {
      throw new Error("Cannot serialize object: toJSON not implemented by " + this.type);
    }
    toHTML(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this.toHTML(options);
    }
    _toString() {
      throw new Error("_toString not implemented for " + this.type);
    }
    toTex(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toTex(options);
    }
    _toTex(options) {
      throw new Error("_toTex not implemented for " + this.type);
    }
    _getCustomString(options) {
      if (options && typeof options === "object") {
        switch (typeof options.handler) {
          case "object":
          case "undefined":
            return;
          case "function":
            return options.handler(this, options);
          default:
            throw new TypeError("Object or function expected as callback");
        }
      }
    }
    getIdentifier() {
      return this.type;
    }
    getContent() {
      return this;
    }
  }
  return Node;
}, {
  isClass: true,
  isNode: true
});
// ../../node_modules/mathjs/lib/esm/expression/node/AccessorNode.js
var defineProperty2 = __toESM(require_defineProperty(), 1);

// ../../node_modules/mathjs/lib/esm/expression/transform/utils/errorTransform.js
function errorTransform(err) {
  if (err && err.isIndexError) {
    return new IndexError(err.index + 1, err.min + 1, err.max !== undefined ? err.max + 1 : undefined);
  }
  return err;
}

// ../../node_modules/mathjs/lib/esm/expression/node/utils/access.js
function accessFactory(_ref) {
  var {
    subset
  } = _ref;
  return function access(object20, index) {
    try {
      if (Array.isArray(object20)) {
        return subset(object20, index);
      } else if (object20 && typeof object20.subset === "function") {
        return object20.subset(index);
      } else if (typeof object20 === "string") {
        return subset(object20, index);
      } else if (typeof object20 === "object") {
        if (!index.isObjectProperty()) {
          throw new TypeError("Cannot apply a numeric index as object property");
        }
        return getSafeProperty(object20, index.getObjectProperty());
      } else {
        throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (err) {
      throw errorTransform(err);
    }
  };
}

// ../../node_modules/mathjs/lib/esm/expression/node/AccessorNode.js
var name204 = "AccessorNode";
var dependencies204 = ["subset", "Node"];
var createAccessorNode = factory(name204, dependencies204, (_ref) => {
  var {
    subset,
    Node
  } = _ref;
  var access2 = accessFactory({
    subset
  });
  function needParenthesis(node) {
    return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));
  }

  class AccessorNode extends Node {
    constructor(object20, index) {
      super();
      if (!isNode(object20)) {
        throw new TypeError('Node expected for parameter "object"');
      }
      if (!isIndexNode(index)) {
        throw new TypeError('IndexNode expected for parameter "index"');
      }
      this.object = object20;
      this.index = index;
    }
    get name() {
      if (this.index) {
        return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
      } else {
        return this.object.name || "";
      }
    }
    get type() {
      return name204;
    }
    get isAccessorNode() {
      return true;
    }
    _compile(math, argNames) {
      var evalObject = this.object._compile(math, argNames);
      var evalIndex = this.index._compile(math, argNames);
      if (this.index.isObjectProperty()) {
        var prop = this.index.getObjectProperty();
        return function evalAccessorNode(scope, args, context2) {
          return getSafeProperty(evalObject(scope, args, context2), prop);
        };
      } else {
        return function evalAccessorNode(scope, args, context2) {
          var object20 = evalObject(scope, args, context2);
          var index = evalIndex(scope, args, object20);
          return access2(object20, index);
        };
      }
    }
    forEach(callback) {
      callback(this.object, "object", this);
      callback(this.index, "index", this);
    }
    map(callback) {
      return new AccessorNode(this._ifNode(callback(this.object, "object", this)), this._ifNode(callback(this.index, "index", this)));
    }
    clone() {
      return new AccessorNode(this.object, this.index);
    }
    _toString(options) {
      var object20 = this.object.toString(options);
      if (needParenthesis(this.object)) {
        object20 = "(" + object20 + ")";
      }
      return object20 + this.index.toString(options);
    }
    toHTML(options) {
      var object20 = this.object.toHTML(options);
      if (needParenthesis(this.object)) {
        object20 = '<span class="math-parenthesis math-round-parenthesis">(</span>' + object20 + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return object20 + this.index.toHTML(options);
    }
    _toTex(options) {
      var object20 = this.object.toTex(options);
      if (needParenthesis(this.object)) {
        object20 = "\\left(\' + object + \'\\right)";
      }
      return object20 + this.index.toTex(options);
    }
    toJSON() {
      return {
        mathjs: name204,
        object: this.object,
        index: this.index
      };
    }
    static fromJSON(json) {
      return new AccessorNode(json.object, json.index);
    }
  }
  defineProperty2.default(AccessorNode, "name", name204);
  return AccessorNode;
}, {
  isClass: true,
  isNode: true
});
// ../../node_modules/mathjs/lib/esm/expression/node/ArrayNode.js
var defineProperty3 = __toESM(require_defineProperty(), 1);
var name205 = "ArrayNode";
var dependencies205 = ["Node"];
var createArrayNode = factory(name205, dependencies205, (_ref) => {
  var {
    Node
  } = _ref;

  class ArrayNode extends Node {
    constructor(items) {
      super();
      this.items = items || [];
      if (!Array.isArray(this.items) || !this.items.every(isNode)) {
        throw new TypeError("Array containing Nodes expected");
      }
    }
    get type() {
      return name205;
    }
    get isArrayNode() {
      return true;
    }
    _compile(math, argNames) {
      var evalItems = map(this.items, function(item) {
        return item._compile(math, argNames);
      });
      var asMatrix = math.config.matrix !== "Array";
      if (asMatrix) {
        var matrix = math.matrix;
        return function evalArrayNode(scope, args, context2) {
          return matrix(map(evalItems, function(evalItem) {
            return evalItem(scope, args, context2);
          }));
        };
      } else {
        return function evalArrayNode(scope, args, context2) {
          return map(evalItems, function(evalItem) {
            return evalItem(scope, args, context2);
          });
        };
      }
    }
    forEach(callback) {
      for (var i = 0;i < this.items.length; i++) {
        var node = this.items[i];
        callback(node, "items[" + i + "]", this);
      }
    }
    map(callback) {
      var items = [];
      for (var i = 0;i < this.items.length; i++) {
        items[i] = this._ifNode(callback(this.items[i], "items[" + i + "]", this));
      }
      return new ArrayNode(items);
    }
    clone() {
      return new ArrayNode(this.items.slice(0));
    }
    _toString(options) {
      var items = this.items.map(function(node) {
        return node.toString(options);
      });
      return "[" + items.join(", ") + "]";
    }
    toJSON() {
      return {
        mathjs: name205,
        items: this.items
      };
    }
    static fromJSON(json) {
      return new ArrayNode(json.items);
    }
    toHTML(options) {
      var items = this.items.map(function(node) {
        return node.toHTML(options);
      });
      return '<span class="math-parenthesis math-square-parenthesis">[</span>' + items.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
    }
    _toTex(options) {
      function itemsToTex(items, nested) {
        var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);
        var itemsFormRow = nested || mixedItems;
        var itemSep = itemsFormRow ? "&" : "\\\\";
        var itemsTex = items.map(function(node) {
          if (node.items) {
            return itemsToTex(node.items, !nested);
          } else {
            return node.toTex(options);
          }
        }).join(itemSep);
        return mixedItems || !itemsFormRow || itemsFormRow && !nested ? "\\begin{bmatrix}" + itemsTex + "\\end{bmatrix}" : itemsTex;
      }
      return itemsToTex(this.items, false);
    }
  }
  defineProperty3.default(ArrayNode, "name", name205);
  return ArrayNode;
}, {
  isClass: true,
  isNode: true
});
// ../../node_modules/mathjs/lib/esm/expression/node/AssignmentNode.js
var defineProperty4 = __toESM(require_defineProperty(), 1);

// ../../node_modules/mathjs/lib/esm/expression/node/utils/assign.js
function assignFactory(_ref) {
  var {
    subset,
    matrix
  } = _ref;
  return function assign(object20, index, value) {
    try {
      if (Array.isArray(object20)) {
        return matrix(object20).subset(index, value).valueOf();
      } else if (object20 && typeof object20.subset === "function") {
        return object20.subset(index, value);
      } else if (typeof object20 === "string") {
        return subset(object20, index, value);
      } else if (typeof object20 === "object") {
        if (!index.isObjectProperty()) {
          throw TypeError("Cannot apply a numeric index as object property");
        }
        setSafeProperty(object20, index.getObjectProperty(), value);
        return object20;
      } else {
        throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (err) {
      throw errorTransform(err);
    }
  };
}

// ../../node_modules/mathjs/lib/esm/expression/operators.js
var unwrapParen = function(_node, parenthesis) {
  if (!parenthesis || parenthesis !== "auto")
    return _node;
  var node = _node;
  while (isParenthesisNode(node))
    node = node.content;
  return node;
};
function getPrecedence(_node, parenthesis, implicit, parent) {
  var node = _node;
  if (parenthesis !== "keep") {
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  var precedence = null;
  for (var i = 0;i < properties.length; i++) {
    if (identifier in properties[i]) {
      precedence = i;
      break;
    }
  }
  if (identifier === "OperatorNode:multiply" && node.implicit && implicit !== "show") {
    var leftArg = unwrapParen(node.args[0], parenthesis);
    if (!(isConstantNode(leftArg) && parent && parent.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(parent.args[0], parenthesis))) && !(leftArg.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(leftArg.args[0], parenthesis)) && isConstantNode(unwrapParen(leftArg.args[1])))) {
      precedence += 1;
    }
  }
  return precedence;
}
function getAssociativity(_node, parenthesis) {
  var node = _node;
  if (parenthesis !== "keep") {
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  var index = getPrecedence(node, parenthesis);
  if (index === null) {
    return null;
  }
  var property = properties[index][identifier];
  if (hasOwnProperty2(property, "associativity")) {
    if (property.associativity === "left") {
      return "left";
    }
    if (property.associativity === "right") {
      return "right";
    }
    throw Error("\'" + identifier + "\' has the invalid associativity \'" + property.associativity + "\'.");
  }
  return null;
}
function isAssociativeWith(nodeA, nodeB, parenthesis) {
  var a = parenthesis !== "keep" ? nodeA.getContent() : nodeA;
  var b = parenthesis !== "keep" ? nodeA.getContent() : nodeB;
  var identifierA = a.getIdentifier();
  var identifierB = b.getIdentifier();
  var index = getPrecedence(a, parenthesis);
  if (index === null) {
    return null;
  }
  var property = properties[index][identifierA];
  if (hasOwnProperty2(property, "associativeWith") && property.associativeWith instanceof Array) {
    for (var i = 0;i < property.associativeWith.length; i++) {
      if (property.associativeWith[i] === identifierB) {
        return true;
      }
    }
    return false;
  }
  return null;
}
function getOperator(fn) {
  var identifier = "OperatorNode:" + fn;
  for (var group of properties) {
    if (identifier in group) {
      return group[identifier].op;
    }
  }
  return null;
}
var properties = [{
  AssignmentNode: {},
  FunctionAssignmentNode: {}
}, {
  ConditionalNode: {
    latexLeftParens: false,
    latexRightParens: false,
    latexParens: false
  }
}, {
  "OperatorNode:or": {
    op: "or",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:xor": {
    op: "xor",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:and": {
    op: "and",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:bitOr": {
    op: "|",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:bitXor": {
    op: "^|",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:bitAnd": {
    op: "&",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:equal": {
    op: "==",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:unequal": {
    op: "!=",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:smaller": {
    op: "<",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:larger": {
    op: ">",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:smallerEq": {
    op: "<=",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:largerEq": {
    op: ">=",
    associativity: "left",
    associativeWith: []
  },
  RelationalNode: {
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:leftShift": {
    op: "<<",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:rightArithShift": {
    op: ">>",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:rightLogShift": {
    op: ">>>",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:to": {
    op: "to",
    associativity: "left",
    associativeWith: []
  }
}, {
  RangeNode: {}
}, {
  "OperatorNode:add": {
    op: "+",
    associativity: "left",
    associativeWith: ["OperatorNode:add", "OperatorNode:subtract"]
  },
  "OperatorNode:subtract": {
    op: "-",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:multiply": {
    op: "*",
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
  },
  "OperatorNode:divide": {
    op: "/",
    associativity: "left",
    associativeWith: [],
    latexLeftParens: false,
    latexRightParens: false,
    latexParens: false
  },
  "OperatorNode:dotMultiply": {
    op: ".*",
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "OperatorNode:dotMultiply", "OperatorNode:doDivide"]
  },
  "OperatorNode:dotDivide": {
    op: "./",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:mod": {
    op: "mod",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:multiply": {
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
  }
}, {
  "OperatorNode:unaryPlus": {
    op: "+",
    associativity: "right"
  },
  "OperatorNode:unaryMinus": {
    op: "-",
    associativity: "right"
  },
  "OperatorNode:bitNot": {
    op: "~",
    associativity: "right"
  },
  "OperatorNode:not": {
    op: "not",
    associativity: "right"
  }
}, {
  "OperatorNode:pow": {
    op: "^",
    associativity: "right",
    associativeWith: [],
    latexRightParens: false
  },
  "OperatorNode:dotPow": {
    op: ".^",
    associativity: "right",
    associativeWith: []
  }
}, {
  "OperatorNode:factorial": {
    op: "!",
    associativity: "left"
  }
}, {
  "OperatorNode:ctranspose": {
    op: "'",
    associativity: "left"
  }
}];

// ../../node_modules/mathjs/lib/esm/expression/node/AssignmentNode.js
var name206 = "AssignmentNode";
var dependencies206 = [
  "subset",
  "?matrix",
  "Node"
];
var createAssignmentNode = factory(name206, dependencies206, (_ref) => {
  var {
    subset,
    matrix,
    Node
  } = _ref;
  var access3 = accessFactory({
    subset
  });
  var assign3 = assignFactory({
    subset,
    matrix
  });
  function needParenthesis(node, parenthesis, implicit) {
    if (!parenthesis) {
      parenthesis = "keep";
    }
    var precedence = getPrecedence(node, parenthesis, implicit);
    var exprPrecedence = getPrecedence(node.value, parenthesis, implicit);
    return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
  }

  class AssignmentNode extends Node {
    constructor(object21, index, value) {
      super();
      this.object = object21;
      this.index = value ? index : null;
      this.value = value || index;
      if (!isSymbolNode(object21) && !isAccessorNode(object21)) {
        throw new TypeError('SymbolNode or AccessorNode expected as "object"');
      }
      if (isSymbolNode(object21) && object21.name === "end") {
        throw new Error('Cannot assign to symbol "end"');
      }
      if (this.index && !isIndexNode(this.index)) {
        throw new TypeError('IndexNode expected as "index"');
      }
      if (!isNode(this.value)) {
        throw new TypeError('Node expected as "value"');
      }
    }
    get name() {
      if (this.index) {
        return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
      } else {
        return this.object.name || "";
      }
    }
    get type() {
      return name206;
    }
    get isAssignmentNode() {
      return true;
    }
    _compile(math, argNames) {
      var evalObject = this.object._compile(math, argNames);
      var evalIndex = this.index ? this.index._compile(math, argNames) : null;
      var evalValue = this.value._compile(math, argNames);
      var name207 = this.object.name;
      if (!this.index) {
        if (!isSymbolNode(this.object)) {
          throw new TypeError("SymbolNode expected as object");
        }
        return function evalAssignmentNode(scope, args, context2) {
          var value = evalValue(scope, args, context2);
          scope.set(name207, value);
          return value;
        };
      } else if (this.index.isObjectProperty()) {
        var prop = this.index.getObjectProperty();
        return function evalAssignmentNode(scope, args, context2) {
          var object21 = evalObject(scope, args, context2);
          var value = evalValue(scope, args, context2);
          setSafeProperty(object21, prop, value);
          return value;
        };
      } else if (isSymbolNode(this.object)) {
        return function evalAssignmentNode(scope, args, context2) {
          var childObject = evalObject(scope, args, context2);
          var value = evalValue(scope, args, context2);
          var index = evalIndex(scope, args, childObject);
          scope.set(name207, assign3(childObject, index, value));
          return value;
        };
      } else {
        var evalParentObject = this.object.object._compile(math, argNames);
        if (this.object.index.isObjectProperty()) {
          var parentProp = this.object.index.getObjectProperty();
          return function evalAssignmentNode(scope, args, context2) {
            var parent = evalParentObject(scope, args, context2);
            var childObject = getSafeProperty(parent, parentProp);
            var index = evalIndex(scope, args, childObject);
            var value = evalValue(scope, args, context2);
            setSafeProperty(parent, parentProp, assign3(childObject, index, value));
            return value;
          };
        } else {
          var evalParentIndex = this.object.index._compile(math, argNames);
          return function evalAssignmentNode(scope, args, context2) {
            var parent = evalParentObject(scope, args, context2);
            var parentIndex = evalParentIndex(scope, args, parent);
            var childObject = access3(parent, parentIndex);
            var index = evalIndex(scope, args, childObject);
            var value = evalValue(scope, args, context2);
            assign3(parent, parentIndex, assign3(childObject, index, value));
            return value;
          };
        }
      }
    }
    forEach(callback) {
      callback(this.object, "object", this);
      if (this.index) {
        callback(this.index, "index", this);
      }
      callback(this.value, "value", this);
    }
    map(callback) {
      var object21 = this._ifNode(callback(this.object, "object", this));
      var index = this.index ? this._ifNode(callback(this.index, "index", this)) : null;
      var value = this._ifNode(callback(this.value, "value", this));
      return new AssignmentNode(object21, index, value);
    }
    clone() {
      return new AssignmentNode(this.object, this.index, this.value);
    }
    _toString(options) {
      var object21 = this.object.toString(options);
      var index = this.index ? this.index.toString(options) : "";
      var value = this.value.toString(options);
      if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
        value = "(" + value + ")";
      }
      return object21 + index + " = " + value;
    }
    toJSON() {
      return {
        mathjs: name206,
        object: this.object,
        index: this.index,
        value: this.value
      };
    }
    static fromJSON(json) {
      return new AssignmentNode(json.object, json.index, json.value);
    }
    toHTML(options) {
      var object21 = this.object.toHTML(options);
      var index = this.index ? this.index.toHTML(options) : "";
      var value = this.value.toHTML(options);
      if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
        value = '<span class="math-paranthesis math-round-parenthesis">(</span>' + value + '<span class="math-paranthesis math-round-parenthesis">)</span>';
      }
      return object21 + index + '<span class="math-operator math-assignment-operator ' + 'math-variable-assignment-operator math-binary-operator">=</span>' + value;
    }
    _toTex(options) {
      var object21 = this.object.toTex(options);
      var index = this.index ? this.index.toTex(options) : "";
      var value = this.value.toTex(options);
      if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
        value = "\\left(".concat(value, "\\right)");
      }
      return object21 + index + ":=" + value;
    }
  }
  defineProperty4.default(AssignmentNode, "name", name206);
  return AssignmentNode;
}, {
  isClass: true,
  isNode: true
});
// ../../node_modules/mathjs/lib/esm/expression/node/BlockNode.js
var defineProperty5 = __toESM(require_defineProperty(), 1);
var name207 = "BlockNode";
var dependencies207 = ["ResultSet", "Node"];
var createBlockNode = factory(name207, dependencies207, (_ref) => {
  var {
    ResultSet,
    Node
  } = _ref;

  class BlockNode extends Node {
    constructor(blocks) {
      super();
      if (!Array.isArray(blocks))
        throw new Error("Array expected");
      this.blocks = blocks.map(function(block) {
        var node = block && block.node;
        var visible = block && block.visible !== undefined ? block.visible : true;
        if (!isNode(node))
          throw new TypeError('Property "node" must be a Node');
        if (typeof visible !== "boolean") {
          throw new TypeError('Property "visible" must be a boolean');
        }
        return {
          node,
          visible
        };
      });
    }
    get type() {
      return name207;
    }
    get isBlockNode() {
      return true;
    }
    _compile(math, argNames) {
      var evalBlocks = map(this.blocks, function(block) {
        return {
          evaluate: block.node._compile(math, argNames),
          visible: block.visible
        };
      });
      return function evalBlockNodes(scope, args, context2) {
        var results = [];
        forEach(evalBlocks, function evalBlockNode(block) {
          var result = block.evaluate(scope, args, context2);
          if (block.visible) {
            results.push(result);
          }
        });
        return new ResultSet(results);
      };
    }
    forEach(callback) {
      for (var i = 0;i < this.blocks.length; i++) {
        callback(this.blocks[i].node, "blocks[" + i + "].node", this);
      }
    }
    map(callback) {
      var blocks = [];
      for (var i = 0;i < this.blocks.length; i++) {
        var block = this.blocks[i];
        var node = this._ifNode(callback(block.node, "blocks[" + i + "].node", this));
        blocks[i] = {
          node,
          visible: block.visible
        };
      }
      return new BlockNode(blocks);
    }
    clone() {
      var blocks = this.blocks.map(function(block) {
        return {
          node: block.node,
          visible: block.visible
        };
      });
      return new BlockNode(blocks);
    }
    _toString(options) {
      return this.blocks.map(function(param) {
        return param.node.toString(options) + (param.visible ? "" : ";");
      }).join("\n");
    }
    toJSON() {
      return {
        mathjs: name207,
        blocks: this.blocks
      };
    }
    static fromJSON(json) {
      return new BlockNode(json.blocks);
    }
    toHTML(options) {
      return this.blocks.map(function(param) {
        return param.node.toHTML(options) + (param.visible ? "" : '<span class="math-separator">;</span>');
      }).join('<span class="math-separator"><br /></span>');
    }
    _toTex(options) {
      return this.blocks.map(function(param) {
        return param.node.toTex(options) + (param.visible ? "" : ";");
      }).join("\\;\\;\n");
    }
  }
  defineProperty5.default(BlockNode, "name", name207);
  return BlockNode;
}, {
  isClass: true,
  isNode: true
});
// ../../node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js
var defineProperty6 = __toESM(require_defineProperty(), 1);
var name208 = "ConditionalNode";
var dependencies208 = ["Node"];
var createConditionalNode = factory(name208, dependencies208, (_ref) => {
  var {
    Node
  } = _ref;
  function testCondition(condition) {
    if (typeof condition === "number" || typeof condition === "boolean" || typeof condition === "string") {
      return !!condition;
    }
    if (condition) {
      if (isBigNumber(condition)) {
        return !condition.isZero();
      }
      if (isComplex(condition)) {
        return !!(condition.re || condition.im);
      }
      if (isUnit(condition)) {
        return !!condition.value;
      }
    }
    if (condition === null || condition === undefined) {
      return false;
    }
    throw new TypeError('Unsupported type of condition "' + typeOf(condition) + '"');
  }

  class ConditionalNode extends Node {
    constructor(condition, trueExpr, falseExpr) {
      super();
      if (!isNode(condition)) {
        throw new TypeError("Parameter condition must be a Node");
      }
      if (!isNode(trueExpr)) {
        throw new TypeError("Parameter trueExpr must be a Node");
      }
      if (!isNode(falseExpr)) {
        throw new TypeError("Parameter falseExpr must be a Node");
      }
      this.condition = condition;
      this.trueExpr = trueExpr;
      this.falseExpr = falseExpr;
    }
    get type() {
      return name208;
    }
    get isConditionalNode() {
      return true;
    }
    _compile(math, argNames) {
      var evalCondition = this.condition._compile(math, argNames);
      var evalTrueExpr = this.trueExpr._compile(math, argNames);
      var evalFalseExpr = this.falseExpr._compile(math, argNames);
      return function evalConditionalNode(scope, args, context2) {
        return testCondition(evalCondition(scope, args, context2)) ? evalTrueExpr(scope, args, context2) : evalFalseExpr(scope, args, context2);
      };
    }
    forEach(callback) {
      callback(this.condition, "condition", this);
      callback(this.trueExpr, "trueExpr", this);
      callback(this.falseExpr, "falseExpr", this);
    }
    map(callback) {
      return new ConditionalNode(this._ifNode(callback(this.condition, "condition", this)), this._ifNode(callback(this.trueExpr, "trueExpr", this)), this._ifNode(callback(this.falseExpr, "falseExpr", this)));
    }
    clone() {
      return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);
    }
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var condition = this.condition.toString(options);
      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
        condition = "(" + condition + ")";
      }
      var trueExpr = this.trueExpr.toString(options);
      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
        trueExpr = "(" + trueExpr + ")";
      }
      var falseExpr = this.falseExpr.toString(options);
      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
        falseExpr = "(" + falseExpr + ")";
      }
      return condition + " ? " + trueExpr + " : " + falseExpr;
    }
    toJSON() {
      return {
        mathjs: name208,
        condition: this.condition,
        trueExpr: this.trueExpr,
        falseExpr: this.falseExpr
      };
    }
    static fromJSON(json) {
      return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);
    }
    toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var condition = this.condition.toHTML(options);
      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
        condition = '<span class="math-parenthesis math-round-parenthesis">(</span>' + condition + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      var trueExpr = this.trueExpr.toHTML(options);
      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
        trueExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + trueExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      var falseExpr = this.falseExpr.toHTML(options);
      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
        falseExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + falseExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return condition + '<span class="math-operator math-conditional-operator">?</span>' + trueExpr + '<span class="math-operator math-conditional-operator">:</span>' + falseExpr;
    }
    _toTex(options) {
      return "\\begin{cases} {" + this.trueExpr.toTex(options) + "}, &\\quad{\\text{if }\\;" + this.condition.toTex(options) + "}\\\\{" + this.falseExpr.toTex(options) + "}, &\\quad{\\text{otherwise}}\\end{cases}";
    }
  }
  defineProperty6.default(ConditionalNode, "name", name208);
  return ConditionalNode;
}, {
  isClass: true,
  isNode: true
});
// ../../node_modules/mathjs/lib/esm/expression/node/ConstantNode.js
var defineProperty7 = __toESM(require_defineProperty(), 1);

// ../../node_modules/mathjs/lib/esm/utils/latex.js
var import_escape_latex = __toESM(require_dist2(), 1);
function escapeLatex(string12) {
  return import_escape_latex.default(string12, {
    preserveFormatting: true
  });
}
function toSymbol(name209, isUnit2) {
  isUnit2 = typeof isUnit2 === "undefined" ? false : isUnit2;
  if (isUnit2) {
    if (hasOwnProperty2(latexUnits, name209)) {
      return latexUnits[name209];
    }
    return "\\mathrm{" + escapeLatex(name209) + "}";
  }
  if (hasOwnProperty2(latexSymbols, name209)) {
    return latexSymbols[name209];
  }
  return escapeLatex(name209);
}
var latexSymbols = {
  Alpha: "A",
  alpha: "\\alpha",
  Beta: "B",
  beta: "\\beta",
  Gamma: "\\Gamma",
  gamma: "\\gamma",
  Delta: "\\Delta",
  delta: "\\delta",
  Epsilon: "E",
  epsilon: "\\epsilon",
  varepsilon: "\\varepsilon",
  Zeta: "Z",
  zeta: "\\zeta",
  Eta: "H",
  eta: "\\eta",
  Theta: "\\Theta",
  theta: "\\theta",
  vartheta: "\\vartheta",
  Iota: "I",
  iota: "\\iota",
  Kappa: "K",
  kappa: "\\kappa",
  varkappa: "\\varkappa",
  Lambda: "\\Lambda",
  lambda: "\\lambda",
  Mu: "M",
  mu: "\\mu",
  Nu: "N",
  nu: "\\nu",
  Xi: "\\Xi",
  xi: "\\xi",
  Omicron: "O",
  omicron: "o",
  Pi: "\\Pi",
  pi: "\\pi",
  varpi: "\\varpi",
  Rho: "P",
  rho: "\\rho",
  varrho: "\\varrho",
  Sigma: "\\Sigma",
  sigma: "\\sigma",
  varsigma: "\\varsigma",
  Tau: "T",
  tau: "\\tau",
  Upsilon: "\\Upsilon",
  upsilon: "\\upsilon",
  Phi: "\\Phi",
  phi: "\\phi",
  varphi: "\\varphi",
  Chi: "X",
  chi: "\\chi",
  Psi: "\\Psi",
  psi: "\\psi",
  Omega: "\\Omega",
  omega: "\\omega",
  true: "\\mathrm{True}",
  false: "\\mathrm{False}",
  i: "i",
  inf: "\\infty",
  Inf: "\\infty",
  infinity: "\\infty",
  Infinity: "\\infty",
  oo: "\\infty",
  lim: "\\lim",
  undefined: "\\mathbf{?}"
};
var latexOperators = {
  transpose: "^\\top",
  ctranspose: "^H",
  factorial: "!",
  pow: "^",
  dotPow: ".^\\wedge",
  unaryPlus: "+",
  unaryMinus: "-",
  bitNot: "\\~",
  not: "\\neg",
  multiply: "\\cdot",
  divide: "\\frac",
  dotMultiply: ".\\cdot",
  dotDivide: ".:",
  mod: "\\mod",
  add: "+",
  subtract: "-",
  to: "\\rightarrow",
  leftShift: "<<",
  rightArithShift: ">>",
  rightLogShift: ">>>",
  equal: "=",
  unequal: "\\neq",
  smaller: "<",
  larger: ">",
  smallerEq: "\\leq",
  largerEq: "\\geq",
  bitAnd: "\\&",
  bitXor: "\\underline{|}",
  bitOr: "|",
  and: "\\wedge",
  xor: "\\veebar",
  or: "\\vee"
};
var latexFunctions = {
  abs: {
    1: "\\left|${args[0]}\\right|"
  },
  add: {
    2: "\\left(${args[0]}".concat(latexOperators.add, "${args[1]}\\right)")
  },
  cbrt: {
    1: "\\sqrt[3]{${args[0]}}"
  },
  ceil: {
    1: "\\left\\lceil${args[0]}\\right\\rceil"
  },
  cube: {
    1: "\\left(${args[0]}\\right)^3"
  },
  divide: {
    2: "\\frac{${args[0]}}{${args[1]}}"
  },
  dotDivide: {
    2: "\\left(${args[0]}".concat(latexOperators.dotDivide, "${args[1]}\\right)")
  },
  dotMultiply: {
    2: "\\left(${args[0]}".concat(latexOperators.dotMultiply, "${args[1]}\\right)")
  },
  dotPow: {
    2: "\\left(${args[0]}".concat(latexOperators.dotPow, "${args[1]}\\right)")
  },
  exp: {
    1: "\\exp\\left(${args[0]}\\right)"
  },
  expm1: "\\left(e".concat(latexOperators.pow, "{${args[0]}}-1\\right)"),
  fix: {
    1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
  },
  floor: {
    1: "\\left\\lfloor${args[0]}\\right\\rfloor"
  },
  gcd: "\\gcd\\left(${args}\\right)",
  hypot: "\\hypot\\left(${args}\\right)",
  log: {
    1: "\\ln\\left(${args[0]}\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}\\right)"
  },
  log10: {
    1: "\\log_{10}\\left(${args[0]}\\right)"
  },
  log1p: {
    1: "\\ln\\left(${args[0]}+1\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)"
  },
  log2: "\\log_{2}\\left(${args[0]}\\right)",
  mod: {
    2: "\\left(${args[0]}".concat(latexOperators.mod, "${args[1]}\\right)")
  },
  multiply: {
    2: "\\left(${args[0]}".concat(latexOperators.multiply, "${args[1]}\\right)")
  },
  norm: {
    1: "\\left\\|${args[0]}\\right\\|",
    2: undefined
  },
  nthRoot: {
    2: "\\sqrt[${args[1]}]{${args[0]}}"
  },
  nthRoots: {
    2: "\\{y : $y^{args[1]} = {${args[0]}}\\}"
  },
  pow: {
    2: "\\left(${args[0]}\\right)".concat(latexOperators.pow, "{${args[1]}}")
  },
  round: {
    1: "\\left\\lfloor${args[0]}\\right\\rceil",
    2: undefined
  },
  sign: {
    1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
  },
  sqrt: {
    1: "\\sqrt{${args[0]}}"
  },
  square: {
    1: "\\left(${args[0]}\\right)^2"
  },
  subtract: {
    2: "\\left(${args[0]}".concat(latexOperators.subtract, "${args[1]}\\right)")
  },
  unaryMinus: {
    1: "".concat(latexOperators.unaryMinus, "\\left(${args[0]}\\right)")
  },
  unaryPlus: {
    1: "".concat(latexOperators.unaryPlus, "\\left(${args[0]}\\right)")
  },
  bitAnd: {
    2: "\\left(${args[0]}".concat(latexOperators.bitAnd, "${args[1]}\\right)")
  },
  bitNot: {
    1: latexOperators.bitNot + "\\left(${args[0]}\\right)"
  },
  bitOr: {
    2: "\\left(${args[0]}".concat(latexOperators.bitOr, "${args[1]}\\right)")
  },
  bitXor: {
    2: "\\left(${args[0]}".concat(latexOperators.bitXor, "${args[1]}\\right)")
  },
  leftShift: {
    2: "\\left(${args[0]}".concat(latexOperators.leftShift, "${args[1]}\\right)")
  },
  rightArithShift: {
    2: "\\left(${args[0]}".concat(latexOperators.rightArithShift, "${args[1]}\\right)")
  },
  rightLogShift: {
    2: "\\left(${args[0]}".concat(latexOperators.rightLogShift, "${args[1]}\\right)")
  },
  bellNumbers: {
    1: "\\mathrm{B}_{${args[0]}}"
  },
  catalan: {
    1: "\\mathrm{C}_{${args[0]}}"
  },
  stirlingS2: {
    2: "\\mathrm{S}\\left(${args}\\right)"
  },
  arg: {
    1: "\\arg\\left(${args[0]}\\right)"
  },
  conj: {
    1: "\\left(${args[0]}\\right)^*"
  },
  im: {
    1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace"
  },
  re: {
    1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace"
  },
  and: {
    2: "\\left(${args[0]}".concat(latexOperators.and, "${args[1]}\\right)")
  },
  not: {
    1: latexOperators.not + "\\left(${args[0]}\\right)"
  },
  or: {
    2: "\\left(${args[0]}".concat(latexOperators.or, "${args[1]}\\right)")
  },
  xor: {
    2: "\\left(${args[0]}".concat(latexOperators.xor, "${args[1]}\\right)")
  },
  cross: {
    2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)"
  },
  ctranspose: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.ctranspose)
  },
  det: {
    1: "\\det\\left(${args[0]}\\right)"
  },
  dot: {
    2: "\\left(${args[0]}\\cdot${args[1]}\\right)"
  },
  expm: {
    1: "\\exp\\left(${args[0]}\\right)"
  },
  inv: {
    1: "\\left(${args[0]}\\right)^{-1}"
  },
  pinv: {
    1: "\\left(${args[0]}\\right)^{+}"
  },
  sqrtm: {
    1: "{${args[0]}}".concat(latexOperators.pow, "{\\frac{1}{2}}")
  },
  trace: {
    1: "\\mathrm{tr}\\left(${args[0]}\\right)"
  },
  transpose: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.transpose)
  },
  combinations: {
    2: "\\binom{${args[0]}}{${args[1]}}"
  },
  combinationsWithRep: {
    2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"
  },
  factorial: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.factorial)
  },
  gamma: {
    1: "\\Gamma\\left(${args[0]}\\right)"
  },
  lgamma: {
    1: "\\ln\\Gamma\\left(${args[0]}\\right)"
  },
  equal: {
    2: "\\left(${args[0]}".concat(latexOperators.equal, "${args[1]}\\right)")
  },
  larger: {
    2: "\\left(${args[0]}".concat(latexOperators.larger, "${args[1]}\\right)")
  },
  largerEq: {
    2: "\\left(${args[0]}".concat(latexOperators.largerEq, "${args[1]}\\right)")
  },
  smaller: {
    2: "\\left(${args[0]}".concat(latexOperators.smaller, "${args[1]}\\right)")
  },
  smallerEq: {
    2: "\\left(${args[0]}".concat(latexOperators.smallerEq, "${args[1]}\\right)")
  },
  unequal: {
    2: "\\left(${args[0]}".concat(latexOperators.unequal, "${args[1]}\\right)")
  },
  erf: {
    1: "erf\\left(${args[0]}\\right)"
  },
  max: "\\max\\left(${args}\\right)",
  min: "\\min\\left(${args}\\right)",
  variance: "\\mathrm{Var}\\left(${args}\\right)",
  acos: {
    1: "\\cos^{-1}\\left(${args[0]}\\right)"
  },
  acosh: {
    1: "\\cosh^{-1}\\left(${args[0]}\\right)"
  },
  acot: {
    1: "\\cot^{-1}\\left(${args[0]}\\right)"
  },
  acoth: {
    1: "\\coth^{-1}\\left(${args[0]}\\right)"
  },
  acsc: {
    1: "\\csc^{-1}\\left(${args[0]}\\right)"
  },
  acsch: {
    1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)"
  },
  asec: {
    1: "\\sec^{-1}\\left(${args[0]}\\right)"
  },
  asech: {
    1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)"
  },
  asin: {
    1: "\\sin^{-1}\\left(${args[0]}\\right)"
  },
  asinh: {
    1: "\\sinh^{-1}\\left(${args[0]}\\right)"
  },
  atan: {
    1: "\\tan^{-1}\\left(${args[0]}\\right)"
  },
  atan2: {
    2: "\\mathrm{atan2}\\left(${args}\\right)"
  },
  atanh: {
    1: "\\tanh^{-1}\\left(${args[0]}\\right)"
  },
  cos: {
    1: "\\cos\\left(${args[0]}\\right)"
  },
  cosh: {
    1: "\\cosh\\left(${args[0]}\\right)"
  },
  cot: {
    1: "\\cot\\left(${args[0]}\\right)"
  },
  coth: {
    1: "\\coth\\left(${args[0]}\\right)"
  },
  csc: {
    1: "\\csc\\left(${args[0]}\\right)"
  },
  csch: {
    1: "\\mathrm{csch}\\left(${args[0]}\\right)"
  },
  sec: {
    1: "\\sec\\left(${args[0]}\\right)"
  },
  sech: {
    1: "\\mathrm{sech}\\left(${args[0]}\\right)"
  },
  sin: {
    1: "\\sin\\left(${args[0]}\\right)"
  },
  sinh: {
    1: "\\sinh\\left(${args[0]}\\right)"
  },
  tan: {
    1: "\\tan\\left(${args[0]}\\right)"
  },
  tanh: {
    1: "\\tanh\\left(${args[0]}\\right)"
  },
  to: {
    2: "\\left(${args[0]}".concat(latexOperators.to, "${args[1]}\\right)")
  },
  numeric: function numeric(node, options) {
    return node.args[0].toTex();
  },
  number: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  },
  string: {
    0: '\\mathtt{""}',
    1: "\\mathrm{string}\\left(${args[0]}\\right)"
  },
  bignumber: {
    0: "0",
    1: "\\left(${args[0]}\\right)"
  },
  complex: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)+".concat(latexSymbols.i, "\\cdot\\left(${args[1]}\\right)\\right)")
  },
  matrix: {
    0: "\\begin{bmatrix}\\end{bmatrix}",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(${args[0]}\\right)"
  },
  sparse: {
    0: "\\begin{bsparse}\\end{bsparse}",
    1: "\\left(${args[0]}\\right)"
  },
  unit: {
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  }
};
var defaultTemplate = "\\mathrm{${name}}\\left(${args}\\right)";
var latexUnits = {
  deg: "^\\circ"
};

// ../../node_modules/mathjs/lib/esm/expression/node/ConstantNode.js
var name209 = "ConstantNode";
var dependencies209 = ["Node"];
var createConstantNode = factory(name209, dependencies209, (_ref) => {
  var {
    Node
  } = _ref;

  class ConstantNode extends Node {
    constructor(value) {
      super();
      this.value = value;
    }
    get type() {
      return name209;
    }
    get isConstantNode() {
      return true;
    }
    _compile(math, argNames) {
      var value = this.value;
      return function evalConstantNode() {
        return value;
      };
    }
    forEach(callback) {
    }
    map(callback) {
      return this.clone();
    }
    clone() {
      return new ConstantNode(this.value);
    }
    _toString(options) {
      return format3(this.value, options);
    }
    toHTML(options) {
      var value = this._toString(options);
      switch (typeOf(this.value)) {
        case "number":
        case "BigNumber":
        case "Fraction":
          return '<span class="math-number">' + value + "</span>";
        case "string":
          return '<span class="math-string">' + value + "</span>";
        case "boolean":
          return '<span class="math-boolean">' + value + "</span>";
        case "null":
          return '<span class="math-null-symbol">' + value + "</span>";
        case "undefined":
          return '<span class="math-undefined">' + value + "</span>";
        default:
          return '<span class="math-symbol">' + value + "</span>";
      }
    }
    toJSON() {
      return {
        mathjs: name209,
        value: this.value
      };
    }
    static fromJSON(json) {
      return new ConstantNode(json.value);
    }
    _toTex(options) {
      var value = this._toString(options);
      switch (typeOf(this.value)) {
        case "string":
          return "\\mathtt{" + escapeLatex(value) + "}";
        case "number":
        case "BigNumber":
          {
            if (!isFinite(this.value)) {
              return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
            }
            var index = value.toLowerCase().indexOf("e");
            if (index !== -1) {
              return value.substring(0, index) + "\\cdot10^{" + value.substring(index + 1) + "}";
            }
          }
          return value;
        case "Fraction":
          return this.value.toLatex();
        default:
          return value;
      }
    }
  }
  defineProperty7.default(ConstantNode, "name", name209);
  return ConstantNode;
}, {
  isClass: true,
  isNode: true
});
// ../../node_modules/mathjs/lib/esm/expression/node/FunctionAssignmentNode.js
var defineProperty8 = __toESM(require_defineProperty(), 1);
var name210 = "FunctionAssignmentNode";
var dependencies210 = ["typed", "Node"];
var createFunctionAssignmentNode = factory(name210, dependencies210, (_ref) => {
  var {
    typed,
    Node
  } = _ref;
  function needParenthesis(node, parenthesis, implicit) {
    var precedence = getPrecedence(node, parenthesis, implicit);
    var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit);
    return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
  }

  class FunctionAssignmentNode extends Node {
    constructor(name211, params, expr) {
      super();
      if (typeof name211 !== "string") {
        throw new TypeError('String expected for parameter "name"');
      }
      if (!Array.isArray(params)) {
        throw new TypeError('Array containing strings or objects expected for parameter "params"');
      }
      if (!isNode(expr)) {
        throw new TypeError('Node expected for parameter "expr"');
      }
      if (keywords.has(name211)) {
        throw new Error('Illegal function name, "' + name211 + '" is a reserved keyword');
      }
      var paramNames = new Set;
      for (var param of params) {
        var _name = typeof param === "string" ? param : param.name;
        if (paramNames.has(_name)) {
          throw new Error("Duplicate parameter name \"".concat(_name, "\""));
        } else {
          paramNames.add(_name);
        }
      }
      this.name = name211;
      this.params = params.map(function(param2) {
        return param2 && param2.name || param2;
      });
      this.types = params.map(function(param2) {
        return param2 && param2.type || "any";
      });
      this.expr = expr;
    }
    get type() {
      return name210;
    }
    get isFunctionAssignmentNode() {
      return true;
    }
    _compile(math, argNames) {
      var childArgNames = Object.create(argNames);
      forEach(this.params, function(param) {
        childArgNames[param] = true;
      });
      var evalExpr = this.expr._compile(math, childArgNames);
      var name211 = this.name;
      var params = this.params;
      var signature = join(this.types, ",");
      var syntax = name211 + "(" + join(this.params, ", ") + ")";
      return function evalFunctionAssignmentNode(scope, args, context2) {
        var signatures = {};
        signatures[signature] = function() {
          var childArgs = Object.create(args);
          for (var i = 0;i < params.length; i++) {
            childArgs[params[i]] = arguments[i];
          }
          return evalExpr(scope, childArgs, context2);
        };
        var fn = typed(name211, signatures);
        fn.syntax = syntax;
        scope.set(name211, fn);
        return fn;
      };
    }
    forEach(callback) {
      callback(this.expr, "expr", this);
    }
    map(callback) {
      var expr = this._ifNode(callback(this.expr, "expr", this));
      return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);
    }
    clone() {
      return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);
    }
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var expr = this.expr.toString(options);
      if (needParenthesis(this, parenthesis, options && options.implicit)) {
        expr = "(" + expr + ")";
      }
      return this.name + "(" + this.params.join(", ") + ") = " + expr;
    }
    toJSON() {
      var types4 = this.types;
      return {
        mathjs: name210,
        name: this.name,
        params: this.params.map(function(param, index) {
          return {
            name: param,
            type: types4[index]
          };
        }),
        expr: this.expr
      };
    }
    static fromJSON(json) {
      return new FunctionAssignmentNode(json.name, json.params, json.expr);
    }
    toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var params = [];
      for (var i = 0;i < this.params.length; i++) {
        params.push('<span class="math-symbol math-parameter">' + escape(this.params[i]) + "</span>");
      }
      var expr = this.expr.toHTML(options);
      if (needParenthesis(this, parenthesis, options && options.implicit)) {
        expr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + expr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return '<span class="math-function">' + escape(this.name) + "</span>" + '<span class="math-parenthesis math-round-parenthesis">(</span>' + params.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span>' + '<span class="math-operator math-assignment-operator ' + 'math-variable-assignment-operator math-binary-operator">=</span>' + expr;
    }
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var expr = this.expr.toTex(options);
      if (needParenthesis(this, parenthesis, options && options.implicit)) {
        expr = "\\left(".concat(expr, "\\right)");
      }
      return "\\mathrm{" + this.name + "}\\left(" + this.params.map(toSymbol).join(",") + "\\right):=" + expr;
    }
  }
  defineProperty8.default(FunctionAssignmentNode, "name", name210);
  return FunctionAssignmentNode;
}, {
  isClass: true,
  isNode: true
});
// ../../node_modules/mathjs/lib/esm/expression/node/IndexNode.js
var defineProperty9 = __toESM(require_defineProperty(), 1);
var name211 = "IndexNode";
var dependencies211 = ["Node", "size"];
var createIndexNode = factory(name211, dependencies211, (_ref) => {
  var {
    Node,
    size
  } = _ref;

  class IndexNode extends Node {
    constructor(dimensions, dotNotation) {
      super();
      this.dimensions = dimensions;
      this.dotNotation = dotNotation || false;
      if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
      }
      if (this.dotNotation && !this.isObjectProperty()) {
        throw new Error("dotNotation only applicable for object properties");
      }
    }
    get type() {
      return name211;
    }
    get isIndexNode() {
      return true;
    }
    _compile(math, argNames) {
      var evalDimensions = map(this.dimensions, function(dimension, i) {
        var needsEnd = dimension.filter((node) => node.isSymbolNode && node.name === "end").length > 0;
        if (needsEnd) {
          var childArgNames = Object.create(argNames);
          childArgNames.end = true;
          var _evalDimension = dimension._compile(math, childArgNames);
          return function evalDimension(scope, args, context2) {
            if (!isMatrix(context2) && !isArray(context2) && !isString(context2)) {
              throw new TypeError('Cannot resolve "end": ' + "context must be a Matrix, Array, or string but is " + typeOf(context2));
            }
            var s = size(context2).valueOf();
            var childArgs = Object.create(args);
            childArgs.end = s[i];
            return _evalDimension(scope, childArgs, context2);
          };
        } else {
          return dimension._compile(math, argNames);
        }
      });
      var index = getSafeProperty(math, "index");
      return function evalIndexNode(scope, args, context2) {
        var dimensions = map(evalDimensions, function(evalDimension) {
          return evalDimension(scope, args, context2);
        });
        return index(...dimensions);
      };
    }
    forEach(callback) {
      for (var i = 0;i < this.dimensions.length; i++) {
        callback(this.dimensions[i], "dimensions[" + i + "]", this);
      }
    }
    map(callback) {
      var dimensions = [];
      for (var i = 0;i < this.dimensions.length; i++) {
        dimensions[i] = this._ifNode(callback(this.dimensions[i], "dimensions[" + i + "]", this));
      }
      return new IndexNode(dimensions, this.dotNotation);
    }
    clone() {
      return new IndexNode(this.dimensions.slice(0), this.dotNotation);
    }
    isObjectProperty() {
      return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === "string";
    }
    getObjectProperty() {
      return this.isObjectProperty() ? this.dimensions[0].value : null;
    }
    _toString(options) {
      return this.dotNotation ? "." + this.getObjectProperty() : "[" + this.dimensions.join(", ") + "]";
    }
    toJSON() {
      return {
        mathjs: name211,
        dimensions: this.dimensions,
        dotNotation: this.dotNotation
      };
    }
    static fromJSON(json) {
      return new IndexNode(json.dimensions, json.dotNotation);
    }
    toHTML(options) {
      var dimensions = [];
      for (var i = 0;i < this.dimensions.length; i++) {
        dimensions[i] = this.dimensions[i].toHTML();
      }
      if (this.dotNotation) {
        return '<span class="math-operator math-accessor-operator">.</span>' + '<span class="math-symbol math-property">' + escape(this.getObjectProperty()) + "</span>";
      } else {
        return '<span class="math-parenthesis math-square-parenthesis">[</span>' + dimensions.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
      }
    }
    _toTex(options) {
      var dimensions = this.dimensions.map(function(range) {
        return range.toTex(options);
      });
      return this.dotNotation ? "." + this.getObjectProperty() + "" : "_{" + dimensions.join(",") + "}";
    }
  }
  defineProperty9.default(IndexNode, "name", name211);
  return IndexNode;
}, {
  isClass: true,
  isNode: true
});
// ../../node_modules/mathjs/lib/esm/expression/node/ObjectNode.js
var defineProperty10 = __toESM(require_defineProperty(), 1);
var name212 = "ObjectNode";
var dependencies212 = ["Node"];
var createObjectNode = factory(name212, dependencies212, (_ref) => {
  var {
    Node
  } = _ref;

  class ObjectNode extends Node {
    constructor(properties2) {
      super();
      this.properties = properties2 || {};
      if (properties2) {
        if (!(typeof properties2 === "object") || !Object.keys(properties2).every(function(key) {
          return isNode(properties2[key]);
        })) {
          throw new TypeError("Object containing Nodes expected");
        }
      }
    }
    get type() {
      return name212;
    }
    get isObjectNode() {
      return true;
    }
    _compile(math, argNames) {
      var evalEntries = {};
      for (var key in this.properties) {
        if (hasOwnProperty2(this.properties, key)) {
          var stringifiedKey = stringify(key);
          var parsedKey = JSON.parse(stringifiedKey);
          if (!isSafeProperty(this.properties, parsedKey)) {
            throw new Error('No access to property "' + parsedKey + '"');
          }
          evalEntries[parsedKey] = this.properties[key]._compile(math, argNames);
        }
      }
      return function evalObjectNode(scope, args, context2) {
        var obj = {};
        for (var _key in evalEntries) {
          if (hasOwnProperty2(evalEntries, _key)) {
            obj[_key] = evalEntries[_key](scope, args, context2);
          }
        }
        return obj;
      };
    }
    forEach(callback) {
      for (var key in this.properties) {
        if (hasOwnProperty2(this.properties, key)) {
          callback(this.properties[key], "properties[" + stringify(key) + "]", this);
        }
      }
    }
    map(callback) {
      var properties2 = {};
      for (var key in this.properties) {
        if (hasOwnProperty2(this.properties, key)) {
          properties2[key] = this._ifNode(callback(this.properties[key], "properties[" + stringify(key) + "]", this));
        }
      }
      return new ObjectNode(properties2);
    }
    clone() {
      var properties2 = {};
      for (var key in this.properties) {
        if (hasOwnProperty2(this.properties, key)) {
          properties2[key] = this.properties[key];
        }
      }
      return new ObjectNode(properties2);
    }
    _toString(options) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty2(this.properties, key)) {
          entries.push(stringify(key) + ": " + this.properties[key].toString(options));
        }
      }
      return "{" + entries.join(", ") + "}";
    }
    toJSON() {
      return {
        mathjs: name212,
        properties: this.properties
      };
    }
    static fromJSON(json) {
      return new ObjectNode(json.properties);
    }
    toHTML(options) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty2(this.properties, key)) {
          entries.push('<span class="math-symbol math-property">' + escape(key) + "</span>" + '<span class="math-operator math-assignment-operator ' + 'math-property-assignment-operator math-binary-operator">' + ":</span>" + this.properties[key].toHTML(options));
        }
      }
      return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + entries.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
    }
    _toTex(options) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty2(this.properties, key)) {
          entries.push("\\mathbf{" + key + ":} & " + this.properties[key].toTex(options) + "\\\\");
        }
      }
      var tex = "\\left\\{\\begin{array}{ll}" + entries.join("\n") + "\\end{array}\\right\\}";
      return tex;
    }
  }
  defineProperty10.default(ObjectNode, "name", name212);
  return ObjectNode;
}, {
  isClass: true,
  isNode: true
});
// ../../node_modules/mathjs/lib/esm/expression/node/OperatorNode.js
var defineProperty11 = __toESM(require_defineProperty(), 1);
var name213 = "OperatorNode";
var dependencies213 = ["Node"];
var createOperatorNode = factory(name213, dependencies213, (_ref) => {
  var {
    Node
  } = _ref;
  function startsWithConstant(expr, parenthesis) {
    var curNode = expr;
    if (parenthesis === "auto") {
      while (isParenthesisNode(curNode))
        curNode = curNode.content;
    }
    if (isConstantNode(curNode))
      return true;
    if (isOperatorNode(curNode)) {
      return startsWithConstant(curNode.args[0], parenthesis);
    }
    return false;
  }
  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex4) {
    var precedence = getPrecedence(root, parenthesis, implicit);
    var associativity = getAssociativity(root, parenthesis);
    if (parenthesis === "all" || args.length > 2 && root.getIdentifier() !== "OperatorNode:add" && root.getIdentifier() !== "OperatorNode:multiply") {
      return args.map(function(arg) {
        switch (arg.getContent().type) {
          case "ArrayNode":
          case "ConstantNode":
          case "SymbolNode":
          case "ParenthesisNode":
            return false;
          default:
            return true;
        }
      });
    }
    var result;
    switch (args.length) {
      case 0:
        result = [];
        break;
      case 1:
        {
          var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root);
          if (latex4 && operandPrecedence !== null) {
            var operandIdentifier;
            var rootIdentifier;
            if (parenthesis === "keep") {
              operandIdentifier = args[0].getIdentifier();
              rootIdentifier = root.getIdentifier();
            } else {
              operandIdentifier = args[0].getContent().getIdentifier();
              rootIdentifier = root.getContent().getIdentifier();
            }
            if (properties[precedence][rootIdentifier].latexLeftParens === false) {
              result = [false];
              break;
            }
            if (properties[operandPrecedence][operandIdentifier].latexParens === false) {
              result = [false];
              break;
            }
          }
          if (operandPrecedence === null) {
            result = [false];
            break;
          }
          if (operandPrecedence <= precedence) {
            result = [true];
            break;
          }
          result = [false];
        }
        break;
      case 2:
        {
          var lhsParens;
          var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root);
          var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);
          if (lhsPrecedence === null) {
            lhsParens = false;
          } else if (lhsPrecedence === precedence && associativity === "right" && !assocWithLhs) {
            lhsParens = true;
          } else if (lhsPrecedence < precedence) {
            lhsParens = true;
          } else {
            lhsParens = false;
          }
          var rhsParens;
          var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root);
          var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);
          if (rhsPrecedence === null) {
            rhsParens = false;
          } else if (rhsPrecedence === precedence && associativity === "left" && !assocWithRhs) {
            rhsParens = true;
          } else if (rhsPrecedence < precedence) {
            rhsParens = true;
          } else {
            rhsParens = false;
          }
          if (latex4) {
            var _rootIdentifier;
            var lhsIdentifier;
            var rhsIdentifier;
            if (parenthesis === "keep") {
              _rootIdentifier = root.getIdentifier();
              lhsIdentifier = root.args[0].getIdentifier();
              rhsIdentifier = root.args[1].getIdentifier();
            } else {
              _rootIdentifier = root.getContent().getIdentifier();
              lhsIdentifier = root.args[0].getContent().getIdentifier();
              rhsIdentifier = root.args[1].getContent().getIdentifier();
            }
            if (lhsPrecedence !== null) {
              if (properties[precedence][_rootIdentifier].latexLeftParens === false) {
                lhsParens = false;
              }
              if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
                lhsParens = false;
              }
            }
            if (rhsPrecedence !== null) {
              if (properties[precedence][_rootIdentifier].latexRightParens === false) {
                rhsParens = false;
              }
              if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
                rhsParens = false;
              }
            }
          }
          result = [lhsParens, rhsParens];
        }
        break;
      default:
        if (root.getIdentifier() === "OperatorNode:add" || root.getIdentifier() === "OperatorNode:multiply") {
          result = args.map(function(arg) {
            var argPrecedence = getPrecedence(arg, parenthesis, implicit, root);
            var assocWithArg = isAssociativeWith(root, arg, parenthesis);
            var argAssociativity = getAssociativity(arg, parenthesis);
            if (argPrecedence === null) {
              return false;
            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {
              return true;
            } else if (argPrecedence < precedence) {
              return true;
            }
            return false;
          });
        }
        break;
    }
    if (args.length >= 2 && root.getIdentifier() === "OperatorNode:multiply" && root.implicit && parenthesis !== "all" && implicit === "hide") {
      for (var i = 1;i < result.length; ++i) {
        if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== "keep" || !isParenthesisNode(args[i - 1]))) {
          result[i] = true;
        }
      }
    }
    return result;
  }

  class OperatorNode extends Node {
    constructor(op, fn, args, implicit, isPercentage) {
      super();
      if (typeof op !== "string") {
        throw new TypeError('string expected for parameter "op"');
      }
      if (typeof fn !== "string") {
        throw new TypeError('string expected for parameter "fn"');
      }
      if (!Array.isArray(args) || !args.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      }
      this.implicit = implicit === true;
      this.isPercentage = isPercentage === true;
      this.op = op;
      this.fn = fn;
      this.args = args || [];
    }
    get type() {
      return name213;
    }
    get isOperatorNode() {
      return true;
    }
    _compile(math, argNames) {
      if (typeof this.fn !== "string" || !isSafeMethod(math, this.fn)) {
        if (!math[this.fn]) {
          throw new Error("Function " + this.fn + ' missing in provided namespace "math"');
        } else {
          throw new Error('No access to function "' + this.fn + '"');
        }
      }
      var fn = getSafeProperty(math, this.fn);
      var evalArgs = map(this.args, function(arg) {
        return arg._compile(math, argNames);
      });
      if (evalArgs.length === 1) {
        var evalArg0 = evalArgs[0];
        return function evalOperatorNode(scope, args, context2) {
          return fn(evalArg0(scope, args, context2));
        };
      } else if (evalArgs.length === 2) {
        var _evalArg = evalArgs[0];
        var evalArg1 = evalArgs[1];
        return function evalOperatorNode(scope, args, context2) {
          return fn(_evalArg(scope, args, context2), evalArg1(scope, args, context2));
        };
      } else {
        return function evalOperatorNode(scope, args, context2) {
          return fn.apply(null, map(evalArgs, function(evalArg) {
            return evalArg(scope, args, context2);
          }));
        };
      }
    }
    forEach(callback) {
      for (var i = 0;i < this.args.length; i++) {
        callback(this.args[i], "args[" + i + "]", this);
      }
    }
    map(callback) {
      var args = [];
      for (var i = 0;i < this.args.length; i++) {
        args[i] = this._ifNode(callback(this.args[i], "args[" + i + "]", this));
      }
      return new OperatorNode(this.op, this.fn, args, this.implicit, this.isPercentage);
    }
    clone() {
      return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);
    }
    isUnary() {
      return this.args.length === 1;
    }
    isBinary() {
      return this.args.length === 2;
    }
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toString(options);
        if (parens[0]) {
          operand = "(" + operand + ")";
        }
        var opIsNamed = /[a-zA-Z]+/.test(this.op);
        if (assoc === "right") {
          return this.op + (opIsNamed ? " " : "") + operand;
        } else if (assoc === "left") {
          return operand + (opIsNamed ? " " : "") + this.op;
        }
        return operand + this.op;
      } else if (args.length === 2) {
        var lhs = args[0].toString(options);
        var rhs = args[1].toString(options);
        if (parens[0]) {
          lhs = "(" + lhs + ")";
        }
        if (parens[1]) {
          rhs = "(" + rhs + ")";
        }
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return lhs + " " + rhs;
        }
        return lhs + " " + this.op + " " + rhs;
      } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var stringifiedArgs = args.map(function(arg, index) {
          arg = arg.toString(options);
          if (parens[index]) {
            arg = "(" + arg + ")";
          }
          return arg;
        });
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return stringifiedArgs.join(" ");
        }
        return stringifiedArgs.join(" " + this.op + " ");
      } else {
        return this.fn + "(" + this.args.join(", ") + ")";
      }
    }
    toJSON() {
      return {
        mathjs: name213,
        op: this.op,
        fn: this.fn,
        args: this.args,
        implicit: this.implicit,
        isPercentage: this.isPercentage
      };
    }
    static fromJSON(json) {
      return new OperatorNode(json.op, json.fn, json.args, json.implicit, json.isPercentage);
    }
    toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toHTML(options);
        if (parens[0]) {
          operand = '<span class="math-parenthesis math-round-parenthesis">(</span>' + operand + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (assoc === "right") {
          return '<span class="math-operator math-unary-operator ' + 'math-lefthand-unary-operator">' + escape(this.op) + "</span>" + operand;
        } else {
          return operand + '<span class="math-operator math-unary-operator ' + 'math-righthand-unary-operator">' + escape(this.op) + "</span>";
        }
      } else if (args.length === 2) {
        var lhs = args[0].toHTML(options);
        var rhs = args[1].toHTML(options);
        if (parens[0]) {
          lhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + lhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (parens[1]) {
          rhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + rhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return lhs + '<span class="math-operator math-binary-operator ' + 'math-implicit-binary-operator"></span>' + rhs;
        }
        return lhs + '<span class="math-operator math-binary-operator ' + 'math-explicit-binary-operator">' + escape(this.op) + "</span>" + rhs;
      } else {
        var stringifiedArgs = args.map(function(arg, index) {
          arg = arg.toHTML(options);
          if (parens[index]) {
            arg = '<span class="math-parenthesis math-round-parenthesis">(</span>' + arg + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          return arg;
        });
        if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return stringifiedArgs.join('<span class="math-operator math-binary-operator ' + 'math-implicit-binary-operator"></span>');
          }
          return stringifiedArgs.join('<span class="math-operator math-binary-operator ' + 'math-explicit-binary-operator">' + escape(this.op) + "</span>");
        } else {
          return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">' + "(</span>" + stringifiedArgs.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
        }
      }
    }
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);
      var op = latexOperators[this.fn];
      op = typeof op === "undefined" ? this.op : op;
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toTex(options);
        if (parens[0]) {
          operand = "\\left(".concat(operand, "\\right)");
        }
        if (assoc === "right") {
          return op + operand;
        } else if (assoc === "left") {
          return operand + op;
        }
        return operand + op;
      } else if (args.length === 2) {
        var lhs = args[0];
        var lhsTex = lhs.toTex(options);
        if (parens[0]) {
          lhsTex = "\\left(".concat(lhsTex, "\\right)");
        }
        var rhs = args[1];
        var rhsTex = rhs.toTex(options);
        if (parens[1]) {
          rhsTex = "\\left(".concat(rhsTex, "\\right)");
        }
        var lhsIdentifier;
        if (parenthesis === "keep") {
          lhsIdentifier = lhs.getIdentifier();
        } else {
          lhsIdentifier = lhs.getContent().getIdentifier();
        }
        switch (this.getIdentifier()) {
          case "OperatorNode:divide":
            return op + "{" + lhsTex + "}" + "{" + rhsTex + "}";
          case "OperatorNode:pow":
            lhsTex = "{" + lhsTex + "}";
            rhsTex = "{" + rhsTex + "}";
            switch (lhsIdentifier) {
              case "ConditionalNode":
              case "OperatorNode:divide":
                lhsTex = "\\left(".concat(lhsTex, "\\right)");
            }
            break;
          case "OperatorNode:multiply":
            if (this.implicit && implicit === "hide") {
              return lhsTex + "~" + rhsTex;
            }
        }
        return lhsTex + op + rhsTex;
      } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var texifiedArgs = args.map(function(arg, index) {
          arg = arg.toTex(options);
          if (parens[index]) {
            arg = "\\left(".concat(arg, "\\right)");
          }
          return arg;
        });
        if (this.getIdentifier() === "OperatorNode:multiply" && this.implicit && implicit === "hide") {
          return texifiedArgs.join("~");
        }
        return texifiedArgs.join(op);
      } else {
        return "\\mathrm{" + this.fn + "}\\left(" + args.map(function(arg) {
          return arg.toTex(options);
        }).join(",") + "\\right)";
      }
    }
    getIdentifier() {
      return this.type + ":" + this.fn;
    }
  }
  defineProperty11.default(OperatorNode, "name", name213);
  return OperatorNode;
}, {
  isClass: true,
  isNode: true
});
// ../../node_modules/mathjs/lib/esm/expression/node/ParenthesisNode.js
var defineProperty12 = __toESM(require_defineProperty(), 1);
var name214 = "ParenthesisNode";
var dependencies214 = ["Node"];
var createParenthesisNode = factory(name214, dependencies214, (_ref) => {
  var {
    Node
  } = _ref;

  class ParenthesisNode extends Node {
    constructor(content) {
      super();
      if (!isNode(content)) {
        throw new TypeError('Node expected for parameter "content"');
      }
      this.content = content;
    }
    get type() {
      return name214;
    }
    get isParenthesisNode() {
      return true;
    }
    _compile(math, argNames) {
      return this.content._compile(math, argNames);
    }
    getContent() {
      return this.content.getContent();
    }
    forEach(callback) {
      callback(this.content, "content", this);
    }
    map(callback) {
      var content = callback(this.content, "content", this);
      return new ParenthesisNode(content);
    }
    clone() {
      return new ParenthesisNode(this.content);
    }
    _toString(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return "(" + this.content.toString(options) + ")";
      }
      return this.content.toString(options);
    }
    toJSON() {
      return {
        mathjs: name214,
        content: this.content
      };
    }
    static fromJSON(json) {
      return new ParenthesisNode(json.content);
    }
    toHTML(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return this.content.toHTML(options);
    }
    _toTex(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return "\\left(".concat(this.content.toTex(options), "\\right)");
      }
      return this.content.toTex(options);
    }
  }
  defineProperty12.default(ParenthesisNode, "name", name214);
  return ParenthesisNode;
}, {
  isClass: true,
  isNode: true
});
// ../../node_modules/mathjs/lib/esm/expression/node/RangeNode.js
var defineProperty13 = __toESM(require_defineProperty(), 1);
var name215 = "RangeNode";
var dependencies215 = ["Node"];
var createRangeNode = factory(name215, dependencies215, (_ref) => {
  var {
    Node
  } = _ref;
  function calculateNecessaryParentheses(node, parenthesis, implicit) {
    var precedence = getPrecedence(node, parenthesis, implicit);
    var parens = {};
    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);
    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === "all";
    if (node.step) {
      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);
      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === "all";
    }
    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);
    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === "all";
    return parens;
  }

  class RangeNode extends Node {
    constructor(start, end, step) {
      super();
      if (!isNode(start))
        throw new TypeError("Node expected");
      if (!isNode(end))
        throw new TypeError("Node expected");
      if (step && !isNode(step))
        throw new TypeError("Node expected");
      if (arguments.length > 3)
        throw new Error("Too many arguments");
      this.start = start;
      this.end = end;
      this.step = step || null;
    }
    get type() {
      return name215;
    }
    get isRangeNode() {
      return true;
    }
    needsEnd() {
      var endSymbols = this.filter(function(node) {
        return isSymbolNode(node) && node.name === "end";
      });
      return endSymbols.length > 0;
    }
    _compile(math, argNames) {
      var range = math.range;
      var evalStart = this.start._compile(math, argNames);
      var evalEnd = this.end._compile(math, argNames);
      if (this.step) {
        var evalStep = this.step._compile(math, argNames);
        return function evalRangeNode(scope, args, context2) {
          return range(evalStart(scope, args, context2), evalEnd(scope, args, context2), evalStep(scope, args, context2));
        };
      } else {
        return function evalRangeNode(scope, args, context2) {
          return range(evalStart(scope, args, context2), evalEnd(scope, args, context2));
        };
      }
    }
    forEach(callback) {
      callback(this.start, "start", this);
      callback(this.end, "end", this);
      if (this.step) {
        callback(this.step, "step", this);
      }
    }
    map(callback) {
      return new RangeNode(this._ifNode(callback(this.start, "start", this)), this._ifNode(callback(this.end, "end", this)), this.step && this._ifNode(callback(this.step, "step", this)));
    }
    clone() {
      return new RangeNode(this.start, this.end, this.step && this.step);
    }
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
      var str;
      var start = this.start.toString(options);
      if (parens.start) {
        start = "(" + start + ")";
      }
      str = start;
      if (this.step) {
        var step = this.step.toString(options);
        if (parens.step) {
          step = "(" + step + ")";
        }
        str += ":" + step;
      }
      var end = this.end.toString(options);
      if (parens.end) {
        end = "(" + end + ")";
      }
      str += ":" + end;
      return str;
    }
    toJSON() {
      return {
        mathjs: name215,
        start: this.start,
        end: this.end,
        step: this.step
      };
    }
    static fromJSON(json) {
      return new RangeNode(json.start, json.end, json.step);
    }
    toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
      var str;
      var start = this.start.toHTML(options);
      if (parens.start) {
        start = '<span class="math-parenthesis math-round-parenthesis">(</span>' + start + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      str = start;
      if (this.step) {
        var step = this.step.toHTML(options);
        if (parens.step) {
          step = '<span class="math-parenthesis math-round-parenthesis">(</span>' + step + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        str += '<span class="math-operator math-range-operator">:</span>' + step;
      }
      var end = this.end.toHTML(options);
      if (parens.end) {
        end = '<span class="math-parenthesis math-round-parenthesis">(</span>' + end + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      str += '<span class="math-operator math-range-operator">:</span>' + end;
      return str;
    }
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
      var str = this.start.toTex(options);
      if (parens.start) {
        str = "\\left(".concat(str, "\\right)");
      }
      if (this.step) {
        var step = this.step.toTex(options);
        if (parens.step) {
          step = "\\left(".concat(step, "\\right)");
        }
        str += ":" + step;
      }
      var end = this.end.toTex(options);
      if (parens.end) {
        end = "\\left(".concat(end, "\\right)");
      }
      str += ":" + end;
      return str;
    }
  }
  defineProperty13.default(RangeNode, "name", name215);
  return RangeNode;
}, {
  isClass: true,
  isNode: true
});
// ../../node_modules/mathjs/lib/esm/expression/node/RelationalNode.js
var defineProperty14 = __toESM(require_defineProperty(), 1);
var name216 = "RelationalNode";
var dependencies216 = ["Node"];
var createRelationalNode = factory(name216, dependencies216, (_ref) => {
  var {
    Node
  } = _ref;
  var operatorMap = {
    equal: "==",
    unequal: "!=",
    smaller: "<",
    larger: ">",
    smallerEq: "<=",
    largerEq: ">="
  };

  class RelationalNode extends Node {
    constructor(conditionals, params) {
      super();
      if (!Array.isArray(conditionals)) {
        throw new TypeError("Parameter conditionals must be an array");
      }
      if (!Array.isArray(params)) {
        throw new TypeError("Parameter params must be an array");
      }
      if (conditionals.length !== params.length - 1) {
        throw new TypeError("Parameter params must contain exactly one more element " + "than parameter conditionals");
      }
      this.conditionals = conditionals;
      this.params = params;
    }
    get type() {
      return name216;
    }
    get isRelationalNode() {
      return true;
    }
    _compile(math, argNames) {
      var self2 = this;
      var compiled = this.params.map((p) => p._compile(math, argNames));
      return function evalRelationalNode(scope, args, context2) {
        var evalLhs;
        var evalRhs = compiled[0](scope, args, context2);
        for (var i = 0;i < self2.conditionals.length; i++) {
          evalLhs = evalRhs;
          evalRhs = compiled[i + 1](scope, args, context2);
          var condFn = getSafeProperty(math, self2.conditionals[i]);
          if (!condFn(evalLhs, evalRhs)) {
            return false;
          }
        }
        return true;
      };
    }
    forEach(callback) {
      this.params.forEach((n, i) => callback(n, "params[" + i + "]", this), this);
    }
    map(callback) {
      return new RelationalNode(this.conditionals.slice(), this.params.map((n, i) => this._ifNode(callback(n, "params[" + i + "]", this)), this));
    }
    clone() {
      return new RelationalNode(this.conditionals, this.params);
    }
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var paramStrings = this.params.map(function(p, index) {
        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "(" + p.toString(options) + ")" : p.toString(options);
      });
      var ret = paramStrings[0];
      for (var i = 0;i < this.conditionals.length; i++) {
        ret += " " + operatorMap[this.conditionals[i]];
        ret += " " + paramStrings[i + 1];
      }
      return ret;
    }
    toJSON() {
      return {
        mathjs: name216,
        conditionals: this.conditionals,
        params: this.params
      };
    }
    static fromJSON(json) {
      return new RelationalNode(json.conditionals, json.params);
    }
    toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var paramStrings = this.params.map(function(p, index) {
        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + p.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : p.toHTML(options);
      });
      var ret = paramStrings[0];
      for (var i = 0;i < this.conditionals.length; i++) {
        ret += '<span class="math-operator math-binary-operator ' + 'math-explicit-binary-operator">' + escape(operatorMap[this.conditionals[i]]) + "</span>" + paramStrings[i + 1];
      }
      return ret;
    }
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var paramStrings = this.params.map(function(p, index) {
        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "\\left(" + p.toTex(options) + "\right)" : p.toTex(options);
      });
      var ret = paramStrings[0];
      for (var i = 0;i < this.conditionals.length; i++) {
        ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];
      }
      return ret;
    }
  }
  defineProperty14.default(RelationalNode, "name", name216);
  return RelationalNode;
}, {
  isClass: true,
  isNode: true
});
// ../../node_modules/mathjs/lib/esm/expression/node/SymbolNode.js
var name217 = "SymbolNode";
var dependencies217 = ["math", "?Unit", "Node"];
var createSymbolNode = factory(name217, dependencies217, (_ref) => {
  var {
    math,
    Unit,
    Node
  } = _ref;
  function isValuelessUnit(name218) {
    return Unit ? Unit.isValuelessUnit(name218) : false;
  }

  class SymbolNode extends Node {
    constructor(name218) {
      super();
      if (typeof name218 !== "string") {
        throw new TypeError('String expected for parameter "name"');
      }
      this.name = name218;
    }
    get type() {
      return "SymbolNode";
    }
    get isSymbolNode() {
      return true;
    }
    _compile(math2, argNames) {
      var name218 = this.name;
      if (argNames[name218] === true) {
        return function(scope, args, context2) {
          return args[name218];
        };
      } else if (name218 in math2) {
        return function(scope, args, context2) {
          return scope.has(name218) ? scope.get(name218) : getSafeProperty(math2, name218);
        };
      } else {
        var isUnit2 = isValuelessUnit(name218);
        return function(scope, args, context2) {
          return scope.has(name218) ? scope.get(name218) : isUnit2 ? new Unit(null, name218) : SymbolNode.onUndefinedSymbol(name218);
        };
      }
    }
    forEach(callback) {
    }
    map(callback) {
      return this.clone();
    }
    static onUndefinedSymbol(name218) {
      throw new Error("Undefined symbol " + name218);
    }
    clone() {
      return new SymbolNode(this.name);
    }
    _toString(options) {
      return this.name;
    }
    toHTML(options) {
      var name218 = escape(this.name);
      if (name218 === "true" || name218 === "false") {
        return '<span class="math-symbol math-boolean">' + name218 + "</span>";
      } else if (name218 === "i") {
        return '<span class="math-symbol math-imaginary-symbol">' + name218 + "</span>";
      } else if (name218 === "Infinity") {
        return '<span class="math-symbol math-infinity-symbol">' + name218 + "</span>";
      } else if (name218 === "NaN") {
        return '<span class="math-symbol math-nan-symbol">' + name218 + "</span>";
      } else if (name218 === "null") {
        return '<span class="math-symbol math-null-symbol">' + name218 + "</span>";
      } else if (name218 === "undefined") {
        return '<span class="math-symbol math-undefined-symbol">' + name218 + "</span>";
      }
      return '<span class="math-symbol">' + name218 + "</span>";
    }
    toJSON() {
      return {
        mathjs: "SymbolNode",
        name: this.name
      };
    }
    static fromJSON(json) {
      return new SymbolNode(json.name);
    }
    _toTex(options) {
      var isUnit2 = false;
      if (typeof math[this.name] === "undefined" && isValuelessUnit(this.name)) {
        isUnit2 = true;
      }
      var symbol = toSymbol(this.name, isUnit2);
      if (symbol[0] === "\\") {
        return symbol;
      }
      return " " + symbol;
    }
  }
  return SymbolNode;
}, {
  isClass: true,
  isNode: true
});
// ../../node_modules/mathjs/lib/esm/expression/node/FunctionNode.js
var defineProperty15 = __toESM(require_defineProperty(), 1);

// ../../node_modules/mathjs/lib/esm/utils/scope.js
function createSubScope(parentScope) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (typeof parentScope.createSubScope === "function") {
    return assign(parentScope.createSubScope(), ...args);
  }
  return assign(createEmptyMap(), parentScope, ...args);
}

// ../../node_modules/mathjs/lib/esm/expression/node/FunctionNode.js
var name218 = "FunctionNode";
var dependencies218 = ["math", "Node", "SymbolNode"];
var createFunctionNode = factory(name218, dependencies218, (_ref) => {
  var {
    math,
    Node,
    SymbolNode
  } = _ref;
  var strin = (entity) => format3(entity, {
    truncate: 78
  });
  function expandTemplate(template, node, options) {
    var latex7 = "";
    var regex = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi;
    var inputPos = 0;
    var match;
    while ((match = regex.exec(template)) !== null) {
      latex7 += template.substring(inputPos, match.index);
      inputPos = match.index;
      if (match[0] === "$$") {
        latex7 += "$";
        inputPos++;
      } else {
        inputPos += match[0].length;
        var property = node[match[1]];
        if (!property) {
          throw new ReferenceError("Template: Property " + match[1] + " does not exist.");
        }
        if (match[2] === undefined) {
          switch (typeof property) {
            case "string":
              latex7 += property;
              break;
            case "object":
              if (isNode(property)) {
                latex7 += property.toTex(options);
              } else if (Array.isArray(property)) {
                latex7 += property.map(function(arg, index) {
                  if (isNode(arg)) {
                    return arg.toTex(options);
                  }
                  throw new TypeError("Template: " + match[1] + "[" + index + "] is not a Node.");
                }).join(",");
              } else {
                throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
              }
              break;
            default:
              throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
          }
        } else {
          if (isNode(property[match[2]] && property[match[2]])) {
            latex7 += property[match[2]].toTex(options);
          } else {
            throw new TypeError("Template: " + match[1] + "[" + match[2] + "] is not a Node.");
          }
        }
      }
    }
    latex7 += template.slice(inputPos);
    return latex7;
  }

  class FunctionNode extends Node {
    constructor(fn, args) {
      super();
      if (typeof fn === "string") {
        fn = new SymbolNode(fn);
      }
      if (!isNode(fn))
        throw new TypeError('Node expected as parameter "fn"');
      if (!Array.isArray(args) || !args.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      }
      this.fn = fn;
      this.args = args || [];
    }
    get name() {
      return this.fn.name || "";
    }
    get type() {
      return name218;
    }
    get isFunctionNode() {
      return true;
    }
    _compile(math2, argNames) {
      var evalArgs = this.args.map((arg) => arg._compile(math2, argNames));
      if (isSymbolNode(this.fn)) {
        var _name = this.fn.name;
        if (!argNames[_name]) {
          var fn = _name in math2 ? getSafeProperty(math2, _name) : undefined;
          var isRaw = typeof fn === "function" && fn.rawArgs === true;
          var resolveFn = (scope2) => {
            var value;
            if (scope2.has(_name)) {
              value = scope2.get(_name);
            } else if (_name in math2) {
              value = getSafeProperty(math2, _name);
            } else {
              return FunctionNode.onUndefinedFunction(_name);
            }
            if (typeof value === "function") {
              return value;
            }
            throw new TypeError("'".concat(_name, "' is not a function; its value is:\n  ").concat(strin(value)));
          };
          if (isRaw) {
            var rawArgs = this.args;
            return function evalFunctionNode(scope2, args, context2) {
              var fn2 = resolveFn(scope2);
              return fn2(rawArgs, math2, createSubScope(scope2, args), scope2);
            };
          } else {
            switch (evalArgs.length) {
              case 0:
                return function evalFunctionNode(scope2, args, context2) {
                  var fn2 = resolveFn(scope2);
                  return fn2();
                };
              case 1:
                return function evalFunctionNode(scope2, args, context2) {
                  var fn2 = resolveFn(scope2);
                  var evalArg0 = evalArgs[0];
                  return fn2(evalArg0(scope2, args, context2));
                };
              case 2:
                return function evalFunctionNode(scope2, args, context2) {
                  var fn2 = resolveFn(scope2);
                  var evalArg0 = evalArgs[0];
                  var evalArg1 = evalArgs[1];
                  return fn2(evalArg0(scope2, args, context2), evalArg1(scope2, args, context2));
                };
              default:
                return function evalFunctionNode(scope2, args, context2) {
                  var fn2 = resolveFn(scope2);
                  var values = evalArgs.map((evalArg) => evalArg(scope2, args, context2));
                  return fn2(...values);
                };
            }
          }
        } else {
          var _rawArgs = this.args;
          return function evalFunctionNode(scope2, args, context2) {
            var fn2 = args[_name];
            if (typeof fn2 !== "function") {
              throw new TypeError("Argument '".concat(_name, "' was not a function; received: ").concat(strin(fn2)));
            }
            if (fn2.rawArgs) {
              return fn2(_rawArgs, math2, createSubScope(scope2, args), scope2);
            } else {
              var values = evalArgs.map((evalArg) => evalArg(scope2, args, context2));
              return fn2.apply(fn2, values);
            }
          };
        }
      } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {
        var evalObject = this.fn.object._compile(math2, argNames);
        var prop = this.fn.index.getObjectProperty();
        var _rawArgs2 = this.args;
        return function evalFunctionNode(scope2, args, context2) {
          var object24 = evalObject(scope2, args, context2);
          validateSafeMethod(object24, prop);
          var isRaw2 = object24[prop] && object24[prop].rawArgs;
          if (isRaw2) {
            return object24[prop](_rawArgs2, math2, createSubScope(scope2, args), scope2);
          } else {
            var values = evalArgs.map((evalArg) => evalArg(scope2, args, context2));
            return object24[prop].apply(object24, values);
          }
        };
      } else {
        var fnExpr = this.fn.toString();
        var evalFn = this.fn._compile(math2, argNames);
        var _rawArgs3 = this.args;
        return function evalFunctionNode(scope2, args, context2) {
          var fn2 = evalFn(scope2, args, context2);
          if (typeof fn2 !== "function") {
            throw new TypeError("Expression '".concat(fnExpr, "' did not evaluate to a function; value is:") + "\n  ".concat(strin(fn2)));
          }
          if (fn2.rawArgs) {
            return fn2(_rawArgs3, math2, createSubScope(scope2, args), scope2);
          } else {
            var values = evalArgs.map((evalArg) => evalArg(scope2, args, context2));
            return fn2.apply(fn2, values);
          }
        };
      }
    }
    forEach(callback) {
      callback(this.fn, "fn", this);
      for (var i = 0;i < this.args.length; i++) {
        callback(this.args[i], "args[" + i + "]", this);
      }
    }
    map(callback) {
      var fn = this._ifNode(callback(this.fn, "fn", this));
      var args = [];
      for (var i = 0;i < this.args.length; i++) {
        args[i] = this._ifNode(callback(this.args[i], "args[" + i + "]", this));
      }
      return new FunctionNode(fn, args);
    }
    clone() {
      return new FunctionNode(this.fn, this.args.slice(0));
    }
    toString(options) {
      var customString;
      var name219 = this.fn.toString(options);
      if (options && typeof options.handler === "object" && hasOwnProperty2(options.handler, name219)) {
        customString = options.handler[name219](this, options);
      }
      if (typeof customString !== "undefined") {
        return customString;
      }
      return super.toString(options);
    }
    _toString(options) {
      var args = this.args.map(function(arg) {
        return arg.toString(options);
      });
      var fn = isFunctionAssignmentNode(this.fn) ? "(" + this.fn.toString(options) + ")" : this.fn.toString(options);
      return fn + "(" + args.join(", ") + ")";
    }
    toJSON() {
      return {
        mathjs: name218,
        fn: this.fn,
        args: this.args
      };
    }
    toHTML(options) {
      var args = this.args.map(function(arg) {
        return arg.toHTML(options);
      });
      return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + args.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
    }
    toTex(options) {
      var customTex;
      if (options && typeof options.handler === "object" && hasOwnProperty2(options.handler, this.name)) {
        customTex = options.handler[this.name](this, options);
      }
      if (typeof customTex !== "undefined") {
        return customTex;
      }
      return super.toTex(options);
    }
    _toTex(options) {
      var args = this.args.map(function(arg) {
        return arg.toTex(options);
      });
      var latexConverter;
      if (latexFunctions[this.name]) {
        latexConverter = latexFunctions[this.name];
      }
      if (math[this.name] && (typeof math[this.name].toTex === "function" || typeof math[this.name].toTex === "object" || typeof math[this.name].toTex === "string")) {
        latexConverter = math[this.name].toTex;
      }
      var customToTex;
      switch (typeof latexConverter) {
        case "function":
          customToTex = latexConverter(this, options);
          break;
        case "string":
          customToTex = expandTemplate(latexConverter, this, options);
          break;
        case "object":
          switch (typeof latexConverter[args.length]) {
            case "function":
              customToTex = latexConverter[args.length](this, options);
              break;
            case "string":
              customToTex = expandTemplate(latexConverter[args.length], this, options);
              break;
          }
      }
      if (typeof customToTex !== "undefined") {
        return customToTex;
      }
      return expandTemplate(defaultTemplate, this, options);
    }
    getIdentifier() {
      return this.type + ":" + this.name;
    }
  }
  defineProperty15.default(FunctionNode, "name", name218);
  defineProperty15.default(FunctionNode, "onUndefinedFunction", function(name219) {
    throw new Error("Undefined function " + name219);
  });
  defineProperty15.default(FunctionNode, "fromJSON", function(json) {
    return new FunctionNode(json.fn, json.args);
  });
  return FunctionNode;
}, {
  isClass: true,
  isNode: true
});
// ../../node_modules/mathjs/lib/esm/expression/parse.js
var extends4 = __toESM(require_extends(), 1);
var name219 = "parse";
var dependencies219 = ["typed", "numeric", "config", "AccessorNode", "ArrayNode", "AssignmentNode", "BlockNode", "ConditionalNode", "ConstantNode", "FunctionAssignmentNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "RangeNode", "RelationalNode", "SymbolNode"];
var createParse = factory(name219, dependencies219, (_ref) => {
  var {
    typed,
    numeric: numeric2,
    config: config6,
    AccessorNode,
    ArrayNode,
    AssignmentNode,
    BlockNode,
    ConditionalNode,
    ConstantNode,
    FunctionAssignmentNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    ParenthesisNode,
    RangeNode,
    RelationalNode,
    SymbolNode
  } = _ref;
  var parse = typed(name219, {
    string: function string(expression) {
      return parseStart(expression, {});
    },
    "Array | Matrix": function ArrayMatrix(expressions) {
      return parseMultiple(expressions, {});
    },
    "string, Object": function stringObject(expression, options) {
      var extraNodes = options.nodes !== undefined ? options.nodes : {};
      return parseStart(expression, extraNodes);
    },
    "Array | Matrix, Object": parseMultiple
  });
  function parseMultiple(expressions) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var extraNodes = options.nodes !== undefined ? options.nodes : {};
    return deepMap(expressions, function(elem) {
      if (typeof elem !== "string")
        throw new TypeError("String expected");
      return parseStart(elem, extraNodes);
    });
  }
  var TOKENTYPE = {
    NULL: 0,
    DELIMITER: 1,
    NUMBER: 2,
    SYMBOL: 3,
    UNKNOWN: 4
  };
  var DELIMITERS = {
    ",": true,
    "(": true,
    ")": true,
    "[": true,
    "]": true,
    "{": true,
    "}": true,
    '"': true,
    "\'": true,
    ";": true,
    "+": true,
    "-": true,
    "*": true,
    ".*": true,
    "/": true,
    "./": true,
    "%": true,
    "^": true,
    ".^": true,
    "~": true,
    "!": true,
    "&": true,
    "|": true,
    "^|": true,
    "=": true,
    ":": true,
    "?": true,
    "==": true,
    "!=": true,
    "<": true,
    ">": true,
    "<=": true,
    ">=": true,
    "<<": true,
    ">>": true,
    ">>>": true
  };
  var NAMED_DELIMITERS = {
    mod: true,
    to: true,
    in: true,
    and: true,
    xor: true,
    or: true,
    not: true
  };
  var CONSTANTS = {
    true: true,
    false: false,
    null: null,
    undefined: undefined
  };
  var NUMERIC_CONSTANTS = ["NaN", "Infinity"];
  function initialState() {
    return {
      extraNodes: {},
      expression: "",
      comment: "",
      index: 0,
      token: "",
      tokenType: TOKENTYPE.NULL,
      nestingLevel: 0,
      conditionalLevel: null
    };
  }
  function currentString(state, length) {
    return state.expression.substr(state.index, length);
  }
  function currentCharacter(state) {
    return currentString(state, 1);
  }
  function next(state) {
    state.index++;
  }
  function prevCharacter(state) {
    return state.expression.charAt(state.index - 1);
  }
  function nextCharacter(state) {
    return state.expression.charAt(state.index + 1);
  }
  function getToken(state) {
    state.tokenType = TOKENTYPE.NULL;
    state.token = "";
    state.comment = "";
    while (true) {
      if (currentCharacter(state) === "#") {
        while (currentCharacter(state) !== "\n" && currentCharacter(state) !== "") {
          state.comment += currentCharacter(state);
          next(state);
        }
      }
      if (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {
        next(state);
      } else {
        break;
      }
    }
    if (currentCharacter(state) === "") {
      state.tokenType = TOKENTYPE.DELIMITER;
      return;
    }
    if (currentCharacter(state) === "\n" && !state.nestingLevel) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = currentCharacter(state);
      next(state);
      return;
    }
    var c1 = currentCharacter(state);
    var c2 = currentString(state, 2);
    var c3 = currentString(state, 3);
    if (c3.length === 3 && DELIMITERS[c3]) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = c3;
      next(state);
      next(state);
      next(state);
      return;
    }
    if (c2.length === 2 && DELIMITERS[c2]) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = c2;
      next(state);
      next(state);
      return;
    }
    if (DELIMITERS[c1]) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = c1;
      next(state);
      return;
    }
    if (parse.isDigitDot(c1)) {
      state.tokenType = TOKENTYPE.NUMBER;
      var _c = currentString(state, 2);
      if (_c === "0b" || _c === "0o" || _c === "0x") {
        state.token += currentCharacter(state);
        next(state);
        state.token += currentCharacter(state);
        next(state);
        while (parse.isHexDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (currentCharacter(state) === ".") {
          state.token += ".";
          next(state);
          while (parse.isHexDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
        } else if (currentCharacter(state) === "i") {
          state.token += "i";
          next(state);
          while (parse.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
        }
        return;
      }
      if (currentCharacter(state) === ".") {
        state.token += currentCharacter(state);
        next(state);
        if (!parse.isDigit(currentCharacter(state))) {
          state.tokenType = TOKENTYPE.DELIMITER;
          return;
        }
      } else {
        while (parse.isDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
      }
      while (parse.isDigit(currentCharacter(state))) {
        state.token += currentCharacter(state);
        next(state);
      }
      if (currentCharacter(state) === "E" || currentCharacter(state) === "e") {
        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === "-" || nextCharacter(state) === "+") {
          state.token += currentCharacter(state);
          next(state);
          if (currentCharacter(state) === "+" || currentCharacter(state) === "-") {
            state.token += currentCharacter(state);
            next(state);
          }
          if (!parse.isDigit(currentCharacter(state))) {
            throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
          }
          while (parse.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
            throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
          }
        } else if (nextCharacter(state) === ".") {
          next(state);
          throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
        }
      }
      return;
    }
    if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {
      while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {
        state.token += currentCharacter(state);
        next(state);
      }
      if (hasOwnProperty2(NAMED_DELIMITERS, state.token)) {
        state.tokenType = TOKENTYPE.DELIMITER;
      } else {
        state.tokenType = TOKENTYPE.SYMBOL;
      }
      return;
    }
    state.tokenType = TOKENTYPE.UNKNOWN;
    while (currentCharacter(state) !== "") {
      state.token += currentCharacter(state);
      next(state);
    }
    throw createSyntaxError(state, 'Syntax error in part "' + state.token + '"');
  }
  function getTokenSkipNewline(state) {
    do {
      getToken(state);
    } while (state.token === "\n");
  }
  function openParams(state) {
    state.nestingLevel++;
  }
  function closeParams(state) {
    state.nestingLevel--;
  }
  parse.isAlpha = function isAlpha(c, cPrev, cNext) {
    return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);
  };
  parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {
    return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c);
  };
  parse.isValidMathSymbol = function isValidMathSymbol(high, low) {
    return /^[\uD835]$/.test(high) && /^[\uDC00-\uDFFF]$/.test(low) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
  };
  parse.isWhitespace = function isWhitespace(c, nestingLevel) {
    return c === " " || c === "\t" || c === "\n" && nestingLevel > 0;
  };
  parse.isDecimalMark = function isDecimalMark(c, cNext) {
    return c === "." && cNext !== "/" && cNext !== "*" && cNext !== "^";
  };
  parse.isDigitDot = function isDigitDot(c) {
    return c >= "0" && c <= "9" || c === ".";
  };
  parse.isDigit = function isDigit(c) {
    return c >= "0" && c <= "9";
  };
  parse.isHexDigit = function isHexDigit(c) {
    return c >= "0" && c <= "9" || c >= "a" && c <= "f" || c >= "A" && c <= "F";
  };
  function parseStart(expression, extraNodes) {
    var state = initialState();
    extends4.default(state, {
      expression,
      extraNodes
    });
    getToken(state);
    var node = parseBlock(state);
    if (state.token !== "") {
      if (state.tokenType === TOKENTYPE.DELIMITER) {
        throw createError(state, "Unexpected operator " + state.token);
      } else {
        throw createSyntaxError(state, 'Unexpected part "' + state.token + '"');
      }
    }
    return node;
  }
  function parseBlock(state) {
    var node;
    var blocks = [];
    var visible;
    if (state.token !== "" && state.token !== "\n" && state.token !== ";") {
      node = parseAssignment(state);
      if (state.comment) {
        node.comment = state.comment;
      }
    }
    while (state.token === "\n" || state.token === ";") {
      if (blocks.length === 0 && node) {
        visible = state.token !== ";";
        blocks.push({
          node,
          visible
        });
      }
      getToken(state);
      if (state.token !== "\n" && state.token !== ";" && state.token !== "") {
        node = parseAssignment(state);
        if (state.comment) {
          node.comment = state.comment;
        }
        visible = state.token !== ";";
        blocks.push({
          node,
          visible
        });
      }
    }
    if (blocks.length > 0) {
      return new BlockNode(blocks);
    } else {
      if (!node) {
        node = new ConstantNode(undefined);
        if (state.comment) {
          node.comment = state.comment;
        }
      }
      return node;
    }
  }
  function parseAssignment(state) {
    var name220, args, value, valid;
    var node = parseConditional(state);
    if (state.token === "=") {
      if (isSymbolNode(node)) {
        name220 = node.name;
        getTokenSkipNewline(state);
        value = parseAssignment(state);
        return new AssignmentNode(new SymbolNode(name220), value);
      } else if (isAccessorNode(node)) {
        getTokenSkipNewline(state);
        value = parseAssignment(state);
        return new AssignmentNode(node.object, node.index, value);
      } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {
        valid = true;
        args = [];
        name220 = node.name;
        node.args.forEach(function(arg, index) {
          if (isSymbolNode(arg)) {
            args[index] = arg.name;
          } else {
            valid = false;
          }
        });
        if (valid) {
          getTokenSkipNewline(state);
          value = parseAssignment(state);
          return new FunctionAssignmentNode(name220, args, value);
        }
      }
      throw createSyntaxError(state, "Invalid left hand side of assignment operator =");
    }
    return node;
  }
  function parseConditional(state) {
    var node = parseLogicalOr(state);
    while (state.token === "?") {
      var prev = state.conditionalLevel;
      state.conditionalLevel = state.nestingLevel;
      getTokenSkipNewline(state);
      var condition = node;
      var trueExpr = parseAssignment(state);
      if (state.token !== ":")
        throw createSyntaxError(state, "False part of conditional expression expected");
      state.conditionalLevel = null;
      getTokenSkipNewline(state);
      var falseExpr = parseAssignment(state);
      node = new ConditionalNode(condition, trueExpr, falseExpr);
      state.conditionalLevel = prev;
    }
    return node;
  }
  function parseLogicalOr(state) {
    var node = parseLogicalXor(state);
    while (state.token === "or") {
      getTokenSkipNewline(state);
      node = new OperatorNode("or", "or", [node, parseLogicalXor(state)]);
    }
    return node;
  }
  function parseLogicalXor(state) {
    var node = parseLogicalAnd(state);
    while (state.token === "xor") {
      getTokenSkipNewline(state);
      node = new OperatorNode("xor", "xor", [node, parseLogicalAnd(state)]);
    }
    return node;
  }
  function parseLogicalAnd(state) {
    var node = parseBitwiseOr(state);
    while (state.token === "and") {
      getTokenSkipNewline(state);
      node = new OperatorNode("and", "and", [node, parseBitwiseOr(state)]);
    }
    return node;
  }
  function parseBitwiseOr(state) {
    var node = parseBitwiseXor(state);
    while (state.token === "|") {
      getTokenSkipNewline(state);
      node = new OperatorNode("|", "bitOr", [node, parseBitwiseXor(state)]);
    }
    return node;
  }
  function parseBitwiseXor(state) {
    var node = parseBitwiseAnd(state);
    while (state.token === "^|") {
      getTokenSkipNewline(state);
      node = new OperatorNode("^|", "bitXor", [node, parseBitwiseAnd(state)]);
    }
    return node;
  }
  function parseBitwiseAnd(state) {
    var node = parseRelational(state);
    while (state.token === "&") {
      getTokenSkipNewline(state);
      node = new OperatorNode("&", "bitAnd", [node, parseRelational(state)]);
    }
    return node;
  }
  function parseRelational(state) {
    var params = [parseShift(state)];
    var conditionals = [];
    var operators7 = {
      "==": "equal",
      "!=": "unequal",
      "<": "smaller",
      ">": "larger",
      "<=": "smallerEq",
      ">=": "largerEq"
    };
    while (hasOwnProperty2(operators7, state.token)) {
      var cond = {
        name: state.token,
        fn: operators7[state.token]
      };
      conditionals.push(cond);
      getTokenSkipNewline(state);
      params.push(parseShift(state));
    }
    if (params.length === 1) {
      return params[0];
    } else if (params.length === 2) {
      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);
    } else {
      return new RelationalNode(conditionals.map((c) => c.fn), params);
    }
  }
  function parseShift(state) {
    var node, name220, fn, params;
    node = parseConversion(state);
    var operators7 = {
      "<<": "leftShift",
      ">>": "rightArithShift",
      ">>>": "rightLogShift"
    };
    while (hasOwnProperty2(operators7, state.token)) {
      name220 = state.token;
      fn = operators7[name220];
      getTokenSkipNewline(state);
      params = [node, parseConversion(state)];
      node = new OperatorNode(name220, fn, params);
    }
    return node;
  }
  function parseConversion(state) {
    var node, name220, fn, params;
    node = parseRange(state);
    var operators7 = {
      to: "to",
      in: "to"
    };
    while (hasOwnProperty2(operators7, state.token)) {
      name220 = state.token;
      fn = operators7[name220];
      getTokenSkipNewline(state);
      if (name220 === "in" && state.token === "") {
        node = new OperatorNode("*", "multiply", [node, new SymbolNode("in")], true);
      } else {
        params = [node, parseRange(state)];
        node = new OperatorNode(name220, fn, params);
      }
    }
    return node;
  }
  function parseRange(state) {
    var node;
    var params = [];
    if (state.token === ":") {
      node = new ConstantNode(1);
    } else {
      node = parseAddSubtract(state);
    }
    if (state.token === ":" && state.conditionalLevel !== state.nestingLevel) {
      params.push(node);
      while (state.token === ":" && params.length < 3) {
        getTokenSkipNewline(state);
        if (state.token === ")" || state.token === "]" || state.token === "," || state.token === "") {
          params.push(new SymbolNode("end"));
        } else {
          params.push(parseAddSubtract(state));
        }
      }
      if (params.length === 3) {
        node = new RangeNode(params[0], params[2], params[1]);
      } else {
        node = new RangeNode(params[0], params[1]);
      }
    }
    return node;
  }
  function parseAddSubtract(state) {
    var node, name220, fn, params;
    node = parseMultiplyDivide(state);
    var operators7 = {
      "+": "add",
      "-": "subtract"
    };
    while (hasOwnProperty2(operators7, state.token)) {
      name220 = state.token;
      fn = operators7[name220];
      getTokenSkipNewline(state);
      var rightNode = parseMultiplyDivide(state);
      if (rightNode.isPercentage) {
        params = [node, new OperatorNode("*", "multiply", [node, rightNode])];
      } else {
        params = [node, rightNode];
      }
      node = new OperatorNode(name220, fn, params);
    }
    return node;
  }
  function parseMultiplyDivide(state) {
    var node, last, name220, fn;
    node = parseImplicitMultiplication(state);
    last = node;
    var operators7 = {
      "*": "multiply",
      ".*": "dotMultiply",
      "/": "divide",
      "./": "dotDivide"
    };
    while (true) {
      if (hasOwnProperty2(operators7, state.token)) {
        name220 = state.token;
        fn = operators7[name220];
        getTokenSkipNewline(state);
        last = parseImplicitMultiplication(state);
        node = new OperatorNode(name220, fn, [node, last]);
      } else {
        break;
      }
    }
    return node;
  }
  function parseImplicitMultiplication(state) {
    var node, last;
    node = parseRule2(state);
    last = node;
    while (true) {
      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "in" && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === "!") || state.token === "(") {
        last = parseRule2(state);
        node = new OperatorNode("*", "multiply", [node, last], true);
      } else {
        break;
      }
    }
    return node;
  }
  function parseRule2(state) {
    var node = parsePercentage(state);
    var last = node;
    var tokenStates = [];
    while (true) {
      if (state.token === "/" && rule2Node(last)) {
        tokenStates.push(extends4.default({}, state));
        getTokenSkipNewline(state);
        if (state.tokenType === TOKENTYPE.NUMBER) {
          tokenStates.push(extends4.default({}, state));
          getTokenSkipNewline(state);
          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "(") {
            extends4.default(state, tokenStates.pop());
            tokenStates.pop();
            last = parsePercentage(state);
            node = new OperatorNode("/", "divide", [node, last]);
          } else {
            tokenStates.pop();
            extends4.default(state, tokenStates.pop());
            break;
          }
        } else {
          extends4.default(state, tokenStates.pop());
          break;
        }
      } else {
        break;
      }
    }
    return node;
  }
  function parsePercentage(state) {
    var node, name220, fn, params;
    node = parseUnary(state);
    var operators7 = {
      "%": "mod",
      mod: "mod"
    };
    while (hasOwnProperty2(operators7, state.token)) {
      name220 = state.token;
      fn = operators7[name220];
      getTokenSkipNewline(state);
      if (name220 === "%" && state.tokenType === TOKENTYPE.DELIMITER && state.token !== "(") {
        node = new OperatorNode("/", "divide", [node, new ConstantNode(100)], false, true);
      } else {
        params = [node, parseUnary(state)];
        node = new OperatorNode(name220, fn, params);
      }
    }
    return node;
  }
  function parseUnary(state) {
    var name220, params, fn;
    var operators7 = {
      "-": "unaryMinus",
      "+": "unaryPlus",
      "~": "bitNot",
      not: "not"
    };
    if (hasOwnProperty2(operators7, state.token)) {
      fn = operators7[state.token];
      name220 = state.token;
      getTokenSkipNewline(state);
      params = [parseUnary(state)];
      return new OperatorNode(name220, fn, params);
    }
    return parsePow(state);
  }
  function parsePow(state) {
    var node, name220, fn, params;
    node = parseLeftHandOperators(state);
    if (state.token === "^" || state.token === ".^") {
      name220 = state.token;
      fn = name220 === "^" ? "pow" : "dotPow";
      getTokenSkipNewline(state);
      params = [node, parseUnary(state)];
      node = new OperatorNode(name220, fn, params);
    }
    return node;
  }
  function parseLeftHandOperators(state) {
    var node, name220, fn, params;
    node = parseCustomNodes(state);
    var operators7 = {
      "!": "factorial",
      "\'": "ctranspose"
    };
    while (hasOwnProperty2(operators7, state.token)) {
      name220 = state.token;
      fn = operators7[name220];
      getToken(state);
      params = [node];
      node = new OperatorNode(name220, fn, params);
      node = parseAccessors(state, node);
    }
    return node;
  }
  function parseCustomNodes(state) {
    var params = [];
    if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty2(state.extraNodes, state.token)) {
      var CustomNode = state.extraNodes[state.token];
      getToken(state);
      if (state.token === "(") {
        params = [];
        openParams(state);
        getToken(state);
        if (state.token !== ")") {
          params.push(parseAssignment(state));
          while (state.token === ",") {
            getToken(state);
            params.push(parseAssignment(state));
          }
        }
        if (state.token !== ")") {
          throw createSyntaxError(state, "Parenthesis ) expected");
        }
        closeParams(state);
        getToken(state);
      }
      return new CustomNode(params);
    }
    return parseSymbol(state);
  }
  function parseSymbol(state) {
    var node, name220;
    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
      name220 = state.token;
      getToken(state);
      if (hasOwnProperty2(CONSTANTS, name220)) {
        node = new ConstantNode(CONSTANTS[name220]);
      } else if (NUMERIC_CONSTANTS.indexOf(name220) !== -1) {
        node = new ConstantNode(numeric2(name220, "number"));
      } else {
        node = new SymbolNode(name220);
      }
      node = parseAccessors(state, node);
      return node;
    }
    return parseDoubleQuotesString(state);
  }
  function parseAccessors(state, node, types4) {
    var params;
    while ((state.token === "(" || state.token === "[" || state.token === ".") && (!types4 || types4.indexOf(state.token) !== -1)) {
      params = [];
      if (state.token === "(") {
        if (isSymbolNode(node) || isAccessorNode(node)) {
          openParams(state);
          getToken(state);
          if (state.token !== ")") {
            params.push(parseAssignment(state));
            while (state.token === ",") {
              getToken(state);
              params.push(parseAssignment(state));
            }
          }
          if (state.token !== ")") {
            throw createSyntaxError(state, "Parenthesis ) expected");
          }
          closeParams(state);
          getToken(state);
          node = new FunctionNode(node, params);
        } else {
          return node;
        }
      } else if (state.token === "[") {
        openParams(state);
        getToken(state);
        if (state.token !== "]") {
          params.push(parseAssignment(state));
          while (state.token === ",") {
            getToken(state);
            params.push(parseAssignment(state));
          }
        }
        if (state.token !== "]") {
          throw createSyntaxError(state, "Parenthesis ] expected");
        }
        closeParams(state);
        getToken(state);
        node = new AccessorNode(node, new IndexNode(params));
      } else {
        getToken(state);
        if (state.tokenType !== TOKENTYPE.SYMBOL) {
          throw createSyntaxError(state, "Property name expected after dot");
        }
        params.push(new ConstantNode(state.token));
        getToken(state);
        var dotNotation = true;
        node = new AccessorNode(node, new IndexNode(params, dotNotation));
      }
    }
    return node;
  }
  function parseDoubleQuotesString(state) {
    var node, str;
    if (state.token === '"') {
      str = parseDoubleQuotesStringToken(state);
      node = new ConstantNode(str);
      node = parseAccessors(state, node);
      return node;
    }
    return parseSingleQuotesString(state);
  }
  function parseDoubleQuotesStringToken(state) {
    var str = "";
    while (currentCharacter(state) !== "" && currentCharacter(state) !== '"') {
      if (currentCharacter(state) === "\\") {
        str += currentCharacter(state);
        next(state);
      }
      str += currentCharacter(state);
      next(state);
    }
    getToken(state);
    if (state.token !== '"') {
      throw createSyntaxError(state, 'End of string " expected');
    }
    getToken(state);
    return JSON.parse('"' + str + '"');
  }
  function parseSingleQuotesString(state) {
    var node, str;
    if (state.token === "\'") {
      str = parseSingleQuotesStringToken(state);
      node = new ConstantNode(str);
      node = parseAccessors(state, node);
      return node;
    }
    return parseMatrix(state);
  }
  function parseSingleQuotesStringToken(state) {
    var str = "";
    while (currentCharacter(state) !== "" && currentCharacter(state) !== "\'") {
      if (currentCharacter(state) === "\\") {
        str += currentCharacter(state);
        next(state);
      }
      str += currentCharacter(state);
      next(state);
    }
    getToken(state);
    if (state.token !== "\'") {
      throw createSyntaxError(state, "End of string \' expected");
    }
    getToken(state);
    return JSON.parse('"' + str + '"');
  }
  function parseMatrix(state) {
    var array47, params, rows, cols;
    if (state.token === "[") {
      openParams(state);
      getToken(state);
      if (state.token !== "]") {
        var row = parseRow(state);
        if (state.token === ";") {
          rows = 1;
          params = [row];
          while (state.token === ";") {
            getToken(state);
            params[rows] = parseRow(state);
            rows++;
          }
          if (state.token !== "]") {
            throw createSyntaxError(state, "End of matrix ] expected");
          }
          closeParams(state);
          getToken(state);
          cols = params[0].items.length;
          for (var r = 1;r < rows; r++) {
            if (params[r].items.length !== cols) {
              throw createError(state, "Column dimensions mismatch " + "(" + params[r].items.length + " !== " + cols + ")");
            }
          }
          array47 = new ArrayNode(params);
        } else {
          if (state.token !== "]") {
            throw createSyntaxError(state, "End of matrix ] expected");
          }
          closeParams(state);
          getToken(state);
          array47 = row;
        }
      } else {
        closeParams(state);
        getToken(state);
        array47 = new ArrayNode([]);
      }
      return parseAccessors(state, array47);
    }
    return parseObject(state);
  }
  function parseRow(state) {
    var params = [parseAssignment(state)];
    var len = 1;
    while (state.token === ",") {
      getToken(state);
      params[len] = parseAssignment(state);
      len++;
    }
    return new ArrayNode(params);
  }
  function parseObject(state) {
    if (state.token === "{") {
      openParams(state);
      var key;
      var properties2 = {};
      do {
        getToken(state);
        if (state.token !== "}") {
          if (state.token === '"') {
            key = parseDoubleQuotesStringToken(state);
          } else if (state.token === "\'") {
            key = parseSingleQuotesStringToken(state);
          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
            key = state.token;
            getToken(state);
          } else {
            throw createSyntaxError(state, "Symbol or string expected as object key");
          }
          if (state.token !== ":") {
            throw createSyntaxError(state, "Colon : expected after object key");
          }
          getToken(state);
          properties2[key] = parseAssignment(state);
        }
      } while (state.token === ",");
      if (state.token !== "}") {
        throw createSyntaxError(state, "Comma , or bracket } expected after object value");
      }
      closeParams(state);
      getToken(state);
      var node = new ObjectNode(properties2);
      node = parseAccessors(state, node);
      return node;
    }
    return parseNumber(state);
  }
  function parseNumber(state) {
    var numberStr;
    if (state.tokenType === TOKENTYPE.NUMBER) {
      numberStr = state.token;
      getToken(state);
      return new ConstantNode(numeric2(numberStr, config6.number));
    }
    return parseParentheses(state);
  }
  function parseParentheses(state) {
    var node;
    if (state.token === "(") {
      openParams(state);
      getToken(state);
      node = parseAssignment(state);
      if (state.token !== ")") {
        throw createSyntaxError(state, "Parenthesis ) expected");
      }
      closeParams(state);
      getToken(state);
      node = new ParenthesisNode(node);
      node = parseAccessors(state, node);
      return node;
    }
    return parseEnd(state);
  }
  function parseEnd(state) {
    if (state.token === "") {
      throw createSyntaxError(state, "Unexpected end of expression");
    } else {
      throw createSyntaxError(state, "Value expected");
    }
  }
  function col(state) {
    return state.index - state.token.length + 1;
  }
  function createSyntaxError(state, message) {
    var c = col(state);
    var error = new SyntaxError(message + " (char " + c + ")");
    error.char = c;
    return error;
  }
  function createError(state, message) {
    var c = col(state);
    var error = new SyntaxError(message + " (char " + c + ")");
    error.char = c;
    return error;
  }
  typed.addConversion({
    from: "string",
    to: "Node",
    convert: parse
  });
  return parse;
});
// ../../node_modules/mathjs/lib/esm/expression/function/compile.js
var name220 = "compile";
var dependencies220 = ["typed", "parse"];
var createCompile = factory(name220, dependencies220, (_ref) => {
  var {
    typed,
    parse
  } = _ref;
  return typed(name220, {
    string: function string(expr) {
      return parse(expr).compile();
    },
    "Array | Matrix": function ArrayMatrix(expr) {
      return deepMap(expr, function(entry) {
        return parse(entry).compile();
      });
    }
  });
});
// ../../node_modules/mathjs/lib/esm/expression/function/evaluate.js
var name221 = "evaluate";
var dependencies221 = ["typed", "parse"];
var createEvaluate = factory(name221, dependencies221, (_ref) => {
  var {
    typed,
    parse
  } = _ref;
  return typed(name221, {
    string: function string(expr) {
      var scope2 = createEmptyMap();
      return parse(expr).compile().evaluate(scope2);
    },
    "string, Map | Object": function stringMapObject(expr, scope2) {
      return parse(expr).compile().evaluate(scope2);
    },
    "Array | Matrix": function ArrayMatrix(expr) {
      var scope2 = createEmptyMap();
      return deepMap(expr, function(entry) {
        return parse(entry).compile().evaluate(scope2);
      });
    },
    "Array | Matrix, Map | Object": function ArrayMatrixMapObject(expr, scope2) {
      return deepMap(expr, function(entry) {
        return parse(entry).compile().evaluate(scope2);
      });
    }
  });
});
// ../../node_modules/mathjs/lib/esm/expression/Parser.js
var name222 = "Parser";
var dependencies222 = ["evaluate"];
var createParserClass = factory(name222, dependencies222, (_ref) => {
  var {
    evaluate
  } = _ref;
  function Parser() {
    if (!(this instanceof Parser)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    Object.defineProperty(this, "scope", {
      value: createEmptyMap(),
      writable: false
    });
  }
  Parser.prototype.type = "Parser";
  Parser.prototype.isParser = true;
  Parser.prototype.evaluate = function(expr) {
    return evaluate(expr, this.scope);
  };
  Parser.prototype.get = function(name223) {
    if (this.scope.has(name223)) {
      return this.scope.get(name223);
    }
  };
  Parser.prototype.getAll = function() {
    return toObject(this.scope);
  };
  Parser.prototype.getAllAsMap = function() {
    return this.scope;
  };
  Parser.prototype.set = function(name223, value) {
    this.scope.set(name223, value);
    return value;
  };
  Parser.prototype.remove = function(name223) {
    this.scope.delete(name223);
  };
  Parser.prototype.clear = function() {
    this.scope.clear();
  };
  return Parser;
}, {
  isClass: true
});
// ../../node_modules/mathjs/lib/esm/expression/function/parser.js
var name223 = "parser";
var dependencies223 = ["typed", "Parser"];
var createParser = factory(name223, dependencies223, (_ref) => {
  var {
    typed,
    Parser
  } = _ref;
  return typed(name223, {
    "": function _() {
      return new Parser;
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js
var name224 = "lup";
var dependencies224 = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtract", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"];
var createLup = factory(name224, dependencies224, (_ref) => {
  var {
    typed,
    matrix,
    abs: abs2,
    addScalar,
    divideScalar,
    multiplyScalar,
    subtract,
    larger,
    equalScalar,
    unaryMinus,
    DenseMatrix,
    SparseMatrix,
    Spa
  } = _ref;
  return typed(name224, {
    DenseMatrix: function DenseMatrix(m) {
      return _denseLUP(m);
    },
    SparseMatrix: function SparseMatrix(m) {
      return _sparseLUP(m);
    },
    Array: function Array(a) {
      var m = matrix(a);
      var r = _denseLUP(m);
      return {
        L: r.L.valueOf(),
        U: r.U.valueOf(),
        p: r.p
      };
    }
  });
  function _denseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var data = clone(m._data);
    var ldata = [];
    var lsize = [rows, n];
    var udata = [];
    var usize = [n, columns];
    var i, j, k;
    var p = [];
    for (i = 0;i < rows; i++) {
      p[i] = i;
    }
    for (j = 0;j < columns; j++) {
      if (j > 0) {
        for (i = 0;i < rows; i++) {
          var min2 = Math.min(i, j);
          var s = 0;
          for (k = 0;k < min2; k++) {
            s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));
          }
          data[i][j] = subtract(data[i][j], s);
        }
      }
      var pi2 = j;
      var pabsv = 0;
      var vjj = 0;
      for (i = j;i < rows; i++) {
        var v = data[i][j];
        var absv = abs2(v);
        if (larger(absv, pabsv)) {
          pi2 = i;
          pabsv = absv;
          vjj = v;
        }
      }
      if (j !== pi2) {
        p[j] = [p[pi2], p[pi2] = p[j]][0];
        DenseMatrix._swapRows(j, pi2, data);
      }
      if (j < rows) {
        for (i = j + 1;i < rows; i++) {
          var vij = data[i][j];
          if (!equalScalar(vij, 0)) {
            data[i][j] = divideScalar(data[i][j], vjj);
          }
        }
      }
    }
    for (j = 0;j < columns; j++) {
      for (i = 0;i < rows; i++) {
        if (j === 0) {
          if (i < columns) {
            udata[i] = [];
          }
          ldata[i] = [];
        }
        if (i < j) {
          if (i < columns) {
            udata[i][j] = data[i][j];
          }
          if (j < rows) {
            ldata[i][j] = 0;
          }
          continue;
        }
        if (i === j) {
          if (i < columns) {
            udata[i][j] = data[i][j];
          }
          if (j < rows) {
            ldata[i][j] = 1;
          }
          continue;
        }
        if (i < columns) {
          udata[i][j] = 0;
        }
        if (j < rows) {
          ldata[i][j] = data[i][j];
        }
      }
    }
    var l = new DenseMatrix({
      data: ldata,
      size: lsize
    });
    var u = new DenseMatrix({
      data: udata,
      size: usize
    });
    var pv = [];
    for (i = 0, n = p.length;i < n; i++) {
      pv[p[i]] = i;
    }
    return {
      L: l,
      U: u,
      p: pv,
      toString: function toString() {
        return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
      }
    };
  }
  function _sparseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var lsize = [rows, n];
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var usize = [n, columns];
    var i, j, k;
    var pvCo = [];
    var pvOc = [];
    for (i = 0;i < rows; i++) {
      pvCo[i] = i;
      pvOc[i] = i;
    }
    var swapIndeces = function swapIndeces(x, y) {
      var kx = pvOc[x];
      var ky = pvOc[y];
      pvCo[kx] = y;
      pvCo[ky] = x;
      pvOc[x] = ky;
      pvOc[y] = kx;
    };
    var _loop = function _loop() {
      var spa = new Spa;
      if (j < rows) {
        lptr.push(lvalues.length);
        lvalues.push(1);
        lindex.push(j);
      }
      uptr.push(uvalues.length);
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (k = k0;k < k1; k++) {
        i = index[k];
        spa.set(pvCo[i], values[k]);
      }
      if (j > 0) {
        spa.forEach(0, j - 1, function(k2, vkj) {
          SparseMatrix._forEachRow(k2, lvalues, lindex, lptr, function(i2, vik) {
            if (i2 > k2) {
              spa.accumulate(i2, unaryMinus(multiplyScalar(vik, vkj)));
            }
          });
        });
      }
      var pi2 = j;
      var vjj = spa.get(j);
      var pabsv = abs2(vjj);
      spa.forEach(j + 1, rows - 1, function(x, v) {
        var absv = abs2(v);
        if (larger(absv, pabsv)) {
          pi2 = x;
          pabsv = absv;
          vjj = v;
        }
      });
      if (j !== pi2) {
        SparseMatrix._swapRows(j, pi2, lsize[1], lvalues, lindex, lptr);
        SparseMatrix._swapRows(j, pi2, usize[1], uvalues, uindex, uptr);
        spa.swap(j, pi2);
        swapIndeces(j, pi2);
      }
      spa.forEach(0, rows - 1, function(x, v) {
        if (x <= j) {
          uvalues.push(v);
          uindex.push(x);
        } else {
          v = divideScalar(v, vjj);
          if (!equalScalar(v, 0)) {
            lvalues.push(v);
            lindex.push(x);
          }
        }
      });
    };
    for (j = 0;j < columns; j++) {
      _loop();
    }
    uptr.push(uvalues.length);
    lptr.push(lvalues.length);
    return {
      L: new SparseMatrix({
        values: lvalues,
        index: lindex,
        ptr: lptr,
        size: lsize
      }),
      U: new SparseMatrix({
        values: uvalues,
        index: uindex,
        ptr: uptr,
        size: usize
      }),
      p: pvCo,
      toString: function toString() {
        return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
      }
    };
  }
});
// ../../node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js
var extends5 = __toESM(require_extends(), 1);
var name225 = "qr";
var dependencies225 = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtract", "complex"];
var createQr = factory(name225, dependencies225, (_ref) => {
  var {
    typed,
    matrix,
    zeros: zeros2,
    identity,
    isZero,
    equal,
    sign: sign3,
    sqrt: sqrt2,
    conj,
    unaryMinus,
    addScalar,
    divideScalar,
    multiplyScalar,
    subtract,
    complex: complex2
  } = _ref;
  return extends5.default(typed(name225, {
    DenseMatrix: function DenseMatrix(m) {
      return _denseQR(m);
    },
    SparseMatrix: function SparseMatrix(m) {
      return _sparseQR(m);
    },
    Array: function Array(a) {
      var m = matrix(a);
      var r = _denseQR(m);
      return {
        Q: r.Q.valueOf(),
        R: r.R.valueOf()
      };
    }
  }), {
    _denseQRimpl
  });
  function _denseQRimpl(m) {
    var rows = m._size[0];
    var cols = m._size[1];
    var Q2 = identity([rows], "dense");
    var Qdata = Q2._data;
    var R = m.clone();
    var Rdata = R._data;
    var i, j, k;
    var w = zeros2([rows], "");
    for (k = 0;k < Math.min(cols, rows); ++k) {
      var pivot = Rdata[k][k];
      var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign3(pivot));
      var conjSgn = conj(sgn);
      var alphaSquared = 0;
      for (i = k;i < rows; i++) {
        alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));
      }
      var alpha = multiplyScalar(sgn, sqrt2(alphaSquared));
      if (!isZero(alpha)) {
        var u1 = subtract(pivot, alpha);
        w[k] = 1;
        for (i = k + 1;i < rows; i++) {
          w[i] = divideScalar(Rdata[i][k], u1);
        }
        var tau2 = unaryMinus(conj(divideScalar(u1, alpha)));
        var s = undefined;
        for (j = k;j < cols; j++) {
          s = 0;
          for (i = k;i < rows; i++) {
            s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));
          }
          s = multiplyScalar(s, tau2);
          for (i = k;i < rows; i++) {
            Rdata[i][j] = multiplyScalar(subtract(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);
          }
        }
        for (i = 0;i < rows; i++) {
          s = 0;
          for (j = k;j < rows; j++) {
            s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));
          }
          s = multiplyScalar(s, tau2);
          for (j = k;j < rows; ++j) {
            Qdata[i][j] = divideScalar(subtract(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);
          }
        }
      }
    }
    return {
      Q: Q2,
      R,
      toString: function toString() {
        return "Q: " + this.Q.toString() + "\nR: " + this.R.toString();
      }
    };
  }
  function _denseQR(m) {
    var ret = _denseQRimpl(m);
    var Rdata = ret.R._data;
    if (m._data.length > 0) {
      var zero = Rdata[0][0].type === "Complex" ? complex2(0) : 0;
      for (var i = 0;i < Rdata.length; ++i) {
        for (var j = 0;j < i && j < (Rdata[0] || []).length; ++j) {
          Rdata[i][j] = zero;
        }
      }
    }
    return ret;
  }
  function _sparseQR(m) {
    throw new Error("qr not implemented for sparse matrices yet");
  }
});
// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js
function csPermute(a, pinv, q, values) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var adt = a._datatype;
  var m = asize[0];
  var n = asize[1];
  var cvalues = values && a._values ? [] : null;
  var cindex = [];
  var cptr = [];
  var nz = 0;
  for (var k = 0;k < n; k++) {
    cptr[k] = nz;
    var j = q ? q[k] : k;
    for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0;t < t1; t++) {
      var r = pinv ? pinv[aindex[t]] : aindex[t];
      cindex[nz] = r;
      if (cvalues) {
        cvalues[nz] = avalues[t];
      }
      nz++;
    }
  }
  cptr[n] = nz;
  return a.createSparseMatrix({
    values: cvalues,
    index: cindex,
    ptr: cptr,
    size: [m, n],
    datatype: adt
  });
}

// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js
function csTdfs(j, k, w, head, next, post, stack) {
  var top = 0;
  w[stack] = j;
  while (top >= 0) {
    var p = w[stack + top];
    var i = w[head + p];
    if (i === -1) {
      top--;
      post[k++] = p;
    } else {
      w[head + p] = w[next + i];
      ++top;
      w[stack + top] = i;
    }
  }
  return k;
}

// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js
function csPost(parent, n) {
  if (!parent) {
    return null;
  }
  var k = 0;
  var j;
  var post = [];
  var w = [];
  var head = 0;
  var next = n;
  var stack = 2 * n;
  for (j = 0;j < n; j++) {
    w[head + j] = -1;
  }
  for (j = n - 1;j >= 0; j--) {
    if (parent[j] === -1) {
      continue;
    }
    w[next + j] = w[head + parent[j]];
    w[head + parent[j]] = j;
  }
  for (j = 0;j < n; j++) {
    if (parent[j] !== -1) {
      continue;
    }
    k = csTdfs(j, k, w, head, next, post, stack);
  }
  return post;
}

// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js
function csEtree(a, ata) {
  if (!a) {
    return null;
  }
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var m = asize[0];
  var n = asize[1];
  var parent = [];
  var w = [];
  var ancestor = 0;
  var prev = n;
  var i, inext;
  if (ata) {
    for (i = 0;i < m; i++) {
      w[prev + i] = -1;
    }
  }
  for (var k = 0;k < n; k++) {
    parent[k] = -1;
    w[ancestor + k] = -1;
    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0;p < p1; p++) {
      var r = aindex[p];
      i = ata ? w[prev + r] : r;
      for (;i !== -1 && i < k; i = inext) {
        inext = w[ancestor + i];
        w[ancestor + i] = k;
        if (inext === -1) {
          parent[i] = k;
        }
      }
      if (ata) {
        w[prev + r] = k;
      }
    }
  }
  return parent;
}

// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js
function csFkeep(a, callback, other) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var n = asize[1];
  var nz = 0;
  for (var j = 0;j < n; j++) {
    var p = aptr[j];
    aptr[j] = nz;
    for (;p < aptr[j + 1]; p++) {
      if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
        aindex[nz] = aindex[p];
        if (avalues) {
          avalues[nz] = avalues[p];
        }
        nz++;
      }
    }
  }
  aptr[n] = nz;
  aindex.splice(nz, aindex.length - nz);
  if (avalues) {
    avalues.splice(nz, avalues.length - nz);
  }
  return nz;
}

// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js
function csFlip(i) {
  return -i - 2;
}

// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js
var name226 = "csAmd";
var dependencies226 = ["add", "multiply", "transpose"];
var createCsAmd = factory(name226, dependencies226, (_ref) => {
  var {
    add: add2,
    multiply,
    transpose
  } = _ref;
  return function csAmd(order, a) {
    if (!a || order <= 0 || order > 3) {
      return null;
    }
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var lemax = 0;
    var dense = Math.max(16, 10 * Math.sqrt(n));
    dense = Math.min(n - 2, dense);
    var cm = _createTargetMatrix(order, a, m, n, dense);
    csFkeep(cm, _diag, null);
    var cindex = cm._index;
    var cptr = cm._ptr;
    var cnz = cptr[n];
    var P3 = [];
    var W = [];
    var len = 0;
    var nv = n + 1;
    var next = 2 * (n + 1);
    var head = 3 * (n + 1);
    var elen = 4 * (n + 1);
    var degree = 5 * (n + 1);
    var w = 6 * (n + 1);
    var hhead = 7 * (n + 1);
    var last = P3;
    var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree);
    var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next);
    var mindeg = 0;
    var i, j, k, k1, k2, e2, pj, ln2, nvi, pk, eln, p1, p2, pn, h2, d;
    while (nel < n) {
      for (k = -1;mindeg < n && (k = W[head + mindeg]) === -1; mindeg++)
        ;
      if (W[next + k] !== -1) {
        last[W[next + k]] = -1;
      }
      W[head + mindeg] = W[next + k];
      var elenk = W[elen + k];
      var nvk = W[nv + k];
      nel += nvk;
      var dk = 0;
      W[nv + k] = -nvk;
      var p = cptr[k];
      var pk1 = elenk === 0 ? p : cnz;
      var pk2 = pk1;
      for (k1 = 1;k1 <= elenk + 1; k1++) {
        if (k1 > elenk) {
          e2 = k;
          pj = p;
          ln2 = W[len + k] - elenk;
        } else {
          e2 = cindex[p++];
          pj = cptr[e2];
          ln2 = W[len + e2];
        }
        for (k2 = 1;k2 <= ln2; k2++) {
          i = cindex[pj++];
          if ((nvi = W[nv + i]) <= 0) {
            continue;
          }
          dk += nvi;
          W[nv + i] = -nvi;
          cindex[pk2++] = i;
          if (W[next + i] !== -1) {
            last[W[next + i]] = last[i];
          }
          if (last[i] !== -1) {
            W[next + last[i]] = W[next + i];
          } else {
            W[head + W[degree + i]] = W[next + i];
          }
        }
        if (e2 !== k) {
          cptr[e2] = csFlip(k);
          W[w + e2] = 0;
        }
      }
      if (elenk !== 0) {
        cnz = pk2;
      }
      W[degree + k] = dk;
      cptr[k] = pk1;
      W[len + k] = pk2 - pk1;
      W[elen + k] = -2;
      mark = _wclear(mark, lemax, W, w, n);
      for (pk = pk1;pk < pk2; pk++) {
        i = cindex[pk];
        if ((eln = W[elen + i]) <= 0) {
          continue;
        }
        nvi = -W[nv + i];
        var wnvi = mark - nvi;
        for (p = cptr[i], p1 = cptr[i] + eln - 1;p <= p1; p++) {
          e2 = cindex[p];
          if (W[w + e2] >= mark) {
            W[w + e2] -= nvi;
          } else if (W[w + e2] !== 0) {
            W[w + e2] = W[degree + e2] + wnvi;
          }
        }
      }
      for (pk = pk1;pk < pk2; pk++) {
        i = cindex[pk];
        p1 = cptr[i];
        p2 = p1 + W[elen + i] - 1;
        pn = p1;
        for (h2 = 0, d = 0, p = p1;p <= p2; p++) {
          e2 = cindex[p];
          if (W[w + e2] !== 0) {
            var dext = W[w + e2] - mark;
            if (dext > 0) {
              d += dext;
              cindex[pn++] = e2;
              h2 += e2;
            } else {
              cptr[e2] = csFlip(k);
              W[w + e2] = 0;
            }
          }
        }
        W[elen + i] = pn - p1 + 1;
        var p3 = pn;
        var p4 = p1 + W[len + i];
        for (p = p2 + 1;p < p4; p++) {
          j = cindex[p];
          var nvj = W[nv + j];
          if (nvj <= 0) {
            continue;
          }
          d += nvj;
          cindex[pn++] = j;
          h2 += j;
        }
        if (d === 0) {
          cptr[i] = csFlip(k);
          nvi = -W[nv + i];
          dk -= nvi;
          nvk += nvi;
          nel += nvi;
          W[nv + i] = 0;
          W[elen + i] = -1;
        } else {
          W[degree + i] = Math.min(W[degree + i], d);
          cindex[pn] = cindex[p3];
          cindex[p3] = cindex[p1];
          cindex[p1] = k;
          W[len + i] = pn - p1 + 1;
          h2 = (h2 < 0 ? -h2 : h2) % n;
          W[next + i] = W[hhead + h2];
          W[hhead + h2] = i;
          last[i] = h2;
        }
      }
      W[degree + k] = dk;
      lemax = Math.max(lemax, dk);
      mark = _wclear(mark + lemax, lemax, W, w, n);
      for (pk = pk1;pk < pk2; pk++) {
        i = cindex[pk];
        if (W[nv + i] >= 0) {
          continue;
        }
        h2 = last[i];
        i = W[hhead + h2];
        W[hhead + h2] = -1;
        for (;i !== -1 && W[next + i] !== -1; i = W[next + i], mark++) {
          ln2 = W[len + i];
          eln = W[elen + i];
          for (p = cptr[i] + 1;p <= cptr[i] + ln2 - 1; p++) {
            W[w + cindex[p]] = mark;
          }
          var jlast = i;
          for (j = W[next + i];j !== -1; ) {
            var ok = W[len + j] === ln2 && W[elen + j] === eln;
            for (p = cptr[j] + 1;ok && p <= cptr[j] + ln2 - 1; p++) {
              if (W[w + cindex[p]] !== mark) {
                ok = 0;
              }
            }
            if (ok) {
              cptr[j] = csFlip(i);
              W[nv + i] += W[nv + j];
              W[nv + j] = 0;
              W[elen + j] = -1;
              j = W[next + j];
              W[next + jlast] = j;
            } else {
              jlast = j;
              j = W[next + j];
            }
          }
        }
      }
      for (p = pk1, pk = pk1;pk < pk2; pk++) {
        i = cindex[pk];
        if ((nvi = -W[nv + i]) <= 0) {
          continue;
        }
        W[nv + i] = nvi;
        d = W[degree + i] + dk - nvi;
        d = Math.min(d, n - nel - nvi);
        if (W[head + d] !== -1) {
          last[W[head + d]] = i;
        }
        W[next + i] = W[head + d];
        last[i] = -1;
        W[head + d] = i;
        mindeg = Math.min(mindeg, d);
        W[degree + i] = d;
        cindex[p++] = i;
      }
      W[nv + k] = nvk;
      if ((W[len + k] = p - pk1) === 0) {
        cptr[k] = -1;
        W[w + k] = 0;
      }
      if (elenk !== 0) {
        cnz = p;
      }
    }
    for (i = 0;i < n; i++) {
      cptr[i] = csFlip(cptr[i]);
    }
    for (j = 0;j <= n; j++) {
      W[head + j] = -1;
    }
    for (j = n;j >= 0; j--) {
      if (W[nv + j] > 0) {
        continue;
      }
      W[next + j] = W[head + cptr[j]];
      W[head + cptr[j]] = j;
    }
    for (e2 = n;e2 >= 0; e2--) {
      if (W[nv + e2] <= 0) {
        continue;
      }
      if (cptr[e2] !== -1) {
        W[next + e2] = W[head + cptr[e2]];
        W[head + cptr[e2]] = e2;
      }
    }
    for (k = 0, i = 0;i <= n; i++) {
      if (cptr[i] === -1) {
        k = csTdfs(i, k, W, head, next, P3, w);
      }
    }
    P3.splice(P3.length - 1, 1);
    return P3;
  };
  function _createTargetMatrix(order, a, m, n, dense) {
    var at = transpose(a);
    if (order === 1 && n === m) {
      return add2(a, at);
    }
    if (order === 2) {
      var tindex = at._index;
      var tptr = at._ptr;
      var p2 = 0;
      for (var j = 0;j < m; j++) {
        var p = tptr[j];
        tptr[j] = p2;
        if (tptr[j + 1] - p > dense) {
          continue;
        }
        for (var p1 = tptr[j + 1];p < p1; p++) {
          tindex[p2++] = tindex[p];
        }
      }
      tptr[m] = p2;
      a = transpose(at);
      return multiply(at, a);
    }
    return multiply(at, a);
  }
  function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
    for (var k = 0;k < n; k++) {
      W[len + k] = cptr[k + 1] - cptr[k];
    }
    W[len + n] = 0;
    for (var i = 0;i <= n; i++) {
      W[head + i] = -1;
      last[i] = -1;
      W[next + i] = -1;
      W[hhead + i] = -1;
      W[nv + i] = 1;
      W[w + i] = 1;
      W[elen + i] = 0;
      W[degree + i] = W[len + i];
    }
    var mark = _wclear(0, 0, W, w, n);
    W[elen + n] = -2;
    cptr[n] = -1;
    W[w + n] = 0;
    return mark;
  }
  function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
    var nel = 0;
    for (var i = 0;i < n; i++) {
      var d = W[degree + i];
      if (d === 0) {
        W[elen + i] = -2;
        nel++;
        cptr[i] = -1;
        W[w + i] = 0;
      } else if (d > dense) {
        W[nv + i] = 0;
        W[elen + i] = -1;
        nel++;
        cptr[i] = csFlip(n);
        W[nv + n]++;
      } else {
        var h2 = W[head + d];
        if (h2 !== -1) {
          last[h2] = i;
        }
        W[next + i] = W[head + d];
        W[head + d] = i;
      }
    }
    return nel;
  }
  function _wclear(mark, lemax, W, w, n) {
    if (mark < 2 || mark + lemax < 0) {
      for (var k = 0;k < n; k++) {
        if (W[w + k] !== 0) {
          W[w + k] = 1;
        }
      }
      mark = 2;
    }
    return mark;
  }
  function _diag(i, j) {
    return i !== j;
  }
});

// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js
function csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {
  var s, sparent;
  var jleaf = 0;
  var q;
  if (i <= j || w[first + j] <= w[maxfirst + i]) {
    return -1;
  }
  w[maxfirst + i] = w[first + j];
  var jprev = w[prevleaf + i];
  w[prevleaf + i] = j;
  if (jprev === -1) {
    jleaf = 1;
    q = i;
  } else {
    jleaf = 2;
    for (q = jprev;q !== w[ancestor + q]; q = w[ancestor + q])
      ;
    for (s = jprev;s !== q; s = sparent) {
      sparent = w[ancestor + s];
      w[ancestor + s] = q;
    }
  }
  return {
    jleaf,
    q
  };
}

// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js
var name227 = "csCounts";
var dependencies227 = ["transpose"];
var createCsCounts = factory(name227, dependencies227, (_ref) => {
  var {
    transpose
  } = _ref;
  return function(a, parent, post, ata) {
    if (!a || !parent || !post) {
      return null;
    }
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var i, j, k, J, p, p0, p1;
    var s = 4 * n + (ata ? n + m + 1 : 0);
    var w = [];
    var ancestor = 0;
    var maxfirst = n;
    var prevleaf = 2 * n;
    var first = 3 * n;
    var head = 4 * n;
    var next = 5 * n + 1;
    for (k = 0;k < s; k++) {
      w[k] = -1;
    }
    var colcount = [];
    var at = transpose(a);
    var tindex = at._index;
    var tptr = at._ptr;
    for (k = 0;k < n; k++) {
      j = post[k];
      colcount[j] = w[first + j] === -1 ? 1 : 0;
      for (;j !== -1 && w[first + j] === -1; j = parent[j]) {
        w[first + j] = k;
      }
    }
    if (ata) {
      for (k = 0;k < n; k++) {
        w[post[k]] = k;
      }
      for (i = 0;i < m; i++) {
        for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0;p < p1; p++) {
          k = Math.min(k, w[tindex[p]]);
        }
        w[next + i] = w[head + k];
        w[head + k] = i;
      }
    }
    for (i = 0;i < n; i++) {
      w[ancestor + i] = i;
    }
    for (k = 0;k < n; k++) {
      j = post[k];
      if (parent[j] !== -1) {
        colcount[parent[j]]--;
      }
      for (J = ata ? w[head + k] : j;J !== -1; J = ata ? w[next + J] : -1) {
        for (p = tptr[J];p < tptr[J + 1]; p++) {
          i = tindex[p];
          var r = csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor);
          if (r.jleaf >= 1) {
            colcount[j]++;
          }
          if (r.jleaf === 2) {
            colcount[r.q]--;
          }
        }
      }
      if (parent[j] !== -1) {
        w[ancestor + j] = parent[j];
      }
    }
    for (j = 0;j < n; j++) {
      if (parent[j] !== -1) {
        colcount[parent[j]] += colcount[j];
      }
    }
    return colcount;
  };
});

// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js
var name228 = "csSqr";
var dependencies228 = ["add", "multiply", "transpose"];
var createCsSqr = factory(name228, dependencies228, (_ref) => {
  var {
    add: add2,
    multiply,
    transpose
  } = _ref;
  var csAmd2 = createCsAmd({
    add: add2,
    multiply,
    transpose
  });
  var csCounts2 = createCsCounts({
    transpose
  });
  return function csSqr(order, a, qr) {
    var aptr = a._ptr;
    var asize = a._size;
    var n = asize[1];
    var k;
    var s = {};
    s.q = csAmd2(order, a);
    if (order && !s.q) {
      return null;
    }
    if (qr) {
      var c = order ? csPermute(a, null, s.q, 0) : a;
      s.parent = csEtree(c, 1);
      var post = csPost(s.parent, n);
      s.cp = csCounts2(c, s.parent, post, 1);
      if (c && s.parent && s.cp && _vcount(c, s)) {
        for (s.unz = 0, k = 0;k < n; k++) {
          s.unz += s.cp[k];
        }
      }
    } else {
      s.unz = 4 * aptr[n] + n;
      s.lnz = s.unz;
    }
    return s;
  };
  function _vcount(a, s) {
    var aptr = a._ptr;
    var aindex = a._index;
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    s.pinv = [];
    s.leftmost = [];
    var parent = s.parent;
    var pinv = s.pinv;
    var leftmost = s.leftmost;
    var w = [];
    var next = 0;
    var head = m;
    var tail = m + n;
    var nque = m + 2 * n;
    var i, k, p, p0, p1;
    for (k = 0;k < n; k++) {
      w[head + k] = -1;
      w[tail + k] = -1;
      w[nque + k] = 0;
    }
    for (i = 0;i < m; i++) {
      leftmost[i] = -1;
    }
    for (k = n - 1;k >= 0; k--) {
      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0;p < p1; p++) {
        leftmost[aindex[p]] = k;
      }
    }
    for (i = m - 1;i >= 0; i--) {
      pinv[i] = -1;
      k = leftmost[i];
      if (k === -1) {
        continue;
      }
      if (w[nque + k]++ === 0) {
        w[tail + k] = i;
      }
      w[next + i] = w[head + k];
      w[head + k] = i;
    }
    s.lnz = 0;
    s.m2 = m;
    for (k = 0;k < n; k++) {
      i = w[head + k];
      s.lnz++;
      if (i < 0) {
        i = s.m2++;
      }
      pinv[i] = k;
      if (--nque[k] <= 0) {
        continue;
      }
      s.lnz += w[nque + k];
      var pa = parent[k];
      if (pa !== -1) {
        if (w[nque + pa] === 0) {
          w[tail + pa] = w[tail + k];
        }
        w[next + w[tail + k]] = w[head + pa];
        w[head + pa] = w[next + i];
        w[nque + pa] += w[nque + k];
      }
    }
    for (i = 0;i < m; i++) {
      if (pinv[i] < 0) {
        pinv[i] = k++;
      }
    }
    return true;
  }
});

// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js
function csMarked(w, j) {
  return w[j] < 0;
}

// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js
function csMark(w, j) {
  w[j] = csFlip(w[j]);
}

// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js
function csUnflip(i) {
  return i < 0 ? csFlip(i) : i;
}

// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js
function csDfs(j, g, top, xi, pinv) {
  var index = g._index;
  var ptr = g._ptr;
  var size = g._size;
  var n = size[1];
  var i, p, p2;
  var head = 0;
  xi[0] = j;
  while (head >= 0) {
    j = xi[head];
    var jnew = pinv ? pinv[j] : j;
    if (!csMarked(ptr, j)) {
      csMark(ptr, j);
      xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);
    }
    var done = 1;
    for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]);p < p2; p++) {
      i = index[p];
      if (csMarked(ptr, i)) {
        continue;
      }
      xi[n + head] = p;
      xi[++head] = i;
      done = 0;
      break;
    }
    if (done) {
      head--;
      xi[--top] = j;
    }
  }
  return top;
}

// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js
function csReach(g, b, k, xi, pinv) {
  var gptr = g._ptr;
  var gsize = g._size;
  var bindex = b._index;
  var bptr = b._ptr;
  var n = gsize[1];
  var p, p0, p1;
  var top = n;
  for (p0 = bptr[k], p1 = bptr[k + 1], p = p0;p < p1; p++) {
    var i = bindex[p];
    if (!csMarked(gptr, i)) {
      top = csDfs(i, g, top, xi, pinv);
    }
  }
  for (p = top;p < n; p++) {
    csMark(gptr, xi[p]);
  }
  return top;
}

// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js
var name229 = "csSpsolve";
var dependencies229 = ["divideScalar", "multiply", "subtract"];
var createCsSpsolve = factory(name229, dependencies229, (_ref) => {
  var {
    divideScalar,
    multiply,
    subtract
  } = _ref;
  return function csSpsolve(g, b, k, xi, x, pinv, lo) {
    var gvalues = g._values;
    var gindex = g._index;
    var gptr = g._ptr;
    var gsize = g._size;
    var n = gsize[1];
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var p, p0, p1, q;
    var top = csReach(g, b, k, xi, pinv);
    for (p = top;p < n; p++) {
      x[xi[p]] = 0;
    }
    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0;p < p1; p++) {
      x[bindex[p]] = bvalues[p];
    }
    for (var px = top;px < n; px++) {
      var j = xi[px];
      var J = pinv ? pinv[j] : j;
      if (J < 0) {
        continue;
      }
      p0 = gptr[J];
      p1 = gptr[J + 1];
      x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]);
      p = lo ? p0 + 1 : p0;
      q = lo ? p1 : p1 - 1;
      for (;p < q; p++) {
        var i = gindex[p];
        x[i] = subtract(x[i], multiply(gvalues[p], x[j]));
      }
    }
    return top;
  };
});

// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js
var name230 = "csLu";
var dependencies230 = ["abs", "divideScalar", "multiply", "subtract", "larger", "largerEq", "SparseMatrix"];
var createCsLu = factory(name230, dependencies230, (_ref) => {
  var {
    abs: abs2,
    divideScalar,
    multiply,
    subtract,
    larger,
    largerEq,
    SparseMatrix
  } = _ref;
  var csSpsolve2 = createCsSpsolve({
    divideScalar,
    multiply,
    subtract
  });
  return function csLu(m, s, tol) {
    if (!m) {
      return null;
    }
    var size = m._size;
    var n = size[1];
    var q;
    var lnz = 100;
    var unz = 100;
    if (s) {
      q = s.q;
      lnz = s.lnz || lnz;
      unz = s.unz || unz;
    }
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var L = new SparseMatrix({
      values: lvalues,
      index: lindex,
      ptr: lptr,
      size: [n, n]
    });
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var U = new SparseMatrix({
      values: uvalues,
      index: uindex,
      ptr: uptr,
      size: [n, n]
    });
    var pinv = [];
    var i, p;
    var x = [];
    var xi = [];
    for (i = 0;i < n; i++) {
      x[i] = 0;
      pinv[i] = -1;
      lptr[i + 1] = 0;
    }
    lnz = 0;
    unz = 0;
    for (var k = 0;k < n; k++) {
      lptr[k] = lnz;
      uptr[k] = unz;
      var col = q ? q[k] : k;
      var top = csSpsolve2(L, m, col, xi, x, pinv, 1);
      var ipiv = -1;
      var a = -1;
      for (p = top;p < n; p++) {
        i = xi[p];
        if (pinv[i] < 0) {
          var xabs = abs2(x[i]);
          if (larger(xabs, a)) {
            a = xabs;
            ipiv = i;
          }
        } else {
          uindex[unz] = pinv[i];
          uvalues[unz++] = x[i];
        }
      }
      if (ipiv === -1 || a <= 0) {
        return null;
      }
      if (pinv[col] < 0 && largerEq(abs2(x[col]), multiply(a, tol))) {
        ipiv = col;
      }
      var pivot = x[ipiv];
      uindex[unz] = k;
      uvalues[unz++] = pivot;
      pinv[ipiv] = k;
      lindex[lnz] = ipiv;
      lvalues[lnz++] = 1;
      for (p = top;p < n; p++) {
        i = xi[p];
        if (pinv[i] < 0) {
          lindex[lnz] = i;
          lvalues[lnz++] = divideScalar(x[i], pivot);
        }
        x[i] = 0;
      }
    }
    lptr[n] = lnz;
    uptr[n] = unz;
    for (p = 0;p < lnz; p++) {
      lindex[p] = pinv[lindex[p]];
    }
    lvalues.splice(lnz, lvalues.length - lnz);
    lindex.splice(lnz, lindex.length - lnz);
    uvalues.splice(unz, uvalues.length - unz);
    uindex.splice(unz, uindex.length - unz);
    return {
      L,
      U,
      pinv
    };
  };
});

// ../../node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js
var name231 = "slu";
var dependencies231 = ["typed", "abs", "add", "multiply", "transpose", "divideScalar", "subtract", "larger", "largerEq", "SparseMatrix"];
var createSlu = factory(name231, dependencies231, (_ref) => {
  var {
    typed,
    abs: abs2,
    add: add2,
    multiply,
    transpose,
    divideScalar,
    subtract,
    larger,
    largerEq,
    SparseMatrix
  } = _ref;
  var csSqr2 = createCsSqr({
    add: add2,
    multiply,
    transpose
  });
  var csLu2 = createCsLu({
    abs: abs2,
    divideScalar,
    multiply,
    subtract,
    larger,
    largerEq,
    SparseMatrix
  });
  return typed(name231, {
    "SparseMatrix, number, number": function SparseMatrixNumberNumber(a, order, threshold) {
      if (!isInteger(order) || order < 0 || order > 3) {
        throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");
      }
      if (threshold < 0 || threshold > 1) {
        throw new Error("Partial pivoting threshold must be a number from 0 to 1");
      }
      var s = csSqr2(order, a, false);
      var f = csLu2(a, s, threshold);
      return {
        L: f.L,
        U: f.U,
        p: f.pinv,
        q: s.q,
        toString: function toString() {
          return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\np: " + this.p.toString() + (this.q ? "\nq: " + this.q.toString() : "") + "\n";
        }
      };
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js
function csIpvec(p, b) {
  var k;
  var n = b.length;
  var x = [];
  if (p) {
    for (k = 0;k < n; k++) {
      x[p[k]] = b[k];
    }
  } else {
    for (k = 0;k < n; k++) {
      x[k] = b[k];
    }
  }
  return x;
}

// ../../node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js
var name232 = "lusolve";
var dependencies232 = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"];
var createLusolve = factory(name232, dependencies232, (_ref) => {
  var {
    typed,
    matrix,
    lup,
    slu,
    usolve,
    lsolve,
    DenseMatrix
  } = _ref;
  var solveValidation6 = createSolveValidation({
    DenseMatrix
  });
  return typed(name232, {
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      a = matrix(a);
      var d = lup(a);
      var x = _lusolve(d.L, d.U, d.p, null, b);
      return x.valueOf();
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(a, b) {
      var d = lup(a);
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(a, b) {
      var d = lup(a);
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    "SparseMatrix, Array | Matrix, number, number": function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {
      var d = slu(a, order, threshold);
      return _lusolve(d.L, d.U, d.p, d.q, b);
    },
    "Object, Array | Matrix": function ObjectArrayMatrix(d, b) {
      return _lusolve(d.L, d.U, d.p, d.q, b);
    }
  });
  function _toMatrix(a) {
    if (isMatrix(a)) {
      return a;
    }
    if (isArray(a)) {
      return matrix(a);
    }
    throw new TypeError("Invalid Matrix LU decomposition");
  }
  function _lusolve(l, u, p, q, b) {
    l = _toMatrix(l);
    u = _toMatrix(u);
    if (p) {
      b = solveValidation6(l, b, true);
      b._data = csIpvec(p, b._data);
    }
    var y = lsolve(l, b);
    var x = usolve(u, y);
    if (q) {
      x._data = csIpvec(q, x._data);
    }
    return x;
  }
});
// ../../node_modules/mathjs/lib/esm/function/algebra/polynomialRoot.js
var name233 = "polynomialRoot";
var dependencies233 = ["typed", "isZero", "equalScalar", "add", "subtract", "multiply", "divide", "sqrt", "unaryMinus", "cbrt", "typeOf", "im", "re"];
var createPolynomialRoot = factory(name233, dependencies233, (_ref) => {
  var {
    typed,
    isZero,
    equalScalar,
    add: add2,
    subtract,
    multiply,
    divide: divide2,
    sqrt: sqrt2,
    unaryMinus,
    cbrt: cbrt4,
    typeOf: typeOf2,
    im,
    re
  } = _ref;
  return typed(name233, {
    "number|Complex, ...number|Complex": (constant, restCoeffs) => {
      var coeffs = [constant, ...restCoeffs];
      while (coeffs.length > 0 && isZero(coeffs[coeffs.length - 1])) {
        coeffs.pop();
      }
      if (coeffs.length < 2) {
        throw new RangeError("Polynomial [".concat(constant, ", ").concat(restCoeffs, "] must have a non-zero non-constant coefficient"));
      }
      switch (coeffs.length) {
        case 2:
          return [unaryMinus(divide2(coeffs[0], coeffs[1]))];
        case 3: {
          var [c, b, a] = coeffs;
          var denom = multiply(2, a);
          var d1 = multiply(b, b);
          var d2 = multiply(4, a, c);
          if (equalScalar(d1, d2))
            return [divide2(unaryMinus(b), denom)];
          var discriminant = sqrt2(subtract(d1, d2));
          return [divide2(subtract(discriminant, b), denom), divide2(subtract(unaryMinus(discriminant), b), denom)];
        }
        case 4: {
          var [d, _c, _b, _a] = coeffs;
          var _denom = unaryMinus(multiply(3, _a));
          var D0_1 = multiply(_b, _b);
          var D0_2 = multiply(3, _a, _c);
          var D1_1 = add2(multiply(2, _b, _b, _b), multiply(27, _a, _a, d));
          var D1_2 = multiply(9, _a, _b, _c);
          if (equalScalar(D0_1, D0_2) && equalScalar(D1_1, D1_2)) {
            return [divide2(_b, _denom)];
          }
          var Delta0 = subtract(D0_1, D0_2);
          var Delta1 = subtract(D1_1, D1_2);
          var discriminant1 = add2(multiply(18, _a, _b, _c, d), multiply(_b, _b, _c, _c));
          var discriminant2 = add2(multiply(4, _b, _b, _b, d), multiply(4, _a, _c, _c, _c), multiply(27, _a, _a, d, d));
          if (equalScalar(discriminant1, discriminant2)) {
            return [
              divide2(subtract(multiply(4, _a, _b, _c), add2(multiply(9, _a, _a, d), multiply(_b, _b, _b))), multiply(_a, Delta0)),
              divide2(subtract(multiply(9, _a, d), multiply(_b, _c)), multiply(2, Delta0))
            ];
          }
          var Ccubed;
          if (equalScalar(D0_1, D0_2)) {
            Ccubed = Delta1;
          } else {
            Ccubed = divide2(add2(Delta1, sqrt2(subtract(multiply(Delta1, Delta1), multiply(4, Delta0, Delta0, Delta0)))), 2);
          }
          var allRoots = true;
          var rawRoots = cbrt4(Ccubed, allRoots).toArray().map((C) => divide2(add2(_b, C, divide2(Delta0, C)), _denom));
          return rawRoots.map((r) => {
            if (typeOf2(r) === "Complex" && equalScalar(re(r), re(r) + im(r))) {
              return re(r);
            }
            return r;
          });
        }
        default:
          throw new RangeError("only implemented for cubic or lower-order polynomials, not ".concat(coeffs));
      }
    }
  });
});
// ../../node_modules/mathjs/lib/esm/expression/Help.js
var name234 = "Help";
var dependencies234 = ["parse"];
var createHelpClass = factory(name234, dependencies234, (_ref) => {
  var {
    parse
  } = _ref;
  function Help(doc) {
    if (!(this instanceof Help)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (!doc)
      throw new Error('Argument "doc" missing');
    this.doc = doc;
  }
  Help.prototype.type = "Help";
  Help.prototype.isHelp = true;
  Help.prototype.toString = function() {
    var doc = this.doc || {};
    var desc = "\n";
    if (doc.name) {
      desc += "Name: " + doc.name + "\n\n";
    }
    if (doc.category) {
      desc += "Category: " + doc.category + "\n\n";
    }
    if (doc.description) {
      desc += "Description:\n    " + doc.description + "\n\n";
    }
    if (doc.syntax) {
      desc += "Syntax:\n    " + doc.syntax.join("\n    ") + "\n\n";
    }
    if (doc.examples) {
      desc += "Examples:\n";
      var scope2 = {};
      for (var i = 0;i < doc.examples.length; i++) {
        var expr = doc.examples[i];
        desc += "    " + expr + "\n";
        var res = undefined;
        try {
          res = parse(expr).compile().evaluate(scope2);
        } catch (e2) {
          res = e2;
        }
        if (res !== undefined && !isHelp(res)) {
          desc += "        " + format3(res, {
            precision: 14
          }) + "\n";
        }
      }
      desc += "\n";
    }
    if (doc.mayThrow && doc.mayThrow.length) {
      desc += "Throws: " + doc.mayThrow.join(", ") + "\n\n";
    }
    if (doc.seealso && doc.seealso.length) {
      desc += "See also: " + doc.seealso.join(", ") + "\n";
    }
    return desc;
  };
  Help.prototype.toJSON = function() {
    var obj = clone(this.doc);
    obj.mathjs = "Help";
    return obj;
  };
  Help.fromJSON = function(json) {
    var doc = {};
    Object.keys(json).filter((prop) => prop !== "mathjs").forEach((prop) => {
      doc[prop] = json[prop];
    });
    return new Help(doc);
  };
  Help.prototype.valueOf = Help.prototype.toString;
  return Help;
}, {
  isClass: true
});
// ../../node_modules/mathjs/lib/esm/type/chain/Chain.js
var name235 = "Chain";
var dependencies235 = ["?on", "math", "typed"];
var createChainClass = factory(name235, dependencies235, (_ref) => {
  var {
    on,
    math,
    typed
  } = _ref;
  function Chain(value) {
    if (!(this instanceof Chain)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (isChain(value)) {
      this.value = value.value;
    } else {
      this.value = value;
    }
  }
  Chain.prototype.type = "Chain";
  Chain.prototype.isChain = true;
  Chain.prototype.done = function() {
    return this.value;
  };
  Chain.prototype.valueOf = function() {
    return this.value;
  };
  Chain.prototype.toString = function() {
    return format3(this.value);
  };
  Chain.prototype.toJSON = function() {
    return {
      mathjs: "Chain",
      value: this.value
    };
  };
  Chain.fromJSON = function(json) {
    return new Chain(json.value);
  };
  function createProxy(name236, fn) {
    if (typeof fn === "function") {
      Chain.prototype[name236] = chainify(fn);
    }
  }
  function createLazyProxy(name236, resolver) {
    lazy(Chain.prototype, name236, function outerResolver() {
      var fn = resolver();
      if (typeof fn === "function") {
        return chainify(fn);
      }
      return;
    });
  }
  function chainify(fn) {
    return function() {
      if (arguments.length === 0) {
        return new Chain(fn(this.value));
      }
      var args = [this.value];
      for (var i = 0;i < arguments.length; i++) {
        args[i + 1] = arguments[i];
      }
      if (typed.isTypedFunction(fn)) {
        var sigObject = typed.resolve(fn, args);
        if (sigObject.params.length === 1) {
          throw new Error("chain function " + fn.name + " cannot match rest parameter between chain value and additional arguments.");
        }
        return new Chain(sigObject.implementation.apply(fn, args));
      }
      return new Chain(fn.apply(fn, args));
    };
  }
  Chain.createProxy = function(arg0, arg1) {
    if (typeof arg0 === "string") {
      createProxy(arg0, arg1);
    } else {
      var _loop = function _loop(_name2) {
        if (hasOwnProperty2(arg0, _name2) && excludedNames[_name2] === undefined) {
          createLazyProxy(_name2, () => arg0[_name2]);
        }
      };
      for (var _name in arg0) {
        _loop(_name);
      }
    }
  };
  var excludedNames = {
    expression: true,
    docs: true,
    type: true,
    classes: true,
    json: true,
    error: true,
    isChain: true
  };
  Chain.createProxy(math);
  if (on) {
    on("import", function(name236, resolver, path) {
      if (!path) {
        createLazyProxy(name236, resolver);
      }
    });
  }
  return Chain;
}, {
  isClass: true
});
// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/e.js
var eDocs = {
  name: "e",
  category: "Constants",
  syntax: ["e"],
  description: "Euler\'s number, the base of the natural logarithm. Approximately equal to 2.71828",
  examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
  seealso: ["exp"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/false.js
var falseDocs = {
  name: "false",
  category: "Constants",
  syntax: ["false"],
  description: "Boolean value false",
  examples: ["false"],
  seealso: ["true"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/i.js
var iDocs = {
  name: "i",
  category: "Constants",
  syntax: ["i"],
  description: "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
  examples: ["i", "i * i", "sqrt(-1)"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/Infinity.js
var InfinityDocs = {
  name: "Infinity",
  category: "Constants",
  syntax: ["Infinity"],
  description: "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
  examples: ["Infinity", "1 / 0"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN10.js
var LN10Docs = {
  name: "LN10",
  category: "Constants",
  syntax: ["LN10"],
  description: "Returns the natural logarithm of 10, approximately equal to 2.302",
  examples: ["LN10", "log(10)"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN2.js
var LN2Docs = {
  name: "LN2",
  category: "Constants",
  syntax: ["LN2"],
  description: "Returns the natural logarithm of 2, approximately equal to 0.693",
  examples: ["LN2", "log(2)"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG10E.js
var LOG10EDocs = {
  name: "LOG10E",
  category: "Constants",
  syntax: ["LOG10E"],
  description: "Returns the base-10 logarithm of E, approximately equal to 0.434",
  examples: ["LOG10E", "log(e, 10)"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG2E.js
var LOG2EDocs = {
  name: "LOG2E",
  category: "Constants",
  syntax: ["LOG2E"],
  description: "Returns the base-2 logarithm of E, approximately equal to 1.442",
  examples: ["LOG2E", "log(e, 2)"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/NaN.js
var NaNDocs = {
  name: "NaN",
  category: "Constants",
  syntax: ["NaN"],
  description: "Not a number",
  examples: ["NaN", "0 / 0"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/null.js
var nullDocs = {
  name: "null",
  category: "Constants",
  syntax: ["null"],
  description: "Value null",
  examples: ["null"],
  seealso: ["true", "false"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/phi.js
var phiDocs = {
  name: "phi",
  category: "Constants",
  syntax: ["phi"],
  description: "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
  examples: ["phi"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/pi.js
var piDocs = {
  name: "pi",
  category: "Constants",
  syntax: ["pi"],
  description: "The number pi is a mathematical constant that is the ratio of a circle\'s circumference to its diameter, and is approximately equal to 3.14159",
  examples: ["pi", "sin(pi/2)"],
  seealso: ["tau"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT1_2.js
var SQRT12Docs = {
  name: "SQRT1_2",
  category: "Constants",
  syntax: ["SQRT1_2"],
  description: "Returns the square root of 1/2, approximately equal to 0.707",
  examples: ["SQRT1_2", "sqrt(1/2)"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT2.js
var SQRT2Docs = {
  name: "SQRT2",
  category: "Constants",
  syntax: ["SQRT2"],
  description: "Returns the square root of 2, approximately equal to 1.414",
  examples: ["SQRT2", "sqrt(2)"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/tau.js
var tauDocs = {
  name: "tau",
  category: "Constants",
  syntax: ["tau"],
  description: "Tau is the ratio constant of a circle\'s circumference to radius, equal to 2 * pi, approximately 6.2832.",
  examples: ["tau", "2 * pi"],
  seealso: ["pi"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/true.js
var trueDocs = {
  name: "true",
  category: "Constants",
  syntax: ["true"],
  description: "Boolean value true",
  examples: ["true"],
  seealso: ["false"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/version.js
var versionDocs = {
  name: "version",
  category: "Constants",
  syntax: ["version"],
  description: "A string with the version number of math.js",
  examples: ["version"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/bignumber.js
var bignumberDocs = {
  name: "bignumber",
  category: "Construction",
  syntax: ["bignumber(x)"],
  description: "Create a big number from a number or string.",
  examples: ["0.1 + 0.2", "bignumber(0.1) + bignumber(0.2)", 'bignumber("7.2")', 'bignumber("7.2e500")', "bignumber([0.1, 0.2, 0.3])"],
  seealso: ["boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/boolean.js
var booleanDocs = {
  name: "boolean",
  category: "Construction",
  syntax: ["x", "boolean(x)"],
  description: "Convert a string or number into a boolean.",
  examples: ["boolean(0)", "boolean(1)", "boolean(3)", 'boolean("true")', 'boolean("false")', "boolean([1, 0, 1, 1])"],
  seealso: ["bignumber", "complex", "index", "matrix", "number", "string", "unit"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/complex.js
var complexDocs = {
  name: "complex",
  category: "Construction",
  syntax: ["complex()", "complex(re, im)", "complex(string)"],
  description: "Create a complex number.",
  examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
  seealso: ["bignumber", "boolean", "index", "matrix", "number", "string", "unit"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/createUnit.js
var createUnitDocs = {
  name: "createUnit",
  category: "Construction",
  syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
  description: "Create a user-defined unit and register it with the Unit type.",
  examples: ['createUnit("foo")', 'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})', 'createUnit("mph", "1 mile/hour")'],
  seealso: ["unit", "splitUnit"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/fraction.js
var fractionDocs = {
  name: "fraction",
  category: "Construction",
  syntax: ["fraction(num)", "fraction(matrix)", "fraction(num,den)", "fraction({n: num, d: den})"],
  description: "Create a fraction from a number or from integer numerator and denominator.",
  examples: ["fraction(0.125)", "fraction(1, 3) + fraction(2, 5)", "fraction({n: 333, d: 53})", "fraction([sqrt(9), sqrt(10), sqrt(11)])"],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "string", "unit"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/index.js
var indexDocs = {
  name: "index",
  category: "Construction",
  syntax: ["[start]", "[start:end]", "[start:step:end]", "[start1, start 2, ...]", "[start1:end1, start2:end2, ...]", "[start1:step1:end1, start2:step2:end2, ...]"],
  description: "Create an index to get or replace a subset of a matrix",
  examples: ["[1, 2, 3]", "A = [1, 2, 3; 4, 5, 6]", "A[1, :]", "A[1, 2] = 50", "A[1:2, 1:2] = ones(2, 2)"],
  seealso: ["bignumber", "boolean", "complex", "matrix,", "number", "range", "string", "unit"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/matrix.js
var matrixDocs = {
  name: "matrix",
  category: "Construction",
  syntax: ["[]", "[a1, b1, ...; a2, b2, ...]", "matrix()", 'matrix("dense")', "matrix([...])"],
  description: "Create a matrix.",
  examples: ["[]", "[1, 2, 3]", "[1, 2, 3; 4, 5, 6]", "matrix()", "matrix([3, 4])", 'matrix([3, 4; 5, 6], "sparse")', 'matrix([3, 4; 5, 6], "sparse", "number")'],
  seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "sparse"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/number.js
var numberDocs = {
  name: "number",
  category: "Construction",
  syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
  description: "Create a number or convert a string or boolean into a number.",
  examples: ["2", "2e3", "4.05", "number(2)", 'number("7.2")', "number(true)", "number([true, false, true, true])", 'number(unit("52cm"), "m")'],
  seealso: ["bignumber", "boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/sparse.js
var sparseDocs = {
  name: "sparse",
  category: "Construction",
  syntax: ["sparse()", "sparse([a1, b1, ...; a1, b2, ...])", 'sparse([a1, b1, ...; a1, b2, ...], "number")'],
  description: "Create a sparse matrix.",
  examples: ["sparse()", "sparse([3, 4; 5, 6])", 'sparse([3, 0; 5, 0], "number")'],
  seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "matrix"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/splitUnit.js
var splitUnitDocs = {
  name: "splitUnit",
  category: "Construction",
  syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
  description: "Split a unit in an array of units whose sum is equal to the original unit.",
  examples: ['splitUnit(1 m, ["feet", "inch"])'],
  seealso: ["unit", "createUnit"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/string.js
var stringDocs = {
  name: "string",
  category: "Construction",
  syntax: ['"text"', "string(x)"],
  description: "Create a string or convert a value to a string",
  examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "unit"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/unit.js
var unitDocs = {
  name: "unit",
  category: "Construction",
  syntax: ["value unit", "unit(value, unit)", "unit(string)"],
  description: "Create a unit.",
  examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "string"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/core/config.js
var configDocs = {
  name: "config",
  category: "Core",
  syntax: ["config()", "config(options)"],
  description: "Get configuration or change configuration.",
  examples: ["config()", "1/3 + 1/4", 'config({number: "Fraction"})', "1/3 + 1/4"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/core/import.js
var importDocs = {
  name: "import",
  category: "Core",
  syntax: ["import(functions)", "import(functions, options)"],
  description: "Import functions or constants from an object.",
  examples: ["import({myFn: f(x)=x^2, myConstant: 32 })", "myFn(2)", "myConstant"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/core/typed.js
var typedDocs = {
  name: "typed",
  category: "Core",
  syntax: ["typed(signatures)", "typed(name, signatures)"],
  description: "Create a typed function.",
  examples: ['double = typed({ "number": f(x)=x+x })', "double(2)", 'double("hello")'],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/derivative.js
var derivativeDocs = {
  name: "derivative",
  category: "Algebra",
  syntax: ["derivative(expr, variable)", "derivative(expr, variable, {simplify: boolean})"],
  description: "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
  examples: ['derivative("2x^3", "x")', 'derivative("2x^3", "x", {simplify: false})', 'derivative("2x^2 + 3x + 4", "x")', 'derivative("sin(2x)", "x")', 'f = parse("x^2 + x")', 'x = parse("x")', "df = derivative(f, x)", "df.evaluate({x: 3})"],
  seealso: ["simplify", "parse", "evaluate"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/leafCount.js
var leafCountDocs = {
  name: "leafCount",
  category: "Algebra",
  syntax: ["leafCount(expr)"],
  description: "Computes the number of leaves in the parse tree of the given expression",
  examples: ['leafCount("e^(i*pi)-1")', 'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'],
  seealso: ["simplify"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolve.js
var lsolveDocs = {
  name: "lsolve",
  category: "Algebra",
  syntax: ["x=lsolve(L, b)"],
  description: "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolveAll.js
var lsolveAllDocs = {
  name: "lsolveAll",
  category: "Algebra",
  syntax: ["x=lsolveAll(L, b)"],
  description: "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lup.js
var lupDocs = {
  name: "lup",
  category: "Algebra",
  syntax: ["lup(m)"],
  description: "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
  examples: ["lup([[2, 1], [1, 4]])", "lup(matrix([[2, 1], [1, 4]]))", "lup(sparse([[2, 1], [1, 4]]))"],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lusolve.js
var lusolveDocs = {
  name: "lusolve",
  category: "Algebra",
  syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
  description: "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
  seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/polynomialRoot.js
var polynomialRootDocs = {
  name: "polynomialRoot",
  category: "Algebra",
  syntax: ["x=polynomialRoot(-6, 3)", "x=polynomialRoot(4, -4, 1)", "x=polynomialRoot(-8, 12, -6, 1)"],
  description: "Finds the roots of a univariate polynomial given by its coefficients starting from constant, linear, and so on, increasing in degree.",
  examples: ["a = polynomialRoot(-6, 11, -6 1)"],
  seealso: ["cbrt", "sqrt"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/qr.js
var qrDocs = {
  name: "qr",
  category: "Algebra",
  syntax: ["qr(A)"],
  description: "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
  examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
  seealso: ["lup", "slu", "matrix"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/rationalize.js
var rationalizeDocs = {
  name: "rationalize",
  category: "Algebra",
  syntax: ["rationalize(expr)", "rationalize(expr, scope)", "rationalize(expr, scope, detailed)"],
  description: "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
  examples: ['rationalize("2x/y - y/(x+1)")', 'rationalize("2x/y - y/(x+1)", true)'],
  seealso: ["simplify"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/resolve.js
var resolveDocs = {
  name: "resolve",
  category: "Algebra",
  syntax: ["resolve(node, scope)"],
  description: "Recursively substitute variables in an expression tree.",
  examples: ['resolve(parse("1 + x"), { x: 7 })', 'resolve(parse("size(text)"), { text: "Hello World" })', 'resolve(parse("x + y"), { x: parse("3z") })', 'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'],
  seealso: ["simplify", "evaluate"],
  mayThrow: ["ReferenceError"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplify.js
var simplifyDocs = {
  name: "simplify",
  category: "Algebra",
  syntax: ["simplify(expr)", "simplify(expr, rules)"],
  description: "Simplify an expression tree.",
  examples: ['simplify("3 + 2 / 4")', 'simplify("2x + x")', 'f = parse("x * (x + 2 + x)")', "simplified = simplify(f)", "simplified.evaluate({x: 2})"],
  seealso: ["simplifyCore", "derivative", "evaluate", "parse", "rationalize", "resolve"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyConstant.js
var simplifyConstantDocs = {
  name: "simplifyConstant",
  category: "Algebra",
  syntax: ["simplifyConstant(expr)", "simplifyConstant(expr, options)"],
  description: "Replace constant subexpressions of node with their values.",
  examples: ['simplifyConatant("(3-3)*x")', 'simplifyConstant(parse("z-cos(tau/8)"))'],
  seealso: ["simplify", "simplifyCore", "evaluate"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyCore.js
var simplifyCoreDocs = {
  name: "simplifyCore",
  category: "Algebra",
  syntax: ["simplifyCore(node)"],
  description: "Perform simple one-pass simplifications on an expression tree.",
  examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
  seealso: ["simplify", "simplifyConstant", "evaluate"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/slu.js
var sluDocs = {
  name: "slu",
  category: "Algebra",
  syntax: ["slu(A, order, threshold)"],
  description: "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
  examples: ["slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/symbolicEqual.js
var symbolicEqualDocs = {
  name: "symbolicEqual",
  category: "Algebra",
  syntax: ["symbolicEqual(expr1, expr2)", "symbolicEqual(expr1, expr2, options)"],
  description: "Returns true if the difference of the expressions simplifies to 0",
  examples: ['symbolicEqual("x*y","y*x")', 'symbolicEqual("abs(x^2)", "x^2")', 'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'],
  seealso: ["simplify", "evaluate"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolve.js
var usolveDocs = {
  name: "usolve",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
  seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolveAll.js
var usolveAllDocs = {
  name: "usolveAll",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
  seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/abs.js
var absDocs = {
  name: "abs",
  category: "Arithmetic",
  syntax: ["abs(x)"],
  description: "Compute the absolute value.",
  examples: ["abs(3.5)", "abs(-4.2)"],
  seealso: ["sign"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/add.js
var addDocs = {
  name: "add",
  category: "Operators",
  syntax: ["x + y", "add(x, y)"],
  description: "Add two values.",
  examples: ["a = 2.1 + 3.6", "a - 3.6", "3 + 2i", "3 cm + 2 inch", '"2.3" + "4"'],
  seealso: ["subtract"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cbrt.js
var cbrtDocs = {
  name: "cbrt",
  category: "Arithmetic",
  syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
  description: "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
  examples: ["cbrt(64)", "cube(4)", "cbrt(-8)", "cbrt(2 + 3i)", "cbrt(8i)", "cbrt(8i, true)", "cbrt(27 m^3)"],
  seealso: ["square", "sqrt", "cube", "multiply"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/ceil.js
var ceilDocs = {
  name: "ceil",
  category: "Arithmetic",
  syntax: ["ceil(x)"],
  description: "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
  examples: ["ceil(3.2)", "ceil(3.8)", "ceil(-4.2)"],
  seealso: ["floor", "fix", "round"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cube.js
var cubeDocs = {
  name: "cube",
  category: "Arithmetic",
  syntax: ["cube(x)"],
  description: "Compute the cube of a value. The cube of x is x * x * x.",
  examples: ["cube(2)", "2^3", "2 * 2 * 2"],
  seealso: ["multiply", "square", "pow"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/divide.js
var divideDocs = {
  name: "divide",
  category: "Operators",
  syntax: ["x / y", "divide(x, y)"],
  description: "Divide two values.",
  examples: ["a = 2 / 3", "a * 3", "4.5 / 2", "3 + 4 / 2", "(3 + 4) / 2", "18 km / 4.5"],
  seealso: ["multiply"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotDivide.js
var dotDivideDocs = {
  name: "dotDivide",
  category: "Operators",
  syntax: ["x ./ y", "dotDivide(x, y)"],
  description: "Divide two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
  seealso: ["multiply", "dotMultiply", "divide"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotMultiply.js
var dotMultiplyDocs = {
  name: "dotMultiply",
  category: "Operators",
  syntax: ["x .* y", "dotMultiply(x, y)"],
  description: "Multiply two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
  seealso: ["multiply", "divide", "dotDivide"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotPow.js
var dotPowDocs = {
  name: "dotPow",
  category: "Operators",
  syntax: ["x .^ y", "dotPow(x, y)"],
  description: "Calculates the power of x to y element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
  seealso: ["pow"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/exp.js
var expDocs = {
  name: "exp",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Calculate the exponent of a value.",
  examples: ["exp(1.3)", "e ^ 1.3", "log(exp(1.3))", "x = 2.4", "(exp(i*x) == cos(x) + i*sin(x))   # Euler\'s formula"],
  seealso: ["expm", "expm1", "pow", "log"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm.js
var expmDocs = {
  name: "expm",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Compute the matrix exponential, expm(A) = e^A. " + "The matrix must be square. " + "Not to be confused with exp(a), which performs element-wise exponentiation.",
  examples: ["expm([[0,2],[0,0]])"],
  seealso: ["exp"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm1.js
var expm1Docs = {
  name: "expm1",
  category: "Arithmetic",
  syntax: ["expm1(x)"],
  description: "Calculate the value of subtracting 1 from the exponential value.",
  examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
  seealso: ["exp", "pow", "log"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/fix.js
var fixDocs = {
  name: "fix",
  category: "Arithmetic",
  syntax: ["fix(x)"],
  description: "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
  examples: ["fix(3.2)", "fix(3.8)", "fix(-4.2)", "fix(-4.8)"],
  seealso: ["ceil", "floor", "round"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/floor.js
var floorDocs = {
  name: "floor",
  category: "Arithmetic",
  syntax: ["floor(x)"],
  description: "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
  examples: ["floor(3.2)", "floor(3.8)", "floor(-4.2)"],
  seealso: ["ceil", "fix", "round"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/gcd.js
var gcdDocs = {
  name: "gcd",
  category: "Arithmetic",
  syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
  description: "Compute the greatest common divisor.",
  examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
  seealso: ["lcm", "xgcd"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/hypot.js
var hypotDocs = {
  name: "hypot",
  category: "Arithmetic",
  syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
  description: "Calculate the hypotenusa of a list with values. ",
  examples: ["hypot(3, 4)", "sqrt(3^2 + 4^2)", "hypot(-2)", "hypot([3, 4, 5])"],
  seealso: ["abs", "norm"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/invmod.js
var invmodDocs = {
  name: "invmod",
  category: "Arithmetic",
  syntax: ["invmod(a, b)"],
  description: "Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax \u2263 1 (mod b)",
  examples: ["invmod(8, 12)=NaN", "invmod(7, 13)=2", "invmod(15151, 15122)=10429"],
  seealso: ["gcd", "xgcd"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/lcm.js
var lcmDocs = {
  name: "lcm",
  category: "Arithmetic",
  syntax: ["lcm(x, y)"],
  description: "Compute the least common multiple.",
  examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
  seealso: ["gcd"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log.js
var logDocs = {
  name: "log",
  category: "Arithmetic",
  syntax: ["log(x)", "log(x, base)"],
  description: "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
  examples: ["log(3.5)", "a = log(2.4)", "exp(a)", "10 ^ 4", "log(10000, 10)", "log(10000) / log(10)", "b = log(1024, 2)", "2 ^ b"],
  seealso: ["exp", "log1p", "log2", "log10"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log10.js
var log10Docs = {
  name: "log10",
  category: "Arithmetic",
  syntax: ["log10(x)"],
  description: "Compute the 10-base logarithm of a value.",
  examples: ["log10(0.00001)", "log10(10000)", "10 ^ 4", "log(10000) / log(10)", "log(10000, 10)"],
  seealso: ["exp", "log"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log1p.js
var log1pDocs = {
  name: "log1p",
  category: "Arithmetic",
  syntax: ["log1p(x)", "log1p(x, base)"],
  description: "Calculate the logarithm of a `value+1`",
  examples: ["log1p(2.5)", "exp(log1p(1.4))", "pow(10, 4)", "log1p(9999, 10)", "log1p(9999) / log(10)"],
  seealso: ["exp", "log", "log2", "log10"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log2.js
var log2Docs = {
  name: "log2",
  category: "Arithmetic",
  syntax: ["log2(x)"],
  description: "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
  examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
  seealso: ["exp", "log1p", "log", "log10"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/mod.js
var modDocs = {
  name: "mod",
  category: "Operators",
  syntax: ["x % y", "x mod y", "mod(x, y)"],
  description: "Calculates the modulus, the remainder of an integer division.",
  examples: ["7 % 3", "11 % 2", "10 mod 4", "isOdd(x) = x % 2", "isOdd(2)", "isOdd(3)"],
  seealso: ["divide"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/multiply.js
var multiplyDocs = {
  name: "multiply",
  category: "Operators",
  syntax: ["x * y", "multiply(x, y)"],
  description: "multiply two values.",
  examples: ["a = 2.1 * 3.4", "a / 3.4", "2 * 3 + 4", "2 * (3 + 4)", "3 * 2.1 km"],
  seealso: ["divide"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/norm.js
var normDocs = {
  name: "norm",
  category: "Arithmetic",
  syntax: ["norm(x)", "norm(x, p)"],
  description: "Calculate the norm of a number, vector or matrix.",
  examples: ["abs(-3.5)", "norm(-3.5)", "norm(3 - 4i)", "norm([1, 2, -3], Infinity)", "norm([1, 2, -3], -Infinity)", "norm([3, 4], 2)", "norm([[1, 2], [3, 4]], 1)", 'norm([[1, 2], [3, 4]], "inf")', 'norm([[1, 2], [3, 4]], "fro")']
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoot.js
var nthRootDocs = {
  name: "nthRoot",
  category: "Arithmetic",
  syntax: ["nthRoot(a)", "nthRoot(a, root)"],
  description: "Calculate the nth root of a value. " + "The principal nth root of a positive real number A, " + 'is the positive real solution of the equation "x^root = A".',
  examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
  seealso: ["nthRoots", "pow", "sqrt"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoots.js
var nthRootsDocs = {
  name: "nthRoots",
  category: "Arithmetic",
  syntax: ["nthRoots(A)", "nthRoots(A, root)"],
  description: "" + "Calculate the nth roots of a value. " + "An nth root of a positive real number A, " + 'is a positive real solution of the equation "x^root = A". ' + "This function returns an array of complex values.",
  examples: ["nthRoots(1)", "nthRoots(1, 3)"],
  seealso: ["sqrt", "pow", "nthRoot"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/pow.js
var powDocs = {
  name: "pow",
  category: "Operators",
  syntax: ["x ^ y", "pow(x, y)"],
  description: "Calculates the power of x to y, x^y.",
  examples: ["2^3", "2*2*2", "1 + e ^ (pi * i)", "pow([[1, 2], [4, 3]], 2)", "pow([[1, 2], [4, 3]], -1)"],
  seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/round.js
var roundDocs = {
  name: "round",
  category: "Arithmetic",
  syntax: ["round(x)", "round(x, n)"],
  description: "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
  examples: ["round(3.2)", "round(3.8)", "round(-4.2)", "round(-4.8)", "round(pi, 3)", "round(123.45678, 2)"],
  seealso: ["ceil", "floor", "fix"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sign.js
var signDocs = {
  name: "sign",
  category: "Arithmetic",
  syntax: ["sign(x)"],
  description: "Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",
  examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
  seealso: ["abs"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrt.js
var sqrtDocs = {
  name: "sqrt",
  category: "Arithmetic",
  syntax: ["sqrt(x)"],
  description: "Compute the square root value. If x = y * y, then y is the square root of x.",
  examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
  seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrtm.js
var sqrtmDocs = {
  name: "sqrtm",
  category: "Arithmetic",
  syntax: ["sqrtm(x)"],
  description: "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
  examples: ["sqrtm([[33, 24], [48, 57]])"],
  seealso: ["sqrt", "abs", "square", "multiply"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/sylvester.js
var sylvesterDocs = {
  name: "sylvester",
  category: "Matrix",
  syntax: ["sylvester(A,B,C)"],
  description: "Solves the real-valued Sylvester equation AX+XB=C for X",
  examples: ["sylvester([[-1, -2], [1, 1]], [[-2, 1], [-1, 2]], [[-3, 2], [3, 0]])", "sylvester(A,B,C)"],
  seealso: ["schur", "lyap"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/schur.js
var schurDocs = {
  name: "schur",
  category: "Matrix",
  syntax: ["schur(A)"],
  description: "Performs a real Schur decomposition of the real matrix A = UTU\'",
  examples: ["schur([[1, 0], [-4, 3]])", "schur(A)"],
  seealso: ["lyap", "sylvester"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/lyap.js
var lyapDocs = {
  name: "lyap",
  category: "Matrix",
  syntax: ["lyap(A,Q)"],
  description: "Solves the Continuous-time Lyapunov equation AP+PA\'+Q=0 for P",
  examples: ["lyap([[-2, 0], [1, -4]], [[3, 1], [1, 3]])", "lyap(A,Q)"],
  seealso: ["schur", "sylvester"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/square.js
var squareDocs = {
  name: "square",
  category: "Arithmetic",
  syntax: ["square(x)"],
  description: "Compute the square of a value. The square of x is x * x.",
  examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
  seealso: ["multiply", "pow", "sqrt", "cube"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/subtract.js
var subtractDocs = {
  name: "subtract",
  category: "Operators",
  syntax: ["x - y", "subtract(x, y)"],
  description: "subtract two values.",
  examples: ["a = 5.3 - 2", "a + 2", "2/3 - 1/6", "2 * 3 - 3", "2.1 km - 500m"],
  seealso: ["add"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryMinus.js
var unaryMinusDocs = {
  name: "unaryMinus",
  category: "Operators",
  syntax: ["-x", "unaryMinus(x)"],
  description: "Inverse the sign of a value. Converts booleans and strings to numbers.",
  examples: ["-4.5", "-(-5.6)", '-"22"'],
  seealso: ["add", "subtract", "unaryPlus"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryPlus.js
var unaryPlusDocs = {
  name: "unaryPlus",
  category: "Operators",
  syntax: ["+x", "unaryPlus(x)"],
  description: "Converts booleans and strings to numbers.",
  examples: ["+true", '+"2"'],
  seealso: ["add", "subtract", "unaryMinus"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/xgcd.js
var xgcdDocs = {
  name: "xgcd",
  category: "Arithmetic",
  syntax: ["xgcd(a, b)"],
  description: "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
  examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
  seealso: ["gcd", "lcm"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitAnd.js
var bitAndDocs = {
  name: "bitAnd",
  category: "Bitwise",
  syntax: ["x & y", "bitAnd(x, y)"],
  description: "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
  examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
  seealso: ["bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitNot.js
var bitNotDocs = {
  name: "bitNot",
  category: "Bitwise",
  syntax: ["~x", "bitNot(x)"],
  description: "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
  examples: ["~1", "~2", "bitNot([2, -3, 4])"],
  seealso: ["bitAnd", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitOr.js
var bitOrDocs = {
  name: "bitOr",
  category: "Bitwise",
  syntax: ["x | y", "bitOr(x, y)"],
  description: "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
  examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
  seealso: ["bitAnd", "bitNot", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitXor.js
var bitXorDocs = {
  name: "bitXor",
  category: "Bitwise",
  syntax: ["bitXor(x, y)"],
  description: "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
  examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
  seealso: ["bitAnd", "bitNot", "bitOr", "leftShift", "rightArithShift", "rightLogShift"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/leftShift.js
var leftShiftDocs = {
  name: "leftShift",
  category: "Bitwise",
  syntax: ["x << y", "leftShift(x, y)"],
  description: "Bitwise left logical shift of a value x by y number of bits.",
  examples: ["4 << 1", "8 >> 1"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "rightArithShift", "rightLogShift"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightArithShift.js
var rightArithShiftDocs = {
  name: "rightArithShift",
  category: "Bitwise",
  syntax: ["x >> y", "rightArithShift(x, y)"],
  description: "Bitwise right arithmetic shift of a value x by y number of bits.",
  examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightLogShift"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightLogShift.js
var rightLogShiftDocs = {
  name: "rightLogShift",
  category: "Bitwise",
  syntax: ["x >>> y", "rightLogShift(x, y)"],
  description: "Bitwise right logical shift of a value x by y number of bits.",
  examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/bellNumbers.js
var bellNumbersDocs = {
  name: "bellNumbers",
  category: "Combinatorics",
  syntax: ["bellNumbers(n)"],
  description: "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["bellNumbers(3)", "bellNumbers(8)"],
  seealso: ["stirlingS2"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/catalan.js
var catalanDocs = {
  name: "catalan",
  category: "Combinatorics",
  syntax: ["catalan(n)"],
  description: "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["catalan(3)", "catalan(8)"],
  seealso: ["bellNumbers"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/composition.js
var compositionDocs = {
  name: "composition",
  category: "Combinatorics",
  syntax: ["composition(n, k)"],
  description: "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
  examples: ["composition(5, 3)"],
  seealso: ["combinations"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/stirlingS2.js
var stirlingS2Docs = {
  name: "stirlingS2",
  category: "Combinatorics",
  syntax: ["stirlingS2(n, k)"],
  description: "he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
  examples: ["stirlingS2(5, 3)"],
  seealso: ["bellNumbers"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/arg.js
var argDocs = {
  name: "arg",
  category: "Complex",
  syntax: ["arg(x)"],
  description: "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
  examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
  seealso: ["re", "im", "conj", "abs"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/conj.js
var conjDocs = {
  name: "conj",
  category: "Complex",
  syntax: ["conj(x)"],
  description: "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
  examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
  seealso: ["re", "im", "abs", "arg"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/im.js
var imDocs = {
  name: "im",
  category: "Complex",
  syntax: ["im(x)"],
  description: "Get the imaginary part of a complex number.",
  examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
  seealso: ["re", "conj", "abs", "arg"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/re.js
var reDocs = {
  name: "re",
  category: "Complex",
  syntax: ["re(x)"],
  description: "Get the real part of a complex number.",
  examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
  seealso: ["im", "conj", "abs", "arg"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/evaluate.js
var evaluateDocs = {
  name: "evaluate",
  category: "Expression",
  syntax: ["evaluate(expression)", "evaluate([expr1, expr2, expr3, ...])"],
  description: "Evaluate an expression or an array with expressions.",
  examples: ['evaluate("2 + 3")', 'evaluate("sqrt(" + 4 + ")")'],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/help.js
var helpDocs = {
  name: "help",
  category: "Expression",
  syntax: ["help(object)", "help(string)"],
  description: "Display documentation on a function or data type.",
  examples: ["help(sqrt)", 'help("complex")'],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/distance.js
var distanceDocs = {
  name: "distance",
  category: "Geometry",
  syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
  description: "Calculates the Euclidean distance between two points.",
  examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/intersect.js
var intersectDocs = {
  name: "intersect",
  category: "Geometry",
  syntax: ["intersect(expr1, expr2, expr3, expr4)", "intersect(expr1, expr2, expr3)"],
  description: "Computes the intersection point of lines and/or planes.",
  examples: ["intersect([0, 0], [10, 10], [10, 0], [0, 10])", "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/and.js
var andDocs = {
  name: "and",
  category: "Logical",
  syntax: ["x and y", "and(x, y)"],
  description: "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
  examples: ["true and false", "true and true", "2 and 4"],
  seealso: ["not", "or", "xor"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/not.js
var notDocs = {
  name: "not",
  category: "Logical",
  syntax: ["not x", "not(x)"],
  description: "Logical not. Flips the boolean value of given argument.",
  examples: ["not true", "not false", "not 2", "not 0"],
  seealso: ["and", "or", "xor"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/or.js
var orDocs = {
  name: "or",
  category: "Logical",
  syntax: ["x or y", "or(x, y)"],
  description: "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
  examples: ["true or false", "false or false", "0 or 4"],
  seealso: ["not", "and", "xor"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/xor.js
var xorDocs = {
  name: "xor",
  category: "Logical",
  syntax: ["x xor y", "xor(x, y)"],
  description: "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
  examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
  seealso: ["not", "and", "or"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/column.js
var columnDocs = {
  name: "column",
  category: "Matrix",
  syntax: ["column(x, index)"],
  description: "Return a column from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
  seealso: ["row", "matrixFromColumns"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/concat.js
var concatDocs = {
  name: "concat",
  category: "Matrix",
  syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
  description: "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
  examples: ["A = [1, 2; 5, 6]", "B = [3, 4; 7, 8]", "concat(A, B)", "concat(A, B, 1)", "concat(A, B, 2)"],
  seealso: ["det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/count.js
var countDocs = {
  name: "count",
  category: "Matrix",
  syntax: ["count(x)"],
  description: "Count the number of elements of a matrix, array or string.",
  examples: ["a = [1, 2; 3, 4; 5, 6]", "count(a)", "size(a)", 'count("hello world")'],
  seealso: ["size"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/cross.js
var crossDocs = {
  name: "cross",
  category: "Matrix",
  syntax: ["cross(A, B)"],
  description: "Calculate the cross product for two vectors in three dimensional space.",
  examples: ["cross([1, 1, 0],  [0, 1, 1])", "cross([3, -3, 1], [4, 9, 2])", "cross([2, 3, 4],  [5, 6, 7])"],
  seealso: ["multiply", "dot"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ctranspose.js
var ctransposeDocs = {
  name: "ctranspose",
  category: "Matrix",
  syntax: ["x\'", "ctranspose(x)"],
  description: "Complex Conjugate and Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a\'", "ctranspose(a)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/det.js
var detDocs = {
  name: "det",
  category: "Matrix",
  syntax: ["det(x)"],
  description: "Calculate the determinant of a matrix",
  examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
  seealso: ["concat", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diag.js
var diagDocs = {
  name: "diag",
  category: "Matrix",
  syntax: ["diag(x)", "diag(x, k)"],
  description: "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
  examples: ["diag(1:3)", "diag(1:3, 1)", "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]", "diag(a)"],
  seealso: ["concat", "det", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diff.js
var diffDocs = {
  name: "diff",
  category: "Matrix",
  syntax: ["diff(arr)", "diff(arr, dim)"],
  description: ["Create a new matrix or array with the difference of the passed matrix or array.", "Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference", "If no dimension parameter is passed it is assumed as dimension 0", "Dimension is zero-based in javascript and one-based in the parser", "Arrays must be \'rectangular\' meaning arrays like [1, 2]", "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"],
  examples: ["diff([1, 2, 4, 7, 0])", "diff([1, 2, 4, 7, 0], 0)", "diff(matrix([1, 2, 4, 7, 0]))", "diff([[1, 2], [3, 4]])", "diff([[1, 2], [3, 4]], 0)", "diff([[1, 2], [3, 4]], 1)", "diff([[1, 2], [3, 4]], bignumber(1))", "diff(matrix([[1, 2], [3, 4]]), 1)", "diff([[1, 2], matrix([3, 4])], 1)"],
  seealso: ["subtract", "partitionSelect"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/dot.js
var dotDocs = {
  name: "dot",
  category: "Matrix",
  syntax: ["dot(A, B)", "A * B"],
  description: "Calculate the dot product of two vectors. " + "The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] " + "is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
  examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
  seealso: ["multiply", "cross"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/eigs.js
var eigsDocs = {
  name: "eigs",
  category: "Matrix",
  syntax: ["eigs(x)"],
  description: "Calculate the eigenvalues and eigenvectors of a real symmetric matrix",
  examples: ["eigs([[5, 2.3], [2.3, 1]])"],
  seealso: ["inv"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/filter.js
var filterDocs = {
  name: "filter",
  category: "Matrix",
  syntax: ["filter(x, test)"],
  description: "Filter items in a matrix.",
  examples: ["isPositive(x) = x > 0", "filter([6, -2, -1, 4, 3], isPositive)", "filter([6, -2, 0, 1, 0], x != 0)"],
  seealso: ["sort", "map", "forEach"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/flatten.js
var flattenDocs = {
  name: "flatten",
  category: "Matrix",
  syntax: ["flatten(x)"],
  description: "Flatten a multi dimensional matrix into a single dimensional matrix.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "size(a)", "b = flatten(a)", "size(b)"],
  seealso: ["concat", "resize", "size", "squeeze"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/forEach.js
var forEachDocs = {
  name: "forEach",
  category: "Matrix",
  syntax: ["forEach(x, callback)"],
  description: "Iterates over all elements of a matrix/array, and executes the given callback function.",
  examples: ["numberOfPets = {}", "addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;", 'forEach(["Dog","Cat","Cat"], addPet)', "numberOfPets"],
  seealso: ["map", "sort", "filter"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/getMatrixDataType.js
var getMatrixDataTypeDocs = {
  name: "getMatrixDataType",
  category: "Matrix",
  syntax: ["getMatrixDataType(x)"],
  description: "Find the data type of all elements in a matrix or array, " + 'for example "number" if all items are a number ' + 'and "Complex" if all values are complex numbers. ' + 'If a matrix contains more than one data type, it will return "mixed".',
  examples: ["getMatrixDataType([1, 2, 3])", "getMatrixDataType([[5 cm], [2 inch]])", 'getMatrixDataType([1, "text"])', "getMatrixDataType([1, bignumber(4)])"],
  seealso: ["matrix", "sparse", "typeOf"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/identity.js
var identityDocs = {
  name: "identity",
  category: "Matrix",
  syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
  description: "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
  examples: ["identity(3)", "identity(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "identity(size(a))"],
  seealso: ["concat", "det", "diag", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/inv.js
var invDocs = {
  name: "inv",
  category: "Matrix",
  syntax: ["inv(x)"],
  description: "Calculate the inverse of a matrix",
  examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
  seealso: ["concat", "det", "diag", "identity", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/pinv.js
var pinvDocs = {
  name: "pinv",
  category: "Matrix",
  syntax: ["pinv(x)"],
  description: "Calculate the Moore\u2013Penrose inverse of a matrix",
  examples: ["pinv([1, 2; 3, 4])", "pinv([[1, 0], [0, 1], [0, 1]])", "pinv(4)"],
  seealso: ["inv"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/kron.js
var kronDocs = {
  name: "kron",
  category: "Matrix",
  syntax: ["kron(x, y)"],
  description: "Calculates the kronecker product of 2 matrices or vectors.",
  examples: ["kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])", "kron([1,1], [2,3,4])"],
  seealso: ["multiply", "dot", "cross"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/map.js
var mapDocs = {
  name: "map",
  category: "Matrix",
  syntax: ["map(x, callback)"],
  description: "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",
  examples: ["map([1, 2, 3], square)"],
  seealso: ["filter", "forEach"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromColumns.js
var matrixFromColumnsDocs = {
  name: "matrixFromColumns",
  category: "Matrix",
  syntax: ["matrixFromColumns(...arr)", "matrixFromColumns(row1, row2)", "matrixFromColumns(row1, row2, row3)"],
  description: "Create a dense matrix from vectors as individual columns.",
  examples: ["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromRows", "matrixFromFunction", "zeros"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromFunction.js
var matrixFromFunctionDocs = {
  name: "matrixFromFunction",
  category: "Matrix",
  syntax: ["matrixFromFunction(size, fn)", "matrixFromFunction(size, fn, format)", "matrixFromFunction(size, fn, format, datatype)", "matrixFromFunction(size, format, fn)", "matrixFromFunction(size, format, datatype, fn)"],
  description: "Create a matrix by evaluating a generating function at each index.",
  examples: ["f(I) = I[1] - I[2]", "matrixFromFunction([3,3], f)", "g(I) = I[1] - I[2] == 1 ? 4 : 0", 'matrixFromFunction([100, 100], "sparse", g)', "matrixFromFunction([5], random)"],
  seealso: ["matrix", "matrixFromRows", "matrixFromColumns", "zeros"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromRows.js
var matrixFromRowsDocs = {
  name: "matrixFromRows",
  category: "Matrix",
  syntax: ["matrixFromRows(...arr)", "matrixFromRows(row1, row2)", "matrixFromRows(row1, row2, row3)"],
  description: "Create a dense matrix from vectors as individual rows.",
  examples: ["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromColumns", "matrixFromFunction", "zeros"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ones.js
var onesDocs = {
  name: "ones",
  category: "Matrix",
  syntax: ["ones(m)", "ones(m, n)", "ones(m, n, p, ...)", "ones([m])", "ones([m, n])", "ones([m, n, p, ...])"],
  description: "Create a matrix containing ones.",
  examples: ["ones(3)", "ones(3, 5)", "ones([2,3]) * 4.5", "a = [1, 2, 3; 4, 5, 6]", "ones(size(a))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/partitionSelect.js
var partitionSelectDocs = {
  name: "partitionSelect",
  category: "Matrix",
  syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
  description: "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
  examples: ["partitionSelect([5, 10, 1], 2)", 'partitionSelect(["C", "B", "A", "D"], 1, compareText)', "arr = [5, 2, 1]", "partitionSelect(arr, 0) # returns 1, arr is now: [1, 2, 5]", "arr", "partitionSelect(arr, 1, \'desc\') # returns 2, arr is now: [5, 2, 1]", "arr"],
  seealso: ["sort"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/range.js
var rangeDocs = {
  name: "range",
  category: "Type",
  syntax: ["start:end", "start:step:end", "range(start, end)", "range(start, end, step)", "range(string)"],
  description: "Create a range. Lower bound of the range is included, upper bound is excluded.",
  examples: ["1:5", "3:-1:-3", "range(3, 7)", "range(0, 12, 2)", 'range("4:10")', "a = [1, 2, 3, 4; 5, 6, 7, 8]", "a[1:2, 1:2]"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/reshape.js
var reshapeDocs = {
  name: "reshape",
  category: "Matrix",
  syntax: ["reshape(x, sizes)"],
  description: "Reshape a multi dimensional array to fit the specified dimensions.",
  examples: ["reshape([1, 2, 3, 4, 5, 6], [2, 3])", "reshape([[1, 2], [3, 4]], [1, 4])", "reshape([[1, 2], [3, 4]], [4])", "reshape([1, 2, 3, 4], [-1, 2])"],
  seealso: ["size", "squeeze", "resize"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/resize.js
var resizeDocs = {
  name: "resize",
  category: "Matrix",
  syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
  description: "Resize a matrix.",
  examples: ["resize([1,2,3,4,5], [3])", "resize([1,2,3], [5])", "resize([1,2,3], [5], -1)", "resize(2, [2, 3])", 'resize("hello", [8], "!")'],
  seealso: ["size", "subset", "squeeze", "reshape"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotate.js
var rotateDocs = {
  name: "rotate",
  category: "Matrix",
  syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). " + "Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: ["rotate([1, 0], pi / 2)", 'rotate(matrix([1, 0]), unit("35deg"))', 'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])', 'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],
  seealso: ["matrix", "rotationMatrix"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotationMatrix.js
var rotationMatrixDocs = {
  name: "rotationMatrix",
  category: "Matrix",
  syntax: ["rotationMatrix(theta)", "rotationMatrix(theta, v)", "rotationMatrix(theta, v, format)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). " + "Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: ["rotationMatrix(pi / 2)", 'rotationMatrix(unit("45deg"), [0, 0, 1])', 'rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],
  seealso: ["cos", "sin"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/row.js
var rowDocs = {
  name: "row",
  category: "Matrix",
  syntax: ["row(x, index)"],
  description: "Return a row from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
  seealso: ["column", "matrixFromRows"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/size.js
var sizeDocs = {
  name: "size",
  category: "Matrix",
  syntax: ["size(x)"],
  description: "Calculate the size of a matrix.",
  examples: ["size(2.3)", 'size("hello world")', "a = [1, 2; 3, 4; 5, 6]", "size(a)", "size(1:6)"],
  seealso: ["concat", "count", "det", "diag", "identity", "inv", "ones", "range", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/sort.js
var sortDocs = {
  name: "sort",
  category: "Matrix",
  syntax: ["sort(x)", "sort(x, compare)"],
  description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
  examples: ["sort([5, 10, 1])", 'sort(["C", "B", "A", "D"], "natural")', "sortByLength(a, b) = size(a)[1] - size(b)[1]", 'sort(["Langdon", "Tom", "Sara"], sortByLength)', 'sort(["10", "1", "2"], "natural")'],
  seealso: ["map", "filter", "forEach"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/squeeze.js
var squeezeDocs = {
  name: "squeeze",
  category: "Matrix",
  syntax: ["squeeze(x)"],
  description: "Remove inner and outer singleton dimensions from a matrix.",
  examples: ["a = zeros(3,2,1)", "size(squeeze(a))", "b = zeros(1,1,3)", "size(squeeze(b))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "subset", "trace", "transpose", "zeros"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/subset.js
var subsetDocs = {
  name: "subset",
  category: "Matrix",
  syntax: ["value(index)", "value(index) = replacement", "subset(value, [index])", "subset(value, [index], replacement)"],
  description: "Get or set a subset of the entries of a matrix or " + "characters of a string. " + "Indexes are one-based. There should be one index specification for " + "each dimension of the target. Each specification can be a single " + "index, a list of indices, or a range in colon notation `l:u`. " + "In a range, both the lower bound l and upper bound u are included; " + "and if a bound is omitted it defaults to the most extreme valid value. " + "The cartesian product of the indices specified in each dimension " + "determines the target of the operation.",
  examples: ["d = [1, 2; 3, 4]", "e = []", "e[1, 1:2] = [5, 6]", "e[2, :] = [7, 8]", "f = d * e", "f[2, 1]", "f[:, 1]", "f[[1,2], [1,3]] = [9, 10; 11, 12]", "f"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "trace", "transpose", "zeros"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/trace.js
var traceDocs = {
  name: "trace",
  category: "Matrix",
  syntax: ["trace(A)"],
  description: "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
  examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "transpose", "zeros"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/transpose.js
var transposeDocs = {
  name: "transpose",
  category: "Matrix",
  syntax: ["x\'", "transpose(x)"],
  description: "Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a\'", "transpose(a)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/zeros.js
var zerosDocs = {
  name: "zeros",
  category: "Matrix",
  syntax: ["zeros(m)", "zeros(m, n)", "zeros(m, n, p, ...)", "zeros([m])", "zeros([m, n])", "zeros([m, n, p, ...])"],
  description: "Create a matrix containing zeros.",
  examples: ["zeros(3)", "zeros(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "zeros(size(a))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/fft.js
var fftDocs = {
  name: "fft",
  category: "Matrix",
  syntax: ["fft(x)"],
  description: "Calculate N-dimensional fourier transform",
  examples: ["fft([[1, 0], [1, 0]])"],
  seealso: ["ifft"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ifft.js
var ifftDocs = {
  name: "ifft",
  category: "Matrix",
  syntax: ["ifft(x)"],
  description: "Calculate N-dimensional inverse fourier transform",
  examples: ["ifft([[2, 2], [0, 0]])"],
  seealso: ["fft"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinations.js
var combinationsDocs = {
  name: "combinations",
  category: "Probability",
  syntax: ["combinations(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time",
  examples: ["combinations(7, 5)"],
  seealso: ["combinationsWithRep", "permutations", "factorial"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinationsWithRep.js
var combinationsWithRepDocs = {
  name: "combinationsWithRep",
  category: "Probability",
  syntax: ["combinationsWithRep(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time with replacements.",
  examples: ["combinationsWithRep(7, 5)"],
  seealso: ["combinations", "permutations", "factorial"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/factorial.js
var factorialDocs = {
  name: "factorial",
  category: "Probability",
  syntax: ["n!", "factorial(n)"],
  description: "Compute the factorial of a value",
  examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
  seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/gamma.js
var gammaDocs = {
  name: "gamma",
  category: "Probability",
  syntax: ["gamma(n)"],
  description: "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
  examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
  seealso: ["factorial"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/lgamma.js
var lgammaDocs = {
  name: "lgamma",
  category: "Probability",
  syntax: ["lgamma(n)"],
  description: "Logarithm of the gamma function for real, positive numbers and complex numbers, " + "using Lanczos approximation for numbers and Stirling series for complex numbers.",
  examples: ["lgamma(4)", "lgamma(1/2)", "lgamma(i)", "lgamma(complex(1.1, 2))"],
  seealso: ["gamma"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/kldivergence.js
var kldivergenceDocs = {
  name: "kldivergence",
  category: "Probability",
  syntax: ["kldivergence(x, y)"],
  description: "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
  examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/multinomial.js
var multinomialDocs = {
  name: "multinomial",
  category: "Probability",
  syntax: ["multinomial(A)"],
  description: "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
  examples: ["multinomial([1, 2, 1])"],
  seealso: ["combinations", "factorial"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/permutations.js
var permutationsDocs = {
  name: "permutations",
  category: "Probability",
  syntax: ["permutations(n)", "permutations(n, k)"],
  description: "Compute the number of permutations of n items taken k at a time",
  examples: ["permutations(5)", "permutations(5, 3)"],
  seealso: ["combinations", "combinationsWithRep", "factorial"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/pickRandom.js
var pickRandomDocs = {
  name: "pickRandom",
  category: "Probability",
  syntax: ["pickRandom(array)", "pickRandom(array, number)", "pickRandom(array, weights)", "pickRandom(array, number, weights)", "pickRandom(array, weights, number)"],
  description: "Pick a random entry from a given array.",
  examples: ["pickRandom(0:10)", "pickRandom([1, 3, 1, 6])", "pickRandom([1, 3, 1, 6], 2)", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"],
  seealso: ["random", "randomInt"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/random.js
var randomDocs = {
  name: "random",
  category: "Probability",
  syntax: ["random()", "random(max)", "random(min, max)", "random(size)", "random(size, max)", "random(size, min, max)"],
  description: "Return a random number.",
  examples: ["random()", "random(10, 20)", "random([2, 3])"],
  seealso: ["pickRandom", "randomInt"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/randomInt.js
var randomIntDocs = {
  name: "randomInt",
  category: "Probability",
  syntax: ["randomInt(max)", "randomInt(min, max)", "randomInt(size)", "randomInt(size, max)", "randomInt(size, min, max)"],
  description: "Return a random integer number",
  examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
  seealso: ["pickRandom", "random"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compare.js
var compareDocs = {
  name: "compare",
  category: "Relational",
  syntax: ["compare(x, y)"],
  description: "Compare two values. " + "Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ["compare(2, 3)", "compare(3, 2)", "compare(2, 2)", "compare(5cm, 40mm)", "compare(2, [1, 2, 3])"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compareNatural", "compareText"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareNatural.js
var compareNaturalDocs = {
  name: "compareNatural",
  category: "Relational",
  syntax: ["compareNatural(x, y)"],
  description: "Compare two values of any type in a deterministic, natural way. " + "Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ["compareNatural(2, 3)", "compareNatural(3, 2)", "compareNatural(2, 2)", "compareNatural(5cm, 40mm)", 'compareNatural("2", "10")', "compareNatural(2 + 3i, 2 + 4i)", "compareNatural([1, 2, 4], [1, 2, 3])", "compareNatural([1, 5], [1, 2, 3])", "compareNatural([1, 2], [1, 2])", "compareNatural({a: 2}, {a: 4})"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare", "compareText"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareText.js
var compareTextDocs = {
  name: "compareText",
  category: "Relational",
  syntax: ["compareText(x, y)"],
  description: "Compare two strings lexically. Comparison is case sensitive. " + "Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ['compareText("B", "A")', 'compareText("A", "B")', 'compareText("A", "A")', 'compareText("2", "10")', 'compare("2", "10")', "compare(2, 10)", 'compareNatural("2", "10")', 'compareText("B", ["A", "B", "C"])'],
  seealso: ["compare", "compareNatural"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/deepEqual.js
var deepEqualDocs = {
  name: "deepEqual",
  category: "Relational",
  syntax: ["deepEqual(x, y)"],
  description: "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
  examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
  seealso: ["equal", "unequal", "smaller", "larger", "smallerEq", "largerEq", "compare"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equal.js
var equalDocs = {
  name: "equal",
  category: "Relational",
  syntax: ["x == y", "equal(x, y)"],
  description: "Check equality of two values. Returns true if the values are equal, and false if not.",
  examples: ["2+2 == 3", "2+2 == 4", "a = 3.2", "b = 6-2.8", "a == b", "50cm == 0.5m"],
  seealso: ["unequal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual", "equalText"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equalText.js
var equalTextDocs = {
  name: "equalText",
  category: "Relational",
  syntax: ["equalText(x, y)"],
  description: "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
  examples: ['equalText("Hello", "Hello")', 'equalText("a", "A")', 'equal("2e3", "2000")', 'equalText("2e3", "2000")', 'equalText("B", ["A", "B", "C"])'],
  seealso: ["compare", "compareNatural", "compareText", "equal"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/larger.js
var largerDocs = {
  name: "larger",
  category: "Relational",
  syntax: ["x > y", "larger(x, y)"],
  description: "Check if value x is larger than y. Returns true if x is larger than y, and false if not.",
  examples: ["2 > 3", "5 > 2*2", "a = 3.3", "b = 6-2.8", "(a > b)", "(b < a)", "5 cm > 2 inch"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/largerEq.js
var largerEqDocs = {
  name: "largerEq",
  category: "Relational",
  syntax: ["x >= y", "largerEq(x, y)"],
  description: "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
  examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
  seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smaller.js
var smallerDocs = {
  name: "smaller",
  category: "Relational",
  syntax: ["x < y", "smaller(x, y)"],
  description: "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 < 3", "5 < 2*2", "a = 3.3", "b = 6-2.8", "(a < b)", "5 cm < 2 inch"],
  seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smallerEq.js
var smallerEqDocs = {
  name: "smallerEq",
  category: "Relational",
  syntax: ["x <= y", "smallerEq(x, y)"],
  description: "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
  seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/unequal.js
var unequalDocs = {
  name: "unequal",
  category: "Relational",
  syntax: ["x != y", "unequal(x, y)"],
  description: "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
  examples: ["2+2 != 3", "2+2 != 4", "a = 3.2", "b = 6-2.8", "a != b", "50cm != 0.5m", "5 cm != 2 inch"],
  seealso: ["equal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setCartesian.js
var setCartesianDocs = {
  name: "setCartesian",
  category: "Set",
  syntax: ["setCartesian(set1, set2)"],
  description: "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",
  examples: ["setCartesian([1, 2], [3, 4])"],
  seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDifference.js
var setDifferenceDocs = {
  name: "setDifference",
  category: "Set",
  syntax: ["setDifference(set1, set2)"],
  description: "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setIntersect", "setSymDifference"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDistinct.js
var setDistinctDocs = {
  name: "setDistinct",
  category: "Set",
  syntax: ["setDistinct(set)"],
  description: "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
  seealso: ["setMultiplicity"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIntersect.js
var setIntersectDocs = {
  name: "setIntersect",
  category: "Set",
  syntax: ["setIntersect(set1, set2)"],
  description: "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setIntersect([1, 2, 3, 4], [3, 4, 5, 6])", "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setDifference"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIsSubset.js
var setIsSubsetDocs = {
  name: "setIsSubset",
  category: "Set",
  syntax: ["setIsSubset(set1, set2)"],
  description: "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setIsSubset([1, 2], [3, 4, 5, 6])", "setIsSubset([3, 4], [3, 4, 5, 6])"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setMultiplicity.js
var setMultiplicityDocs = {
  name: "setMultiplicity",
  category: "Set",
  syntax: ["setMultiplicity(element, set)"],
  description: "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setMultiplicity(1, [1, 2, 2, 4])", "setMultiplicity(2, [1, 2, 2, 4])"],
  seealso: ["setDistinct", "setSize"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setPowerset.js
var setPowersetDocs = {
  name: "setPowerset",
  category: "Set",
  syntax: ["setPowerset(set)"],
  description: "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setPowerset([1, 2, 3])"],
  seealso: ["setCartesian"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSize.js
var setSizeDocs = {
  name: "setSize",
  category: "Set",
  syntax: ["setSize(set)", "setSize(set, unique)"],
  description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
  examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSymDifference.js
var setSymDifferenceDocs = {
  name: "setSymDifference",
  category: "Set",
  syntax: ["setSymDifference(set1, set2)"],
  description: "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setUnion.js
var setUnionDocs = {
  name: "setUnion",
  category: "Set",
  syntax: ["setUnion(set1, set2)"],
  description: "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setUnion([1, 2, 3, 4], [3, 4, 5, 6])", "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setIntersect", "setDifference"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/erf.js
var erfDocs = {
  name: "erf",
  category: "Special",
  syntax: ["erf(x)"],
  description: "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
  examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mad.js
var madDocs = {
  name: "mad",
  category: "Statistics",
  syntax: ["mad(a, b, c, ...)", "mad(A)"],
  description: "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
  examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
  seealso: ["mean", "median", "std", "abs"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/max.js
var maxDocs = {
  name: "max",
  category: "Statistics",
  syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dimension)"],
  description: "Compute the maximum value of a list of values.",
  examples: ["max(2, 3, 4, 1)", "max([2, 3, 4, 1])", "max([2, 5; 4, 3])", "max([2, 5; 4, 3], 1)", "max([2, 5; 4, 3], 2)", "max(2.7, 7.1, -4.5, 2.0, 4.1)", "min(2.7, 7.1, -4.5, 2.0, 4.1)"],
  seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mean.js
var meanDocs = {
  name: "mean",
  category: "Statistics",
  syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dimension)"],
  description: "Compute the arithmetic mean of a list of values.",
  examples: ["mean(2, 3, 4, 1)", "mean([2, 3, 4, 1])", "mean([2, 5; 4, 3])", "mean([2, 5; 4, 3], 1)", "mean([2, 5; 4, 3], 2)", "mean([1.0, 2.7, 3.2, 4.0])"],
  seealso: ["max", "median", "min", "prod", "std", "sum", "variance"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/median.js
var medianDocs = {
  name: "median",
  category: "Statistics",
  syntax: ["median(a, b, c, ...)", "median(A)"],
  description: "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
  examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
  seealso: ["max", "mean", "min", "prod", "std", "sum", "variance", "quantileSeq"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/min.js
var minDocs = {
  name: "min",
  category: "Statistics",
  syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dimension)"],
  description: "Compute the minimum value of a list of values.",
  examples: ["min(2, 3, 4, 1)", "min([2, 3, 4, 1])", "min([2, 5; 4, 3])", "min([2, 5; 4, 3], 1)", "min([2, 5; 4, 3], 2)", "min(2.7, 7.1, -4.5, 2.0, 4.1)", "max(2.7, 7.1, -4.5, 2.0, 4.1)"],
  seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mode.js
var modeDocs = {
  name: "mode",
  category: "Statistics",
  syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
  description: "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
  examples: ["mode(2, 1, 4, 3, 1)", "mode([1, 2.7, 3.2, 4, 2.7])", "mode(1, 4, 6, 1, 6)"],
  seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/prod.js
var prodDocs = {
  name: "prod",
  category: "Statistics",
  syntax: ["prod(a, b, c, ...)", "prod(A)"],
  description: "Compute the product of all values.",
  examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
  seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/quantileSeq.js
var quantileSeqDocs = {
  name: "quantileSeq",
  category: "Statistics",
  syntax: ["quantileSeq(A, prob[, sorted])", "quantileSeq(A, [prob1, prob2, ...][, sorted])", "quantileSeq(A, N[, sorted])"],
  description: "Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.",
  examples: ["quantileSeq([3, -1, 5, 7], 0.5)", "quantileSeq([3, -1, 5, 7], [1/3, 2/3])", "quantileSeq([3, -1, 5, 7], 2)", "quantileSeq([-1, 3, 5, 7], 0.5, true)"],
  seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/std.js
var stdDocs = {
  name: "std",
  category: "Statistics",
  syntax: ["std(a, b, c, ...)", "std(A)", "std(A, dimension)", "std(A, normalization)", "std(A, dimension, normalization)"],
  description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: ["std(2, 4, 6)", "std([2, 4, 6, 8])", 'std([2, 4, 6, 8], "uncorrected")', 'std([2, 4, 6, 8], "biased")', "std([1, 2, 3; 4, 5, 6])"],
  seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/cumsum.js
var cumSumDocs = {
  name: "cumsum",
  category: "Statistics",
  syntax: ["cumsum(a, b, c, ...)", "cumsum(A)"],
  description: "Compute the cumulative sum of all values.",
  examples: ["cumsum(2, 3, 4, 1)", "cumsum([2, 3, 4, 1])", "cumsum([1, 2; 3, 4])", "cumsum([1, 2; 3, 4], 1)", "cumsum([1, 2; 3, 4], 2)"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/sum.js
var sumDocs = {
  name: "sum",
  category: "Statistics",
  syntax: ["sum(a, b, c, ...)", "sum(A)", "sum(A, dimension)"],
  description: "Compute the sum of all values.",
  examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/variance.js
var varianceDocs = {
  name: "variance",
  category: "Statistics",
  syntax: ["variance(a, b, c, ...)", "variance(A)", "variance(A, dimension)", "variance(A, normalization)", "variance(A, dimension, normalization)"],
  description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: ["variance(2, 4, 6)", "variance([2, 4, 6, 8])", 'variance([2, 4, 6, 8], "uncorrected")', 'variance([2, 4, 6, 8], "biased")', "variance([1, 2, 3; 4, 5, 6])"],
  seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acos.js
var acosDocs = {
  name: "acos",
  category: "Trigonometry",
  syntax: ["acos(x)"],
  description: "Compute the inverse cosine of a value in radians.",
  examples: ["acos(0.5)", "acos(cos(2.3))"],
  seealso: ["cos", "atan", "asin"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acosh.js
var acoshDocs = {
  name: "acosh",
  category: "Trigonometry",
  syntax: ["acosh(x)"],
  description: "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
  examples: ["acosh(1.5)"],
  seealso: ["cosh", "asinh", "atanh"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acot.js
var acotDocs = {
  name: "acot",
  category: "Trigonometry",
  syntax: ["acot(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
  seealso: ["cot", "atan"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acoth.js
var acothDocs = {
  name: "acoth",
  category: "Trigonometry",
  syntax: ["acoth(x)"],
  description: "Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
  examples: ["acoth(2)", "acoth(0.5)"],
  seealso: ["acsch", "asech"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsc.js
var acscDocs = {
  name: "acsc",
  category: "Trigonometry",
  syntax: ["acsc(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
  seealso: ["csc", "asin", "asec"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsch.js
var acschDocs = {
  name: "acsch",
  category: "Trigonometry",
  syntax: ["acsch(x)"],
  description: "Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
  examples: ["acsch(0.5)"],
  seealso: ["asech", "acoth"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asec.js
var asecDocs = {
  name: "asec",
  category: "Trigonometry",
  syntax: ["asec(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
  seealso: ["acos", "acot", "acsc"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asech.js
var asechDocs = {
  name: "asech",
  category: "Trigonometry",
  syntax: ["asech(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asech(0.5)"],
  seealso: ["acsch", "acoth"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asin.js
var asinDocs = {
  name: "asin",
  category: "Trigonometry",
  syntax: ["asin(x)"],
  description: "Compute the inverse sine of a value in radians.",
  examples: ["asin(0.5)", "asin(sin(0.5))"],
  seealso: ["sin", "acos", "atan"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asinh.js
var asinhDocs = {
  name: "asinh",
  category: "Trigonometry",
  syntax: ["asinh(x)"],
  description: "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
  examples: ["asinh(0.5)"],
  seealso: ["acosh", "atanh"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan.js
var atanDocs = {
  name: "atan",
  category: "Trigonometry",
  syntax: ["atan(x)"],
  description: "Compute the inverse tangent of a value in radians.",
  examples: ["atan(0.5)", "atan(tan(0.5))"],
  seealso: ["tan", "acos", "asin"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan2.js
var atan2Docs = {
  name: "atan2",
  category: "Trigonometry",
  syntax: ["atan2(y, x)"],
  description: "Computes the principal value of the arc tangent of y/x in radians.",
  examples: ["atan2(2, 2) / pi", "angle = 60 deg in rad", "x = cos(angle)", "y = sin(angle)", "atan2(y, x)"],
  seealso: ["sin", "cos", "tan"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atanh.js
var atanhDocs = {
  name: "atanh",
  category: "Trigonometry",
  syntax: ["atanh(x)"],
  description: "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
  examples: ["atanh(0.5)"],
  seealso: ["acosh", "asinh"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cos.js
var cosDocs = {
  name: "cos",
  category: "Trigonometry",
  syntax: ["cos(x)"],
  description: "Compute the cosine of x in radians.",
  examples: ["cos(2)", "cos(pi / 4) ^ 2", "cos(180 deg)", "cos(60 deg)", "sin(0.2)^2 + cos(0.2)^2"],
  seealso: ["acos", "sin", "tan"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cosh.js
var coshDocs = {
  name: "cosh",
  category: "Trigonometry",
  syntax: ["cosh(x)"],
  description: "Compute the hyperbolic cosine of x in radians.",
  examples: ["cosh(0.5)"],
  seealso: ["sinh", "tanh", "coth"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cot.js
var cotDocs = {
  name: "cot",
  category: "Trigonometry",
  syntax: ["cot(x)"],
  description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
  examples: ["cot(2)", "1 / tan(2)"],
  seealso: ["sec", "csc", "tan"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/coth.js
var cothDocs = {
  name: "coth",
  category: "Trigonometry",
  syntax: ["coth(x)"],
  description: "Compute the hyperbolic cotangent of x in radians.",
  examples: ["coth(2)", "1 / tanh(2)"],
  seealso: ["sech", "csch", "tanh"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csc.js
var cscDocs = {
  name: "csc",
  category: "Trigonometry",
  syntax: ["csc(x)"],
  description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
  examples: ["csc(2)", "1 / sin(2)"],
  seealso: ["sec", "cot", "sin"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csch.js
var cschDocs = {
  name: "csch",
  category: "Trigonometry",
  syntax: ["csch(x)"],
  description: "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
  examples: ["csch(2)", "1 / sinh(2)"],
  seealso: ["sech", "coth", "sinh"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sec.js
var secDocs = {
  name: "sec",
  category: "Trigonometry",
  syntax: ["sec(x)"],
  description: "Compute the secant of x in radians. Defined as 1/cos(x)",
  examples: ["sec(2)", "1 / cos(2)"],
  seealso: ["cot", "csc", "cos"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sech.js
var sechDocs = {
  name: "sech",
  category: "Trigonometry",
  syntax: ["sech(x)"],
  description: "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
  examples: ["sech(2)", "1 / cosh(2)"],
  seealso: ["coth", "csch", "cosh"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sin.js
var sinDocs = {
  name: "sin",
  category: "Trigonometry",
  syntax: ["sin(x)"],
  description: "Compute the sine of x in radians.",
  examples: ["sin(2)", "sin(pi / 4) ^ 2", "sin(90 deg)", "sin(30 deg)", "sin(0.2)^2 + cos(0.2)^2"],
  seealso: ["asin", "cos", "tan"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sinh.js
var sinhDocs = {
  name: "sinh",
  category: "Trigonometry",
  syntax: ["sinh(x)"],
  description: "Compute the hyperbolic sine of x in radians.",
  examples: ["sinh(0.5)"],
  seealso: ["cosh", "tanh"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tan.js
var tanDocs = {
  name: "tan",
  category: "Trigonometry",
  syntax: ["tan(x)"],
  description: "Compute the tangent of x in radians.",
  examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
  seealso: ["atan", "sin", "cos"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tanh.js
var tanhDocs = {
  name: "tanh",
  category: "Trigonometry",
  syntax: ["tanh(x)"],
  description: "Compute the hyperbolic tangent of x in radians.",
  examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
  seealso: ["sinh", "cosh"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/units/to.js
var toDocs = {
  name: "to",
  category: "Units",
  syntax: ["x to unit", "to(x, unit)"],
  description: "Change the unit of a value.",
  examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/bin.js
var binDocs = {
  name: "bin",
  category: "Utils",
  syntax: ["bin(value)"],
  description: "Format a number as binary",
  examples: ["bin(2)"],
  seealso: ["oct", "hex"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/clone.js
var cloneDocs = {
  name: "clone",
  category: "Utils",
  syntax: ["clone(x)"],
  description: "Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",
  examples: ["clone(3.5)", "clone(2 - 4i)", "clone(45 deg)", "clone([1, 2; 3, 4])", 'clone("hello world")'],
  seealso: []
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/format.js
var formatDocs = {
  name: "format",
  category: "Utils",
  syntax: ["format(value)", "format(value, precision)"],
  description: "Format a value of any type as string.",
  examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
  seealso: ["print"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hasNumericValue.js
var hasNumericValueDocs = {
  name: "hasNumericValue",
  category: "Utils",
  syntax: ["hasNumericValue(x)"],
  description: "Test whether a value is an numeric value. " + "In case of a string, true is returned if the string contains a numeric value.",
  examples: ["hasNumericValue(2)", 'hasNumericValue("2")', 'isNumeric("2")', "hasNumericValue(0)", "hasNumericValue(bignumber(500))", "hasNumericValue(fraction(0.125))", "hasNumericValue(2 + 3i)", 'hasNumericValue([2.3, "foo", false])'],
  seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "isNumeric"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hex.js
var hexDocs = {
  name: "hex",
  category: "Utils",
  syntax: ["hex(value)"],
  description: "Format a number as hexadecimal",
  examples: ["hex(240)"],
  seealso: ["bin", "oct"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isInteger.js
var isIntegerDocs = {
  name: "isInteger",
  category: "Utils",
  syntax: ["isInteger(x)"],
  description: "Test whether a value is an integer number.",
  examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNaN.js
var isNaNDocs = {
  name: "isNaN",
  category: "Utils",
  syntax: ["isNaN(x)"],
  description: "Test whether a value is NaN (not a number)",
  examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNegative.js
var isNegativeDocs = {
  name: "isNegative",
  category: "Utils",
  syntax: ["isNegative(x)"],
  description: "Test whether a value is negative: smaller than zero.",
  examples: ["isNegative(2)", "isNegative(0)", "isNegative(-4)", "isNegative([3, 0.5, -2])"],
  seealso: ["isInteger", "isNumeric", "isPositive", "isZero"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNumeric.js
var isNumericDocs = {
  name: "isNumeric",
  category: "Utils",
  syntax: ["isNumeric(x)"],
  description: "Test whether a value is a numeric value. " + "Returns true when the input is a number, BigNumber, Fraction, or boolean.",
  examples: ["isNumeric(2)", 'isNumeric("2")', 'hasNumericValue("2")', "isNumeric(0)", "isNumeric(bignumber(500))", "isNumeric(fraction(0.125))", "isNumeric(2 + 3i)", 'isNumeric([2.3, "foo", false])'],
  seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "hasNumericValue"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPositive.js
var isPositiveDocs = {
  name: "isPositive",
  category: "Utils",
  syntax: ["isPositive(x)"],
  description: "Test whether a value is positive: larger than zero.",
  examples: ["isPositive(2)", "isPositive(0)", "isPositive(-4)", "isPositive([3, 0.5, -2])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPrime.js
var isPrimeDocs = {
  name: "isPrime",
  category: "Utils",
  syntax: ["isPrime(x)"],
  description: "Test whether a value is prime: has no divisors other than itself and one.",
  examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isZero.js
var isZeroDocs = {
  name: "isZero",
  category: "Utils",
  syntax: ["isZero(x)"],
  description: "Test whether a value is zero.",
  examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/numeric.js
var numericDocs = {
  name: "numeric",
  category: "Utils",
  syntax: ["numeric(x)"],
  description: "Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.",
  examples: ['numeric("4")', 'numeric("4", "number")', 'numeric("4", "BigNumber")', 'numeric("4", "Fraction)', 'numeric(4, "Fraction")', 'numeric(fraction(2, 5), "number)'],
  seealso: ["number", "fraction", "bignumber", "string", "format"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/oct.js
var octDocs = {
  name: "oct",
  category: "Utils",
  syntax: ["oct(value)"],
  description: "Format a number as octal",
  examples: ["oct(56)"],
  seealso: ["bin", "hex"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/print.js
var printDocs = {
  name: "print",
  category: "Utils",
  syntax: ["print(template, values)", "print(template, values, precision)"],
  description: "Interpolate values into a string template.",
  examples: ['print("Lucy is $age years old", {age: 5})', 'print("The value of pi is $pi", {pi: pi}, 3)', 'print("Hello, $user.name!", {user: {name: "John"}})', 'print("Values: $0, $1, $2", [6, 9, 4])'],
  seealso: ["format"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/typeOf.js
var typeOfDocs = {
  name: "typeOf",
  category: "Utils",
  syntax: ["typeOf(x)"],
  description: "Get the type of a variable.",
  examples: ["typeOf(3.5)", "typeOf(2 - 4i)", "typeOf(45 deg)", 'typeOf("hello world")'],
  seealso: ["getMatrixDataType"]
};

// ../../node_modules/mathjs/lib/esm/expression/embeddedDocs/embeddedDocs.js
var embeddedDocs = {
  bignumber: bignumberDocs,
  boolean: booleanDocs,
  complex: complexDocs,
  createUnit: createUnitDocs,
  fraction: fractionDocs,
  index: indexDocs,
  matrix: matrixDocs,
  number: numberDocs,
  sparse: sparseDocs,
  splitUnit: splitUnitDocs,
  string: stringDocs,
  unit: unitDocs,
  e: eDocs,
  E: eDocs,
  false: falseDocs,
  i: iDocs,
  Infinity: InfinityDocs,
  LN2: LN2Docs,
  LN10: LN10Docs,
  LOG2E: LOG2EDocs,
  LOG10E: LOG10EDocs,
  NaN: NaNDocs,
  null: nullDocs,
  pi: piDocs,
  PI: piDocs,
  phi: phiDocs,
  SQRT1_2: SQRT12Docs,
  SQRT2: SQRT2Docs,
  tau: tauDocs,
  true: trueDocs,
  version: versionDocs,
  speedOfLight: {
    description: "Speed of light in vacuum",
    examples: ["speedOfLight"]
  },
  gravitationConstant: {
    description: "Newtonian constant of gravitation",
    examples: ["gravitationConstant"]
  },
  planckConstant: {
    description: "Planck constant",
    examples: ["planckConstant"]
  },
  reducedPlanckConstant: {
    description: "Reduced Planck constant",
    examples: ["reducedPlanckConstant"]
  },
  magneticConstant: {
    description: "Magnetic constant (vacuum permeability)",
    examples: ["magneticConstant"]
  },
  electricConstant: {
    description: "Electric constant (vacuum permeability)",
    examples: ["electricConstant"]
  },
  vacuumImpedance: {
    description: "Characteristic impedance of vacuum",
    examples: ["vacuumImpedance"]
  },
  coulomb: {
    description: "Coulomb\'s constant",
    examples: ["coulomb"]
  },
  elementaryCharge: {
    description: "Elementary charge",
    examples: ["elementaryCharge"]
  },
  bohrMagneton: {
    description: "Borh magneton",
    examples: ["bohrMagneton"]
  },
  conductanceQuantum: {
    description: "Conductance quantum",
    examples: ["conductanceQuantum"]
  },
  inverseConductanceQuantum: {
    description: "Inverse conductance quantum",
    examples: ["inverseConductanceQuantum"]
  },
  magneticFluxQuantum: {
    description: "Magnetic flux quantum",
    examples: ["magneticFluxQuantum"]
  },
  nuclearMagneton: {
    description: "Nuclear magneton",
    examples: ["nuclearMagneton"]
  },
  klitzing: {
    description: "Von Klitzing constant",
    examples: ["klitzing"]
  },
  bohrRadius: {
    description: "Borh radius",
    examples: ["bohrRadius"]
  },
  classicalElectronRadius: {
    description: "Classical electron radius",
    examples: ["classicalElectronRadius"]
  },
  electronMass: {
    description: "Electron mass",
    examples: ["electronMass"]
  },
  fermiCoupling: {
    description: "Fermi coupling constant",
    examples: ["fermiCoupling"]
  },
  fineStructure: {
    description: "Fine-structure constant",
    examples: ["fineStructure"]
  },
  hartreeEnergy: {
    description: "Hartree energy",
    examples: ["hartreeEnergy"]
  },
  protonMass: {
    description: "Proton mass",
    examples: ["protonMass"]
  },
  deuteronMass: {
    description: "Deuteron Mass",
    examples: ["deuteronMass"]
  },
  neutronMass: {
    description: "Neutron mass",
    examples: ["neutronMass"]
  },
  quantumOfCirculation: {
    description: "Quantum of circulation",
    examples: ["quantumOfCirculation"]
  },
  rydberg: {
    description: "Rydberg constant",
    examples: ["rydberg"]
  },
  thomsonCrossSection: {
    description: "Thomson cross section",
    examples: ["thomsonCrossSection"]
  },
  weakMixingAngle: {
    description: "Weak mixing angle",
    examples: ["weakMixingAngle"]
  },
  efimovFactor: {
    description: "Efimov factor",
    examples: ["efimovFactor"]
  },
  atomicMass: {
    description: "Atomic mass constant",
    examples: ["atomicMass"]
  },
  avogadro: {
    description: "Avogadro\'s number",
    examples: ["avogadro"]
  },
  boltzmann: {
    description: "Boltzmann constant",
    examples: ["boltzmann"]
  },
  faraday: {
    description: "Faraday constant",
    examples: ["faraday"]
  },
  firstRadiation: {
    description: "First radiation constant",
    examples: ["firstRadiation"]
  },
  loschmidt: {
    description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
    examples: ["loschmidt"]
  },
  gasConstant: {
    description: "Gas constant",
    examples: ["gasConstant"]
  },
  molarPlanckConstant: {
    description: "Molar Planck constant",
    examples: ["molarPlanckConstant"]
  },
  molarVolume: {
    description: "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
    examples: ["molarVolume"]
  },
  sackurTetrode: {
    description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
    examples: ["sackurTetrode"]
  },
  secondRadiation: {
    description: "Second radiation constant",
    examples: ["secondRadiation"]
  },
  stefanBoltzmann: {
    description: "Stefan-Boltzmann constant",
    examples: ["stefanBoltzmann"]
  },
  wienDisplacement: {
    description: "Wien displacement law constant",
    examples: ["wienDisplacement"]
  },
  molarMass: {
    description: "Molar mass constant",
    examples: ["molarMass"]
  },
  molarMassC12: {
    description: "Molar mass constant of carbon-12",
    examples: ["molarMassC12"]
  },
  gravity: {
    description: "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
    examples: ["gravity"]
  },
  planckLength: {
    description: "Planck length",
    examples: ["planckLength"]
  },
  planckMass: {
    description: "Planck mass",
    examples: ["planckMass"]
  },
  planckTime: {
    description: "Planck time",
    examples: ["planckTime"]
  },
  planckCharge: {
    description: "Planck charge",
    examples: ["planckCharge"]
  },
  planckTemperature: {
    description: "Planck temperature",
    examples: ["planckTemperature"]
  },
  derivative: derivativeDocs,
  lsolve: lsolveDocs,
  lsolveAll: lsolveAllDocs,
  lup: lupDocs,
  lusolve: lusolveDocs,
  leafCount: leafCountDocs,
  polynomialRoot: polynomialRootDocs,
  resolve: resolveDocs,
  simplify: simplifyDocs,
  simplifyConstant: simplifyConstantDocs,
  simplifyCore: simplifyCoreDocs,
  symbolicEqual: symbolicEqualDocs,
  rationalize: rationalizeDocs,
  slu: sluDocs,
  usolve: usolveDocs,
  usolveAll: usolveAllDocs,
  qr: qrDocs,
  abs: absDocs,
  add: addDocs,
  cbrt: cbrtDocs,
  ceil: ceilDocs,
  cube: cubeDocs,
  divide: divideDocs,
  dotDivide: dotDivideDocs,
  dotMultiply: dotMultiplyDocs,
  dotPow: dotPowDocs,
  exp: expDocs,
  expm: expmDocs,
  expm1: expm1Docs,
  fix: fixDocs,
  floor: floorDocs,
  gcd: gcdDocs,
  hypot: hypotDocs,
  lcm: lcmDocs,
  log: logDocs,
  log2: log2Docs,
  log1p: log1pDocs,
  log10: log10Docs,
  mod: modDocs,
  multiply: multiplyDocs,
  norm: normDocs,
  nthRoot: nthRootDocs,
  nthRoots: nthRootsDocs,
  pow: powDocs,
  round: roundDocs,
  sign: signDocs,
  sqrt: sqrtDocs,
  sqrtm: sqrtmDocs,
  square: squareDocs,
  subtract: subtractDocs,
  unaryMinus: unaryMinusDocs,
  unaryPlus: unaryPlusDocs,
  xgcd: xgcdDocs,
  invmod: invmodDocs,
  bitAnd: bitAndDocs,
  bitNot: bitNotDocs,
  bitOr: bitOrDocs,
  bitXor: bitXorDocs,
  leftShift: leftShiftDocs,
  rightArithShift: rightArithShiftDocs,
  rightLogShift: rightLogShiftDocs,
  bellNumbers: bellNumbersDocs,
  catalan: catalanDocs,
  composition: compositionDocs,
  stirlingS2: stirlingS2Docs,
  config: configDocs,
  import: importDocs,
  typed: typedDocs,
  arg: argDocs,
  conj: conjDocs,
  re: reDocs,
  im: imDocs,
  evaluate: evaluateDocs,
  help: helpDocs,
  distance: distanceDocs,
  intersect: intersectDocs,
  and: andDocs,
  not: notDocs,
  or: orDocs,
  xor: xorDocs,
  concat: concatDocs,
  count: countDocs,
  cross: crossDocs,
  column: columnDocs,
  ctranspose: ctransposeDocs,
  det: detDocs,
  diag: diagDocs,
  diff: diffDocs,
  dot: dotDocs,
  getMatrixDataType: getMatrixDataTypeDocs,
  identity: identityDocs,
  filter: filterDocs,
  flatten: flattenDocs,
  forEach: forEachDocs,
  inv: invDocs,
  pinv: pinvDocs,
  eigs: eigsDocs,
  kron: kronDocs,
  matrixFromFunction: matrixFromFunctionDocs,
  matrixFromRows: matrixFromRowsDocs,
  matrixFromColumns: matrixFromColumnsDocs,
  map: mapDocs,
  ones: onesDocs,
  partitionSelect: partitionSelectDocs,
  range: rangeDocs,
  resize: resizeDocs,
  reshape: reshapeDocs,
  rotate: rotateDocs,
  rotationMatrix: rotationMatrixDocs,
  row: rowDocs,
  size: sizeDocs,
  sort: sortDocs,
  squeeze: squeezeDocs,
  subset: subsetDocs,
  trace: traceDocs,
  transpose: transposeDocs,
  zeros: zerosDocs,
  fft: fftDocs,
  ifft: ifftDocs,
  sylvester: sylvesterDocs,
  schur: schurDocs,
  lyap: lyapDocs,
  combinations: combinationsDocs,
  combinationsWithRep: combinationsWithRepDocs,
  factorial: factorialDocs,
  gamma: gammaDocs,
  kldivergence: kldivergenceDocs,
  lgamma: lgammaDocs,
  multinomial: multinomialDocs,
  permutations: permutationsDocs,
  pickRandom: pickRandomDocs,
  random: randomDocs,
  randomInt: randomIntDocs,
  compare: compareDocs,
  compareNatural: compareNaturalDocs,
  compareText: compareTextDocs,
  deepEqual: deepEqualDocs,
  equal: equalDocs,
  equalText: equalTextDocs,
  larger: largerDocs,
  largerEq: largerEqDocs,
  smaller: smallerDocs,
  smallerEq: smallerEqDocs,
  unequal: unequalDocs,
  setCartesian: setCartesianDocs,
  setDifference: setDifferenceDocs,
  setDistinct: setDistinctDocs,
  setIntersect: setIntersectDocs,
  setIsSubset: setIsSubsetDocs,
  setMultiplicity: setMultiplicityDocs,
  setPowerset: setPowersetDocs,
  setSize: setSizeDocs,
  setSymDifference: setSymDifferenceDocs,
  setUnion: setUnionDocs,
  erf: erfDocs,
  cumsum: cumSumDocs,
  mad: madDocs,
  max: maxDocs,
  mean: meanDocs,
  median: medianDocs,
  min: minDocs,
  mode: modeDocs,
  prod: prodDocs,
  quantileSeq: quantileSeqDocs,
  std: stdDocs,
  sum: sumDocs,
  variance: varianceDocs,
  acos: acosDocs,
  acosh: acoshDocs,
  acot: acotDocs,
  acoth: acothDocs,
  acsc: acscDocs,
  acsch: acschDocs,
  asec: asecDocs,
  asech: asechDocs,
  asin: asinDocs,
  asinh: asinhDocs,
  atan: atanDocs,
  atanh: atanhDocs,
  atan2: atan2Docs,
  cos: cosDocs,
  cosh: coshDocs,
  cot: cotDocs,
  coth: cothDocs,
  csc: cscDocs,
  csch: cschDocs,
  sec: secDocs,
  sech: sechDocs,
  sin: sinDocs,
  sinh: sinhDocs,
  tan: tanDocs,
  tanh: tanhDocs,
  to: toDocs,
  clone: cloneDocs,
  format: formatDocs,
  bin: binDocs,
  oct: octDocs,
  hex: hexDocs,
  isNaN: isNaNDocs,
  isInteger: isIntegerDocs,
  isNegative: isNegativeDocs,
  isNumeric: isNumericDocs,
  hasNumericValue: hasNumericValueDocs,
  isPositive: isPositiveDocs,
  isPrime: isPrimeDocs,
  isZero: isZeroDocs,
  print: printDocs,
  typeOf: typeOfDocs,
  numeric: numericDocs
};

// ../../node_modules/mathjs/lib/esm/expression/function/help.js
var name236 = "help";
var dependencies236 = ["typed", "mathWithTransform", "Help"];
var createHelp = factory(name236, dependencies236, (_ref) => {
  var {
    typed: typed2,
    mathWithTransform,
    Help
  } = _ref;
  return typed2(name236, {
    any: function any(search) {
      var prop;
      var searchName = search;
      if (typeof search !== "string") {
        for (prop in mathWithTransform) {
          if (hasOwnProperty2(mathWithTransform, prop) && search === mathWithTransform[prop]) {
            searchName = prop;
            break;
          }
        }
      }
      var doc = getSafeProperty(embeddedDocs, searchName);
      if (!doc) {
        var searchText = typeof searchName === "function" ? searchName.name : searchName;
        throw new Error('No documentation found on "' + searchText + '"');
      }
      return new Help(doc);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/type/chain/function/chain.js
var name237 = "chain";
var dependencies237 = ["typed", "Chain"];
var createChain = factory(name237, dependencies237, (_ref) => {
  var {
    typed: typed2,
    Chain
  } = _ref;
  return typed2(name237, {
    "": function _() {
      return new Chain;
    },
    any: function any(value) {
      return new Chain(value);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/matrix/det.js
var name238 = "det";
var dependencies238 = ["typed", "matrix", "subtract", "multiply", "divideScalar", "isZero", "unaryMinus"];
var createDet = factory(name238, dependencies238, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    multiply: multiply2,
    divideScalar,
    isZero: isZero2,
    unaryMinus: unaryMinus2
  } = _ref;
  return typed2(name238, {
    any: function any(x) {
      return clone(x);
    },
    "Array | Matrix": function det(x) {
      var size2;
      if (isMatrix(x)) {
        size2 = x.size();
      } else if (Array.isArray(x)) {
        x = matrix2(x);
        size2 = x.size();
      } else {
        size2 = [];
      }
      switch (size2.length) {
        case 0:
          return clone(x);
        case 1:
          if (size2[0] === 1) {
            return clone(x.valueOf()[0]);
          }
          if (size2[0] === 0) {
            return 1;
          } else {
            throw new RangeError("Matrix must be square " + "(size: " + format3(size2) + ")");
          }
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            return _det(x.clone().valueOf(), rows, cols);
          }
          if (cols === 0) {
            return 1;
          } else {
            throw new RangeError("Matrix must be square " + "(size: " + format3(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional " + "(size: " + format3(size2) + ")");
      }
    }
  });
  function _det(matrix3, rows, cols) {
    if (rows === 1) {
      return clone(matrix3[0][0]);
    } else if (rows === 2) {
      return subtract2(multiply2(matrix3[0][0], matrix3[1][1]), multiply2(matrix3[1][0], matrix3[0][1]));
    } else {
      var negated = false;
      var rowIndices = new Array(rows).fill(0).map((_, i3) => i3);
      for (var k = 0;k < rows; k++) {
        var k_ = rowIndices[k];
        if (isZero2(matrix3[k_][k])) {
          var _k = undefined;
          for (_k = k + 1;_k < rows; _k++) {
            if (!isZero2(matrix3[rowIndices[_k]][k])) {
              k_ = rowIndices[_k];
              rowIndices[_k] = rowIndices[k];
              rowIndices[k] = k_;
              negated = !negated;
              break;
            }
          }
          if (_k === rows)
            return matrix3[k_][k];
        }
        var piv = matrix3[k_][k];
        var piv_ = k === 0 ? 1 : matrix3[rowIndices[k - 1]][k - 1];
        for (var i2 = k + 1;i2 < rows; i2++) {
          var i_ = rowIndices[i2];
          for (var j = k + 1;j < rows; j++) {
            matrix3[i_][j] = divideScalar(subtract2(multiply2(matrix3[i_][j], piv), multiply2(matrix3[i_][k], matrix3[k_][j])), piv_);
          }
        }
      }
      var det2 = matrix3[rowIndices[rows - 1]][rows - 1];
      return negated ? unaryMinus2(det2) : det2;
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/inv.js
var name239 = "inv";
var dependencies239 = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"];
var createInv = factory(name239, dependencies239, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar,
    addScalar,
    multiply: multiply2,
    unaryMinus: unaryMinus2,
    det: det2,
    identity: identity2,
    abs: abs3
  } = _ref;
  return typed2(name239, {
    "Array | Matrix": function ArrayMatrix(x) {
      var size2 = isMatrix(x) ? x.size() : arraySize(x);
      switch (size2.length) {
        case 1:
          if (size2[0] === 1) {
            if (isMatrix(x)) {
              return matrix2([divideScalar(1, x.valueOf()[0])]);
            } else {
              return [divideScalar(1, x[0])];
            }
          } else {
            throw new RangeError("Matrix must be square " + "(size: " + format3(size2) + ")");
          }
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            if (isMatrix(x)) {
              return matrix2(_inv(x.valueOf(), rows, cols), x.storage());
            } else {
              return _inv(x, rows, cols);
            }
          } else {
            throw new RangeError("Matrix must be square " + "(size: " + format3(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional " + "(size: " + format3(size2) + ")");
      }
    },
    any: function any(x) {
      return divideScalar(1, x);
    }
  });
  function _inv(mat, rows, cols) {
    var r, s, f, value, temp;
    if (rows === 1) {
      value = mat[0][0];
      if (value === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar(1, value)]];
    } else if (rows === 2) {
      var d = det2(mat);
      if (d === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus2(mat[0][1]), d)], [divideScalar(unaryMinus2(mat[1][0]), d), divideScalar(mat[0][0], d)]];
    } else {
      var A = mat.concat();
      for (r = 0;r < rows; r++) {
        A[r] = A[r].concat();
      }
      var B = identity2(rows).valueOf();
      for (var c = 0;c < cols; c++) {
        var ABig = abs3(A[c][c]);
        var rBig = c;
        r = c + 1;
        while (r < rows) {
          if (abs3(A[r][c]) > ABig) {
            ABig = abs3(A[r][c]);
            rBig = r;
          }
          r++;
        }
        if (ABig === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        r = rBig;
        if (r !== c) {
          temp = A[c];
          A[c] = A[r];
          A[r] = temp;
          temp = B[c];
          B[c] = B[r];
          B[r] = temp;
        }
        var Ac = A[c];
        var Bc = B[c];
        for (r = 0;r < rows; r++) {
          var Ar = A[r];
          var Br = B[r];
          if (r !== c) {
            if (Ar[c] !== 0) {
              f = divideScalar(unaryMinus2(Ar[c]), Ac[c]);
              for (s = c;s < cols; s++) {
                Ar[s] = addScalar(Ar[s], multiply2(f, Ac[s]));
              }
              for (s = 0;s < cols; s++) {
                Br[s] = addScalar(Br[s], multiply2(f, Bc[s]));
              }
            }
          } else {
            f = Ac[c];
            for (s = c;s < cols; s++) {
              Ar[s] = divideScalar(Ar[s], f);
            }
            for (s = 0;s < cols; s++) {
              Br[s] = divideScalar(Br[s], f);
            }
          }
        }
      }
      return B;
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/pinv.js
var name240 = "pinv";
var dependencies240 = ["typed", "matrix", "inv", "deepEqual", "equal", "dotDivide", "dot", "ctranspose", "divideScalar", "multiply", "add", "Complex"];
var createPinv = factory(name240, dependencies240, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    inv: inv2,
    deepEqual: deepEqual2,
    equal: equal2,
    dotDivide: dotDivide2,
    dot: dot2,
    ctranspose: ctranspose2,
    divideScalar,
    multiply: multiply2,
    add: add3,
    Complex: Complex2
  } = _ref;
  return typed2(name240, {
    "Array | Matrix": function ArrayMatrix(x) {
      var size2 = isMatrix(x) ? x.size() : arraySize(x);
      switch (size2.length) {
        case 1:
          if (_isZeros(x))
            return ctranspose2(x);
          if (size2[0] === 1) {
            return inv2(x);
          } else {
            return dotDivide2(ctranspose2(x), dot2(x, x));
          }
        case 2: {
          if (_isZeros(x))
            return ctranspose2(x);
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            try {
              return inv2(x);
            } catch (err) {
              if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {
              } else {
                throw err;
              }
            }
          }
          if (isMatrix(x)) {
            return matrix2(_pinv(x.valueOf(), rows, cols), x.storage());
          } else {
            return _pinv(x, rows, cols);
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional " + "(size: " + format3(size2) + ")");
      }
    },
    any: function any(x) {
      if (equal2(x, 0))
        return clone(x);
      return divideScalar(1, x);
    }
  });
  function _pinv(mat, rows, cols) {
    var {
      C,
      F
    } = _rankFact(mat, rows, cols);
    var Cpinv = multiply2(inv2(multiply2(ctranspose2(C), C)), ctranspose2(C));
    var Fpinv = multiply2(ctranspose2(F), inv2(multiply2(F, ctranspose2(F))));
    return multiply2(Fpinv, Cpinv);
  }
  function _rref(mat, rows, cols) {
    var M = clone(mat);
    var lead = 0;
    for (var r = 0;r < rows; r++) {
      if (cols <= lead) {
        return M;
      }
      var i2 = r;
      while (_isZero(M[i2][lead])) {
        i2++;
        if (rows === i2) {
          i2 = r;
          lead++;
          if (cols === lead) {
            return M;
          }
        }
      }
      [M[i2], M[r]] = [M[r], M[i2]];
      var val = M[r][lead];
      for (var j = 0;j < cols; j++) {
        M[r][j] = dotDivide2(M[r][j], val);
      }
      for (var _i = 0;_i < rows; _i++) {
        if (_i === r)
          continue;
        val = M[_i][lead];
        for (var _j = 0;_j < cols; _j++) {
          M[_i][_j] = add3(M[_i][_j], multiply2(-1, multiply2(val, M[r][_j])));
        }
      }
      lead++;
    }
    return M;
  }
  function _rankFact(mat, rows, cols) {
    var rref = _rref(mat, rows, cols);
    var C = mat.map((_, i2) => _.filter((_2, j) => j < rows && !_isZero(dot2(rref[j], rref[j]))));
    var F = rref.filter((_, i2) => !_isZero(dot2(rref[i2], rref[i2])));
    return {
      C,
      F
    };
  }
  function _isZero(x) {
    return equal2(add3(x, Complex2(1, 1)), add3(0, Complex2(1, 1)));
  }
  function _isZeros(arr) {
    return deepEqual2(add3(arr, Complex2(1, 1)), add3(multiply2(arr, 0), Complex2(1, 1)));
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js
function createComplexEigs(_ref) {
  var {
    addScalar,
    subtract: subtract2,
    flatten: flatten3,
    multiply: multiply2,
    multiplyScalar,
    divideScalar,
    sqrt: sqrt3,
    abs: abs3,
    bignumber: bignumber2,
    diag: diag2,
    inv: inv2,
    qr: qr2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    equal: equal2,
    complex: complex3,
    larger: larger2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  } = _ref;
  function complexEigs(arr, N, prec, type, findVectors) {
    if (findVectors === undefined) {
      findVectors = true;
    }
    var R = balance(arr, N, prec, type, findVectors);
    reduceToHessenberg(arr, N, prec, type, findVectors, R);
    var {
      values,
      C
    } = iterateUntilTriangular(arr, N, prec, type, findVectors);
    var vectors;
    if (findVectors) {
      vectors = findEigenvectors(arr, N, C, R, values, prec, type);
      vectors = matrixFromColumns2(...vectors);
    }
    return {
      values,
      vectors
    };
  }
  function balance(arr, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var realzero = big ? bignumber2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex3(1) : 1;
    var realone = big ? bignumber2(1) : 1;
    var radix = big ? bignumber2(10) : 2;
    var radixSq = multiplyScalar(radix, radix);
    var Rdiag;
    if (findVectors) {
      Rdiag = Array(N).fill(one);
    }
    var last = false;
    while (!last) {
      last = true;
      for (var i2 = 0;i2 < N; i2++) {
        var colNorm = realzero;
        var rowNorm = realzero;
        for (var j = 0;j < N; j++) {
          if (i2 === j)
            continue;
          var c = abs3(arr[i2][j]);
          colNorm = addScalar(colNorm, c);
          rowNorm = addScalar(rowNorm, c);
        }
        if (!equal2(colNorm, 0) && !equal2(rowNorm, 0)) {
          var f = realone;
          var _c = colNorm;
          var rowDivRadix = divideScalar(rowNorm, radix);
          var rowMulRadix = multiplyScalar(rowNorm, radix);
          while (smaller2(_c, rowDivRadix)) {
            _c = multiplyScalar(_c, radixSq);
            f = multiplyScalar(f, radix);
          }
          while (larger2(_c, rowMulRadix)) {
            _c = divideScalar(_c, radixSq);
            f = divideScalar(f, radix);
          }
          var condition = smaller2(divideScalar(addScalar(_c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95));
          if (condition) {
            last = false;
            var g = divideScalar(1, f);
            for (var _j = 0;_j < N; _j++) {
              if (i2 === _j) {
                continue;
              }
              arr[i2][_j] = multiplyScalar(arr[i2][_j], f);
              arr[_j][i2] = multiplyScalar(arr[_j][i2], g);
            }
            if (findVectors) {
              Rdiag[i2] = multiplyScalar(Rdiag[i2], f);
            }
          }
        }
      }
    }
    return diag2(Rdiag);
  }
  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex3(0) : 0;
    if (big) {
      prec = bignumber2(prec);
    }
    for (var i2 = 0;i2 < N - 2; i2++) {
      var maxIndex = 0;
      var max3 = zero;
      for (var j = i2 + 1;j < N; j++) {
        var el = arr[j][i2];
        if (smaller2(abs3(max3), abs3(el))) {
          max3 = el;
          maxIndex = j;
        }
      }
      if (smaller2(abs3(max3), prec)) {
        continue;
      }
      if (maxIndex !== i2 + 1) {
        var tmp1 = arr[maxIndex];
        arr[maxIndex] = arr[i2 + 1];
        arr[i2 + 1] = tmp1;
        for (var _j2 = 0;_j2 < N; _j2++) {
          var tmp2 = arr[_j2][maxIndex];
          arr[_j2][maxIndex] = arr[_j2][i2 + 1];
          arr[_j2][i2 + 1] = tmp2;
        }
        if (findVectors) {
          var tmp3 = R[maxIndex];
          R[maxIndex] = R[i2 + 1];
          R[i2 + 1] = tmp3;
        }
      }
      for (var _j3 = i2 + 2;_j3 < N; _j3++) {
        var n = divideScalar(arr[_j3][i2], max3);
        if (n === 0) {
          continue;
        }
        for (var k = 0;k < N; k++) {
          arr[_j3][k] = subtract2(arr[_j3][k], multiplyScalar(n, arr[i2 + 1][k]));
        }
        for (var _k = 0;_k < N; _k++) {
          arr[_k][i2 + 1] = addScalar(arr[_k][i2 + 1], multiplyScalar(n, arr[_k][_j3]));
        }
        if (findVectors) {
          for (var _k2 = 0;_k2 < N; _k2++) {
            R[_j3][_k2] = subtract2(R[_j3][_k2], multiplyScalar(n, R[i2 + 1][_k2]));
          }
        }
      }
    }
    return R;
  }
  function iterateUntilTriangular(A, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one = big ? bignumber2(1) : cplx ? complex3(1) : 1;
    if (big) {
      prec = bignumber2(prec);
    }
    var arr = clone(A);
    var lambdas = [];
    var n = N;
    var Sdiag = [];
    var Qtotal = findVectors ? diag2(Array(N).fill(one)) : undefined;
    var Qpartial = findVectors ? diag2(Array(n).fill(one)) : undefined;
    var lastConvergenceBefore = 0;
    while (lastConvergenceBefore <= 100) {
      lastConvergenceBefore += 1;
      var k = 0;
      for (var i2 = 0;i2 < n; i2++) {
        arr[i2][i2] = subtract2(arr[i2][i2], k);
      }
      var {
        Q: Q2,
        R
      } = qr2(arr);
      arr = multiply2(R, Q2);
      for (var _i = 0;_i < n; _i++) {
        arr[_i][_i] = addScalar(arr[_i][_i], k);
      }
      if (findVectors) {
        Qpartial = multiply2(Qpartial, Q2);
      }
      if (n === 1 || smaller2(abs3(arr[n - 1][n - 2]), prec)) {
        lastConvergenceBefore = 0;
        lambdas.push(arr[n - 1][n - 1]);
        if (findVectors) {
          Sdiag.unshift([[1]]);
          inflateMatrix(Qpartial, N);
          Qtotal = multiply2(Qtotal, Qpartial);
          if (n > 1) {
            Qpartial = diag2(Array(n - 1).fill(one));
          }
        }
        n -= 1;
        arr.pop();
        for (var _i2 = 0;_i2 < n; _i2++) {
          arr[_i2].pop();
        }
      } else if (n === 2 || smaller2(abs3(arr[n - 2][n - 3]), prec)) {
        lastConvergenceBefore = 0;
        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
        lambdas.push(...ll);
        if (findVectors) {
          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
          inflateMatrix(Qpartial, N);
          Qtotal = multiply2(Qtotal, Qpartial);
          if (n > 2) {
            Qpartial = diag2(Array(n - 2).fill(one));
          }
        }
        n -= 2;
        arr.pop();
        arr.pop();
        for (var _i3 = 0;_i3 < n; _i3++) {
          arr[_i3].pop();
          arr[_i3].pop();
        }
      }
      if (n === 0) {
        break;
      }
    }
    lambdas.sort((a, b) => +subtract2(abs3(a), abs3(b)));
    if (lastConvergenceBefore > 100) {
      var err = Error("The eigenvalues failed to converge. Only found these eigenvalues: " + lambdas.join(", "));
      err.values = lambdas;
      err.vectors = [];
      throw err;
    }
    var C = findVectors ? multiply2(Qtotal, blockDiag(Sdiag, N)) : undefined;
    return {
      values: lambdas,
      C
    };
  }
  function findEigenvectors(A, N, C, R, values, prec, type) {
    var Cinv = inv2(C);
    var U = multiply2(Cinv, A, C);
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex3(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex3(1) : 1;
    var uniqueValues = [];
    var multiplicities = [];
    for (var  of values) {
      var i2 = indexOf(uniqueValues, , equal2);
      if (i2 === -1) {
        uniqueValues.push();
        multiplicities.push(1);
      } else {
        multiplicities[i2] += 1;
      }
    }
    var vectors = [];
    var len = uniqueValues.length;
    var b = Array(N).fill(zero);
    var E = diag2(Array(N).fill(one));
    var failedLambdas = [];
    var _loop = function _loop() {
      var 2 = uniqueValues[_i4];
      var S = subtract2(U, multiply2(2, E));
      var solutions = usolveAll2(S, b);
      solutions.shift();
      while (solutions.length < multiplicities[_i4]) {
        var approxVec = inverseIterate(S, N, solutions, prec, type);
        if (approxVec == null) {
          failedLambdas.push(2);
          break;
        }
        solutions.push(approxVec);
      }
      var correction = multiply2(inv2(R), C);
      solutions = solutions.map((v) => multiply2(correction, v));
      vectors.push(...solutions.map((v) => flatten3(v)));
    };
    for (var _i4 = 0;_i4 < len; _i4++) {
      _loop();
    }
    if (failedLambdas.length !== 0) {
      var err = new Error("Failed to find eigenvectors for the following eigenvalues: " + failedLambdas.join(", "));
      err.values = values;
      err.vectors = vectors;
      throw err;
    }
    return vectors;
  }
  function eigenvalues2x2(a, b, c, d) {
    var trA = addScalar(a, d);
    var detA = subtract2(multiplyScalar(a, d), multiplyScalar(b, c));
    var x = multiplyScalar(trA, 0.5);
    var y = multiplyScalar(sqrt3(subtract2(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);
    return [addScalar(x, y), subtract2(x, y)];
  }
  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex3(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex3(1) : 1;
    if (smaller2(abs3(c), prec)) {
      return [[one, zero], [zero, one]];
    }
    if (larger2(abs3(subtract2(l1, l2)), prec)) {
      return [[subtract2(l1, d), subtract2(l2, d)], [c, c]];
    }
    var na = subtract2(a, l1);
    var nb = subtract2(b, l1);
    var nc = subtract2(c, l1);
    var nd = subtract2(d, l1);
    if (smaller2(abs3(nb), prec)) {
      return [[na, one], [nc, zero]];
    } else {
      return [[nb, zero], [nd, one]];
    }
  }
  function inflateMatrix(arr, N) {
    for (var i2 = 0;i2 < arr.length; i2++) {
      arr[i2].push(...Array(N - arr[i2].length).fill(0));
    }
    for (var _i5 = arr.length;_i5 < N; _i5++) {
      arr.push(Array(N).fill(0));
      arr[_i5][_i5] = 1;
    }
    return arr;
  }
  function blockDiag(arr, N) {
    var M = [];
    for (var i2 = 0;i2 < N; i2++) {
      M[i2] = Array(N).fill(0);
    }
    var I = 0;
    for (var sub2 of arr) {
      var n = sub2.length;
      for (var _i6 = 0;_i6 < n; _i6++) {
        for (var j = 0;j < n; j++) {
          M[I + _i6][I + j] = sub2[_i6][j];
        }
      }
      I += n;
    }
    return M;
  }
  function indexOf(arr, el, fn) {
    for (var i2 = 0;i2 < arr.length; i2++) {
      if (fn(arr[i2], el)) {
        return i2;
      }
    }
    return -1;
  }
  function inverseIterate(A, N, orthog, prec, type) {
    var largeNum = type === "BigNumber" ? bignumber2(1000) : 1000;
    var b;
    var i2 = 0;
    while (true) {
      b = randomOrthogonalVector(N, orthog, type);
      b = usolve2(A, b);
      if (larger2(norm2(b), largeNum)) {
        break;
      }
      if (++i2 >= 5) {
        return null;
      }
    }
    i2 = 0;
    while (true) {
      var c = usolve2(A, b);
      if (smaller2(norm2(orthogonalComplement(b, [c])), prec)) {
        break;
      }
      if (++i2 >= 10) {
        return null;
      }
      b = normalize(c);
    }
    return b;
  }
  function randomOrthogonalVector(N, orthog, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var v = Array(N).fill(0).map((_) => 2 * Math.random() - 1);
    if (big) {
      v = v.map((n) => bignumber2(n));
    }
    if (cplx) {
      v = v.map((n) => complex3(n));
    }
    v = orthogonalComplement(v, orthog);
    return normalize(v, type);
  }
  function orthogonalComplement(v, orthog) {
    for (var w of orthog) {
      v = subtract2(v, multiply2(divideScalar(dot2(w, v), dot2(w, w)), w));
    }
    return v;
  }
  function norm2(v) {
    return abs3(sqrt3(dot2(v, v)));
  }
  function normalize(v, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one = big ? bignumber2(1) : cplx ? complex3(1) : 1;
    return multiply2(divideScalar(one, norm2(v)), v);
  }
  return complexEigs;
}

// ../../node_modules/mathjs/lib/esm/function/matrix/eigs/realSymetric.js
function createRealSymmetric(_ref) {
  var {
    config: config7,
    addScalar,
    subtract: subtract2,
    abs: abs3,
    atan: atan4,
    cos: cos3,
    sin: sin3,
    multiplyScalar,
    inv: inv2,
    bignumber: bignumber2,
    multiply: multiply2,
    add: add3
  } = _ref;
  function main(arr, N) {
    var prec = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : config7.epsilon;
    var type = arguments.length > 3 ? arguments[3] : undefined;
    if (type === "number") {
      return diag2(arr, prec);
    }
    if (type === "BigNumber") {
      return diagBig(arr, prec);
    }
    throw TypeError("Unsupported data type: " + type);
  }
  function diag2(x, precision) {
    var N = x.length;
    var e0 = Math.abs(precision / N);
    var psi;
    var Sij = new Array(N);
    for (var i2 = 0;i2 < N; i2++) {
      Sij[i2] = createArray(N, 0);
      Sij[i2][i2] = 1;
    }
    var Vab = getAij(x);
    while (Math.abs(Vab[1]) >= Math.abs(e0)) {
      var _i = Vab[0][0];
      var j = Vab[0][1];
      psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
      x = x1(x, psi, _i, j);
      Sij = Sij1(Sij, psi, _i, j);
      Vab = getAij(x);
    }
    var Ei = createArray(N, 0);
    for (var _i2 = 0;_i2 < N; _i2++) {
      Ei[_i2] = x[_i2][_i2];
    }
    return sorting(clone(Ei), clone(Sij));
  }
  function diagBig(x, precision) {
    var N = x.length;
    var e0 = abs3(precision / N);
    var psi;
    var Sij = new Array(N);
    for (var i2 = 0;i2 < N; i2++) {
      Sij[i2] = createArray(N, 0);
      Sij[i2][i2] = 1;
    }
    var Vab = getAijBig(x);
    while (abs3(Vab[1]) >= abs3(e0)) {
      var _i3 = Vab[0][0];
      var j = Vab[0][1];
      psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
      x = x1Big(x, psi, _i3, j);
      Sij = Sij1Big(Sij, psi, _i3, j);
      Vab = getAijBig(x);
    }
    var Ei = createArray(N, 0);
    for (var _i4 = 0;_i4 < N; _i4++) {
      Ei[_i4] = x[_i4][_i4];
    }
    return sorting(clone(Ei), clone(Sij));
  }
  function getTheta(aii, ajj, aij) {
    var denom = ajj - aii;
    if (Math.abs(denom) <= config7.epsilon) {
      return Math.PI / 4;
    } else {
      return 0.5 * Math.atan(2 * aij / (ajj - aii));
    }
  }
  function getThetaBig(aii, ajj, aij) {
    var denom = subtract2(ajj, aii);
    if (abs3(denom) <= config7.epsilon) {
      return bignumber2(-1).acos().div(4);
    } else {
      return multiplyScalar(0.5, atan4(multiply2(2, aij, inv2(denom))));
    }
  }
  function Sij1(Sij, theta, i2, j) {
    var N = Sij.length;
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var Ski = createArray(N, 0);
    var Skj = createArray(N, 0);
    for (var k = 0;k < N; k++) {
      Ski[k] = c * Sij[k][i2] - s * Sij[k][j];
      Skj[k] = s * Sij[k][i2] + c * Sij[k][j];
    }
    for (var _k = 0;_k < N; _k++) {
      Sij[_k][i2] = Ski[_k];
      Sij[_k][j] = Skj[_k];
    }
    return Sij;
  }
  function Sij1Big(Sij, theta, i2, j) {
    var N = Sij.length;
    var c = cos3(theta);
    var s = sin3(theta);
    var Ski = createArray(N, bignumber2(0));
    var Skj = createArray(N, bignumber2(0));
    for (var k = 0;k < N; k++) {
      Ski[k] = subtract2(multiplyScalar(c, Sij[k][i2]), multiplyScalar(s, Sij[k][j]));
      Skj[k] = addScalar(multiplyScalar(s, Sij[k][i2]), multiplyScalar(c, Sij[k][j]));
    }
    for (var _k2 = 0;_k2 < N; _k2++) {
      Sij[_k2][i2] = Ski[_k2];
      Sij[_k2][j] = Skj[_k2];
    }
    return Sij;
  }
  function x1Big(Hij, theta, i2, j) {
    var N = Hij.length;
    var c = bignumber2(cos3(theta));
    var s = bignumber2(sin3(theta));
    var c2 = multiplyScalar(c, c);
    var s2 = multiplyScalar(s, s);
    var Aki = createArray(N, bignumber2(0));
    var Akj = createArray(N, bignumber2(0));
    var csHij = multiply2(bignumber2(2), c, s, Hij[i2][j]);
    var Aii = addScalar(subtract2(multiplyScalar(c2, Hij[i2][i2]), csHij), multiplyScalar(s2, Hij[j][j]));
    var Ajj = add3(multiplyScalar(s2, Hij[i2][i2]), csHij, multiplyScalar(c2, Hij[j][j]));
    for (var k = 0;k < N; k++) {
      Aki[k] = subtract2(multiplyScalar(c, Hij[i2][k]), multiplyScalar(s, Hij[j][k]));
      Akj[k] = addScalar(multiplyScalar(s, Hij[i2][k]), multiplyScalar(c, Hij[j][k]));
    }
    Hij[i2][i2] = Aii;
    Hij[j][j] = Ajj;
    Hij[i2][j] = bignumber2(0);
    Hij[j][i2] = bignumber2(0);
    for (var _k3 = 0;_k3 < N; _k3++) {
      if (_k3 !== i2 && _k3 !== j) {
        Hij[i2][_k3] = Aki[_k3];
        Hij[_k3][i2] = Aki[_k3];
        Hij[j][_k3] = Akj[_k3];
        Hij[_k3][j] = Akj[_k3];
      }
    }
    return Hij;
  }
  function x1(Hij, theta, i2, j) {
    var N = Hij.length;
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var c2 = c * c;
    var s2 = s * s;
    var Aki = createArray(N, 0);
    var Akj = createArray(N, 0);
    var Aii = c2 * Hij[i2][i2] - 2 * c * s * Hij[i2][j] + s2 * Hij[j][j];
    var Ajj = s2 * Hij[i2][i2] + 2 * c * s * Hij[i2][j] + c2 * Hij[j][j];
    for (var k = 0;k < N; k++) {
      Aki[k] = c * Hij[i2][k] - s * Hij[j][k];
      Akj[k] = s * Hij[i2][k] + c * Hij[j][k];
    }
    Hij[i2][i2] = Aii;
    Hij[j][j] = Ajj;
    Hij[i2][j] = 0;
    Hij[j][i2] = 0;
    for (var _k4 = 0;_k4 < N; _k4++) {
      if (_k4 !== i2 && _k4 !== j) {
        Hij[i2][_k4] = Aki[_k4];
        Hij[_k4][i2] = Aki[_k4];
        Hij[j][_k4] = Akj[_k4];
        Hij[_k4][j] = Akj[_k4];
      }
    }
    return Hij;
  }
  function getAij(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i2 = 0;i2 < N; i2++) {
      for (var j = i2 + 1;j < N; j++) {
        if (Math.abs(maxMij) < Math.abs(Mij[i2][j])) {
          maxMij = Math.abs(Mij[i2][j]);
          maxIJ = [i2, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function getAijBig(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i2 = 0;i2 < N; i2++) {
      for (var j = i2 + 1;j < N; j++) {
        if (abs3(maxMij) < abs3(Mij[i2][j])) {
          maxMij = abs3(Mij[i2][j]);
          maxIJ = [i2, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function sorting(E, S) {
    var N = E.length;
    var values = Array(N);
    var vectors = Array(N);
    for (var k = 0;k < N; k++) {
      vectors[k] = Array(N);
    }
    for (var i2 = 0;i2 < N; i2++) {
      var minID = 0;
      var minE = E[0];
      for (var j = 0;j < E.length; j++) {
        if (abs3(E[j]) < abs3(minE)) {
          minID = j;
          minE = E[minID];
        }
      }
      values[i2] = E.splice(minID, 1)[0];
      for (var _k5 = 0;_k5 < N; _k5++) {
        vectors[_k5][i2] = S[_k5][minID];
        S[_k5].splice(minID, 1);
      }
    }
    return {
      values,
      vectors
    };
  }
  function createArray(size2, value) {
    var array49 = new Array(size2);
    for (var i2 = 0;i2 < size2; i2++) {
      array49[i2] = value;
    }
    return array49;
  }
  return main;
}

// ../../node_modules/mathjs/lib/esm/function/matrix/eigs.js
var name241 = "eigs";
var dependencies241 = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "divideScalar", "inv", "bignumber", "multiply", "add", "larger", "column", "flatten", "number", "complex", "sqrt", "diag", "qr", "usolve", "usolveAll", "im", "re", "smaller", "matrixFromColumns", "dot"];
var createEigs = factory(name241, dependencies241, (_ref) => {
  var {
    config: config7,
    typed: typed2,
    matrix: matrix2,
    addScalar,
    subtract: subtract2,
    equal: equal2,
    abs: abs3,
    atan: atan4,
    cos: cos3,
    sin: sin3,
    multiplyScalar,
    divideScalar,
    inv: inv2,
    bignumber: bignumber2,
    multiply: multiply2,
    add: add3,
    larger: larger2,
    column: column2,
    flatten: flatten3,
    number: number93,
    complex: complex3,
    sqrt: sqrt3,
    diag: diag2,
    qr: qr2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    im: im2,
    re: re2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  } = _ref;
  var doRealSymetric = createRealSymmetric({
    config: config7,
    addScalar,
    subtract: subtract2,
    column: column2,
    flatten: flatten3,
    equal: equal2,
    abs: abs3,
    atan: atan4,
    cos: cos3,
    sin: sin3,
    multiplyScalar,
    inv: inv2,
    bignumber: bignumber2,
    complex: complex3,
    multiply: multiply2,
    add: add3
  });
  var doComplexEigs = createComplexEigs({
    config: config7,
    addScalar,
    subtract: subtract2,
    multiply: multiply2,
    multiplyScalar,
    flatten: flatten3,
    divideScalar,
    sqrt: sqrt3,
    abs: abs3,
    bignumber: bignumber2,
    diag: diag2,
    qr: qr2,
    inv: inv2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    equal: equal2,
    complex: complex3,
    larger: larger2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  });
  return typed2("eigs", {
    Array: function Array(x) {
      var mat = matrix2(x);
      return computeValuesAndVectors(mat);
    },
    "Array, number|BigNumber": function ArrayNumberBigNumber(x, prec) {
      var mat = matrix2(x);
      return computeValuesAndVectors(mat, prec);
    },
    Matrix: function Matrix(mat) {
      var {
        values,
        vectors
      } = computeValuesAndVectors(mat);
      return {
        values: matrix2(values),
        vectors: matrix2(vectors)
      };
    },
    "Matrix, number|BigNumber": function MatrixNumberBigNumber(mat, prec) {
      var {
        values,
        vectors
      } = computeValuesAndVectors(mat, prec);
      return {
        values: matrix2(values),
        vectors: matrix2(vectors)
      };
    }
  });
  function computeValuesAndVectors(mat, prec) {
    if (prec === undefined) {
      prec = config7.epsilon;
    }
    var size2 = mat.size();
    if (size2.length !== 2 || size2[0] !== size2[1]) {
      throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
    }
    var arr = mat.toArray();
    var N = size2[0];
    if (isReal(arr, N, prec)) {
      coerceReal(arr, N);
      if (isSymmetric(arr, N, prec)) {
        var _type = coerceTypes(mat, arr, N);
        return doRealSymetric(arr, N, prec, _type);
      }
    }
    var type = coerceTypes(mat, arr, N);
    return doComplexEigs(arr, N, prec, type);
  }
  function isSymmetric(arr, N, prec) {
    for (var i2 = 0;i2 < N; i2++) {
      for (var j = i2;j < N; j++) {
        if (larger2(bignumber2(abs3(subtract2(arr[i2][j], arr[j][i2]))), prec)) {
          return false;
        }
      }
    }
    return true;
  }
  function isReal(arr, N, prec) {
    for (var i2 = 0;i2 < N; i2++) {
      for (var j = 0;j < N; j++) {
        if (larger2(bignumber2(abs3(im2(arr[i2][j]))), prec)) {
          return false;
        }
      }
    }
    return true;
  }
  function coerceReal(arr, N) {
    for (var i2 = 0;i2 < N; i2++) {
      for (var j = 0;j < N; j++) {
        arr[i2][j] = re2(arr[i2][j]);
      }
    }
  }
  function coerceTypes(mat, arr, N) {
    var type = mat.datatype();
    if (type === "number" || type === "BigNumber" || type === "Complex") {
      return type;
    }
    var hasNumber = false;
    var hasBig = false;
    var hasComplex = false;
    for (var i2 = 0;i2 < N; i2++) {
      for (var j = 0;j < N; j++) {
        var el = arr[i2][j];
        if (isNumber(el) || isFraction(el)) {
          hasNumber = true;
        } else if (isBigNumber(el)) {
          hasBig = true;
        } else if (isComplex(el)) {
          hasComplex = true;
        } else {
          throw TypeError("Unsupported type in Matrix: " + typeOf(el));
        }
      }
    }
    if (hasBig && hasComplex) {
      console.warn("Complex BigNumbers not supported, this operation will lose precission.");
    }
    if (hasComplex) {
      for (var _i = 0;_i < N; _i++) {
        for (var _j = 0;_j < N; _j++) {
          arr[_i][_j] = complex3(arr[_i][_j]);
        }
      }
      return "Complex";
    }
    if (hasBig) {
      for (var _i2 = 0;_i2 < N; _i2++) {
        for (var _j2 = 0;_j2 < N; _j2++) {
          arr[_i2][_j2] = bignumber2(arr[_i2][_j2]);
        }
      }
      return "BigNumber";
    }
    if (hasNumber) {
      for (var _i3 = 0;_i3 < N; _i3++) {
        for (var _j3 = 0;_j3 < N; _j3++) {
          arr[_i3][_j3] = number93(arr[_i3][_j3]);
        }
      }
      return "number";
    } else {
      throw TypeError("Matrix contains unsupported types only.");
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/expm.js
var name242 = "expm";
var dependencies242 = ["typed", "abs", "add", "identity", "inv", "multiply"];
var createExpm = factory(name242, dependencies242, (_ref) => {
  var {
    typed: typed2,
    abs: abs3,
    add: add3,
    identity: identity2,
    inv: inv2,
    multiply: multiply2
  } = _ref;
  return typed2(name242, {
    Matrix: function Matrix(A) {
      var size2 = A.size();
      if (size2.length !== 2 || size2[0] !== size2[1]) {
        throw new RangeError("Matrix must be square " + "(size: " + format3(size2) + ")");
      }
      var n = size2[0];
      var eps = 0.000000000000001;
      var infNorm = infinityNorm(A);
      var params = findParams(infNorm, eps);
      var q = params.q;
      var j = params.j;
      var Apos = multiply2(A, Math.pow(2, -j));
      var N = identity2(n);
      var D = identity2(n);
      var factor = 1;
      var AposToI = Apos;
      var alternate = -1;
      for (var i2 = 1;i2 <= q; i2++) {
        if (i2 > 1) {
          AposToI = multiply2(AposToI, Apos);
          alternate = -alternate;
        }
        factor = factor * (q - i2 + 1) / ((2 * q - i2 + 1) * i2);
        N = add3(N, multiply2(factor, AposToI));
        D = add3(D, multiply2(factor * alternate, AposToI));
      }
      var R = multiply2(inv2(D), N);
      for (var _i = 0;_i < j; _i++) {
        R = multiply2(R, R);
      }
      return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;
    }
  });
  function infinityNorm(A) {
    var n = A.size()[0];
    var infNorm = 0;
    for (var i2 = 0;i2 < n; i2++) {
      var rowSum = 0;
      for (var j = 0;j < n; j++) {
        rowSum += abs3(A.get([i2, j]));
      }
      infNorm = Math.max(rowSum, infNorm);
    }
    return infNorm;
  }
  function findParams(infNorm, eps) {
    var maxSearchSize = 30;
    for (var k = 0;k < maxSearchSize; k++) {
      for (var q = 0;q <= k; q++) {
        var j = k - q;
        if (errorEstimate(infNorm, q, j) < eps) {
          return {
            q,
            j
          };
        }
      }
    }
    throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)");
  }
  function errorEstimate(infNorm, q, j) {
    var qfac = 1;
    for (var i2 = 2;i2 <= q; i2++) {
      qfac *= i2;
    }
    var twoqfac = qfac;
    for (var _i2 = q + 1;_i2 <= 2 * q; _i2++) {
      twoqfac *= _i2;
    }
    var twoqp1fac = twoqfac * (2 * q + 1);
    return 8 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
  }
});
// ../../node_modules/mathjs/lib/esm/function/matrix/sqrtm.js
var name243 = "sqrtm";
var dependencies243 = ["typed", "abs", "add", "multiply", "map", "sqrt", "subtract", "inv", "size", "max", "identity"];
var createSqrtm = factory(name243, dependencies243, (_ref) => {
  var {
    typed: typed2,
    abs: abs3,
    add: add3,
    multiply: multiply2,
    map: map8,
    sqrt: sqrt3,
    subtract: subtract2,
    inv: inv2,
    size: size2,
    max: max3,
    identity: identity2
  } = _ref;
  var _maxIterations = 1000;
  var _tolerance = 0.000001;
  function _denmanBeavers(A) {
    var error;
    var iterations = 0;
    var Y = A;
    var Z = identity2(size2(A));
    do {
      var Yk = Y;
      Y = multiply2(0.5, add3(Yk, inv2(Z)));
      Z = multiply2(0.5, add3(Z, inv2(Yk)));
      error = max3(abs3(subtract2(Y, Yk)));
      if (error > _tolerance && ++iterations > _maxIterations) {
        throw new Error("computing square root of matrix: iterative method could not converge");
      }
    } while (error > _tolerance);
    return Y;
  }
  return typed2(name243, {
    "Array | Matrix": function ArrayMatrix(A) {
      var size3 = isMatrix(A) ? A.size() : arraySize(A);
      switch (size3.length) {
        case 1:
          if (size3[0] === 1) {
            return map8(A, sqrt3);
          } else {
            throw new RangeError("Matrix must be square " + "(size: " + format3(size3) + ")");
          }
        case 2: {
          var rows = size3[0];
          var cols = size3[1];
          if (rows === cols) {
            return _denmanBeavers(A);
          } else {
            throw new RangeError("Matrix must be square " + "(size: " + format3(size3) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be at most two dimensional " + "(size: " + format3(size3) + ")");
      }
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/algebra/sylvester.js
var name244 = "sylvester";
var dependencies244 = ["typed", "schur", "matrixFromColumns", "matrix", "multiply", "range", "concat", "transpose", "index", "subset", "add", "subtract", "identity", "lusolve", "abs"];
var createSylvester = factory(name244, dependencies244, (_ref) => {
  var {
    typed: typed2,
    schur: schur2,
    matrixFromColumns: matrixFromColumns2,
    matrix: matrix2,
    multiply: multiply2,
    range: range2,
    concat: concat2,
    transpose: transpose2,
    index,
    subset: subset2,
    add: add3,
    subtract: subtract2,
    identity: identity2,
    lusolve: lusolve2,
    abs: abs3
  } = _ref;
  return typed2(name244, {
    "Matrix, Matrix, Matrix": _sylvester,
    "Array, Matrix, Matrix": function ArrayMatrixMatrix(A, B, C) {
      return _sylvester(matrix2(A), B, C);
    },
    "Array, Array, Matrix": function ArrayArrayMatrix(A, B, C) {
      return _sylvester(matrix2(A), matrix2(B), C);
    },
    "Array, Matrix, Array": function ArrayMatrixArray(A, B, C) {
      return _sylvester(matrix2(A), B, matrix2(C));
    },
    "Matrix, Array, Matrix": function MatrixArrayMatrix(A, B, C) {
      return _sylvester(A, matrix2(B), C);
    },
    "Matrix, Array, Array": function MatrixArrayArray(A, B, C) {
      return _sylvester(A, matrix2(B), matrix2(C));
    },
    "Matrix, Matrix, Array": function MatrixMatrixArray(A, B, C) {
      return _sylvester(A, B, matrix2(C));
    },
    "Array, Array, Array": function ArrayArrayArray(A, B, C) {
      return _sylvester(matrix2(A), matrix2(B), matrix2(C)).toArray();
    }
  });
  function _sylvester(A, B, C) {
    var n = B.size()[0];
    var m = A.size()[0];
    var sA = schur2(A);
    var F = sA.T;
    var U = sA.U;
    var sB = schur2(multiply2(-1, B));
    var G = sB.T;
    var V = sB.U;
    var D = multiply2(multiply2(transpose2(U), C), V);
    var all = range2(0, m);
    var y = [];
    var hc = (a, b) => concat2(a, b, 1);
    var vc = (a, b) => concat2(a, b, 0);
    for (var k = 0;k < n; k++) {
      if (k < n - 1 && abs3(subset2(G, index(k + 1, k))) > 0.00001) {
        var RHS = vc(subset2(D, index(all, k)), subset2(D, index(all, k + 1)));
        for (var j = 0;j < k; j++) {
          RHS = add3(RHS, vc(multiply2(y[j], subset2(G, index(j, k))), multiply2(y[j], subset2(G, index(j, k + 1)))));
        }
        var gkk = multiply2(identity2(m), multiply2(-1, subset2(G, index(k, k))));
        var gmk = multiply2(identity2(m), multiply2(-1, subset2(G, index(k + 1, k))));
        var gkm = multiply2(identity2(m), multiply2(-1, subset2(G, index(k, k + 1))));
        var gmm = multiply2(identity2(m), multiply2(-1, subset2(G, index(k + 1, k + 1))));
        var LHS = vc(hc(add3(F, gkk), gmk), hc(gkm, add3(F, gmm)));
        var yAux = lusolve2(LHS, RHS);
        y[k] = yAux.subset(index(range2(0, m), 0));
        y[k + 1] = yAux.subset(index(range2(m, 2 * m), 0));
        k++;
      } else {
        var _RHS = subset2(D, index(all, k));
        for (var _j = 0;_j < k; _j++) {
          _RHS = add3(_RHS, multiply2(y[_j], subset2(G, index(_j, k))));
        }
        var _gkk = subset2(G, index(k, k));
        var _LHS = subtract2(F, multiply2(_gkk, identity2(m)));
        y[k] = lusolve2(_LHS, _RHS);
      }
    }
    var Y = matrix2(matrixFromColumns2(...y));
    var X = multiply2(U, multiply2(Y, transpose2(V)));
    return X;
  }
});
// ../../node_modules/mathjs/lib/esm/function/algebra/decomposition/schur.js
var name245 = "schur";
var dependencies245 = ["typed", "matrix", "identity", "multiply", "qr", "norm", "subtract"];
var createSchur = factory(name245, dependencies245, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    identity: identity2,
    multiply: multiply2,
    qr: qr2,
    norm: norm2,
    subtract: subtract2
  } = _ref;
  return typed2(name245, {
    Array: function Array(X) {
      var r = _schur(matrix2(X));
      return {
        U: r.U.valueOf(),
        T: r.T.valueOf()
      };
    },
    Matrix: function Matrix(X) {
      return _schur(X);
    }
  });
  function _schur(X) {
    var n = X.size()[0];
    var A = X;
    var U = identity2(n);
    var k = 0;
    var A0;
    do {
      A0 = A;
      var QR = qr2(A);
      var Q2 = QR.Q;
      var R = QR.R;
      A = multiply2(R, Q2);
      U = multiply2(U, Q2);
      if (k++ > 100) {
        break;
      }
    } while (norm2(subtract2(A, A0)) > 0.0001);
    return {
      U,
      T: A
    };
  }
});
// ../../node_modules/mathjs/lib/esm/function/algebra/lyap.js
var name246 = "lyap";
var dependencies246 = ["typed", "matrix", "sylvester", "multiply", "transpose"];
var createLyap = factory(name246, dependencies246, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    sylvester: sylvester2,
    multiply: multiply2,
    transpose: transpose2
  } = _ref;
  return typed2(name246, {
    "Matrix, Matrix": function MatrixMatrix(A, Q2) {
      return sylvester2(A, transpose2(A), multiply2(-1, Q2));
    },
    "Array, Matrix": function ArrayMatrix(A, Q2) {
      return sylvester2(matrix2(A), transpose2(matrix2(A)), multiply2(-1, Q2));
    },
    "Matrix, Array": function MatrixArray(A, Q2) {
      return sylvester2(A, transpose2(matrix2(A)), matrix2(multiply2(-1, Q2)));
    },
    "Array, Array": function ArrayArray(A, Q2) {
      return sylvester2(matrix2(A), transpose2(matrix2(A)), matrix2(multiply2(-1, Q2))).toArray();
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/arithmetic/divide.js
var name247 = "divide";
var dependencies247 = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"];
var createDivide = factory(name247, dependencies247, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    multiply: multiply2,
    equalScalar,
    divideScalar,
    inv: inv2
  } = _ref;
  var matAlgo11xS0s18 = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matAlgo14xDs12 = createMatAlgo14xDs({
    typed: typed2
  });
  return typed2("divide", extend({
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(x, y) {
      return multiply2(x, inv2(y));
    },
    "DenseMatrix, any": function DenseMatrixAny(x, y) {
      return matAlgo14xDs12(x, y, divideScalar, false);
    },
    "SparseMatrix, any": function SparseMatrixAny(x, y) {
      return matAlgo11xS0s18(x, y, divideScalar, false);
    },
    "Array, any": function ArrayAny(x, y) {
      return matAlgo14xDs12(matrix2(x), y, divideScalar, false).valueOf();
    },
    "any, Array | Matrix": function anyArrayMatrix(x, y) {
      return multiply2(x, inv2(y));
    }
  }, divideScalar.signatures));
});
// ../../node_modules/mathjs/lib/esm/function/geometry/distance.js
var name248 = "distance";
var dependencies248 = ["typed", "addScalar", "subtract", "divideScalar", "multiplyScalar", "unaryMinus", "sqrt", "abs"];
var createDistance = factory(name248, dependencies248, (_ref) => {
  var {
    typed: typed2,
    addScalar,
    subtract: subtract2,
    multiplyScalar,
    divideScalar,
    unaryMinus: unaryMinus2,
    sqrt: sqrt3,
    abs: abs3
  } = _ref;
  return typed2(name248, {
    "Array, Array, Array": function ArrayArrayArray(x, y, z2) {
      if (x.length === 2 && y.length === 2 && z2.length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_2d(y)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
        }
        if (!_2d(z2)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
        }
        var m = divideScalar(subtract2(z2[1], z2[0]), subtract2(y[1], y[0]));
        var xCoeff = multiplyScalar(multiplyScalar(m, m), y[0]);
        var yCoeff = unaryMinus2(multiplyScalar(m, y[0]));
        var constant = x[1];
        return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Object, Object, Object": function ObjectObjectObject(x, y, z2) {
      if (Object.keys(x).length === 2 && Object.keys(y).length === 2 && Object.keys(z2).length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        }
        if (!_2d(y)) {
          throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");
        }
        if (!_2d(z2)) {
          throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "lineOnePtX" in y && "lineOnePtY" in y && "lineTwoPtX" in z2 && "lineTwoPtY" in z2) {
          var m = divideScalar(subtract2(z2.lineTwoPtY, z2.lineTwoPtX), subtract2(y.lineOnePtY, y.lineOnePtX));
          var xCoeff = multiplyScalar(multiplyScalar(m, m), y.lineOnePtX);
          var yCoeff = unaryMinus2(multiplyScalar(m, y.lineOnePtX));
          var constant = x.pointX;
          return _distancePointLine2D(x.pointX, x.pointY, xCoeff, yCoeff, constant);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Array, Array": function ArrayArray(x, y) {
      if (x.length === 2 && y.length === 3) {
        if (!_2d(x)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_3d(y)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
        }
        return _distancePointLine2D(x[0], x[1], y[0], y[1], y[2]);
      } else if (x.length === 3 && y.length === 6) {
        if (!_3d(x)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
        }
        if (!_parametricLine(y)) {
          throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");
        }
        return _distancePointLine3D(x[0], x[1], x[2], y[0], y[1], y[2], y[3], y[4], y[5]);
      } else if (x.length === y.length && x.length > 0) {
        if (!_containsOnlyNumbers(x)) {
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        }
        if (!_containsOnlyNumbers(y)) {
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        }
        return _euclideanDistance(x, y);
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Object, Object": function ObjectObject(x, y) {
      if (Object.keys(x).length === 2 && Object.keys(y).length === 3) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        }
        if (!_3d(y)) {
          throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "xCoeffLine" in y && "yCoeffLine" in y && "constant" in y) {
          return _distancePointLine2D(x.pointX, x.pointY, y.xCoeffLine, y.yCoeffLine, y.constant);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 3 && Object.keys(y).length === 6) {
        if (!_3d(x)) {
          throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");
        }
        if (!_parametricLine(y)) {
          throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "x0" in y && "y0" in y && "z0" in y && "a" in y && "b" in y && "c" in y) {
          return _distancePointLine3D(x.pointX, x.pointY, x.pointZ, y.x0, y.y0, y.z0, y.a, y.b, y.c);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 2 && Object.keys(y).length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");
        }
        if (!_2d(y)) {
          throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");
        }
        if ("pointOneX" in x && "pointOneY" in x && "pointTwoX" in y && "pointTwoY" in y) {
          return _euclideanDistance([x.pointOneX, x.pointOneY], [y.pointTwoX, y.pointTwoY]);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 3 && Object.keys(y).length === 3) {
        if (!_3d(x)) {
          throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");
        }
        if (!_3d(y)) {
          throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");
        }
        if ("pointOneX" in x && "pointOneY" in x && "pointOneZ" in x && "pointTwoX" in y && "pointTwoY" in y && "pointTwoZ" in y) {
          return _euclideanDistance([x.pointOneX, x.pointOneY, x.pointOneZ], [y.pointTwoX, y.pointTwoY, y.pointTwoZ]);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    Array: function Array(arr) {
      if (!_pairwise(arr)) {
        throw new TypeError("Incorrect array format entered for pairwise distance calculation");
      }
      return _distancePairwise(arr);
    }
  });
  function _isNumber(a) {
    return typeof a === "number" || isBigNumber(a);
  }
  function _2d(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]);
  }
  function _3d(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]);
  }
  function _containsOnlyNumbers(a) {
    if (!Array.isArray(a)) {
      a = _objectToArray(a);
    }
    return a.every(_isNumber);
  }
  function _parametricLine(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]) && _isNumber(a[3]) && _isNumber(a[4]) && _isNumber(a[5]);
  }
  function _objectToArray(o) {
    var keys = Object.keys(o);
    var a = [];
    for (var i2 = 0;i2 < keys.length; i2++) {
      a.push(o[keys[i2]]);
    }
    return a;
  }
  function _pairwise(a) {
    if (a[0].length === 2 && _isNumber(a[0][0]) && _isNumber(a[0][1])) {
      if (a.some((aI) => aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]))) {
        return false;
      }
    } else if (a[0].length === 3 && _isNumber(a[0][0]) && _isNumber(a[0][1]) && _isNumber(a[0][2])) {
      if (a.some((aI) => aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]))) {
        return false;
      }
    } else {
      return false;
    }
    return true;
  }
  function _distancePointLine2D(x, y, a, b, c) {
    var num = abs3(addScalar(addScalar(multiplyScalar(a, x), multiplyScalar(b, y)), c));
    var den = sqrt3(addScalar(multiplyScalar(a, a), multiplyScalar(b, b)));
    return divideScalar(num, den);
  }
  function _distancePointLine3D(x, y, z2, x0, y0, z0, a, b, c) {
    var num = [subtract2(multiplyScalar(subtract2(y0, y), c), multiplyScalar(subtract2(z0, z2), b)), subtract2(multiplyScalar(subtract2(z0, z2), a), multiplyScalar(subtract2(x0, x), c)), subtract2(multiplyScalar(subtract2(x0, x), b), multiplyScalar(subtract2(y0, y), a))];
    num = sqrt3(addScalar(addScalar(multiplyScalar(num[0], num[0]), multiplyScalar(num[1], num[1])), multiplyScalar(num[2], num[2])));
    var den = sqrt3(addScalar(addScalar(multiplyScalar(a, a), multiplyScalar(b, b)), multiplyScalar(c, c)));
    return divideScalar(num, den);
  }
  function _euclideanDistance(x, y) {
    var vectorSize = x.length;
    var result = 0;
    var diff2 = 0;
    for (var i2 = 0;i2 < vectorSize; i2++) {
      diff2 = subtract2(x[i2], y[i2]);
      result = addScalar(multiplyScalar(diff2, diff2), result);
    }
    return sqrt3(result);
  }
  function _distancePairwise(a) {
    var result = [];
    var pointA = [];
    var pointB = [];
    for (var i2 = 0;i2 < a.length - 1; i2++) {
      for (var j = i2 + 1;j < a.length; j++) {
        if (a[0].length === 2) {
          pointA = [a[i2][0], a[i2][1]];
          pointB = [a[j][0], a[j][1]];
        } else if (a[0].length === 3) {
          pointA = [a[i2][0], a[i2][1], a[i2][2]];
          pointB = [a[j][0], a[j][1], a[j][2]];
        }
        result.push(_euclideanDistance(pointA, pointB));
      }
    }
    return result;
  }
});
// ../../node_modules/mathjs/lib/esm/function/geometry/intersect.js
var name249 = "intersect";
var dependencies249 = ["typed", "config", "abs", "add", "addScalar", "matrix", "multiply", "multiplyScalar", "divideScalar", "subtract", "smaller", "equalScalar", "flatten", "isZero", "isNumeric"];
var createIntersect = factory(name249, dependencies249, (_ref) => {
  var {
    typed: typed2,
    config: config7,
    abs: abs3,
    add: add3,
    addScalar,
    matrix: matrix2,
    multiply: multiply2,
    multiplyScalar,
    divideScalar,
    subtract: subtract2,
    smaller: smaller2,
    equalScalar,
    flatten: flatten3,
    isZero: isZero2,
    isNumeric: isNumeric2
  } = _ref;
  return typed2("intersect", {
    "Array, Array, Array": _AAA,
    "Array, Array, Array, Array": _AAAA,
    "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(x, y, plane) {
      var arr = _AAA(x.valueOf(), y.valueOf(), plane.valueOf());
      return arr === null ? null : matrix2(arr);
    },
    "Matrix, Matrix, Matrix, Matrix": function MatrixMatrixMatrixMatrix(w, x, y, z2) {
      var arr = _AAAA(w.valueOf(), x.valueOf(), y.valueOf(), z2.valueOf());
      return arr === null ? null : matrix2(arr);
    }
  });
  function _AAA(x, y, plane) {
    x = _coerceArr(x);
    y = _coerceArr(y);
    plane = _coerceArr(plane);
    if (!_3d(x)) {
      throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
    }
    if (!_3d(y)) {
      throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
    }
    if (!_4d(plane)) {
      throw new TypeError("Array with 4 numbers expected as third argument");
    }
    return _intersectLinePlane(x[0], x[1], x[2], y[0], y[1], y[2], plane[0], plane[1], plane[2], plane[3]);
  }
  function _AAAA(w, x, y, z2) {
    w = _coerceArr(w);
    x = _coerceArr(x);
    y = _coerceArr(y);
    z2 = _coerceArr(z2);
    if (w.length === 2) {
      if (!_2d(w)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
      }
      if (!_2d(x)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
      }
      if (!_2d(y)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
      }
      if (!_2d(z2)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");
      }
      return _intersect2d(w, x, y, z2);
    } else if (w.length === 3) {
      if (!_3d(w)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
      }
      if (!_3d(x)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
      }
      if (!_3d(y)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");
      }
      if (!_3d(z2)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");
      }
      return _intersect3d(w[0], w[1], w[2], x[0], x[1], x[2], y[0], y[1], y[2], z2[0], z2[1], z2[2]);
    } else {
      throw new TypeError("Arrays with two or thee dimensional points expected");
    }
  }
  function _coerceArr(arr) {
    if (arr.length === 1)
      return arr[0];
    if (arr.length > 1 && Array.isArray(arr[0])) {
      if (arr.every((el) => Array.isArray(el) && el.length === 1))
        return flatten3(arr);
    }
    return arr;
  }
  function _2d(x) {
    return x.length === 2 && isNumeric2(x[0]) && isNumeric2(x[1]);
  }
  function _3d(x) {
    return x.length === 3 && isNumeric2(x[0]) && isNumeric2(x[1]) && isNumeric2(x[2]);
  }
  function _4d(x) {
    return x.length === 4 && isNumeric2(x[0]) && isNumeric2(x[1]) && isNumeric2(x[2]) && isNumeric2(x[3]);
  }
  function _intersect2d(p1a, p1b, p2a, p2b) {
    var o1 = p1a;
    var o2 = p2a;
    var d1 = subtract2(o1, p1b);
    var d2 = subtract2(o2, p2b);
    var det2 = subtract2(multiplyScalar(d1[0], d2[1]), multiplyScalar(d2[0], d1[1]));
    if (isZero2(det2))
      return null;
    if (smaller2(abs3(det2), config7.epsilon)) {
      return null;
    }
    var d20o11 = multiplyScalar(d2[0], o1[1]);
    var d21o10 = multiplyScalar(d2[1], o1[0]);
    var d20o21 = multiplyScalar(d2[0], o2[1]);
    var d21o20 = multiplyScalar(d2[1], o2[0]);
    var t = divideScalar(addScalar(subtract2(subtract2(d20o11, d21o10), d20o21), d21o20), det2);
    return add3(multiply2(d1, t), o1);
  }
  function _intersect3dHelper(a, b, c, d, e3, f, g, h2, i2, j, k, l) {
    var add1 = multiplyScalar(subtract2(a, b), subtract2(c, d));
    var add22 = multiplyScalar(subtract2(e3, f), subtract2(g, h2));
    var add32 = multiplyScalar(subtract2(i2, j), subtract2(k, l));
    return addScalar(addScalar(add1, add22), add32);
  }
  function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
    var d1343 = _intersect3dHelper(x1, x3, x4, x3, y1, y3, y4, y3, z1, z3, z4, z3);
    var d4321 = _intersect3dHelper(x4, x3, x2, x1, y4, y3, y2, y1, z4, z3, z2, z1);
    var d1321 = _intersect3dHelper(x1, x3, x2, x1, y1, y3, y2, y1, z1, z3, z2, z1);
    var d4343 = _intersect3dHelper(x4, x3, x4, x3, y4, y3, y4, y3, z4, z3, z4, z3);
    var d2121 = _intersect3dHelper(x2, x1, x2, x1, y2, y1, y2, y1, z2, z1, z2, z1);
    var numerator = subtract2(multiplyScalar(d1343, d4321), multiplyScalar(d1321, d4343));
    var denominator = subtract2(multiplyScalar(d2121, d4343), multiplyScalar(d4321, d4321));
    if (isZero2(denominator))
      return null;
    var ta = divideScalar(numerator, denominator);
    var tb = divideScalar(addScalar(d1343, multiplyScalar(ta, d4321)), d4343);
    var pax = addScalar(x1, multiplyScalar(ta, subtract2(x2, x1)));
    var pay = addScalar(y1, multiplyScalar(ta, subtract2(y2, y1)));
    var paz = addScalar(z1, multiplyScalar(ta, subtract2(z2, z1)));
    var pbx = addScalar(x3, multiplyScalar(tb, subtract2(x4, x3)));
    var pby = addScalar(y3, multiplyScalar(tb, subtract2(y4, y3)));
    var pbz = addScalar(z3, multiplyScalar(tb, subtract2(z4, z3)));
    if (equalScalar(pax, pbx) && equalScalar(pay, pby) && equalScalar(paz, pbz)) {
      return [pax, pay, paz];
    } else {
      return null;
    }
  }
  function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y, z3, c) {
    var x1x = multiplyScalar(x1, x);
    var x2x = multiplyScalar(x2, x);
    var y1y = multiplyScalar(y1, y);
    var y2y = multiplyScalar(y2, y);
    var z1z = multiplyScalar(z1, z3);
    var z2z = multiplyScalar(z2, z3);
    var numerator = subtract2(subtract2(subtract2(c, x1x), y1y), z1z);
    var denominator = subtract2(subtract2(subtract2(addScalar(addScalar(x2x, y2y), z2z), x1x), y1y), z1z);
    var t = divideScalar(numerator, denominator);
    var px = addScalar(x1, multiplyScalar(t, subtract2(x2, x1)));
    var py = addScalar(y1, multiplyScalar(t, subtract2(y2, y1)));
    var pz = addScalar(z1, multiplyScalar(t, subtract2(z2, z1)));
    return [px, py, pz];
  }
});
// ../../node_modules/mathjs/lib/esm/function/statistics/sum.js
var name250 = "sum";
var dependencies250 = ["typed", "config", "add", "numeric"];
var createSum = factory(name250, dependencies250, (_ref) => {
  var {
    typed: typed2,
    config: config7,
    add: add3,
    numeric: numeric3
  } = _ref;
  return typed2(name250, {
    "Array | Matrix": _sum,
    "Array | Matrix, number | BigNumber": _nsumDim,
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function sum");
      }
      return _sum(args);
    }
  });
  function _sum(array50) {
    var sum3;
    deepForEach(array50, function(value) {
      try {
        sum3 = sum3 === undefined ? value : add3(sum3, value);
      } catch (err) {
        throw improveErrorMessage(err, "sum", value);
      }
    });
    if (sum3 === undefined) {
      sum3 = numeric3(0, config7.number);
    }
    if (typeof sum3 === "string") {
      sum3 = numeric3(sum3, config7.number);
    }
    return sum3;
  }
  function _nsumDim(array50, dim) {
    try {
      var sum3 = reduce(array50, dim, add3);
      return sum3;
    } catch (err) {
      throw improveErrorMessage(err, "sum");
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/statistics/cumsum.js
var name251 = "cumsum";
var dependencies251 = ["typed", "add", "unaryPlus"];
var createCumSum = factory(name251, dependencies251, (_ref) => {
  var {
    typed: typed2,
    add: add3,
    unaryPlus: unaryPlus2
  } = _ref;
  return typed2(name251, {
    Array: _cumsum,
    Matrix: function Matrix(matrix2) {
      return matrix2.create(_cumsum(matrix2.valueOf()));
    },
    "Array, number | BigNumber": _ncumSumDim,
    "Matrix, number | BigNumber": function MatrixNumberBigNumber(matrix2, dim) {
      return matrix2.create(_ncumSumDim(matrix2.valueOf(), dim));
    },
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("All values expected to be scalar in function cumsum");
      }
      return _cumsum(args);
    }
  });
  function _cumsum(array51) {
    try {
      return _cumsummap(array51);
    } catch (err) {
      throw improveErrorMessage(err, name251);
    }
  }
  function _cumsummap(array51) {
    if (array51.length === 0) {
      return [];
    }
    var sums = [unaryPlus2(array51[0])];
    for (var i2 = 1;i2 < array51.length; ++i2) {
      sums.push(add3(sums[i2 - 1], array51[i2]));
    }
    return sums;
  }
  function _ncumSumDim(array51, dim) {
    var size2 = arraySize(array51);
    if (dim < 0 || dim >= size2.length) {
      throw new IndexError(dim, size2.length);
    }
    try {
      return _cumsumDimensional(array51, dim);
    } catch (err) {
      throw improveErrorMessage(err, name251);
    }
  }
  function _cumsumDimensional(mat, dim) {
    var i2, ret, tran;
    if (dim <= 0) {
      var initialValue = mat[0][0];
      if (!Array.isArray(initialValue)) {
        return _cumsummap(mat);
      } else {
        tran = _switch(mat);
        ret = [];
        for (i2 = 0;i2 < tran.length; i2++) {
          ret[i2] = _cumsumDimensional(tran[i2], dim - 1);
        }
        return ret;
      }
    } else {
      ret = [];
      for (i2 = 0;i2 < mat.length; i2++) {
        ret[i2] = _cumsumDimensional(mat[i2], dim - 1);
      }
      return ret;
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/statistics/mean.js
var name252 = "mean";
var dependencies252 = ["typed", "add", "divide"];
var createMean = factory(name252, dependencies252, (_ref) => {
  var {
    typed: typed2,
    add: add3,
    divide: divide3
  } = _ref;
  return typed2(name252, {
    "Array | Matrix": _mean,
    "Array | Matrix, number | BigNumber": _nmeanDim,
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function mean");
      }
      return _mean(args);
    }
  });
  function _nmeanDim(array52, dim) {
    try {
      var sum3 = reduce(array52, dim, add3);
      var s = Array.isArray(array52) ? arraySize(array52) : array52.size();
      return divide3(sum3, s[dim]);
    } catch (err) {
      throw improveErrorMessage(err, "mean");
    }
  }
  function _mean(array52) {
    var sum3;
    var num = 0;
    deepForEach(array52, function(value) {
      try {
        sum3 = sum3 === undefined ? value : add3(sum3, value);
        num++;
      } catch (err) {
        throw improveErrorMessage(err, "mean", value);
      }
    });
    if (num === 0) {
      throw new Error("Cannot calculate the mean of an empty array");
    }
    return divide3(sum3, num);
  }
});
// ../../node_modules/mathjs/lib/esm/function/statistics/median.js
var name253 = "median";
var dependencies253 = ["typed", "add", "divide", "compare", "partitionSelect"];
var createMedian = factory(name253, dependencies253, (_ref) => {
  var {
    typed: typed2,
    add: add3,
    divide: divide3,
    compare: compare2,
    partitionSelect: partitionSelect2
  } = _ref;
  function _median(array53) {
    try {
      array53 = flatten(array53.valueOf());
      var num = array53.length;
      if (num === 0) {
        throw new Error("Cannot calculate median of an empty array");
      }
      if (num % 2 === 0) {
        var mid = num / 2 - 1;
        var right = partitionSelect2(array53, mid + 1);
        var left = array53[mid];
        for (var i2 = 0;i2 < mid; ++i2) {
          if (compare2(array53[i2], left) > 0) {
            left = array53[i2];
          }
        }
        return middle2(left, right);
      } else {
        var m = partitionSelect2(array53, (num - 1) / 2);
        return middle(m);
      }
    } catch (err) {
      throw improveErrorMessage(err, "median");
    }
  }
  var middle = typed2({
    "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(value) {
      return value;
    }
  });
  var middle2 = typed2({
    "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit": function numberBigNumberComplexUnitNumberBigNumberComplexUnit(left, right) {
      return divide3(add3(left, right), 2);
    }
  });
  return typed2(name253, {
    "Array | Matrix": _median,
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array53, dim) {
      throw new Error("median(A, dim) is not yet supported");
    },
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function median");
      }
      return _median(args);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/statistics/mad.js
var name254 = "mad";
var dependencies254 = ["typed", "abs", "map", "median", "subtract"];
var createMad = factory(name254, dependencies254, (_ref) => {
  var {
    typed: typed2,
    abs: abs3,
    map: map8,
    median: median2,
    subtract: subtract2
  } = _ref;
  return typed2(name254, {
    "Array | Matrix": _mad,
    "...": function _(args) {
      return _mad(args);
    }
  });
  function _mad(array54) {
    array54 = flatten(array54.valueOf());
    if (array54.length === 0) {
      throw new Error("Cannot calculate median absolute deviation (mad) of an empty array");
    }
    try {
      var med = median2(array54);
      return median2(map8(array54, function(value) {
        return abs3(subtract2(value, med));
      }));
    } catch (err) {
      if (err instanceof TypeError && err.message.indexOf("median") !== -1) {
        throw new TypeError(err.message.replace("median", "mad"));
      } else {
        throw improveErrorMessage(err, "mad");
      }
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/statistics/variance.js
var DEFAULT_NORMALIZATION = "unbiased";
var name255 = "variance";
var dependencies255 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
var createVariance = factory(name255, dependencies255, (_ref) => {
  var {
    typed: typed2,
    add: add3,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide3,
    apply,
    isNaN: isNaN3
  } = _ref;
  return typed2(name255, {
    "Array | Matrix": function ArrayMatrix(array54) {
      return _var(array54, DEFAULT_NORMALIZATION);
    },
    "Array | Matrix, string": _var,
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array54, dim) {
      return _varDim(array54, dim, DEFAULT_NORMALIZATION);
    },
    "Array | Matrix, number | BigNumber, string": _varDim,
    "...": function _(args) {
      return _var(args, DEFAULT_NORMALIZATION);
    }
  });
  function _var(array54, normalization) {
    var sum3;
    var num = 0;
    if (array54.length === 0) {
      throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
    }
    deepForEach(array54, function(value) {
      try {
        sum3 = sum3 === undefined ? value : add3(sum3, value);
        num++;
      } catch (err) {
        throw improveErrorMessage(err, "variance", value);
      }
    });
    if (num === 0)
      throw new Error("Cannot calculate variance of an empty array");
    var mean2 = divide3(sum3, num);
    sum3 = undefined;
    deepForEach(array54, function(value) {
      var diff2 = subtract2(value, mean2);
      sum3 = sum3 === undefined ? multiply2(diff2, diff2) : add3(sum3, multiply2(diff2, diff2));
    });
    if (isNaN3(sum3)) {
      return sum3;
    }
    switch (normalization) {
      case "uncorrected":
        return divide3(sum3, num);
      case "biased":
        return divide3(sum3, num + 1);
      case "unbiased": {
        var zero = isBigNumber(sum3) ? sum3.mul(0) : 0;
        return num === 1 ? zero : divide3(sum3, num - 1);
      }
      default:
        throw new Error('Unknown normalization "' + normalization + '". ' + 'Choose "unbiased" (default), "uncorrected", or "biased".');
    }
  }
  function _varDim(array54, dim, normalization) {
    try {
      if (array54.length === 0) {
        throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
      }
      return apply(array54, dim, (x) => _var(x, normalization));
    } catch (err) {
      throw improveErrorMessage(err, "variance");
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/statistics/quantileSeq.js
var name256 = "quantileSeq";
var dependencies256 = ["typed", "add", "multiply", "partitionSelect", "compare"];
var createQuantileSeq = factory(name256, dependencies256, (_ref) => {
  var {
    typed: typed2,
    add: add3,
    multiply: multiply2,
    partitionSelect: partitionSelect2,
    compare: compare2
  } = _ref;
  function quantileSeq2(data, probOrN, sorted) {
    var probArr, dataArr, one;
    if (arguments.length < 2 || arguments.length > 3) {
      throw new SyntaxError("Function quantileSeq requires two or three parameters");
    }
    if (isCollection(data)) {
      sorted = sorted || false;
      if (typeof sorted === "boolean") {
        dataArr = data.valueOf();
        if (isNumber(probOrN)) {
          if (probOrN < 0) {
            throw new Error("N/prob must be non-negative");
          }
          if (probOrN <= 1) {
            return _quantileSeq(dataArr, probOrN, sorted);
          }
          if (probOrN > 1) {
            if (!isInteger(probOrN)) {
              throw new Error("N must be a positive integer");
            }
            var nPlusOne = probOrN + 1;
            probArr = new Array(probOrN);
            for (var i2 = 0;i2 < probOrN; ) {
              probArr[i2] = _quantileSeq(dataArr, ++i2 / nPlusOne, sorted);
            }
            return probArr;
          }
        }
        if (isBigNumber(probOrN)) {
          var BigNumber = probOrN.constructor;
          if (probOrN.isNegative()) {
            throw new Error("N/prob must be non-negative");
          }
          one = new BigNumber(1);
          if (probOrN.lte(one)) {
            return new BigNumber(_quantileSeq(dataArr, probOrN, sorted));
          }
          if (probOrN.gt(one)) {
            if (!probOrN.isInteger()) {
              throw new Error("N must be a positive integer");
            }
            var intN = probOrN.toNumber();
            if (intN > 4294967295) {
              throw new Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");
            }
            var _nPlusOne = new BigNumber(intN + 1);
            probArr = new Array(intN);
            for (var _i = 0;_i < intN; ) {
              probArr[_i] = new BigNumber(_quantileSeq(dataArr, new BigNumber(++_i).div(_nPlusOne), sorted));
            }
            return probArr;
          }
        }
        if (isCollection(probOrN)) {
          var probOrNArr = probOrN.valueOf();
          probArr = new Array(probOrNArr.length);
          for (var _i2 = 0;_i2 < probArr.length; ++_i2) {
            var currProb = probOrNArr[_i2];
            if (isNumber(currProb)) {
              if (currProb < 0 || currProb > 1) {
                throw new Error("Probability must be between 0 and 1, inclusive");
              }
            } else if (isBigNumber(currProb)) {
              one = new currProb.constructor(1);
              if (currProb.isNegative() || currProb.gt(one)) {
                throw new Error("Probability must be between 0 and 1, inclusive");
              }
            } else {
              throw new TypeError("Unexpected type of argument in function quantileSeq");
            }
            probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);
          }
          return probArr;
        }
        throw new TypeError("Unexpected type of argument in function quantileSeq");
      }
      throw new TypeError("Unexpected type of argument in function quantileSeq");
    }
    throw new TypeError("Unexpected type of argument in function quantileSeq");
  }
  function _quantileSeq(array55, prob, sorted) {
    var flat = flatten(array55);
    var len = flat.length;
    if (len === 0) {
      throw new Error("Cannot calculate quantile of an empty sequence");
    }
    if (isNumber(prob)) {
      var _index = prob * (len - 1);
      var _fracPart = _index % 1;
      if (_fracPart === 0) {
        var value = sorted ? flat[_index] : partitionSelect2(flat, _index);
        validate2(value);
        return value;
      }
      var _integerPart = Math.floor(_index);
      var _left;
      var _right;
      if (sorted) {
        _left = flat[_integerPart];
        _right = flat[_integerPart + 1];
      } else {
        _right = partitionSelect2(flat, _integerPart + 1);
        _left = flat[_integerPart];
        for (var i2 = 0;i2 < _integerPart; ++i2) {
          if (compare2(flat[i2], _left) > 0) {
            _left = flat[i2];
          }
        }
      }
      validate2(_left);
      validate2(_right);
      return add3(multiply2(_left, 1 - _fracPart), multiply2(_right, _fracPart));
    }
    var index = prob.times(len - 1);
    if (index.isInteger()) {
      index = index.toNumber();
      var _value = sorted ? flat[index] : partitionSelect2(flat, index);
      validate2(_value);
      return _value;
    }
    var integerPart = index.floor();
    var fracPart = index.minus(integerPart);
    var integerPartNumber = integerPart.toNumber();
    var left;
    var right;
    if (sorted) {
      left = flat[integerPartNumber];
      right = flat[integerPartNumber + 1];
    } else {
      right = partitionSelect2(flat, integerPartNumber + 1);
      left = flat[integerPartNumber];
      for (var _i3 = 0;_i3 < integerPartNumber; ++_i3) {
        if (compare2(flat[_i3], left) > 0) {
          left = flat[_i3];
        }
      }
    }
    validate2(left);
    validate2(right);
    var one = new fracPart.constructor(1);
    return add3(multiply2(left, one.minus(fracPart)), multiply2(right, fracPart));
  }
  var validate2 = typed2({
    "number | BigNumber | Unit": function numberBigNumberUnit(x) {
      return x;
    }
  });
  return quantileSeq2;
});
// ../../node_modules/mathjs/lib/esm/function/statistics/std.js
var name257 = "std";
var dependencies257 = ["typed", "map", "sqrt", "variance"];
var createStd = factory(name257, dependencies257, (_ref) => {
  var {
    typed: typed2,
    map: map8,
    sqrt: sqrt3,
    variance: variance2
  } = _ref;
  return typed2(name257, {
    "Array | Matrix": _std,
    "Array | Matrix, string": _std,
    "Array | Matrix, number | BigNumber": _std,
    "Array | Matrix, number | BigNumber, string": _std,
    "...": function _(args) {
      return _std(args);
    }
  });
  function _std(array55, normalization) {
    if (array55.length === 0) {
      throw new SyntaxError("Function std requires one or more parameters (0 provided)");
    }
    try {
      var v = variance2.apply(null, arguments);
      if (isCollection(v)) {
        return map8(v, sqrt3);
      } else {
        return sqrt3(v);
      }
    } catch (err) {
      if (err instanceof TypeError && err.message.indexOf(" variance") !== -1) {
        throw new TypeError(err.message.replace(" variance", " std"));
      } else {
        throw err;
      }
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/probability/combinations.js
var isPositiveInteger = function(n) {
  return n.isInteger() && n.gte(0);
};
var name258 = "combinations";
var dependencies258 = ["typed"];
var createCombinations = factory(name258, dependencies258, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name258, {
    "number, number": combinationsNumber,
    "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
      var BigNumber = n.constructor;
      var result, i2;
      var nMinusk = n.minus(k);
      var one = new BigNumber(1);
      if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
        throw new TypeError("Positive integer value expected in function combinations");
      }
      if (k.gt(n)) {
        throw new TypeError("k must be less than n in function combinations");
      }
      result = one;
      if (k.lt(nMinusk)) {
        for (i2 = one;i2.lte(nMinusk); i2 = i2.plus(one)) {
          result = result.times(k.plus(i2)).dividedBy(i2);
        }
      } else {
        for (i2 = one;i2.lte(k); i2 = i2.plus(one)) {
          result = result.times(nMinusk.plus(i2)).dividedBy(i2);
        }
      }
      return result;
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/probability/combinationsWithRep.js
var isPositiveInteger2 = function(n) {
  return n.isInteger() && n.gte(0);
};
var name259 = "combinationsWithRep";
var dependencies259 = ["typed"];
var createCombinationsWithRep = factory(name259, dependencies259, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name259, {
    "number, number": function numberNumber(n, k) {
      if (!isInteger(n) || n < 0) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (!isInteger(k) || k < 0) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (n < 1) {
        throw new TypeError("k must be less than or equal to n + k - 1");
      }
      if (k < n - 1) {
        var _prodrange = product2(n, n + k - 1);
        return _prodrange / product2(1, k);
      }
      var prodrange = product2(k + 1, n + k - 1);
      return prodrange / product2(1, n - 1);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
      var BigNumber = n.constructor;
      var result, i2;
      var one = new BigNumber(1);
      var nMinusOne = n.minus(one);
      if (!isPositiveInteger2(n) || !isPositiveInteger2(k)) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (n.lt(one)) {
        throw new TypeError("k must be less than or equal to n + k - 1 in function combinationsWithRep");
      }
      result = one;
      if (k.lt(nMinusOne)) {
        for (i2 = one;i2.lte(nMinusOne); i2 = i2.plus(one)) {
          result = result.times(k.plus(i2)).dividedBy(i2);
        }
      } else {
        for (i2 = one;i2.lte(k); i2 = i2.plus(one)) {
          result = result.times(nMinusOne.plus(i2)).dividedBy(i2);
        }
      }
      return result;
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/probability/gamma.js
var name260 = "gamma";
var dependencies260 = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"];
var createGamma = factory(name260, dependencies260, (_ref) => {
  var {
    typed: typed2,
    config: config7,
    multiplyScalar,
    pow: pow3,
    BigNumber: _BigNumber,
    Complex: Complex2
  } = _ref;
  function gammaComplex(n) {
    if (n.im === 0) {
      return gammaNumber(n.re);
    }
    if (n.re < 0.5) {
      var _t = new Complex2(1 - n.re, -n.im);
      var r = new Complex2(Math.PI * n.re, Math.PI * n.im);
      return new Complex2(Math.PI).div(r.sin()).div(gammaComplex(_t));
    }
    n = new Complex2(n.re - 1, n.im);
    var x = new Complex2(gammaP[0], 0);
    for (var i2 = 1;i2 < gammaP.length; ++i2) {
      var gammaPval = new Complex2(gammaP[i2], 0);
      x = x.add(gammaPval.div(n.add(i2)));
    }
    var t = new Complex2(n.re + gammaG + 0.5, n.im);
    var twoPiSqrt = Math.sqrt(2 * Math.PI);
    var tpow = t.pow(n.add(0.5));
    var expt = t.neg().exp();
    return x.mul(twoPiSqrt).mul(tpow).mul(expt);
  }
  return typed2(name260, {
    number: gammaNumber,
    Complex: gammaComplex,
    BigNumber: function BigNumber(n) {
      if (n.isInteger()) {
        return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));
      }
      if (!n.isFinite()) {
        return new _BigNumber(n.isNegative() ? NaN : Infinity);
      }
      throw new Error("Integer BigNumber expected");
    }
  });
  function bigFactorial(n) {
    if (n < 8) {
      return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);
    }
    var precision = config7.precision + (Math.log(n.toNumber()) | 0);
    var Big = _BigNumber.clone({
      precision
    });
    if (n % 2 === 1) {
      return n.times(bigFactorial(new _BigNumber(n - 1)));
    }
    var p = n;
    var prod2 = new Big(n);
    var sum3 = n.toNumber();
    while (p > 2) {
      p -= 2;
      sum3 += p;
      prod2 = prod2.times(sum3);
    }
    return new _BigNumber(prod2.toPrecision(_BigNumber.precision));
  }
});
// ../../node_modules/mathjs/lib/esm/function/probability/lgamma.js
var name261 = "lgamma";
var dependencies261 = ["Complex", "typed"];
var createLgamma = factory(name261, dependencies261, (_ref) => {
  var {
    Complex: Complex2,
    typed: typed2
  } = _ref;
  var SMALL_RE = 7;
  var SMALL_IM = 7;
  var coeffs = [-0.029550653594771242, 0.00641025641025641, -0.0019175269175269176, 0.0008417508417508417, -0.0005952380952380953, 0.0007936507936507937, -0.002777777777777778, 0.08333333333333333];
  return typed2(name261, {
    number: lgammaNumber,
    Complex: lgammaComplex,
    BigNumber: function BigNumber() {
      throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
    }
  });
  function lgammaComplex(n) {
    var TWOPI = 6.283185307179586;
    var LOGPI = 1.1447298858494002;
    var REFLECTION = 0.1;
    if (n.isNaN()) {
      return new Complex2(NaN, NaN);
    } else if (n.im === 0) {
      return new Complex2(lgammaNumber(n.re), 0);
    } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {
      return lgammaStirling(n);
    } else if (n.re <= REFLECTION) {
      var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);
      var a = n.mul(Math.PI).sin().log();
      var b = lgammaComplex(new Complex2(1 - n.re, -n.im));
      return new Complex2(LOGPI, tmp).sub(a).sub(b);
    } else if (n.im >= 0) {
      return lgammaRecurrence(n);
    } else {
      return lgammaRecurrence(n.conjugate()).conjugate();
    }
  }
  function lgammaStirling(z2) {
    var leftPart = z2.sub(0.5).mul(z2.log()).sub(z2).add(lnSqrt2PI);
    var rz = new Complex2(1, 0).div(z2);
    var rzz = rz.div(z2);
    var a = coeffs[0];
    var b = coeffs[1];
    var r = 2 * rzz.re;
    var s = rzz.re * rzz.re + rzz.im * rzz.im;
    for (var i2 = 2;i2 < 8; i2++) {
      var tmp = b;
      b = -s * a + coeffs[i2];
      a = r * a + tmp;
    }
    var rightPart = rz.mul(rzz.mul(a).add(b));
    return leftPart.add(rightPart);
  }
  function lgammaRecurrence(z2) {
    var signflips = 0;
    var sb = 0;
    var shiftprod = z2;
    z2 = z2.add(1);
    while (z2.re <= SMALL_RE) {
      shiftprod = shiftprod.mul(z2);
      var nsb = shiftprod.im < 0 ? 1 : 0;
      if (nsb !== 0 && sb === 0)
        signflips++;
      sb = nsb;
      z2 = z2.add(1);
    }
    return lgammaStirling(z2).sub(shiftprod.log()).sub(new Complex2(0, signflips * 2 * Math.PI * 1));
  }
});
// ../../node_modules/mathjs/lib/esm/function/probability/factorial.js
var name262 = "factorial";
var dependencies262 = ["typed", "gamma"];
var createFactorial = factory(name262, dependencies262, (_ref) => {
  var {
    typed: typed2,
    gamma: gamma2
  } = _ref;
  return typed2(name262, {
    number: function number(n) {
      if (n < 0) {
        throw new Error("Value must be non-negative");
      }
      return gamma2(n + 1);
    },
    BigNumber: function BigNumber(n) {
      if (n.isNegative()) {
        throw new Error("Value must be non-negative");
      }
      return gamma2(n.plus(1));
    },
    "Array | Matrix": typed2.referToSelf((self2) => (n) => deepMap(n, self2))
  });
});
// ../../node_modules/mathjs/lib/esm/function/probability/kldivergence.js
var name263 = "kldivergence";
var dependencies263 = ["typed", "matrix", "divide", "sum", "multiply", "map", "dotDivide", "log", "isNumeric"];
var createKldivergence = factory(name263, dependencies263, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divide: divide3,
    sum: sum3,
    multiply: multiply2,
    map: map8,
    dotDivide: dotDivide2,
    log: log4,
    isNumeric: isNumeric2
  } = _ref;
  return typed2(name263, {
    "Array, Array": function ArrayArray(q, p) {
      return _kldiv(matrix2(q), matrix2(p));
    },
    "Matrix, Array": function MatrixArray(q, p) {
      return _kldiv(q, matrix2(p));
    },
    "Array, Matrix": function ArrayMatrix(q, p) {
      return _kldiv(matrix2(q), p);
    },
    "Matrix, Matrix": function MatrixMatrix(q, p) {
      return _kldiv(q, p);
    }
  });
  function _kldiv(q, p) {
    var plength = p.size().length;
    var qlength = q.size().length;
    if (plength > 1) {
      throw new Error("first object must be one dimensional");
    }
    if (qlength > 1) {
      throw new Error("second object must be one dimensional");
    }
    if (plength !== qlength) {
      throw new Error("Length of two vectors must be equal");
    }
    var sumq = sum3(q);
    if (sumq === 0) {
      throw new Error("Sum of elements in first object must be non zero");
    }
    var sump = sum3(p);
    if (sump === 0) {
      throw new Error("Sum of elements in second object must be non zero");
    }
    var qnorm = divide3(q, sum3(q));
    var pnorm = divide3(p, sum3(p));
    var result = sum3(multiply2(qnorm, map8(dotDivide2(qnorm, pnorm), (x) => log4(x))));
    if (isNumeric2(result)) {
      return result;
    } else {
      return Number.NaN;
    }
  }
});
// ../../node_modules/mathjs/lib/esm/function/probability/multinomial.js
var name264 = "multinomial";
var dependencies264 = ["typed", "add", "divide", "multiply", "factorial", "isInteger", "isPositive"];
var createMultinomial = factory(name264, dependencies264, (_ref) => {
  var {
    typed: typed2,
    add: add3,
    divide: divide3,
    multiply: multiply2,
    factorial: factorial2,
    isInteger: isInteger3,
    isPositive: isPositive2
  } = _ref;
  return typed2(name264, {
    "Array | Matrix": function ArrayMatrix(a) {
      var sum3 = 0;
      var denom = 1;
      deepForEach(a, function(ai) {
        if (!isInteger3(ai) || !isPositive2(ai)) {
          throw new TypeError("Positive integer value expected in function multinomial");
        }
        sum3 = add3(sum3, ai);
        denom = multiply2(denom, factorial2(ai));
      });
      return divide3(factorial2(sum3), denom);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/probability/permutations.js
var isPositiveInteger3 = function(n) {
  return n.isInteger() && n.gte(0);
};
var name265 = "permutations";
var dependencies265 = ["typed", "factorial"];
var createPermutations = factory(name265, dependencies265, (_ref) => {
  var {
    typed: typed2,
    factorial: factorial2
  } = _ref;
  return typed2(name265, {
    "number | BigNumber": factorial2,
    "number, number": function numberNumber(n, k) {
      if (!isInteger(n) || n < 0) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (!isInteger(k) || k < 0) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (k > n) {
        throw new TypeError("second argument k must be less than or equal to first argument n");
      }
      return product2(n - k + 1, n);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
      var result, i2;
      if (!isPositiveInteger3(n) || !isPositiveInteger3(k)) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (k.gt(n)) {
        throw new TypeError("second argument k must be less than or equal to first argument n");
      }
      var one = n.mul(0).add(1);
      result = one;
      for (i2 = n.minus(k).plus(1);i2.lte(n); i2 = i2.plus(1)) {
        result = result.times(i2);
      }
      return result;
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/probability/util/seededRNG.js
var import_seedrandom = __toESM(require_seedrandom2(), 1);
function createRng(randomSeed) {
  var random3;
  function setSeed(seed) {
    random3 = seed === null ? singletonRandom : import_seedrandom.default(String(seed));
  }
  setSeed(randomSeed);
  function rng() {
    return random3();
  }
  return rng;
}
var singletonRandom = import_seedrandom.default(Date.now());

// ../../node_modules/mathjs/lib/esm/function/probability/pickRandom.js
var name266 = "pickRandom";
var dependencies266 = ["typed", "config", "?on"];
var createPickRandom = factory(name266, dependencies266, (_ref) => {
  var {
    typed: typed2,
    config: config7,
    on
  } = _ref;
  var rng = createRng(config7.randomSeed);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng = createRng(curr.randomSeed);
      }
    });
  }
  return typed2(name266, {
    "Array | Matrix": function ArrayMatrix(possibles) {
      return _pickRandom(possibles, {});
    },
    "Array | Matrix, Object": function ArrayMatrixObject(possibles, options) {
      return _pickRandom(possibles, options);
    },
    "Array | Matrix, number": function ArrayMatrixNumber(possibles, number99) {
      return _pickRandom(possibles, {
        number: number99
      });
    },
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(possibles, weights) {
      return _pickRandom(possibles, {
        weights
      });
    },
    "Array | Matrix, Array | Matrix, number": function ArrayMatrixArrayMatrixNumber(possibles, weights, number99) {
      return _pickRandom(possibles, {
        number: number99,
        weights
      });
    },
    "Array | Matrix, number, Array | Matrix": function ArrayMatrixNumberArrayMatrix(possibles, number99, weights) {
      return _pickRandom(possibles, {
        number: number99,
        weights
      });
    }
  });
  function _pickRandom(possibles, _ref2) {
    var {
      number: number99,
      weights,
      elementWise = true
    } = _ref2;
    var single = typeof number99 === "undefined";
    if (single) {
      number99 = 1;
    }
    var createMatrix2 = isMatrix(possibles) ? possibles.create : isMatrix(weights) ? weights.create : null;
    possibles = possibles.valueOf();
    if (weights) {
      weights = weights.valueOf();
    }
    if (elementWise === true) {
      possibles = flatten(possibles);
      weights = flatten(weights);
    }
    var totalWeights = 0;
    if (typeof weights !== "undefined") {
      if (weights.length !== possibles.length) {
        throw new Error("Weights must have the same length as possibles");
      }
      for (var i2 = 0, len = weights.length;i2 < len; i2++) {
        if (!isNumber(weights[i2]) || weights[i2] < 0) {
          throw new Error("Weights must be an array of positive numbers");
        }
        totalWeights += weights[i2];
      }
    }
    var length = possibles.length;
    var result = [];
    var pick;
    while (result.length < number99) {
      if (typeof weights === "undefined") {
        pick = possibles[Math.floor(rng() * length)];
      } else {
        var randKey = rng() * totalWeights;
        for (var _i = 0, _len = possibles.length;_i < _len; _i++) {
          randKey -= weights[_i];
          if (randKey < 0) {
            pick = possibles[_i];
            break;
          }
        }
      }
      result.push(pick);
    }
    return single ? result[0] : createMatrix2 ? createMatrix2(result) : result;
  }
});
// ../../node_modules/mathjs/lib/esm/function/probability/util/randomMatrix.js
function randomMatrix(size2, random3) {
  var data = [];
  size2 = size2.slice(0);
  if (size2.length > 1) {
    for (var i2 = 0, length = size2.shift();i2 < length; i2++) {
      data.push(randomMatrix(size2, random3));
    }
  } else {
    for (var _i = 0, _length = size2.shift();_i < _length; _i++) {
      data.push(random3());
    }
  }
  return data;
}

// ../../node_modules/mathjs/lib/esm/function/probability/random.js
var name267 = "random";
var dependencies267 = ["typed", "config", "?on"];
var createRandom = factory(name267, dependencies267, (_ref) => {
  var {
    typed: typed2,
    config: config7,
    on
  } = _ref;
  var rng = createRng(config7.randomSeed);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng = createRng(curr.randomSeed);
      }
    });
  }
  return typed2(name267, {
    "": () => _random(0, 1),
    number: (max3) => _random(0, max3),
    "number, number": (min3, max3) => _random(min3, max3),
    "Array | Matrix": (size2) => _randomMatrix(size2, 0, 1),
    "Array | Matrix, number": (size2, max3) => _randomMatrix(size2, 0, max3),
    "Array | Matrix, number, number": (size2, min3, max3) => _randomMatrix(size2, min3, max3)
  });
  function _randomMatrix(size2, min3, max3) {
    var res = randomMatrix(size2.valueOf(), () => _random(min3, max3));
    return isMatrix(size2) ? size2.create(res) : res;
  }
  function _random(min3, max3) {
    return min3 + rng() * (max3 - min3);
  }
});
// ../../node_modules/mathjs/lib/esm/function/probability/randomInt.js
var name268 = "randomInt";
var dependencies268 = ["typed", "config", "?on"];
var createRandomInt = factory(name268, dependencies268, (_ref) => {
  var {
    typed: typed2,
    config: config7,
    on
  } = _ref;
  var rng = createRng(config7.randomSeed);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng = createRng(curr.randomSeed);
      }
    });
  }
  return typed2(name268, {
    "": () => _randomInt(0, 1),
    number: (max3) => _randomInt(0, max3),
    "number, number": (min3, max3) => _randomInt(min3, max3),
    "Array | Matrix": (size2) => _randomIntMatrix(size2, 0, 1),
    "Array | Matrix, number": (size2, max3) => _randomIntMatrix(size2, 0, max3),
    "Array | Matrix, number, number": (size2, min3, max3) => _randomIntMatrix(size2, min3, max3)
  });
  function _randomIntMatrix(size2, min3, max3) {
    var res = randomMatrix(size2.valueOf(), () => _randomInt(min3, max3));
    return isMatrix(size2) ? size2.create(res) : res;
  }
  function _randomInt(min3, max3) {
    return Math.floor(min3 + rng() * (max3 - min3));
  }
});
// ../../node_modules/mathjs/lib/esm/function/combinatorics/stirlingS2.js
var name269 = "stirlingS2";
var dependencies269 = ["typed", "addScalar", "subtract", "multiplyScalar", "divideScalar", "pow", "factorial", "combinations", "isNegative", "isInteger", "number", "?bignumber", "larger"];
var createStirlingS2 = factory(name269, dependencies269, (_ref) => {
  var {
    typed: typed2,
    addScalar,
    subtract: subtract2,
    multiplyScalar,
    divideScalar,
    pow: pow3,
    factorial: factorial2,
    combinations: combinations3,
    isNegative: isNegative2,
    isInteger: isInteger3,
    number: number99,
    bignumber: bignumber2,
    larger: larger2
  } = _ref;
  var smallCache = [];
  var bigCache = [];
  return typed2(name269, {
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
      if (!isInteger3(n) || isNegative2(n) || !isInteger3(k) || isNegative2(k)) {
        throw new TypeError("Non-negative integer value expected in function stirlingS2");
      } else if (larger2(k, n)) {
        throw new TypeError("k must be less than or equal to n in function stirlingS2");
      }
      var big = !(isNumber(n) && isNumber(k));
      var cache = big ? bigCache : smallCache;
      var make = big ? bignumber2 : number99;
      var nn = number99(n);
      var nk = number99(k);
      if (cache[nn] && cache[nn].length > nk) {
        return cache[nn][nk];
      }
      for (var m = 0;m <= nn; ++m) {
        if (!cache[m]) {
          cache[m] = [m === 0 ? make(1) : make(0)];
        }
        if (m === 0)
          continue;
        var row2 = cache[m];
        var prev = cache[m - 1];
        for (var i2 = row2.length;i2 <= m && i2 <= nk; ++i2) {
          if (i2 === m) {
            row2[i2] = 1;
          } else {
            row2[i2] = addScalar(multiplyScalar(make(i2), prev[i2]), prev[i2 - 1]);
          }
        }
      }
      return cache[nn][nk];
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/combinatorics/bellNumbers.js
var name270 = "bellNumbers";
var dependencies270 = ["typed", "addScalar", "isNegative", "isInteger", "stirlingS2"];
var createBellNumbers = factory(name270, dependencies270, (_ref) => {
  var {
    typed: typed2,
    addScalar,
    isNegative: isNegative2,
    isInteger: isInteger3,
    stirlingS2: stirlingS22
  } = _ref;
  return typed2(name270, {
    "number | BigNumber": function numberBigNumber(n) {
      if (!isInteger3(n) || isNegative2(n)) {
        throw new TypeError("Non-negative integer value expected in function bellNumbers");
      }
      var result = 0;
      for (var i2 = 0;i2 <= n; i2++) {
        result = addScalar(result, stirlingS22(n, i2));
      }
      return result;
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/combinatorics/catalan.js
var name271 = "catalan";
var dependencies271 = ["typed", "addScalar", "divideScalar", "multiplyScalar", "combinations", "isNegative", "isInteger"];
var createCatalan = factory(name271, dependencies271, (_ref) => {
  var {
    typed: typed2,
    addScalar,
    divideScalar,
    multiplyScalar,
    combinations: combinations3,
    isNegative: isNegative2,
    isInteger: isInteger3
  } = _ref;
  return typed2(name271, {
    "number | BigNumber": function numberBigNumber(n) {
      if (!isInteger3(n) || isNegative2(n)) {
        throw new TypeError("Non-negative integer value expected in function catalan");
      }
      return divideScalar(combinations3(multiplyScalar(n, 2), n), addScalar(n, 1));
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/combinatorics/composition.js
var name272 = "composition";
var dependencies272 = ["typed", "addScalar", "combinations", "isNegative", "isPositive", "isInteger", "larger"];
var createComposition = factory(name272, dependencies272, (_ref) => {
  var {
    typed: typed2,
    addScalar,
    combinations: combinations3,
    isPositive: isPositive2,
    isNegative: isNegative2,
    isInteger: isInteger3,
    larger: larger2
  } = _ref;
  return typed2(name272, {
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
      if (!isInteger3(n) || !isPositive2(n) || !isInteger3(k) || !isPositive2(k)) {
        throw new TypeError("Positive integer value expected in function composition");
      } else if (larger2(k, n)) {
        throw new TypeError("k must be less than or equal to n in function composition");
      }
      return combinations3(addScalar(n, -1), addScalar(k, -1));
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/algebra/leafCount.js
var name273 = "leafCount";
var dependencies273 = ["parse", "typed"];
var createLeafCount = factory(name273, dependencies273, (_ref) => {
  var {
    parse,
    typed: typed2
  } = _ref;
  function countLeaves(node) {
    var count2 = 0;
    node.forEach((n) => {
      count2 += countLeaves(n);
    });
    return count2 || 1;
  }
  return typed2(name273, {
    Node: function Node(expr) {
      return countLeaves(expr);
    }
  });
});
// ../../node_modules/mathjs/lib/esm/function/algebra/simplify/wildcards.js
function isNumericNode(x) {
  return isConstantNode(x) || isOperatorNode(x) && x.isUnary() && isConstantNode(x.args[0]);
}
function isConstantExpression(x) {
  if (isConstantNode(x)) {
    return true;
  }
  if ((isFunctionNode(x) || isOperatorNode(x)) && x.args.every(isConstantExpression)) {
    return true;
  }
  if (isParenthesisNode(x) && isConstantExpression(x.content)) {
    return true;
  }
  return false;
}

// ../../node_modules/mathjs/lib/esm/function/algebra/simplify/util.js
var defineProperty16 = __toESM(require_defineProperty(), 1);
var ownKeys2 = function(object34, enumerableOnly) {
  var keys = Object.keys(object34);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object34);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object34, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
};
var _objectSpread2 = function(target) {
  for (var i2 = 1;i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      defineProperty16.default(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
};
var name274 = "simplifyUtil";
var dependencies274 = ["FunctionNode", "OperatorNode", "SymbolNode"];
var createUtil = factory(name274, dependencies274, (_ref) => {
  var {
    FunctionNode,
    OperatorNode,
    SymbolNode
  } = _ref;
  var T = true;
  var F = false;
  var defaultName = "defaultF";
  var defaultContext = {
    add: {
      trivial: T,
      total: T,
      commutative: T,
      associative: T
    },
    unaryPlus: {
      trivial: T,
      total: T,
      commutative: T,
      associative: T
    },
    subtract: {
      trivial: F,
      total: T,
      commutative: F,
      associative: F
    },
    multiply: {
      trivial: T,
      total: T,
      commutative: T,
      associative: T
    },
    divide: {
      trivial: F,
      total: T,
      commutative: F,
      associative: F
    },
    paren: {
      trivial: T,
      total: T,
      commutative: T,
      associative: F
    },
    defaultF: {
      trivial: F,
      total: T,
      commutative: F,
      associative: F
    }
  };
  var realContext = {
    divide: {
      total: F
    },
    log: {
      total: F
    }
  };
  var positiveContext = {
    subtract: {
      total: F
    },
    abs: {
      trivial: T
    },
    log: {
      total: T
    }
  };
  function hasProperty(nodeOrName, property) {
    var context2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultContext;
    var name275 = defaultName;
    if (typeof nodeOrName === "string") {
      name275 = nodeOrName;
    } else if (isOperatorNode(nodeOrName)) {
      name275 = nodeOrName.fn.toString();
    } else if (isFunctionNode(nodeOrName)) {
      name275 = nodeOrName.name;
    } else if (isParenthesisNode(nodeOrName)) {
      name275 = "paren";
    }
    if (hasOwnProperty2(context2, name275)) {
      var properties2 = context2[name275];
      if (hasOwnProperty2(properties2, property)) {
        return properties2[property];
      }
      if (hasOwnProperty2(defaultContext, name275)) {
        return defaultContext[name275][property];
      }
    }
    if (hasOwnProperty2(context2, defaultName)) {
      var _properties = context2[defaultName];
      if (hasOwnProperty2(_properties, property)) {
        return _properties[property];
      }
      return defaultContext[defaultName][property];
    }
    if (hasOwnProperty2(defaultContext, name275)) {
      var _properties2 = defaultContext[name275];
      if (hasOwnProperty2(_properties2, property)) {
        return _properties2[property];
      }
    }
    return defaultContext[defaultName][property];
  }
  function isCommutative(node) {
    var context2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;
    return hasProperty(node, "commutative", context2);
  }
  function isAssociative(node) {
    var context2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;
    return hasProperty(node, "associative", context2);
  }
  function mergeContext(primary, secondary) {
    var merged = _objectSpread2({}, primary);
    for (var prop in secondary) {
      if (hasOwnProperty2(primary, prop)) {
        merged[prop] = _objectSpread2(_objectSpread2({}, secondary[prop]), primary[prop]);
      } else {
        merged[prop] = secondary[prop];
      }
    }
    return merged;
  }
  function flatten3(node, context2) {
    if (!node.args || node.args.length === 0) {
      return node;
    }
    node.args = allChildren(node, context2);
    for (var i2 = 0;i2 < node.args.length; i2++) {
      flatten3(node.args[i2], context2);
    }
  }
  function allChildren(node, context2) {
    var op;
    var children = [];
    var findChildren = function findChildren(node2) {
      for (var i2 = 0;i2 < node2.args.length; i2++) {
        var child = node2.args[i2];
        if (isOperatorNode(child) && op === child.op) {
          findChildren(child);
        } else {
          children.push(child);
        }
      }
    };
    if (isAssociative(node, context2)) {
      op = node.op;
      findChildren(node);
      return children;
    } else {
      return node.args;
    }
  }
  function unflattenr(node, context2) {
    if (!node.args || node.args.length === 0) {
      return;
    }
    var makeNode = createMakeNodeFunction(node);
    var l = node.args.length;
    for (var i2 = 0;i2 < l; i2++) {
      unflattenr(node.args[i2], context2);
    }
    if (l > 2 && isAssociative(node, context2)) {
      var curnode = node.args.pop();
      while (node.args.length > 0) {
        curnode = makeNode([node.args.pop(), curnode]);
      }
      node.args = curnode.args;
    }
  }
  function unflattenl(node, context2) {
    if (!node.args || node.args.length === 0) {
      return;
    }
    var makeNode = createMakeNodeFunction(node);
    var l = node.args.length;
    for (var i2 = 0;i2 < l; i2++) {
      unflattenl(node.args[i2], context2);
    }
    if (l > 2 && isAssociative(node, context2)) {
      var curnode = node.args.shift();
      while (node.args.length > 0) {
        curnode = makeNode([curnode, node.args.shift()]);
      }
      node.args = curnode.args;
    }
  }
  function createMakeNodeFunction(node) {
    if (isOperatorNode(node)) {
      return function(args) {
        try {
          return new OperatorNode(node.op, node.fn, args, node.implicit);
        } catch (err) {
          console.error(err);
          return [];
        }
      };
    } else {
      return function(args) {
        return new FunctionNode(new SymbolNode(node.name), args);
      };
    }
  }
  return {
    createMakeNodeFunction,
    hasProperty,
    isCommutative,
    isAssociative,
    mergeContext,
    flatten: flatten3,
    allChildren,
    unflattenr,
    unflattenl,
    defaultContext,
    realContext,
    positiveContext
  };
});

// ../../node_modules/mathjs/lib/esm/function/algebra/simplify.js
var name275 = "simplify";
var dependencies275 = ["config", "typed", "parse", "add", "subtract", "multiply", "divide", "pow", "isZero", "equal", "resolve", "simplifyConstant", "simplifyCore", "?fraction", "?bignumber", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createSimplify = factory(name275, dependencies275, (_ref) => {
  var {
    config: config7,
    typed: typed2,
    parse,
    add: add3,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide3,
    pow: pow3,
    isZero: isZero2,
    equal: equal2,
    resolve: resolve3,
    simplifyConstant: simplifyConstant2,
    simplifyCore: simplifyCore2,
    fraction: fraction2,
    bignumber: bignumber2,
    mathWithTransform,
    matrix: matrix2,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    ParenthesisNode,
    SymbolNode
  } = _ref;
  var {
    hasProperty,
    isCommutative,
    isAssociative,
    mergeContext,
    flatten: flatten3,
    unflattenr,
    unflattenl,
    createMakeNodeFunction,
    defaultContext,
    realContext,
    positiveContext
  } = createUtil({
    FunctionNode,
    OperatorNode,
    SymbolNode
  });
  typed2.addConversion({
    from: "Object",
    to: "Map",
    convert: createMap
  });
  var simplify2 = typed2("simplify", {
    Node: _simplify,
    "Node, Map": (expr, scope2) => _simplify(expr, false, scope2),
    "Node, Map, Object": (expr, scope2, options) => _simplify(expr, false, scope2, options),
    "Node, Array": _simplify,
    "Node, Array, Map": _simplify,
    "Node, Array, Map, Object": _simplify
  });
  typed2.removeConversion({
    from: "Object",
    to: "Map",
    convert: createMap
  });
  simplify2.defaultContext = defaultContext;
  simplify2.realContext = realContext;
  simplify2.positiveContext = positiveContext;
  function removeParens(node) {
    return node.transform(function(node2, path, parent) {
      return isParenthesisNode(node2) ? removeParens(node2.content) : node2;
    });
  }
  var SUPPORTED_CONSTANTS = {
    true: true,
    false: true,
    e: true,
    i: true,
    Infinity: true,
    LN2: true,
    LN10: true,
    LOG2E: true,
    LOG10E: true,
    NaN: true,
    phi: true,
    pi: true,
    SQRT1_2: true,
    SQRT2: true,
    tau: true
  };
  simplify2.rules = [
    simplifyCore2,
    {
      l: "log(e)",
      r: "1"
    },
    {
      s: "n-n1 -> n+-n1",
      assuming: {
        subtract: {
          total: true
        }
      }
    },
    {
      s: "n-n -> 0",
      assuming: {
        subtract: {
          total: false
        }
      }
    },
    {
      s: "-(cl*v) -> v * (-cl)",
      assuming: {
        multiply: {
          commutative: true
        },
        subtract: {
          total: true
        }
      }
    },
    {
      s: "-(cl*v) -> (-cl) * v",
      assuming: {
        multiply: {
          commutative: false
        },
        subtract: {
          total: true
        }
      }
    },
    {
      s: "-(v*cl) -> v * (-cl)",
      assuming: {
        multiply: {
          commutative: false
        },
        subtract: {
          total: true
        }
      }
    },
    {
      l: "-(n1/n2)",
      r: "-n1/n2"
    },
    {
      l: "-v",
      r: "v * (-1)"
    },
    {
      l: "(n1 + n2)*(-1)",
      r: "n1*(-1) + n2*(-1)",
      repeat: true
    },
    {
      l: "n/n1^n2",
      r: "n*n1^-n2"
    },
    {
      l: "n/n1",
      r: "n*n1^-1"
    },
    {
      s: "(n1*n2)^n3 -> n1^n3 * n2^n3",
      assuming: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "(n ^ n1) ^ n2 -> n ^ (n1 * n2)",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      l: " vd   * ( vd   * n1 + n2)",
      r: "vd^2       * n1 +  vd   * n2"
    },
    {
      s: " vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      s: "vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      s: "vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      l: "n*n",
      r: "n^2"
    },
    {
      s: "n * n^n1 -> n^(n1+1)",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      s: "n^n1 * n^n2 -> n^(n1+n2)",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    simplifyConstant2,
    {
      s: "n+n -> 2*n",
      assuming: {
        add: {
          total: true
        }
      }
    },
    {
      l: "n+-n",
      r: "0"
    },
    {
      l: "vd*n + vd",
      r: "vd*(n+1)"
    },
    {
      l: "n3*n1 + n3*n2",
      r: "n3*(n1+n2)"
    },
    {
      l: "n3^(-n4)*n1 +   n3  * n2",
      r: "n3^(-n4)*(n1 + n3^(n4+1) *n2)"
    },
    {
      l: "n3^(-n4)*n1 + n3^n5 * n2",
      r: "n3^(-n4)*(n1 + n3^(n4+n5)*n2)"
    },
    {
      s: "n*vd + vd -> (n+1)*vd",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "vd + n*vd -> (1+n)*vd",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3 + n2*n3 -> (n1+n2)*n3",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n^n1 * n -> n^(n1+1)",
      assuming: {
        divide: {
          total: true
        },
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      l: "n*cd + cd",
      r: "(n+1)*cd"
    },
    {
      s: "cd*n + cd -> cd*(n+1)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "cd + cd*n -> cd*(1+n)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    simplifyConstant2,
    {
      s: "(-n)*n1 -> -(n*n1)",
      assuming: {
        subtract: {
          total: true
        }
      }
    },
    {
      s: "n1*(-n) -> -(n1*n)",
      assuming: {
        subtract: {
          total: true
        },
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "ce+ve -> ve+ce",
      assuming: {
        add: {
          commutative: true
        }
      },
      imposeContext: {
        add: {
          commutative: false
        }
      }
    },
    {
      s: "vd*cd -> cd*vd",
      assuming: {
        multiply: {
          commutative: true
        }
      },
      imposeContext: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      l: "n+-n1",
      r: "n-n1"
    },
    {
      s: "n*(n1^-1) -> n/n1",
      assuming: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "n*n1^-n2 -> n/n1^n2",
      assuming: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "n^-1 -> 1/n",
      assuming: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      l: "n^1",
      r: "n"
    },
    {
      s: "n*(n1/n2) -> (n*n1)/n2",
      assuming: {
        multiply: {
          associative: true
        }
      }
    },
    {
      s: "n-(n1+n2) -> n-n1-n2",
      assuming: {
        addition: {
          associative: true,
          commutative: true
        }
      }
    },
    {
      l: "1*n",
      r: "n",
      imposeContext: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "n1/(n2/n3) -> (n1*n3)/n2",
      assuming: {
        multiply: {
          associative: true
        }
      }
    },
    {
      l: "n1/(-n2)",
      r: "-n1/n2"
    }
  ];
  function _canonicalizeRule(ruleObject, context2) {
    var newRule = {};
    if (ruleObject.s) {
      var lr = ruleObject.s.split("->");
      if (lr.length === 2) {
        newRule.l = lr[0];
        newRule.r = lr[1];
      } else {
        throw SyntaxError("Could not parse rule: " + ruleObject.s);
      }
    } else {
      newRule.l = ruleObject.l;
      newRule.r = ruleObject.r;
    }
    newRule.l = removeParens(parse(newRule.l));
    newRule.r = removeParens(parse(newRule.r));
    for (var prop of ["imposeContext", "repeat", "assuming"]) {
      if (prop in ruleObject) {
        newRule[prop] = ruleObject[prop];
      }
    }
    if (ruleObject.evaluate) {
      newRule.evaluate = parse(ruleObject.evaluate);
    }
    if (isAssociative(newRule.l, context2)) {
      var nonCommutative = !isCommutative(newRule.l, context2);
      var leftExpandsym;
      if (nonCommutative)
        leftExpandsym = _getExpandPlaceholderSymbol();
      var makeNode = createMakeNodeFunction(newRule.l);
      var expandsym = _getExpandPlaceholderSymbol();
      newRule.expanded = {};
      newRule.expanded.l = makeNode([newRule.l, expandsym]);
      flatten3(newRule.expanded.l, context2);
      unflattenr(newRule.expanded.l, context2);
      newRule.expanded.r = makeNode([newRule.r, expandsym]);
      if (nonCommutative) {
        newRule.expandedNC1 = {};
        newRule.expandedNC1.l = makeNode([leftExpandsym, newRule.l]);
        newRule.expandedNC1.r = makeNode([leftExpandsym, newRule.r]);
        newRule.expandedNC2 = {};
        newRule.expandedNC2.l = makeNode([leftExpandsym, newRule.expanded.l]);
        newRule.expandedNC2.r = makeNode([leftExpandsym, newRule.expanded.r]);
      }
    }
    return newRule;
  }
  function _buildRules(rules, context2) {
    var ruleSet = [];
    for (var i2 = 0;i2 < rules.length; i2++) {
      var rule = rules[i2];
      var newRule = undefined;
      var ruleType = typeof rule;
      switch (ruleType) {
        case "string":
          rule = {
            s: rule
          };
        case "object":
          newRule = _canonicalizeRule(rule, context2);
          break;
        case "function":
          newRule = rule;
          break;
        default:
          throw TypeError("Unsupported type of rule: " + ruleType);
      }
      ruleSet.push(newRule);
    }
    return ruleSet;
  }
  var _lastsym = 0;
  function _getExpandPlaceholderSymbol() {
    return new SymbolNode("_p" + _lastsym++);
  }
  function _simplify(expr, rules) {
    var scope2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : createEmptyMap();
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var debug = options.consoleDebug;
    rules = _buildRules(rules || simplify2.rules, options.context);
    var res = resolve3(expr, scope2);
    res = removeParens(res);
    var visited = {};
    var str = res.toString({
      parenthesis: "all"
    });
    while (!visited[str]) {
      visited[str] = true;
      _lastsym = 0;
      var laststr = str;
      if (debug)
        console.log("Working on: ", str);
      for (var i2 = 0;i2 < rules.length; i2++) {
        var rulestr = "";
        if (typeof rules[i2] === "function") {
          res = rules[i2](res, options);
          if (debug)
            rulestr = rules[i2].name;
        } else {
          flatten3(res, options.context);
          res = applyRule(res, rules[i2], options.context);
          if (debug) {
            rulestr = "".concat(rules[i2].l.toString(), " -> ").concat(rules[i2].r.toString());
          }
        }
        if (debug) {
          var newstr = res.toString({
            parenthesis: "all"
          });
          if (newstr !== laststr) {
            console.log("Applying", rulestr, "produced", newstr);
            laststr = newstr;
          }
        }
        unflattenl(res, options.context);
      }
      str = res.toString({
        parenthesis: "all"
      });
    }
    return res;
  }
  function mapRule(nodes, rule, context2) {
    var resNodes = nodes;
    if (nodes) {
      for (var i2 = 0;i2 < nodes.length; ++i2) {
        var newNode = applyRule(nodes[i2], rule, context2);
        if (newNode !== nodes[i2]) {
          if (resNodes === nodes) {
            resNodes = nodes.slice();
          }
          resNodes[i2] = newNode;
        }
      }
    }
    return resNodes;
  }
  function applyRule(node, rule, context2) {
    if (rule.assuming) {
      for (var symbol in rule.assuming) {
        for (var property in rule.assuming[symbol]) {
          if (hasProperty(symbol, property, context2) !== rule.assuming[symbol][property]) {
            return node;
          }
        }
      }
    }
    var mergedContext = mergeContext(rule.imposeContext, context2);
    var res = node;
    if (res instanceof OperatorNode || res instanceof FunctionNode) {
      var newArgs = mapRule(res.args, rule, context2);
      if (newArgs !== res.args) {
        res = res.clone();
        res.args = newArgs;
      }
    } else if (res instanceof ParenthesisNode) {
      if (res.content) {
        var newContent = applyRule(res.content, rule, context2);
        if (newContent !== res.content) {
          res = new ParenthesisNode(newContent);
        }
      }
    } else if (res instanceof ArrayNode) {
      var newItems = mapRule(res.items, rule, context2);
      if (newItems !== res.items) {
        res = new ArrayNode(newItems);
      }
    } else if (res instanceof AccessorNode) {
      var newObj = res.object;
      if (res.object) {
        newObj = applyRule(res.object, rule, context2);
      }
      var newIndex = res.index;
      if (res.index) {
        newIndex = applyRule(res.index, rule, context2);
      }
      if (newObj !== res.object || newIndex !== res.index) {
        res = new AccessorNode(newObj, newIndex);
      }
    } else if (res instanceof IndexNode) {
      var newDims = mapRule(res.dimensions, rule, context2);
      if (newDims !== res.dimensions) {
        res = new IndexNode(newDims);
      }
    } else if (res instanceof ObjectNode) {
      var changed = false;
      var newProps = {};
      for (var prop in res.properties) {
        newProps[prop] = applyRule(res.properties[prop], rule, context2);
        if (newProps[prop] !== res.properties[prop]) {
          changed = true;
        }
      }
      if (changed) {
        res = new ObjectNode(newProps);
      }
    }
    var repl = rule.r;
    var matches = _ruleMatch(rule.l, res, mergedContext)[0];
    if (!matches && rule.expanded) {
      repl = rule.expanded.r;
      matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];
    }
    if (!matches && rule.expandedNC1) {
      repl = rule.expandedNC1.r;
      matches = _ruleMatch(rule.expandedNC1.l, res, mergedContext)[0];
      if (!matches) {
        repl = rule.expandedNC2.r;
        matches = _ruleMatch(rule.expandedNC2.l, res, mergedContext)[0];
      }
    }
    if (matches) {
      var implicit = res.implicit;
      res = repl.clone();
      if (implicit && "implicit" in repl) {
        res.implicit = true;
      }
      res = res.transform(function(node2) {
        if (node2.isSymbolNode && hasOwnProperty2(matches.placeholders, node2.name)) {
          return matches.placeholders[node2.name].clone();
        } else {
          return node2;
        }
      });
    }
    if (rule.repeat && res !== node) {
      res = applyRule(res, rule, context2);
    }
    return res;
  }
  function getSplits(node, context2) {
    var res = [];
    var right, rightArgs;
    var makeNode = createMakeNodeFunction(node);
    if (isCommutative(node, context2)) {
      for (var i2 = 0;i2 < node.args.length; i2++) {
        rightArgs = node.args.slice(0);
        rightArgs.splice(i2, 1);
        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
        res.push(makeNode([node.args[i2], right]));
      }
    } else {
      for (var _i = 1;_i < node.args.length; _i++) {
        var left = node.args[0];
        if (_i > 1) {
          left = makeNode(node.args.slice(0, _i));
        }
        rightArgs = node.args.slice(_i);
        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
        res.push(makeNode([left, right]));
      }
    }
    return res;
  }
  function mergeMatch(match1, match2) {
    var res = {
      placeholders: {}
    };
    if (!match1.placeholders && !match2.placeholders) {
      return res;
    } else if (!match1.placeholders) {
      return match2;
    } else if (!match2.placeholders) {
      return match1;
    }
    for (var key in match1.placeholders) {
      if (hasOwnProperty2(match1.placeholders, key)) {
        res.placeholders[key] = match1.placeholders[key];
        if (hasOwnProperty2(match2.placeholders, key)) {
          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {
            return null;
          }
        }
      }
    }
    for (var _key in match2.placeholders) {
      if (hasOwnProperty2(match2.placeholders, _key)) {
        res.placeholders[_key] = match2.placeholders[_key];
      }
    }
    return res;
  }
  function combineChildMatches(list1, list2) {
    var res = [];
    if (list1.length === 0 || list2.length === 0) {
      return res;
    }
    var merged;
    for (var i1 = 0;i1 < list1.length; i1++) {
      for (var i2 = 0;i2 < list2.length; i2++) {
        merged = mergeMatch(list1[i1], list2[i2]);
        if (merged) {
          res.push(merged);
        }
      }
    }
    return res;
  }
  function mergeChildMatches(childMatches) {
    if (childMatches.length === 0) {
      return childMatches;
    }
    var sets = childMatches.reduce(combineChildMatches);
    var uniqueSets = [];
    var unique = {};
    for (var i2 = 0;i2 < sets.length; i2++) {
      var s = JSON.stringify(sets[i2]);
      if (!unique[s]) {
        unique[s] = true;
        uniqueSets.push(sets[i2]);
      }
    }
    return uniqueSets;
  }
  function _ruleMatch(rule, node, context2, isSplit) {
    var res = [{
      placeholders: {}
    }];
    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {
      if (rule instanceof OperatorNode) {
        if (rule.op !== node.op || rule.fn !== node.fn) {
          return [];
        }
      } else if (rule instanceof FunctionNode) {
        if (rule.name !== node.name) {
          return [];
        }
      }
      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context2) && node.args.length === rule.args.length || isSplit) {
        var childMatches = [];
        for (var i2 = 0;i2 < rule.args.length; i2++) {
          var childMatch = _ruleMatch(rule.args[i2], node.args[i2], context2);
          if (childMatch.length === 0) {
            break;
          }
          childMatches.push(childMatch);
        }
        if (childMatches.length !== rule.args.length) {
          if (!isCommutative(node, context2) || rule.args.length === 1) {
            return [];
          }
          if (rule.args.length > 2) {
            throw new Error("permuting >2 commutative non-associative rule arguments not yet implemented");
          }
          var leftMatch = _ruleMatch(rule.args[0], node.args[1], context2);
          if (leftMatch.length === 0) {
            return [];
          }
          var rightMatch = _ruleMatch(rule.args[1], node.args[0], context2);
          if (rightMatch.length === 0) {
            return [];
          }
          childMatches = [leftMatch, rightMatch];
        }
        res = mergeChildMatches(childMatches);
      } else if (node.args.length >= 2 && rule.args.length === 2) {
        var splits = getSplits(node, context2);
        var splitMatches = [];
        for (var _i2 = 0;_i2 < splits.length; _i2++) {
          var matchSet = _ruleMatch(rule, splits[_i2], context2, true);
          splitMatches = splitMatches.concat(matchSet);
        }
        return splitMatches;
      } else if (rule.args.length > 2) {
        throw Error("Unexpected non-binary associative function: " + rule.toString());
      } else {
        return [];
      }
    } else if (rule instanceof SymbolNode) {
      if (rule.name.length === 0) {
        throw new Error("Symbol in rule has 0 length...!?");
      }
      if (SUPPORTED_CONSTANTS[rule.name]) {
        if (rule.name !== node.name) {
          return [];
        }
      } else {
        switch (rule.name[1] >= "a" && rule.name[1] <= "z" ? rule.name.substring(0, 2) : rule.name[0]) {
          case "n":
          case "_p":
            res[0].placeholders[rule.name] = node;
            break;
          case "c":
          case "cl":
            if (isConstantNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "v":
            if (!isConstantNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "vl":
            if (isSymbolNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "cd":
            if (isNumericNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "vd":
            if (!isNumericNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "ce":
            if (isConstantExpression(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "ve":
            if (!isConstantExpression(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          default:
            throw new Error("Invalid symbol in rule: " + rule.name);
        }
      }
    } else if (rule instanceof ConstantNode) {
      if (!equal2(rule.value, node.value)) {
        return [];
      }
    } else {
      return [];
    }
    return res;
  }
  function _exactMatch(p, q) {
    if (p instanceof ConstantNode && q instanceof ConstantNode) {
      if (!equal2(p.value, q.value)) {
        return false;
      }
    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {
      if (p.name !== q.name) {
        return false;
      }
    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {
      if (p instanceof OperatorNode) {
        if (p.op !== q.op || p.fn !== q.fn) {
          return false;
        }
      } else if (p instanceof FunctionNode) {
        if (p.name !== q.name) {
          return false;
        }
      }
      if (p.args.length !== q.args.length) {
        return false;
      }
      for (var i2 = 0;i2 < p.args.length; i2++) {
        if (!_exactMatch(p.args[i2], q.args[i2])) {
          return false;
        }
      }
    } else {
      return false;
    }
    return true;
  }
  return simplify2;
});
// ../../node_modules/mathjs/lib/esm/function/algebra/simplifyConstant.js
var name276 = "simplifyConstant";
var dependencies276 = ["typed", "config", "mathWithTransform", "matrix", "?fraction", "?bignumber", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode"];
var createSimplifyConstant = factory(name276, dependencies276, (_ref) => {
  var {
    typed: typed2,
    config: config7,
    mathWithTransform,
    matrix: matrix2,
    fraction: fraction2,
    bignumber: bignumber2,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    SymbolNode
  } = _ref;
  var {
    isCommutative,
    isAssociative,
    allChildren,
    createMakeNodeFunction
  } = createUtil({
    FunctionNode,
    OperatorNode,
    SymbolNode
  });
  var simplifyConstant2 = typed2("simplifyConstant", {
    Node: (node) => _ensureNode(foldFraction(node, {})),
    "Node, Object": function NodeObject(expr, options) {
      return _ensureNode(foldFraction(expr, options));
    }
  });
  function _removeFractions(thing) {
    if (isFraction(thing)) {
      return thing.valueOf();
    }
    if (thing instanceof Array) {
      return thing.map(_removeFractions);
    }
    if (isMatrix(thing)) {
      return matrix2(_removeFractions(thing.valueOf()));
    }
    return thing;
  }
  function _eval(fnname, args, options) {
    try {
      return mathWithTransform[fnname].apply(null, args);
    } catch (ignore) {
      args = args.map(_removeFractions);
      return _toNumber(mathWithTransform[fnname].apply(null, args), options);
    }
  }
  var _toNode = typed2({
    Fraction: _fractionToNode,
    number: function number(n) {
      if (n < 0) {
        return unaryMinusNode(new ConstantNode(-n));
      }
      return new ConstantNode(n);
    },
    BigNumber: function BigNumber(n) {
      if (n < 0) {
        return unaryMinusNode(new ConstantNode(-n));
      }
      return new ConstantNode(n);
    },
    Complex: function Complex(s) {
      throw new Error("Cannot convert Complex number to Node");
    },
    string: function string(s) {
      return new ConstantNode(s);
    },
    Matrix: function Matrix(m) {
      return new ArrayNode(m.valueOf().map((e3) => _toNode(e3)));
    }
  });
  function _ensureNode(thing) {
    if (isNode(thing)) {
      return thing;
    }
    return _toNode(thing);
  }
  function _exactFraction(n, options) {
    var exactFractions = options && options.exactFractions !== false;
    if (exactFractions && isFinite(n) && fraction2) {
      var f = fraction2(n);
      var fractionsLimit = options && typeof options.fractionsLimit === "number" ? options.fractionsLimit : Infinity;
      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {
        return f;
      }
    }
    return n;
  }
  var _toNumber = typed2({
    "string, Object": function stringObject(s, options) {
      if (config7.number === "BigNumber") {
        if (bignumber2 === undefined) {
          noBignumber();
        }
        return bignumber2(s);
      } else if (config7.number === "Fraction") {
        if (fraction2 === undefined) {
          noFraction();
        }
        return fraction2(s);
      } else {
        var n = parseFloat(s);
        return _exactFraction(n, options);
      }
    },
    "Fraction, Object": function FractionObject(s, options) {
      return s;
    },
    "BigNumber, Object": function BigNumberObject(s, options) {
      return s;
    },
    "number, Object": function numberObject(s, options) {
      return _exactFraction(s, options);
    },
    "Complex, Object": function ComplexObject(s, options) {
      if (s.im !== 0) {
        return s;
      }
      return _exactFraction(s.re, options);
    },
    "Matrix, Object": function MatrixObject(s, options) {
      return matrix2(_exactFraction(s.valueOf()));
    },
    "Array, Object": function ArrayObject(s, options) {
      return s.map(_exactFraction);
    }
  });
  function unaryMinusNode(n) {
    return new OperatorNode("-", "unaryMinus", [n]);
  }
  function _fractionToNode(f) {
    var n;
    var vn = f.s * f.n;
    if (vn < 0) {
      n = new OperatorNode("-", "unaryMinus", [new ConstantNode(-vn)]);
    } else {
      n = new ConstantNode(vn);
    }
    if (f.d === 1) {
      return n;
    }
    return new OperatorNode("/", "divide", [n, new ConstantNode(f.d)]);
  }
  function _foldAccessor(obj, index, options) {
    if (!isIndexNode(index)) {
      return new AccessorNode(_ensureNode(obj), _ensureNode(index));
    }
    if (isArrayNode(obj) || isMatrix(obj)) {
      var remainingDims = Array.from(index.dimensions);
      while (remainingDims.length > 0) {
        if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== "string") {
          var first = _toNumber(remainingDims.shift().value, options);
          if (isArrayNode(obj)) {
            obj = obj.items[first - 1];
          } else {
            obj = obj.valueOf()[first - 1];
            if (obj instanceof Array) {
              obj = matrix2(obj);
            }
          }
        } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== "string") {
          var second = _toNumber(remainingDims[1].value, options);
          var tryItems = [];
          var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();
          for (var item of fromItems) {
            if (isArrayNode(item)) {
              tryItems.push(item.items[second - 1]);
            } else if (isMatrix(obj)) {
              tryItems.push(item[second - 1]);
            } else {
              break;
            }
          }
          if (tryItems.length === fromItems.length) {
            if (isArrayNode(obj)) {
              obj = new ArrayNode(tryItems);
            } else {
              obj = matrix2(tryItems);
            }
            remainingDims.splice(1, 1);
          } else {
            break;
          }
        } else {
          break;
        }
      }
      if (remainingDims.length === index.dimensions.length) {
        return new AccessorNode(_ensureNode(obj), index);
      }
      if (remainingDims.length > 0) {
        index = new IndexNode(remainingDims);
        return new AccessorNode(_ensureNode(obj), index);
      }
      return obj;
    }
    if (isObjectNode(obj) && index.dimensions.length === 1 && isConstantNode(index.dimensions[0])) {
      var key = index.dimensions[0].value;
      if (key in obj.properties) {
        return obj.properties[key];
      }
      return new ConstantNode;
    }
    return new AccessorNode(_ensureNode(obj), index);
  }
  function foldOp(fn, args, makeNode, options) {
    var first = args.shift();
    var reduction = args.reduce((sofar, next) => {
      if (!isNode(next)) {
        var last = sofar.pop();
        if (isNode(last)) {
          return [last, next];
        }
        try {
          sofar.push(_eval(fn, [last, next], options));
          return sofar;
        } catch (ignoreandcontinue) {
          sofar.push(last);
        }
      }
      sofar.push(_ensureNode(sofar.pop()));
      var newtree = sofar.length === 1 ? sofar[0] : makeNode(sofar);
      return [makeNode([newtree, _ensureNode(next)])];
    }, [first]);
    if (reduction.length === 1) {
      return reduction[0];
    }
    return makeNode([reduction[0], _toNode(reduction[1])]);
  }
  function foldFraction(node, options) {
    switch (node.type) {
      case "SymbolNode":
        return node;
      case "ConstantNode":
        switch (typeof node.value) {
          case "number":
            return _toNumber(node.value, options);
          case "string":
            return node.value;
          default:
            if (!isNaN(node.value))
              return _toNumber(node.value, options);
        }
        return node;
      case "FunctionNode":
        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {
          return node;
        }
        {
          var operatorFunctions = ["add", "multiply"];
          if (operatorFunctions.indexOf(node.name) === -1) {
            var args = node.args.map((arg2) => foldFraction(arg2, options));
            if (!args.some(isNode)) {
              try {
                return _eval(node.name, args, options);
              } catch (ignoreandcontinue) {
              }
            }
            if (node.name === "size" && args.length === 1 && isArrayNode(args[0])) {
              var sz = [];
              var section = args[0];
              while (isArrayNode(section)) {
                sz.push(section.items.length);
                section = section.items[0];
              }
              return matrix2(sz);
            }
            return new FunctionNode(node.name, args.map(_ensureNode));
          } else {
          }
        }
      case "OperatorNode": {
        var fn = node.fn.toString();
        var _args;
        var res;
        var makeNode = createMakeNodeFunction(node);
        if (isOperatorNode(node) && node.isUnary()) {
          _args = [foldFraction(node.args[0], options)];
          if (!isNode(_args[0])) {
            res = _eval(fn, _args, options);
          } else {
            res = makeNode(_args);
          }
        } else if (isAssociative(node, options.context)) {
          _args = allChildren(node, options.context);
          _args = _args.map((arg2) => foldFraction(arg2, options));
          if (isCommutative(fn, options.context)) {
            var consts = [];
            var vars = [];
            for (var i2 = 0;i2 < _args.length; i2++) {
              if (!isNode(_args[i2])) {
                consts.push(_args[i2]);
              } else {
                vars.push(_args[i2]);
              }
            }
            if (consts.length > 1) {
              res = foldOp(fn, consts, makeNode, options);
              vars.unshift(res);
              res = foldOp(fn, vars, makeNode, options);
            } else {
              res = foldOp(fn, _args, makeNode, options);
            }
          } else {
            res = foldOp(fn, _args, makeNode, options);
          }
        } else {
          _args = node.args.map((arg2) => foldFraction(arg2, options));
          res = foldOp(fn, _args, makeNode, options);
        }
        return res;
      }
      case "ParenthesisNode":
        return foldFraction(node.content, options);
      case "AccessorNode":
        return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);
      case "ArrayNode": {
        var foldItems = node.items.map((item) => foldFraction(item, options));
        if (foldItems.some(isNode)) {
          return new ArrayNode(foldItems.map(_ensureNode));
        }
        return matrix2(foldItems);
      }
      case "IndexNode": {
        return new IndexNode(node.dimensions.map((n) => simplifyConstant2(n, options)));
      }
      case "ObjectNode": {
        var foldProps = {};
        for (var prop in node.properties) {
          foldProps[prop] = simplifyConstant2(node.properties[prop], options);
        }
        return new ObjectNode(foldProps);
      }
      case "AssignmentNode":
      case "BlockNode":
      case "FunctionAssignmentNode":
      case "RangeNode":
      case "ConditionalNode":
      default:
        throw new Error("Unimplemented node type in simplifyConstant: ".concat(node.type));
    }
  }
  return simplifyConstant2;
});
// ../../node_modules/mathjs/lib/esm/function/algebra/simplifyCore.js
var name277 = "simplifyCore";
var dependencies277 = ["typed", "parse", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createSimplifyCore = factory(name277, dependencies277, (_ref) => {
  var {
    typed: typed2,
    parse,
    equal: equal2,
    isZero: isZero2,
    add: add3,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide3,
    pow: pow3,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    ParenthesisNode,
    SymbolNode
  } = _ref;
  var node0 = new ConstantNode(0);
  var node1 = new ConstantNode(1);
  var nodeT = new ConstantNode(true);
  var nodeF = new ConstantNode(false);
  function isAlwaysBoolean(node) {
    return isOperatorNode(node) && ["and", "not", "or"].includes(node.op);
  }
  var {
    hasProperty,
    isCommutative
  } = createUtil({
    FunctionNode,
    OperatorNode,
    SymbolNode
  });
  function _simplifyCore(nodeToSimplify) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var context2 = options ? options.context : undefined;
    if (hasProperty(nodeToSimplify, "trivial", context2)) {
      if (isFunctionNode(nodeToSimplify) && nodeToSimplify.args.length === 1) {
        return _simplifyCore(nodeToSimplify.args[0], options);
      }
      var simpChild = false;
      var childCount = 0;
      nodeToSimplify.forEach((c) => {
        ++childCount;
        if (childCount === 1) {
          simpChild = _simplifyCore(c, options);
        }
      });
      if (childCount === 1) {
        return simpChild;
      }
    }
    var node = nodeToSimplify;
    if (isFunctionNode(node)) {
      var op = getOperator(node.name);
      if (op) {
        if (node.args.length > 2 && hasProperty(node, "associative", context2)) {
          while (node.args.length > 2) {
            var last = node.args.pop();
            var seclast = node.args.pop();
            node.args.push(new OperatorNode(op, node.name, [last, seclast]));
          }
        }
        node = new OperatorNode(op, node.name, node.args);
      } else {
        return new FunctionNode(_simplifyCore(node.fn), node.args.map((n) => _simplifyCore(n, options)));
      }
    }
    if (isOperatorNode(node) && node.isUnary()) {
      var a0 = _simplifyCore(node.args[0], options);
      if (node.op === "~") {
        if (isOperatorNode(a0) && a0.isUnary() && a0.op === "~") {
          return a0.args[0];
        }
      }
      if (node.op === "not") {
        if (isOperatorNode(a0) && a0.isUnary() && a0.op === "not") {
          if (isAlwaysBoolean(a0.args[0])) {
            return a0.args[0];
          }
        }
      }
      var finish = true;
      if (node.op === "-") {
        if (isOperatorNode(a0)) {
          if (a0.isBinary() && a0.fn === "subtract") {
            node = new OperatorNode("-", "subtract", [a0.args[1], a0.args[0]]);
            finish = false;
          }
          if (a0.isUnary() && a0.op === "-") {
            return a0.args[0];
          }
        }
      }
      if (finish)
        return new OperatorNode(node.op, node.fn, [a0]);
    }
    if (isOperatorNode(node) && node.isBinary()) {
      var _a = _simplifyCore(node.args[0], options);
      var a1 = _simplifyCore(node.args[1], options);
      if (node.op === "+") {
        if (isConstantNode(_a) && isZero2(_a.value)) {
          return a1;
        }
        if (isConstantNode(a1) && isZero2(a1.value)) {
          return _a;
        }
        if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
          a1 = a1.args[0];
          node = new OperatorNode("-", "subtract", [_a, a1]);
        }
      }
      if (node.op === "-") {
        if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
          return _simplifyCore(new OperatorNode("+", "add", [_a, a1.args[0]]), options);
        }
        if (isConstantNode(_a) && isZero2(_a.value)) {
          return _simplifyCore(new OperatorNode("-", "unaryMinus", [a1]));
        }
        if (isConstantNode(a1) && isZero2(a1.value)) {
          return _a;
        }
        return new OperatorNode(node.op, node.fn, [_a, a1]);
      }
      if (node.op === "*") {
        if (isConstantNode(_a)) {
          if (isZero2(_a.value)) {
            return node0;
          } else if (equal2(_a.value, 1)) {
            return a1;
          }
        }
        if (isConstantNode(a1)) {
          if (isZero2(a1.value)) {
            return node0;
          } else if (equal2(a1.value, 1)) {
            return _a;
          }
          if (isCommutative(node, context2)) {
            return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit);
          }
        }
        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);
      }
      if (node.op === "/") {
        if (isConstantNode(_a) && isZero2(_a.value)) {
          return node0;
        }
        if (isConstantNode(a1) && equal2(a1.value, 1)) {
          return _a;
        }
        return new OperatorNode(node.op, node.fn, [_a, a1]);
      }
      if (node.op === "^") {
        if (isConstantNode(a1)) {
          if (isZero2(a1.value)) {
            return node1;
          } else if (equal2(a1.value, 1)) {
            return _a;
          }
        }
      }
      if (node.op === "and") {
        if (isConstantNode(_a)) {
          if (_a.value) {
            if (isAlwaysBoolean(a1))
              return a1;
          } else {
            return nodeF;
          }
        }
        if (isConstantNode(a1)) {
          if (a1.value) {
            if (isAlwaysBoolean(_a))
              return _a;
          } else {
            return nodeF;
          }
        }
      }
      if (node.op === "or") {
        if (isConstantNode(_a)) {
          if (_a.value) {
            return nodeT;
          } else {
            if (isAlwaysBoolean(a1))
              return a1;
          }
        }
        if (isConstantNode(a1)) {
          if (a1.value) {
            return nodeT;
          } else {
            if (isAlwaysBoolean(_a))
              return _a;
          }
        }
      }
      return new OperatorNode(node.op, node.fn, [_a, a1]);
    }
    if (isOperatorNode(node)) {
      return new OperatorNode(node.op, node.fn, node.args.map((a) => _simplifyCore(a, options)));
    }
    if (isArrayNode(node)) {
      return new ArrayNode(node.items.map((n) => _simplifyCore(n, options)));
    }
    if (isAccessorNode(node)) {
      return new AccessorNode(_simplifyCore(node.object, options), _simplifyCore(node.index, options));
    }
    if (isIndexNode(node)) {
      return new IndexNode(node.dimensions.map((n) => _simplifyCore(n, options)));
    }
    if (isObjectNode(node)) {
      var newProps = {};
      for (var prop in node.properties) {
        newProps[prop] = _simplifyCore(node.properties[prop], options);
      }
      return new ObjectNode(newProps);
    }
    return node;
  }
  return typed2(name277, {
    Node: _simplifyCore,
    "Node,Object": _simplifyCore
  });
});
// ../../node_modules/mathjs/lib/esm/function/algebra/resolve.js
var name278 = "resolve";
var dependencies278 = ["typed", "parse", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode"];
var createResolve = factory(name278, dependencies278, (_ref) => {
  var {
    typed: typed2,
    parse,
    ConstantNode,
    FunctionNode,
    OperatorNode,
    ParenthesisNode
  } = _ref;
  function _resolve(node, scope2) {
    var within = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set;
    if (!scope2) {
      return node;
    }
    if (isSymbolNode(node)) {
      if (within.has(node.name)) {
        var variables = Array.from(within).join(", ");
        throw new ReferenceError("recursive loop of variable definitions among {".concat(variables, "}"));
      }
      var value = scope2.get(node.name);
      if (isNode(value)) {
        var nextWithin = new Set(within);
        nextWithin.add(node.name);
        return _resolve(value, scope2, nextWithin);
      } else if (typeof value === "number") {
        return parse(String(value));
      } else if (value !== undefined) {
        return new ConstantNode(value);
      } else {
        return node;
      }
    } else if (isOperatorNode(node)) {
      var args = node.args.map(function(arg2) {
        return _resolve(arg2, scope2, within);
      });
      return new OperatorNode(node.op, node.fn, args, node.implicit);
    } else if (isParenthesisNode(node)) {
      return new ParenthesisNode(_resolve(node.content, scope2, within));
    } else if (isFunctionNode(node)) {
      var _args = node.args.map(function(arg2) {
        return _resolve(arg2, scope2, within);
      });
      return new FunctionNode(node.name, _args);
    }
    return node.map((child) => _resolve(child, scope2, within));
  }
  return typed2("resolve", {
    Node: _resolve,
    "Node, Map | null | undefined": _resolve,
    "Node, Object": (n, scope2) => _resolve(n, createMap(scope2)),
    "Array | Matrix": typed2.referToSelf((self2) => (A) => A.map((n) => self2(n))),
    "Array | Matrix, null | undefined": typed2.referToSelf((self2) => (A) => A.map((n) => self2(n))),
    "Array, Object": typed2.referTo("Array,Map", (selfAM) => (A, scope2) => selfAM(A, createMap(scope2))),
    "Matrix, Object": typed2.referTo("Matrix,Map", (selfMM) => (A, scope2) => selfMM(A, createMap(scope2))),
    "Array | Matrix, Map": typed2.referToSelf((self2) => (A, scope2) => A.map((n) => self2(n, scope2)))
  });
});
// ../../node_modules/mathjs/lib/esm/function/algebra/symbolicEqual.js
var name279 = "symbolicEqual";
var dependencies279 = ["parse", "simplify", "typed", "OperatorNode"];
var createSymbolicEqual = factory(name279, dependencies279, (_ref) => {
  var {
    parse,
    simplify: simplify2,
    typed: typed2,
    OperatorNode
  } = _ref;
  function _symbolicEqual(e1, e22) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var diff2 = new OperatorNode("-", "subtract", [e1, e22]);
    var simplified = simplify2(diff2, {}, options);
    return isConstantNode(simplified) && !simplified.value;
  }
  return typed2(name279, {
    "Node, Node": _symbolicEqual,
    "Node, Node, Object": _symbolicEqual
  });
});
// ../../node_modules/mathjs/lib/esm/function/algebra/derivative.js
var name280 = "derivative";
var dependencies280 = ["typed", "config", "parse", "simplify", "equal", "isZero", "numeric", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createDerivative = factory(name280, dependencies280, (_ref) => {
  var {
    typed: typed2,
    config: config7,
    parse,
    simplify: simplify2,
    equal: equal2,
    isZero: isZero2,
    numeric: numeric3,
    ConstantNode,
    FunctionNode,
    OperatorNode,
    ParenthesisNode,
    SymbolNode
  } = _ref;
  function plainDerivative(expr, variable) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      simplify: true
    };
    var constNodes = {};
    constTag(constNodes, expr, variable.name);
    var res = _derivative(expr, constNodes);
    return options.simplify ? simplify2(res) : res;
  }
  typed2.addConversion({
    from: "identifier",
    to: "SymbolNode",
    convert: parse
  });
  var derivative2 = typed2(name280, {
    "Node, SymbolNode": plainDerivative,
    "Node, SymbolNode, Object": plainDerivative
  });
  typed2.removeConversion({
    from: "identifier",
    to: "SymbolNode",
    convert: parse
  });
  derivative2._simplify = true;
  derivative2.toTex = function(deriv) {
    return _derivTex.apply(null, deriv.args);
  };
  var _derivTex = typed2("_derivTex", {
    "Node, SymbolNode": function NodeSymbolNode(expr, x) {
      if (isConstantNode(expr) && typeOf(expr.value) === "string") {
        return _derivTex(parse(expr.value).toString(), x.toString(), 1);
      } else {
        return _derivTex(expr.toTex(), x.toString(), 1);
      }
    },
    "Node, ConstantNode": function NodeConstantNode(expr, x) {
      if (typeOf(x.value) === "string") {
        return _derivTex(expr, parse(x.value));
      } else {
        throw new Error("The second parameter to 'derivative' is a non-string constant");
      }
    },
    "Node, SymbolNode, ConstantNode": function NodeSymbolNodeConstantNode(expr, x, order) {
      return _derivTex(expr.toString(), x.name, order.value);
    },
    "string, string, number": function stringStringNumber(expr, x, order) {
      var d;
      if (order === 1) {
        d = "{d\\over d" + x + "}";
      } else {
        d = "{d^{" + order + "}\\over d" + x + "^{" + order + "}}";
      }
      return d + "\\left[".concat(expr, "\\right]");
    }
  });
  var constTag = typed2("constTag", {
    "Object, ConstantNode, string": function ObjectConstantNodeString(constNodes, node) {
      constNodes[node] = true;
      return true;
    },
    "Object, SymbolNode, string": function ObjectSymbolNodeString(constNodes, node, varName) {
      if (node.name !== varName) {
        constNodes[node] = true;
        return true;
      }
      return false;
    },
    "Object, ParenthesisNode, string": function ObjectParenthesisNodeString(constNodes, node, varName) {
      return constTag(constNodes, node.content, varName);
    },
    "Object, FunctionAssignmentNode, string": function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {
      if (node.params.indexOf(varName) === -1) {
        constNodes[node] = true;
        return true;
      }
      return constTag(constNodes, node.expr, varName);
    },
    "Object, FunctionNode | OperatorNode, string": function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {
      if (node.args.length > 0) {
        var isConst = constTag(constNodes, node.args[0], varName);
        for (var i2 = 1;i2 < node.args.length; ++i2) {
          isConst = constTag(constNodes, node.args[i2], varName) && isConst;
        }
        if (isConst) {
          constNodes[node] = true;
          return true;
        }
      }
      return false;
    }
  });
  var _derivative = typed2("_derivative", {
    "ConstantNode, Object": function ConstantNodeObject(node) {
      return createConstantNode2(0);
    },
    "SymbolNode, Object": function SymbolNodeObject(node, constNodes) {
      if (constNodes[node] !== undefined) {
        return createConstantNode2(0);
      }
      return createConstantNode2(1);
    },
    "ParenthesisNode, Object": function ParenthesisNodeObject(node, constNodes) {
      return new ParenthesisNode(_derivative(node.content, constNodes));
    },
    "FunctionAssignmentNode, Object": function FunctionAssignmentNodeObject(node, constNodes) {
      if (constNodes[node] !== undefined) {
        return createConstantNode2(0);
      }
      return _derivative(node.expr, constNodes);
    },
    "FunctionNode, Object": function FunctionNodeObject(node, constNodes) {
      if (node.args.length !== 1) {
        funcArgsCheck(node);
      }
      if (constNodes[node] !== undefined) {
        return createConstantNode2(0);
      }
      var arg0 = node.args[0];
      var arg1;
      var div2 = false;
      var negative = false;
      var funcDerivative;
      switch (node.name) {
        case "cbrt":
          div2 = true;
          funcDerivative = new OperatorNode("*", "multiply", [createConstantNode2(3), new OperatorNode("^", "pow", [arg0, new OperatorNode("/", "divide", [createConstantNode2(2), createConstantNode2(3)])])]);
          break;
        case "sqrt":
        case "nthRoot":
          if (node.args.length === 1) {
            div2 = true;
            funcDerivative = new OperatorNode("*", "multiply", [createConstantNode2(2), new FunctionNode("sqrt", [arg0])]);
          } else if (node.args.length === 2) {
            arg1 = new OperatorNode("/", "divide", [createConstantNode2(1), node.args[1]]);
            constNodes[arg1] = constNodes[node.args[1]];
            return _derivative(new OperatorNode("^", "pow", [arg0, arg1]), constNodes);
          }
          break;
        case "log10":
          arg1 = createConstantNode2(10);
        case "log":
          if (!arg1 && node.args.length === 1) {
            funcDerivative = arg0.clone();
            div2 = true;
          } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== undefined) {
            funcDerivative = new OperatorNode("*", "multiply", [arg0.clone(), new FunctionNode("log", [arg1 || node.args[1]])]);
            div2 = true;
          } else if (node.args.length === 2) {
            return _derivative(new OperatorNode("/", "divide", [new FunctionNode("log", [arg0]), new FunctionNode("log", [node.args[1]])]), constNodes);
          }
          break;
        case "pow":
          constNodes[arg1] = constNodes[node.args[1]];
          return _derivative(new OperatorNode("^", "pow", [arg0, node.args[1]]), constNodes);
        case "exp":
          funcDerivative = new FunctionNode("exp", [arg0.clone()]);
          break;
        case "sin":
          funcDerivative = new FunctionNode("cos", [arg0.clone()]);
          break;
        case "cos":
          funcDerivative = new OperatorNode("-", "unaryMinus", [new FunctionNode("sin", [arg0.clone()])]);
          break;
        case "tan":
          funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("sec", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "sec":
          funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("tan", [arg0.clone()])]);
          break;
        case "csc":
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("cot", [arg0.clone()])]);
          break;
        case "cot":
          negative = true;
          funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("csc", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "asin":
          div2 = true;
          funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
          break;
        case "acos":
          div2 = true;
          negative = true;
          funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
          break;
        case "atan":
          div2 = true;
          funcDerivative = new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
          break;
        case "asec":
          div2 = true;
          funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acsc":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acot":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
          break;
        case "sinh":
          funcDerivative = new FunctionNode("cosh", [arg0.clone()]);
          break;
        case "cosh":
          funcDerivative = new FunctionNode("sinh", [arg0.clone()]);
          break;
        case "tanh":
          funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("sech", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "sech":
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("tanh", [arg0.clone()])]);
          break;
        case "csch":
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("coth", [arg0.clone()])]);
          break;
        case "coth":
          negative = true;
          funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("csch", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "asinh":
          div2 = true;
          funcDerivative = new FunctionNode("sqrt", [new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
          break;
        case "acosh":
          div2 = true;
          funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
          break;
        case "atanh":
          div2 = true;
          funcDerivative = new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
          break;
        case "asech":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [arg0.clone(), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])])])]);
          break;
        case "acsch":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acoth":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
          break;
        case "abs":
          funcDerivative = new OperatorNode("/", "divide", [new FunctionNode(new SymbolNode("abs"), [arg0.clone()]), arg0.clone()]);
          break;
        case "gamma":
        default:
          throw new Error('Function "' + node.name + '" is not supported by derivative, or a wrong number of arguments is passed');
      }
      var op, func;
      if (div2) {
        op = "/";
        func = "divide";
      } else {
        op = "*";
        func = "multiply";
      }
      var chainDerivative = _derivative(arg0, constNodes);
      if (negative) {
        chainDerivative = new OperatorNode("-", "unaryMinus", [chainDerivative]);
      }
      return new OperatorNode(op, func, [chainDerivative, funcDerivative]);
    },
    "OperatorNode, Object": function OperatorNodeObject(node, constNodes) {
      if (constNodes[node] !== undefined) {
        return createConstantNode2(0);
      }
      if (node.op === "+") {
        return new OperatorNode(node.op, node.fn, node.args.map(function(arg2) {
          return _derivative(arg2, constNodes);
        }));
      }
      if (node.op === "-") {
        if (node.isUnary()) {
          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes)]);
        }
        if (node.isBinary()) {
          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);
        }
      }
      if (node.op === "*") {
        var constantTerms = node.args.filter(function(arg2) {
          return constNodes[arg2] !== undefined;
        });
        if (constantTerms.length > 0) {
          var nonConstantTerms = node.args.filter(function(arg2) {
            return constNodes[arg2] === undefined;
          });
          var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode("*", "multiply", nonConstantTerms);
          var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));
          return new OperatorNode("*", "multiply", newArgs);
        }
        return new OperatorNode("+", "add", node.args.map(function(argOuter) {
          return new OperatorNode("*", "multiply", node.args.map(function(argInner) {
            return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();
          }));
        }));
      }
      if (node.op === "/" && node.isBinary()) {
        var arg0 = node.args[0];
        var arg1 = node.args[1];
        if (constNodes[arg1] !== undefined) {
          return new OperatorNode("/", "divide", [_derivative(arg0, constNodes), arg1]);
        }
        if (constNodes[arg0] !== undefined) {
          return new OperatorNode("*", "multiply", [new OperatorNode("-", "unaryMinus", [arg0]), new OperatorNode("/", "divide", [_derivative(arg1, constNodes), new OperatorNode("^", "pow", [arg1.clone(), createConstantNode2(2)])])]);
        }
        return new OperatorNode("/", "divide", [new OperatorNode("-", "subtract", [new OperatorNode("*", "multiply", [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode("*", "multiply", [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode("^", "pow", [arg1.clone(), createConstantNode2(2)])]);
      }
      if (node.op === "^" && node.isBinary()) {
        var _arg = node.args[0];
        var _arg2 = node.args[1];
        if (constNodes[_arg] !== undefined) {
          if (isConstantNode(_arg) && (isZero2(_arg.value) || equal2(_arg.value, 1))) {
            return createConstantNode2(0);
          }
          return new OperatorNode("*", "multiply", [node, new OperatorNode("*", "multiply", [new FunctionNode("log", [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);
        }
        if (constNodes[_arg2] !== undefined) {
          if (isConstantNode(_arg2)) {
            if (isZero2(_arg2.value)) {
              return createConstantNode2(0);
            }
            if (equal2(_arg2.value, 1)) {
              return _derivative(_arg, constNodes);
            }
          }
          var powMinusOne = new OperatorNode("^", "pow", [_arg.clone(), new OperatorNode("-", "subtract", [_arg2, createConstantNode2(1)])]);
          return new OperatorNode("*", "multiply", [_arg2.clone(), new OperatorNode("*", "multiply", [_derivative(_arg, constNodes), powMinusOne])]);
        }
        return new OperatorNode("*", "multiply", [new OperatorNode("^", "pow", [_arg.clone(), _arg2.clone()]), new OperatorNode("+", "add", [new OperatorNode("*", "multiply", [_derivative(_arg, constNodes), new OperatorNode("/", "divide", [_arg2.clone(), _arg.clone()])]), new OperatorNode("*", "multiply", [_derivative(_arg2, constNodes), new FunctionNode("log", [_arg.clone()])])])]);
      }
      throw new Error('Operator "' + node.op + '" is not supported by derivative, or a wrong number of arguments is passed');
    }
  });
  function funcArgsCheck(node) {
    if ((node.name === "log" || node.name === "nthRoot" || node.name === "pow") && node.args.length === 2) {
      return;
    }
    for (var i2 = 0;i2 < node.args.length; ++i2) {
      node.args[i2] = createConstantNode2(0);
    }
    node.compile().evaluate();
    throw new Error("Expected TypeError, but none found");
  }
  function createConstantNode2(value, valueType) {
    return new ConstantNode(numeric3(value, valueType || config7.number));
  }
  return derivative2;
});
// ../../node_modules/mathjs/lib/esm/function/algebra/rationalize.js
var name281 = "rationalize";
var dependencies281 = ["config", "typed", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "parse", "simplifyConstant", "simplifyCore", "simplify", "?bignumber", "?fraction", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode", "ParenthesisNode"];
var createRationalize = factory(name281, dependencies281, (_ref) => {
  var {
    config: config7,
    typed: typed2,
    equal: equal2,
    isZero: isZero2,
    add: add3,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide3,
    pow: pow3,
    parse,
    simplifyConstant: simplifyConstant2,
    simplifyCore: simplifyCore2,
    simplify: simplify2,
    fraction: fraction2,
    bignumber: bignumber2,
    mathWithTransform,
    matrix: matrix2,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    SymbolNode,
    ParenthesisNode
  } = _ref;
  function _rationalize(expr) {
    var scope2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var detailed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var setRules = rulesRationalize();
    var polyRet = polynomial(expr, scope2, true, setRules.firstRules);
    var nVars = polyRet.variables.length;
    var noExactFractions = {
      exactFractions: false
    };
    var withExactFractions = {
      exactFractions: true
    };
    expr = polyRet.expression;
    if (nVars >= 1) {
      expr = expandPower(expr);
      var sBefore;
      var rules;
      var eDistrDiv = true;
      var redoInic = false;
      expr = simplify2(expr, setRules.firstRules, {}, noExactFractions);
      var s;
      while (true) {
        rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;
        expr = simplify2(expr, rules, {}, withExactFractions);
        eDistrDiv = !eDistrDiv;
        s = expr.toString();
        if (s === sBefore) {
          break;
        }
        redoInic = true;
        sBefore = s;
      }
      if (redoInic) {
        expr = simplify2(expr, setRules.firstRulesAgain, {}, noExactFractions);
      }
      expr = simplify2(expr, setRules.finalRules, {}, noExactFractions);
    }
    var coefficients = [];
    var retRationalize = {};
    if (expr.type === "OperatorNode" && expr.isBinary() && expr.op === "/") {
      if (nVars === 1) {
        expr.args[0] = polyToCanonical(expr.args[0], coefficients);
        expr.args[1] = polyToCanonical(expr.args[1]);
      }
      if (detailed) {
        retRationalize.numerator = expr.args[0];
        retRationalize.denominator = expr.args[1];
      }
    } else {
      if (nVars === 1) {
        expr = polyToCanonical(expr, coefficients);
      }
      if (detailed) {
        retRationalize.numerator = expr;
        retRationalize.denominator = null;
      }
    }
    if (!detailed)
      return expr;
    retRationalize.coefficients = coefficients;
    retRationalize.variables = polyRet.variables;
    retRationalize.expression = expr;
    return retRationalize;
  }
  return typed2(name281, {
    Node: _rationalize,
    "Node, boolean": (expr, detailed) => _rationalize(expr, {}, detailed),
    "Node, Object": _rationalize,
    "Node, Object, boolean": _rationalize
  });
  function polynomial(expr, scope2, extended, rules) {
    var variables = [];
    var node = simplify2(expr, rules, scope2, {
      exactFractions: false
    });
    extended = !!extended;
    var oper = "+-*" + (extended ? "/" : "");
    recPoly(node);
    var retFunc = {};
    retFunc.expression = node;
    retFunc.variables = variables;
    return retFunc;
    function recPoly(node2) {
      var tp = node2.type;
      if (tp === "FunctionNode") {
        throw new Error("There is an unsolved function call");
      } else if (tp === "OperatorNode") {
        if (node2.op === "^") {
          if (node2.args[1].type !== "ConstantNode" || !isInteger(parseFloat(node2.args[1].value))) {
            throw new Error("There is a non-integer exponent");
          } else {
            recPoly(node2.args[0]);
          }
        } else {
          if (oper.indexOf(node2.op) === -1) {
            throw new Error("Operator " + node2.op + " invalid in polynomial expression");
          }
          for (var i2 = 0;i2 < node2.args.length; i2++) {
            recPoly(node2.args[i2]);
          }
        }
      } else if (tp === "SymbolNode") {
        var _name = node2.name;
        var pos = variables.indexOf(_name);
        if (pos === -1) {
          variables.push(_name);
        }
      } else if (tp === "ParenthesisNode") {
        recPoly(node2.content);
      } else if (tp !== "ConstantNode") {
        throw new Error("type " + tp + " is not allowed in polynomial expression");
      }
    }
  }
  function rulesRationalize() {
    var oldRules = [
      simplifyCore2,
      {
        l: "n+n",
        r: "2*n"
      },
      {
        l: "n+-n",
        r: "0"
      },
      simplifyConstant2,
      {
        l: "n*(n1^-1)",
        r: "n/n1"
      },
      {
        l: "n*n1^-n2",
        r: "n/n1^n2"
      },
      {
        l: "n1^-1",
        r: "1/n1"
      },
      {
        l: "n*(n1/n2)",
        r: "(n*n1)/n2"
      },
      {
        l: "1*n",
        r: "n"
      }
    ];
    var rulesFirst = [
      {
        l: "(-n1)/(-n2)",
        r: "n1/n2"
      },
      {
        l: "(-n1)*(-n2)",
        r: "n1*n2"
      },
      {
        l: "n1--n2",
        r: "n1+n2"
      },
      {
        l: "n1-n2",
        r: "n1+(-n2)"
      },
      {
        l: "(n1+n2)*n3",
        r: "(n1*n3 + n2*n3)"
      },
      {
        l: "n1*(n2+n3)",
        r: "(n1*n2+n1*n3)"
      },
      {
        l: "c1*n + c2*n",
        r: "(c1+c2)*n"
      },
      {
        l: "c1*n + n",
        r: "(c1+1)*n"
      },
      {
        l: "c1*n - c2*n",
        r: "(c1-c2)*n"
      },
      {
        l: "c1*n - n",
        r: "(c1-1)*n"
      },
      {
        l: "v/c",
        r: "(1/c)*v"
      },
      {
        l: "v/-c",
        r: "-(1/c)*v"
      },
      {
        l: "-v*-c",
        r: "c*v"
      },
      {
        l: "-v*c",
        r: "-c*v"
      },
      {
        l: "v*-c",
        r: "-c*v"
      },
      {
        l: "v*c",
        r: "c*v"
      },
      {
        l: "-(-n1*n2)",
        r: "(n1*n2)"
      },
      {
        l: "-(n1*n2)",
        r: "(-n1*n2)"
      },
      {
        l: "-(-n1+n2)",
        r: "(n1-n2)"
      },
      {
        l: "-(n1+n2)",
        r: "(-n1-n2)"
      },
      {
        l: "(n1^n2)^n3",
        r: "(n1^(n2*n3))"
      },
      {
        l: "-(-n1/n2)",
        r: "(n1/n2)"
      },
      {
        l: "-(n1/n2)",
        r: "(-n1/n2)"
      }
    ];
    var rulesDistrDiv = [
      {
        l: "(n1/n2 + n3/n4)",
        r: "((n1*n4 + n3*n2)/(n2*n4))"
      },
      {
        l: "(n1/n2 + n3)",
        r: "((n1 + n3*n2)/n2)"
      },
      {
        l: "(n1 + n2/n3)",
        r: "((n1*n3 + n2)/n3)"
      }
    ];
    var rulesSucDiv = [
      {
        l: "(n1/(n2/n3))",
        r: "((n1*n3)/n2)"
      },
      {
        l: "(n1/n2/n3)",
        r: "(n1/(n2*n3))"
      }
    ];
    var setRules = {};
    setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv);
    setRules.distrDivRules = rulesDistrDiv;
    setRules.sucDivRules = rulesSucDiv;
    setRules.firstRulesAgain = oldRules.concat(rulesFirst);
    setRules.finalRules = [
      simplifyCore2,
      {
        l: "n*-n",
        r: "-n^2"
      },
      {
        l: "n*n",
        r: "n^2"
      },
      simplifyConstant2,
      {
        l: "n*-n^n1",
        r: "-n^(n1+1)"
      },
      {
        l: "n*n^n1",
        r: "n^(n1+1)"
      },
      {
        l: "n^n1*-n^n2",
        r: "-n^(n1+n2)"
      },
      {
        l: "n^n1*n^n2",
        r: "n^(n1+n2)"
      },
      {
        l: "n^n1*-n",
        r: "-n^(n1+1)"
      },
      {
        l: "n^n1*n",
        r: "n^(n1+1)"
      },
      {
        l: "n^n1/-n",
        r: "-n^(n1-1)"
      },
      {
        l: "n^n1/n",
        r: "n^(n1-1)"
      },
      {
        l: "n/-n^n1",
        r: "-n^(1-n1)"
      },
      {
        l: "n/n^n1",
        r: "n^(1-n1)"
      },
      {
        l: "n^n1/-n^n2",
        r: "n^(n1-n2)"
      },
      {
        l: "n^n1/n^n2",
        r: "n^(n1-n2)"
      },
      {
        l: "n1+(-n2*n3)",
        r: "n1-n2*n3"
      },
      {
        l: "v*(-c)",
        r: "-c*v"
      },
      {
        l: "n1+-n2",
        r: "n1-n2"
      },
      {
        l: "v*c",
        r: "c*v"
      },
      {
        l: "(n1^n2)^n3",
        r: "(n1^(n2*n3))"
      }
    ];
    return setRules;
  }
  function expandPower(node, parent, indParent) {
    var tp = node.type;
    var internal = arguments.length > 1;
    if (tp === "OperatorNode" && node.isBinary()) {
      var does = false;
      var val;
      if (node.op === "^") {
        if ((node.args[0].type === "ParenthesisNode" || node.args[0].type === "OperatorNode") && node.args[1].type === "ConstantNode") {
          val = parseFloat(node.args[1].value);
          does = val >= 2 && isInteger(val);
        }
      }
      if (does) {
        if (val > 2) {
          var nEsqTopo = node.args[0];
          var nDirTopo = new OperatorNode("^", "pow", [node.args[0].cloneDeep(), new ConstantNode(val - 1)]);
          node = new OperatorNode("*", "multiply", [nEsqTopo, nDirTopo]);
        } else {
          node = new OperatorNode("*", "multiply", [node.args[0], node.args[0].cloneDeep()]);
        }
        if (internal) {
          if (indParent === "content") {
            parent.content = node;
          } else {
            parent.args[indParent] = node;
          }
        }
      }
    }
    if (tp === "ParenthesisNode") {
      expandPower(node.content, node, "content");
    } else if (tp !== "ConstantNode" && tp !== "SymbolNode") {
      for (var i2 = 0;i2 < node.args.length; i2++) {
        expandPower(node.args[i2], node, i2);
      }
    }
    if (!internal) {
      return node;
    }
  }
  function polyToCanonical(node, coefficients) {
    if (coefficients === undefined) {
      coefficients = [];
    }
    coefficients[0] = 0;
    var o = {};
    o.cte = 1;
    o.oper = "+";
    o.fire = "";
    var maxExpo = 0;
    var varname = "";
    recurPol(node, null, o);
    maxExpo = coefficients.length - 1;
    var first = true;
    var no;
    for (var i2 = maxExpo;i2 >= 0; i2--) {
      if (coefficients[i2] === 0)
        continue;
      var n16 = new ConstantNode(first ? coefficients[i2] : Math.abs(coefficients[i2]));
      var op = coefficients[i2] < 0 ? "-" : "+";
      if (i2 > 0) {
        var n25 = new SymbolNode(varname);
        if (i2 > 1) {
          var n3 = new ConstantNode(i2);
          n25 = new OperatorNode("^", "pow", [n25, n3]);
        }
        if (coefficients[i2] === -1 && first) {
          n16 = new OperatorNode("-", "unaryMinus", [n25]);
        } else if (Math.abs(coefficients[i2]) === 1) {
          n16 = n25;
        } else {
          n16 = new OperatorNode("*", "multiply", [n16, n25]);
        }
      }
      if (first) {
        no = n16;
      } else if (op === "+") {
        no = new OperatorNode("+", "add", [no, n16]);
      } else {
        no = new OperatorNode("-", "subtract", [no, n16]);
      }
      first = false;
    }
    if (first) {
      return new ConstantNode(0);
    } else {
      return no;
    }
    function recurPol(node2, noPai, o2) {
      var tp = node2.type;
      if (tp === "FunctionNode") {
        throw new Error("There is an unsolved function call");
      } else if (tp === "OperatorNode") {
        if ("+-*^".indexOf(node2.op) === -1)
          throw new Error("Operator " + node2.op + " invalid");
        if (noPai !== null) {
          if ((node2.fn === "unaryMinus" || node2.fn === "pow") && noPai.fn !== "add" && noPai.fn !== "subtract" && noPai.fn !== "multiply") {
            throw new Error("Invalid " + node2.op + " placing");
          }
          if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "multiply") && noPai.fn !== "add" && noPai.fn !== "subtract") {
            throw new Error("Invalid " + node2.op + " placing");
          }
          if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "unaryMinus") && o2.noFil !== 0) {
            throw new Error("Invalid " + node2.op + " placing");
          }
        }
        if (node2.op === "^" || node2.op === "*") {
          o2.fire = node2.op;
        }
        for (var _i = 0;_i < node2.args.length; _i++) {
          if (node2.fn === "unaryMinus")
            o2.oper = "-";
          if (node2.op === "+" || node2.fn === "subtract") {
            o2.fire = "";
            o2.cte = 1;
            o2.oper = _i === 0 ? "+" : node2.op;
          }
          o2.noFil = _i;
          recurPol(node2.args[_i], node2, o2);
        }
      } else if (tp === "SymbolNode") {
        if (node2.name !== varname && varname !== "") {
          throw new Error("There is more than one variable");
        }
        varname = node2.name;
        if (noPai === null) {
          coefficients[1] = 1;
          return;
        }
        if (noPai.op === "^" && o2.noFil !== 0) {
          throw new Error("In power the variable should be the first parameter");
        }
        if (noPai.op === "*" && o2.noFil !== 1) {
          throw new Error("In multiply the variable should be the second parameter");
        }
        if (o2.fire === "" || o2.fire === "*") {
          if (maxExpo < 1)
            coefficients[1] = 0;
          coefficients[1] += o2.cte * (o2.oper === "+" ? 1 : -1);
          maxExpo = Math.max(1, maxExpo);
        }
      } else if (tp === "ConstantNode") {
        var valor = parseFloat(node2.value);
        if (noPai === null) {
          coefficients[0] = valor;
          return;
        }
        if (noPai.op === "^") {
          if (o2.noFil !== 1)
            throw new Error("Constant cannot be powered");
          if (!isInteger(valor) || valor <= 0) {
            throw new Error("Non-integer exponent is not allowed");
          }
          for (var _i2 = maxExpo + 1;_i2 < valor; _i2++)
            coefficients[_i2] = 0;
          if (valor > maxExpo)
            coefficients[valor] = 0;
          coefficients[valor] += o2.cte * (o2.oper === "+" ? 1 : -1);
          maxExpo = Math.max(valor, maxExpo);
          return;
        }
        o2.cte = valor;
        if (o2.fire === "") {
          coefficients[0] += o2.cte * (o2.oper === "+" ? 1 : -1);
        }
      } else {
        throw new Error("Type " + tp + " is not allowed");
      }
    }
  }
});
// ../../node_modules/mathjs/lib/esm/json/reviver.js
var name282 = "reviver";
var dependencies282 = ["classes"];
var createReviver = factory(name282, dependencies282, (_ref) => {
  var {
    classes
  } = _ref;
  return function reviver(key, value) {
    var constructor = classes[value && value.mathjs];
    if (constructor && typeof constructor.fromJSON === "function") {
      return constructor.fromJSON(value);
    }
    return value;
  };
});
// ../../node_modules/mathjs/lib/esm/json/replacer.js
var name283 = "replacer";
var dependencies283 = [];
var createReplacer = factory(name283, dependencies283, () => {
  return function replacer(key, value) {
    if (typeof value === "number" && (!isFinite(value) || isNaN(value))) {
      return {
        mathjs: "number",
        value: String(value)
      };
    }
    return value;
  };
});
// ../../node_modules/mathjs/lib/esm/version.js
var version3 = "11.8.0";

// ../../node_modules/mathjs/lib/esm/constants.js
var recreateFactory = function(name284, dependencies284, create) {
  return factory(name284, dependencies284, create, {
    recreateOnConfigChange: true
  });
};
var createTrue = factory("true", [], () => true);
var createFalse = factory("false", [], () => false);
var createNull = factory("null", [], () => null);
var createInfinity = recreateFactory("Infinity", ["config", "?BigNumber"], (_ref) => {
  var {
    config: config7,
    BigNumber
  } = _ref;
  return config7.number === "BigNumber" ? new BigNumber(Infinity) : Infinity;
});
var createNaN = recreateFactory("NaN", ["config", "?BigNumber"], (_ref2) => {
  var {
    config: config7,
    BigNumber
  } = _ref2;
  return config7.number === "BigNumber" ? new BigNumber(NaN) : NaN;
});
var createPi = recreateFactory("pi", ["config", "?BigNumber"], (_ref3) => {
  var {
    config: config7,
    BigNumber
  } = _ref3;
  return config7.number === "BigNumber" ? createBigNumberPi(BigNumber) : pi;
});
var createTau = recreateFactory("tau", ["config", "?BigNumber"], (_ref4) => {
  var {
    config: config7,
    BigNumber
  } = _ref4;
  return config7.number === "BigNumber" ? createBigNumberTau(BigNumber) : tau;
});
var createE = recreateFactory("e", ["config", "?BigNumber"], (_ref5) => {
  var {
    config: config7,
    BigNumber
  } = _ref5;
  return config7.number === "BigNumber" ? createBigNumberE(BigNumber) : e;
});
var createPhi = recreateFactory("phi", ["config", "?BigNumber"], (_ref6) => {
  var {
    config: config7,
    BigNumber
  } = _ref6;
  return config7.number === "BigNumber" ? createBigNumberPhi(BigNumber) : phi;
});
var createLN2 = recreateFactory("LN2", ["config", "?BigNumber"], (_ref7) => {
  var {
    config: config7,
    BigNumber
  } = _ref7;
  return config7.number === "BigNumber" ? new BigNumber(2).ln() : Math.LN2;
});
var createLN10 = recreateFactory("LN10", ["config", "?BigNumber"], (_ref8) => {
  var {
    config: config7,
    BigNumber
  } = _ref8;
  return config7.number === "BigNumber" ? new BigNumber(10).ln() : Math.LN10;
});
var createLOG2E = recreateFactory("LOG2E", ["config", "?BigNumber"], (_ref9) => {
  var {
    config: config7,
    BigNumber
  } = _ref9;
  return config7.number === "BigNumber" ? new BigNumber(1).div(new BigNumber(2).ln()) : Math.LOG2E;
});
var createLOG10E = recreateFactory("LOG10E", ["config", "?BigNumber"], (_ref10) => {
  var {
    config: config7,
    BigNumber
  } = _ref10;
  return config7.number === "BigNumber" ? new BigNumber(1).div(new BigNumber(10).ln()) : Math.LOG10E;
});
var createSQRT1_2 = recreateFactory("SQRT1_2", ["config", "?BigNumber"], (_ref11) => {
  var {
    config: config7,
    BigNumber
  } = _ref11;
  return config7.number === "BigNumber" ? new BigNumber("0.5").sqrt() : Math.SQRT1_2;
});
var createSQRT2 = recreateFactory("SQRT2", ["config", "?BigNumber"], (_ref12) => {
  var {
    config: config7,
    BigNumber
  } = _ref12;
  return config7.number === "BigNumber" ? new BigNumber(2).sqrt() : Math.SQRT2;
});
var createI = recreateFactory("i", ["Complex"], (_ref13) => {
  var {
    Complex: Complex2
  } = _ref13;
  return Complex2.I;
});
var createVersion = factory("version", [], () => version3);
// ../../node_modules/mathjs/lib/esm/type/unit/physicalConstants.js
var unitFactory = function(name284, valueStr, unitStr) {
  var dependencies284 = ["config", "Unit", "BigNumber"];
  return factory(name284, dependencies284, (_ref) => {
    var {
      config: config7,
      Unit,
      BigNumber
    } = _ref;
    var value = config7.number === "BigNumber" ? new BigNumber(valueStr) : parseFloat(valueStr);
    var unit2 = new Unit(value, unitStr);
    unit2.fixPrefix = true;
    return unit2;
  });
};
var numberFactory = function(name284, value) {
  var dependencies284 = ["config", "BigNumber"];
  return factory(name284, dependencies284, (_ref2) => {
    var {
      config: config7,
      BigNumber
    } = _ref2;
    return config7.number === "BigNumber" ? new BigNumber(value) : value;
  });
};
var createSpeedOfLight = unitFactory("speedOfLight", "299792458", "m s^-1");
var createGravitationConstant = unitFactory("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2");
var createPlanckConstant = unitFactory("planckConstant", "6.62607015e-34", "J s");
var createReducedPlanckConstant = unitFactory("reducedPlanckConstant", "1.0545718176461565e-34", "J s");
var createMagneticConstant = unitFactory("magneticConstant", "1.25663706212e-6", "N A^-2");
var createElectricConstant = unitFactory("electricConstant", "8.8541878128e-12", "F m^-1");
var createVacuumImpedance = unitFactory("vacuumImpedance", "376.730313667", "ohm");
var createCoulomb = unitFactory("coulomb", "8.987551792261171e9", "N m^2 C^-2");
var createElementaryCharge = unitFactory("elementaryCharge", "1.602176634e-19", "C");
var createBohrMagneton = unitFactory("bohrMagneton", "9.2740100783e-24", "J T^-1");
var createConductanceQuantum = unitFactory("conductanceQuantum", "7.748091729863649e-5", "S");
var createInverseConductanceQuantum = unitFactory("inverseConductanceQuantum", "12906.403729652257", "ohm");
var createMagneticFluxQuantum = unitFactory("magneticFluxQuantum", "2.0678338484619295e-15", "Wb");
var createNuclearMagneton = unitFactory("nuclearMagneton", "5.0507837461e-27", "J T^-1");
var createKlitzing = unitFactory("klitzing", "25812.807459304513", "ohm");
var createBohrRadius = unitFactory("bohrRadius", "5.29177210903e-11", "m");
var createClassicalElectronRadius = unitFactory("classicalElectronRadius", "2.8179403262e-15", "m");
var createElectronMass = unitFactory("electronMass", "9.1093837015e-31", "kg");
var createFermiCoupling = unitFactory("fermiCoupling", "1.1663787e-5", "GeV^-2");
var createFineStructure = numberFactory("fineStructure", 0.0072973525693);
var createHartreeEnergy = unitFactory("hartreeEnergy", "4.3597447222071e-18", "J");
var createProtonMass = unitFactory("protonMass", "1.67262192369e-27", "kg");
var createDeuteronMass = unitFactory("deuteronMass", "3.3435830926e-27", "kg");
var createNeutronMass = unitFactory("neutronMass", "1.6749271613e-27", "kg");
var createQuantumOfCirculation = unitFactory("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1");
var createRydberg = unitFactory("rydberg", "10973731.568160", "m^-1");
var createThomsonCrossSection = unitFactory("thomsonCrossSection", "6.6524587321e-29", "m^2");
var createWeakMixingAngle = numberFactory("weakMixingAngle", 0.2229);
var createEfimovFactor = numberFactory("efimovFactor", 22.7);
var createAtomicMass = unitFactory("atomicMass", "1.66053906660e-27", "kg");
var createAvogadro = unitFactory("avogadro", "6.02214076e23", "mol^-1");
var createBoltzmann = unitFactory("boltzmann", "1.380649e-23", "J K^-1");
var createFaraday = unitFactory("faraday", "96485.33212331001", "C mol^-1");
var createFirstRadiation = unitFactory("firstRadiation", "3.7417718521927573e-16", "W m^2");
var createLoschmidt = unitFactory("loschmidt", "2.686780111798444e25", "m^-3");
var createGasConstant = unitFactory("gasConstant", "8.31446261815324", "J K^-1 mol^-1");
var createMolarPlanckConstant = unitFactory("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1");
var createMolarVolume = unitFactory("molarVolume", "0.022413969545014137", "m^3 mol^-1");
var createSackurTetrode = numberFactory("sackurTetrode", -1.16487052358);
var createSecondRadiation = unitFactory("secondRadiation", "0.014387768775039337", "m K");
var createStefanBoltzmann = unitFactory("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4");
var createWienDisplacement = unitFactory("wienDisplacement", "2.897771955e-3", "m K");
var createMolarMass = unitFactory("molarMass", "0.99999999965e-3", "kg mol^-1");
var createMolarMassC12 = unitFactory("molarMassC12", "11.9999999958e-3", "kg mol^-1");
var createGravity = unitFactory("gravity", "9.80665", "m s^-2");
var createPlanckLength = unitFactory("planckLength", "1.616255e-35", "m");
var createPlanckMass = unitFactory("planckMass", "2.176435e-8", "kg");
var createPlanckTime = unitFactory("planckTime", "5.391245e-44", "s");
var createPlanckCharge = unitFactory("planckCharge", "1.87554603778e-18", "C");
var createPlanckTemperature = unitFactory("planckTemperature", "1.416785e+32", "K");
// ../../node_modules/mathjs/lib/esm/expression/transform/apply.transform.js
var name284 = "apply";
var dependencies284 = ["typed", "isInteger"];
var createApplyTransform = factory(name284, dependencies284, (_ref) => {
  var {
    typed: typed2,
    isInteger: isInteger3
  } = _ref;
  var apply2 = createApply({
    typed: typed2,
    isInteger: isInteger3
  });
  return typed2("apply", {
    "...any": function any(args) {
      var dim = args[1];
      if (isNumber(dim)) {
        args[1] = dim - 1;
      } else if (isBigNumber(dim)) {
        args[1] = dim.minus(1);
      }
      try {
        return apply2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/column.transform.js
var name285 = "column";
var dependencies285 = ["typed", "Index", "matrix", "range"];
var createColumnTransform = factory(name285, dependencies285, (_ref) => {
  var {
    typed: typed2,
    Index,
    matrix: matrix2,
    range: range2
  } = _ref;
  var column3 = createColumn({
    typed: typed2,
    Index,
    matrix: matrix2,
    range: range2
  });
  return typed2("column", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      }
      try {
        return column3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/utils/compileInlineExpression.js
function compileInlineExpression(expression, math, scope3) {
  var symbol = expression.filter(function(node) {
    return isSymbolNode(node) && !(node.name in math) && !scope3.has(node.name);
  })[0];
  if (!symbol) {
    throw new Error('No undefined variable found in inline expression "' + expression + '"');
  }
  var name286 = symbol.name;
  var subScope = createSubScope(scope3);
  var eq = expression.compile();
  return function inlineExpression(x) {
    subScope.set(name286, x);
    return eq.evaluate(subScope);
  };
}

// ../../node_modules/mathjs/lib/esm/expression/transform/filter.transform.js
var _filter = function(x, callback) {
  var args = maxArgumentCount(callback);
  return filter(x, function(value, index, array57) {
    if (args === 1) {
      return callback(value);
    } else if (args === 2) {
      return callback(value, [index + 1]);
    } else {
      return callback(value, [index + 1], array57);
    }
  });
};
var name286 = "filter";
var dependencies286 = ["typed"];
var createFilterTransform = factory(name286, dependencies286, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  function filterTransform(args, math, scope3) {
    var x, callback;
    if (args[0]) {
      x = args[0].compile().evaluate(scope3);
    }
    if (args[1]) {
      if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
        callback = args[1].compile().evaluate(scope3);
      } else {
        callback = compileInlineExpression(args[1], math, scope3);
      }
    }
    return filter3(x, callback);
  }
  filterTransform.rawArgs = true;
  var filter3 = typed2("filter", {
    "Array, function": _filter,
    "Matrix, function": function MatrixFunction(x, test) {
      return x.create(_filter(x.toArray(), test));
    },
    "Array, RegExp": filterRegExp,
    "Matrix, RegExp": function MatrixRegExp(x, test) {
      return x.create(filterRegExp(x.toArray(), test));
    }
  });
  return filterTransform;
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/forEach.transform.js
var name287 = "forEach";
var dependencies287 = ["typed"];
var createForEachTransform = factory(name287, dependencies287, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  function forEachTransform(args, math, scope3) {
    var x, callback;
    if (args[0]) {
      x = args[0].compile().evaluate(scope3);
    }
    if (args[1]) {
      if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
        callback = args[1].compile().evaluate(scope3);
      } else {
        callback = compileInlineExpression(args[1], math, scope3);
      }
    }
    return _forEach2(x, callback);
  }
  forEachTransform.rawArgs = true;
  var _forEach2 = typed2("forEach", {
    "Array | Matrix, function": function ArrayMatrixFunction(array58, callback) {
      var args = maxArgumentCount(callback);
      var recurse = function recurse(value, index) {
        if (Array.isArray(value)) {
          forEach(value, function(child, i2) {
            recurse(child, index.concat(i2 + 1));
          });
        } else {
          if (args === 1) {
            callback(value);
          } else if (args === 2) {
            callback(value, index);
          } else {
            callback(value, index, array58);
          }
        }
      };
      recurse(array58.valueOf(), []);
    }
  });
  return forEachTransform;
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/index.transform.js
var name288 = "index";
var dependencies288 = ["Index"];
var createIndexTransform = factory(name288, dependencies288, (_ref) => {
  var {
    Index
  } = _ref;
  return function indexTransform() {
    var args = [];
    for (var i2 = 0, ii = arguments.length;i2 < ii; i2++) {
      var arg2 = arguments[i2];
      if (isRange(arg2)) {
        arg2.start--;
        arg2.end -= arg2.step > 0 ? 0 : 2;
      } else if (arg2 && arg2.isSet === true) {
        arg2 = arg2.map(function(v) {
          return v - 1;
        });
      } else if (isArray(arg2) || isMatrix(arg2)) {
        arg2 = arg2.map(function(v) {
          return v - 1;
        });
      } else if (isNumber(arg2)) {
        arg2--;
      } else if (isBigNumber(arg2)) {
        arg2 = arg2.toNumber() - 1;
      } else if (typeof arg2 === "string") {
      } else {
        throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      }
      args[i2] = arg2;
    }
    var res = new Index;
    Index.apply(res, args);
    return res;
  };
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/map.transform.js
var _map2 = function(array59, callback, orig) {
  var argsCount = maxArgumentCount(callback);
  function recurse(value, index) {
    if (Array.isArray(value)) {
      return map(value, function(child, i2) {
        return recurse(child, index.concat(i2 + 1));
      });
    } else {
      if (argsCount === 1) {
        return callback(value);
      } else if (argsCount === 2) {
        return callback(value, index);
      } else {
        return callback(value, index, orig);
      }
    }
  }
  return recurse(array59, []);
};
var name289 = "map";
var dependencies289 = ["typed"];
var createMapTransform = factory(name289, dependencies289, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  function mapTransform(args, math, scope3) {
    var x, callback;
    if (args[0]) {
      x = args[0].compile().evaluate(scope3);
    }
    if (args[1]) {
      if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
        callback = args[1].compile().evaluate(scope3);
      } else {
        callback = compileInlineExpression(args[1], math, scope3);
      }
    }
    return map10(x, callback);
  }
  mapTransform.rawArgs = true;
  var map10 = typed2("map", {
    "Array, function": function ArrayFunction(x, callback) {
      return _map2(x, callback, x);
    },
    "Matrix, function": function MatrixFunction(x, callback) {
      return x.create(_map2(x.valueOf(), callback, x));
    }
  });
  return mapTransform;
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/utils/lastDimToZeroBase.js
function lastDimToZeroBase(args) {
  if (args.length === 2 && isCollection(args[0])) {
    args = args.slice();
    var dim = args[1];
    if (isNumber(dim)) {
      args[1] = dim - 1;
    } else if (isBigNumber(dim)) {
      args[1] = dim.minus(1);
    }
  }
  return args;
}

// ../../node_modules/mathjs/lib/esm/expression/transform/max.transform.js
var name290 = "max";
var dependencies290 = ["typed", "config", "numeric", "larger"];
var createMaxTransform = factory(name290, dependencies290, (_ref) => {
  var {
    typed: typed2,
    config: config7,
    numeric: numeric3,
    larger: larger2
  } = _ref;
  var max4 = createMax({
    typed: typed2,
    config: config7,
    numeric: numeric3,
    larger: larger2
  });
  return typed2("max", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return max4.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/mean.transform.js
var name291 = "mean";
var dependencies291 = ["typed", "add", "divide"];
var createMeanTransform = factory(name291, dependencies291, (_ref) => {
  var {
    typed: typed2,
    add: add3,
    divide: divide3
  } = _ref;
  var mean3 = createMean({
    typed: typed2,
    add: add3,
    divide: divide3
  });
  return typed2("mean", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return mean3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/min.transform.js
var name292 = "min";
var dependencies292 = ["typed", "config", "numeric", "smaller"];
var createMinTransform = factory(name292, dependencies292, (_ref) => {
  var {
    typed: typed2,
    config: config7,
    numeric: numeric3,
    smaller: smaller2
  } = _ref;
  var min4 = createMin({
    typed: typed2,
    config: config7,
    numeric: numeric3,
    smaller: smaller2
  });
  return typed2("min", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return min4.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/range.transform.js
var name293 = "range";
var dependencies293 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq"];
var createRangeTransform = factory(name293, dependencies293, (_ref) => {
  var {
    typed: typed2,
    config: config7,
    matrix: matrix2,
    bignumber: bignumber2,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2,
    largerEq: largerEq2
  } = _ref;
  var range3 = createRange({
    typed: typed2,
    config: config7,
    matrix: matrix2,
    bignumber: bignumber2,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2,
    largerEq: largerEq2
  });
  return typed2("range", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (typeof last !== "boolean") {
        args.push(true);
      }
      return range3.apply(null, args);
    }
  });
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/row.transform.js
var name294 = "row";
var dependencies294 = ["typed", "Index", "matrix", "range"];
var createRowTransform = factory(name294, dependencies294, (_ref) => {
  var {
    typed: typed2,
    Index,
    matrix: matrix2,
    range: range3
  } = _ref;
  var row3 = createRow({
    typed: typed2,
    Index,
    matrix: matrix2,
    range: range3
  });
  return typed2("row", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      }
      try {
        return row3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/subset.transform.js
var name295 = "subset";
var dependencies295 = ["typed", "matrix"];
var createSubsetTransform = factory(name295, dependencies295, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  var subset3 = createSubset({
    typed: typed2,
    matrix: matrix2
  });
  return typed2("subset", {
    "...any": function any(args) {
      try {
        return subset3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/concat.transform.js
var name296 = "concat";
var dependencies296 = ["typed", "matrix", "isInteger"];
var createConcatTransform = factory(name296, dependencies296, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    isInteger: isInteger3
  } = _ref;
  var concat3 = createConcat({
    typed: typed2,
    matrix: matrix2,
    isInteger: isInteger3
  });
  return typed2("concat", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      } else if (isBigNumber(last)) {
        args[lastIndex] = last.minus(1);
      }
      try {
        return concat3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/diff.transform.js
var name297 = "diff";
var dependencies297 = ["typed", "matrix", "subtract", "number", "bignumber"];
var createDiffTransform = factory(name297, dependencies297, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    number: number101,
    bignumber: bignumber2
  } = _ref;
  var diff3 = createDiff({
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    number: number101,
    bignumber: bignumber2
  });
  return typed2(name297, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return diff3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/std.transform.js
var name298 = "std";
var dependencies298 = ["typed", "map", "sqrt", "variance"];
var createStdTransform = factory(name298, dependencies298, (_ref) => {
  var {
    typed: typed2,
    map: map10,
    sqrt: sqrt3,
    variance: variance2
  } = _ref;
  var std3 = createStd({
    typed: typed2,
    map: map10,
    sqrt: sqrt3,
    variance: variance2
  });
  return typed2("std", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return std3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/sum.transform.js
var name299 = "sum";
var dependencies299 = ["typed", "config", "add", "numeric"];
var createSumTransform = factory(name299, dependencies299, (_ref) => {
  var {
    typed: typed2,
    config: config7,
    add: add3,
    numeric: numeric3
  } = _ref;
  var sum4 = createSum({
    typed: typed2,
    config: config7,
    add: add3,
    numeric: numeric3
  });
  return typed2(name299, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return sum4.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/cumsum.transform.js
var name300 = "cumsum";
var dependencies300 = ["typed", "add", "unaryPlus"];
var createCumSumTransform = factory(name300, dependencies300, (_ref) => {
  var {
    typed: typed2,
    add: add3,
    unaryPlus: unaryPlus2
  } = _ref;
  var cumsum3 = createCumSum({
    typed: typed2,
    add: add3,
    unaryPlus: unaryPlus2
  });
  return typed2(name300, {
    "...any": function any(args) {
      if (args.length === 2 && isCollection(args[0])) {
        var dim = args[1];
        if (isNumber(dim)) {
          args[1] = dim - 1;
        } else if (isBigNumber(dim)) {
          args[1] = dim.minus(1);
        }
      }
      try {
        return cumsum3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/expression/transform/variance.transform.js
var name301 = "variance";
var dependencies301 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
var createVarianceTransform = factory(name301, dependencies301, (_ref) => {
  var {
    typed: typed2,
    add: add3,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide3,
    apply: apply2,
    isNaN: isNaN3
  } = _ref;
  var variance3 = createVariance({
    typed: typed2,
    add: add3,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide3,
    apply: apply2,
    isNaN: isNaN3
  });
  return typed2(name301, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return variance3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// ../../node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js
var BigNumber = createBigNumberClass({
  config: config3
});
var Complex2 = createComplexClass({});
var e3 = createE({
  BigNumber,
  config: config3
});
var _false = createFalse({});
var fineStructure = createFineStructure({
  BigNumber,
  config: config3
});
var Fraction2 = createFractionClass({});
var i2 = createI({
  Complex: Complex2
});
var _Infinity = createInfinity({
  BigNumber,
  config: config3
});
var LN103 = createLN10({
  BigNumber,
  config: config3
});
var LOG10E2 = createLOG10E({
  BigNumber,
  config: config3
});
var Matrix = createMatrixClass({});
var _NaN = createNaN({
  BigNumber,
  config: config3
});
var _null = createNull({});
var phi3 = createPhi({
  BigNumber,
  config: config3
});
var Range = createRangeClass({});
var ResultSet = createResultSet({});
var SQRT1_22 = createSQRT1_2({
  BigNumber,
  config: config3
});
var sackurTetrode = createSackurTetrode({
  BigNumber,
  config: config3
});
var tau3 = createTau({
  BigNumber,
  config: config3
});
var _true = createTrue({});
var version5 = createVersion({});
var DenseMatrix = createDenseMatrixClass({
  Matrix
});
var efimovFactor = createEfimovFactor({
  BigNumber,
  config: config3
});
var LN22 = createLN2({
  BigNumber,
  config: config3
});
var pi3 = createPi({
  BigNumber,
  config: config3
});
var replacer = createReplacer({});
var SQRT22 = createSQRT2({
  BigNumber,
  config: config3
});
var typed2 = createTyped({
  BigNumber,
  Complex: Complex2,
  DenseMatrix,
  Fraction: Fraction2
});
var unaryPlus2 = createUnaryPlus({
  BigNumber,
  config: config3,
  typed: typed2
});
var weakMixingAngle = createWeakMixingAngle({
  BigNumber,
  config: config3
});
var abs3 = createAbs({
  typed: typed2
});
var acos3 = createAcos({
  Complex: Complex2,
  config: config3,
  typed: typed2
});
var acot2 = createAcot({
  BigNumber,
  typed: typed2
});
var acsc2 = createAcsc({
  BigNumber,
  Complex: Complex2,
  config: config3,
  typed: typed2
});
var addScalar = createAddScalar({
  typed: typed2
});
var arg2 = createArg({
  typed: typed2
});
var asech2 = createAsech({
  BigNumber,
  Complex: Complex2,
  config: config3,
  typed: typed2
});
var asinh4 = createAsinh({
  typed: typed2
});
var atan5 = createAtan({
  typed: typed2
});
var atanh4 = createAtanh({
  Complex: Complex2,
  config: config3,
  typed: typed2
});
var bignumber2 = createBignumber({
  BigNumber,
  typed: typed2
});
var bitNot2 = createBitNot({
  typed: typed2
});
var boolean2 = createBoolean({
  typed: typed2
});
var clone4 = createClone({
  typed: typed2
});
var combinations3 = createCombinations({
  typed: typed2
});
var complex3 = createComplex({
  Complex: Complex2,
  typed: typed2
});
var conj2 = createConj({
  typed: typed2
});
var cosh4 = createCosh({
  typed: typed2
});
var coth2 = createCoth({
  BigNumber,
  typed: typed2
});
var csc2 = createCsc({
  BigNumber,
  typed: typed2
});
var cube2 = createCube({
  typed: typed2
});
var equalScalar = createEqualScalar({
  config: config3,
  typed: typed2
});
var erf2 = createErf({
  typed: typed2
});
var exp3 = createExp({
  typed: typed2
});
var expm14 = createExpm1({
  Complex: Complex2,
  typed: typed2
});
var filter3 = createFilter({
  typed: typed2
});
var forEach3 = createForEach({
  typed: typed2
});
var format5 = createFormat({
  typed: typed2
});
var getMatrixDataType2 = createGetMatrixDataType({
  typed: typed2
});
var hex2 = createHex({
  format: format5,
  typed: typed2
});
var im2 = createIm({
  typed: typed2
});
var isInteger3 = createIsInteger({
  typed: typed2
});
var isNegative2 = createIsNegative({
  typed: typed2
});
var isPositive2 = createIsPositive({
  typed: typed2
});
var isZero2 = createIsZero({
  typed: typed2
});
var LOG2E2 = createLOG2E({
  BigNumber,
  config: config3
});
var lgamma2 = createLgamma({
  Complex: Complex2,
  typed: typed2
});
var log105 = createLog10({
  Complex: Complex2,
  config: config3,
  typed: typed2
});
var log25 = createLog2({
  Complex: Complex2,
  config: config3,
  typed: typed2
});
var map10 = createMap2({
  typed: typed2
});
var multiplyScalar = createMultiplyScalar({
  typed: typed2
});
var not2 = createNot({
  typed: typed2
});
var number101 = createNumber({
  typed: typed2
});
var oct2 = createOct({
  format: format5,
  typed: typed2
});
var pickRandom2 = createPickRandom({
  config: config3,
  typed: typed2
});
var print2 = createPrint({
  typed: typed2
});
var random3 = createRandom({
  config: config3,
  typed: typed2
});
var re2 = createRe({
  typed: typed2
});
var sec2 = createSec({
  BigNumber,
  typed: typed2
});
var sign4 = createSign({
  BigNumber,
  Fraction: Fraction2,
  complex: complex3,
  typed: typed2
});
var sin3 = createSin({
  typed: typed2
});
var SparseMatrix = createSparseMatrixClass({
  Matrix,
  equalScalar,
  typed: typed2
});
var splitUnit2 = createSplitUnit({
  typed: typed2
});
var square2 = createSquare({
  typed: typed2
});
var string29 = createString({
  typed: typed2
});
var tan3 = createTan({
  typed: typed2
});
var typeOf3 = createTypeOf({
  typed: typed2
});
var acosh4 = createAcosh({
  Complex: Complex2,
  config: config3,
  typed: typed2
});
var acsch2 = createAcsch({
  BigNumber,
  typed: typed2
});
var apply2 = createApply({
  isInteger: isInteger3,
  typed: typed2
});
var asec2 = createAsec({
  BigNumber,
  Complex: Complex2,
  config: config3,
  typed: typed2
});
var bin2 = createBin({
  format: format5,
  typed: typed2
});
var combinationsWithRep2 = createCombinationsWithRep({
  typed: typed2
});
var cos3 = createCos({
  typed: typed2
});
var csch2 = createCsch({
  BigNumber,
  typed: typed2
});
var isNaN3 = createIsNaN({
  typed: typed2
});
var isPrime2 = createIsPrime({
  typed: typed2
});
var randomInt2 = createRandomInt({
  config: config3,
  typed: typed2
});
var sech2 = createSech({
  BigNumber,
  typed: typed2
});
var sinh4 = createSinh({
  typed: typed2
});
var sparse2 = createSparse({
  SparseMatrix,
  typed: typed2
});
var sqrt3 = createSqrt({
  Complex: Complex2,
  config: config3,
  typed: typed2
});
var tanh4 = createTanh({
  typed: typed2
});
var unaryMinus2 = createUnaryMinus({
  typed: typed2
});
var acoth2 = createAcoth({
  BigNumber,
  Complex: Complex2,
  config: config3,
  typed: typed2
});
var cot2 = createCot({
  BigNumber,
  typed: typed2
});
var fraction2 = createFraction({
  Fraction: Fraction2,
  typed: typed2
});
var isNumeric2 = createIsNumeric({
  typed: typed2
});
var matrix2 = createMatrix({
  DenseMatrix,
  Matrix,
  SparseMatrix,
  typed: typed2
});
var matrixFromFunction2 = createMatrixFromFunction({
  isZero: isZero2,
  matrix: matrix2,
  typed: typed2
});
var mode2 = createMode({
  isNaN: isNaN3,
  isNumeric: isNumeric2,
  typed: typed2
});
var numeric3 = createNumeric({
  bignumber: bignumber2,
  fraction: fraction2,
  number: number101
});
var prod2 = createProd({
  config: config3,
  multiplyScalar,
  numeric: numeric3,
  typed: typed2
});
var reshape3 = createReshape({
  isInteger: isInteger3,
  matrix: matrix2,
  typed: typed2
});
var size2 = createSize({
  matrix: matrix2,
  config: config3,
  typed: typed2
});
var squeeze3 = createSqueeze({
  matrix: matrix2,
  typed: typed2
});
var subset3 = createSubset({
  matrix: matrix2,
  typed: typed2
});
var transpose2 = createTranspose({
  matrix: matrix2,
  typed: typed2
});
var xgcd2 = createXgcd({
  BigNumber,
  config: config3,
  matrix: matrix2,
  typed: typed2
});
var zeros3 = createZeros({
  BigNumber,
  config: config3,
  matrix: matrix2,
  typed: typed2
});
var asin3 = createAsin({
  Complex: Complex2,
  config: config3,
  typed: typed2
});
var cbrt5 = createCbrt({
  BigNumber,
  Complex: Complex2,
  Fraction: Fraction2,
  config: config3,
  isNegative: isNegative2,
  matrix: matrix2,
  typed: typed2,
  unaryMinus: unaryMinus2
});
var concat3 = createConcat({
  isInteger: isInteger3,
  matrix: matrix2,
  typed: typed2
});
var count2 = createCount({
  prod: prod2,
  size: size2,
  typed: typed2
});
var ctranspose2 = createCtranspose({
  conj: conj2,
  transpose: transpose2,
  typed: typed2
});
var diag2 = createDiag({
  DenseMatrix,
  SparseMatrix,
  matrix: matrix2,
  typed: typed2
});
var divideScalar = createDivideScalar({
  numeric: numeric3,
  typed: typed2
});
var dotDivide2 = createDotDivide({
  DenseMatrix,
  concat: concat3,
  divideScalar,
  equalScalar,
  matrix: matrix2,
  typed: typed2
});
var equal2 = createEqual({
  DenseMatrix,
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  typed: typed2
});
var flatten3 = createFlatten({
  matrix: matrix2,
  typed: typed2
});
var gcd2 = createGcd({
  BigNumber,
  DenseMatrix,
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  typed: typed2
});
var hasNumericValue2 = createHasNumericValue({
  isNumeric: isNumeric2,
  typed: typed2
});
var identity2 = createIdentity({
  BigNumber,
  DenseMatrix,
  SparseMatrix,
  config: config3,
  matrix: matrix2,
  typed: typed2
});
var kron2 = createKron({
  matrix: matrix2,
  multiplyScalar,
  typed: typed2
});
var largerEq2 = createLargerEq({
  DenseMatrix,
  concat: concat3,
  config: config3,
  matrix: matrix2,
  typed: typed2
});
var leftShift2 = createLeftShift({
  DenseMatrix,
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  typed: typed2,
  zeros: zeros3
});
var matrixFromColumns2 = createMatrixFromColumns({
  flatten: flatten3,
  matrix: matrix2,
  size: size2,
  typed: typed2
});
var mod3 = createMod({
  DenseMatrix,
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  typed: typed2
});
var nthRoot2 = createNthRoot({
  BigNumber,
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  typed: typed2
});
var ones2 = createOnes({
  BigNumber,
  config: config3,
  matrix: matrix2,
  typed: typed2
});
var resize3 = createResize({
  config: config3,
  matrix: matrix2
});
var rightArithShift2 = createRightArithShift({
  DenseMatrix,
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  typed: typed2,
  zeros: zeros3
});
var round3 = createRound({
  BigNumber,
  DenseMatrix,
  equalScalar,
  matrix: matrix2,
  typed: typed2,
  zeros: zeros3
});
var smaller2 = createSmaller({
  DenseMatrix,
  concat: concat3,
  config: config3,
  matrix: matrix2,
  typed: typed2
});
var to2 = createTo({
  concat: concat3,
  matrix: matrix2,
  typed: typed2
});
var unequal2 = createUnequal({
  DenseMatrix,
  concat: concat3,
  config: config3,
  equalScalar,
  matrix: matrix2,
  typed: typed2
});
var xor2 = createXor({
  DenseMatrix,
  concat: concat3,
  matrix: matrix2,
  typed: typed2
});
var add3 = createAdd({
  DenseMatrix,
  SparseMatrix,
  addScalar,
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  typed: typed2
});
var bitAnd2 = createBitAnd({
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  typed: typed2
});
var bitXor3 = createBitXor({
  DenseMatrix,
  concat: concat3,
  matrix: matrix2,
  typed: typed2
});
var catalan2 = createCatalan({
  addScalar,
  combinations: combinations3,
  divideScalar,
  isInteger: isInteger3,
  isNegative: isNegative2,
  multiplyScalar,
  typed: typed2
});
var compare2 = createCompare({
  BigNumber,
  DenseMatrix,
  Fraction: Fraction2,
  concat: concat3,
  config: config3,
  equalScalar,
  matrix: matrix2,
  typed: typed2
});
var compareText3 = createCompareText({
  concat: concat3,
  matrix: matrix2,
  typed: typed2
});
var cumsum3 = createCumSum({
  add: add3,
  typed: typed2,
  unaryPlus: unaryPlus2
});
var deepEqual2 = createDeepEqual({
  equal: equal2,
  typed: typed2
});
var dot2 = createDot({
  addScalar,
  conj: conj2,
  multiplyScalar,
  size: size2,
  typed: typed2
});
var equalText2 = createEqualText({
  compareText: compareText3,
  isZero: isZero2,
  typed: typed2
});
var floor3 = createFloor({
  DenseMatrix,
  config: config3,
  equalScalar,
  matrix: matrix2,
  round: round3,
  typed: typed2,
  zeros: zeros3
});
var hypot3 = createHypot({
  abs: abs3,
  addScalar,
  divideScalar,
  isPositive: isPositive2,
  multiplyScalar,
  smaller: smaller2,
  sqrt: sqrt3,
  typed: typed2
});
var ImmutableDenseMatrix = createImmutableDenseMatrixClass({
  DenseMatrix,
  smaller: smaller2
});
var Index = createIndexClass({
  ImmutableDenseMatrix
});
var invmod2 = createInvmod({
  BigNumber,
  add: add3,
  config: config3,
  equal: equal2,
  isInteger: isInteger3,
  mod: mod3,
  smaller: smaller2,
  typed: typed2,
  xgcd: xgcd2
});
var larger2 = createLarger({
  DenseMatrix,
  concat: concat3,
  config: config3,
  matrix: matrix2,
  typed: typed2
});
var log5 = createLog({
  Complex: Complex2,
  config: config3,
  divideScalar,
  typed: typed2
});
var matrixFromRows2 = createMatrixFromRows({
  flatten: flatten3,
  matrix: matrix2,
  size: size2,
  typed: typed2
});
var min4 = createMin({
  config: config3,
  numeric: numeric3,
  smaller: smaller2,
  typed: typed2
});
var multiply2 = createMultiply({
  addScalar,
  dot: dot2,
  equalScalar,
  matrix: matrix2,
  multiplyScalar,
  typed: typed2
});
var nthRoots2 = createNthRoots({
  Complex: Complex2,
  config: config3,
  divideScalar,
  typed: typed2
});
var or2 = createOr({
  DenseMatrix,
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  typed: typed2
});
var partitionSelect2 = createPartitionSelect({
  compare: compare2,
  isNaN: isNaN3,
  isNumeric: isNumeric2,
  typed: typed2
});
var quantileSeq2 = createQuantileSeq({
  add: add3,
  compare: compare2,
  multiply: multiply2,
  partitionSelect: partitionSelect2,
  typed: typed2
});
var rightLogShift2 = createRightLogShift({
  DenseMatrix,
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  typed: typed2,
  zeros: zeros3
});
var smallerEq2 = createSmallerEq({
  DenseMatrix,
  concat: concat3,
  config: config3,
  matrix: matrix2,
  typed: typed2
});
var subtract2 = createSubtract({
  DenseMatrix,
  addScalar,
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  typed: typed2,
  unaryMinus: unaryMinus2
});
var trace2 = createTrace({
  add: add3,
  matrix: matrix2,
  typed: typed2
});
var usolve2 = createUsolve({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix: matrix2,
  multiplyScalar,
  subtract: subtract2,
  typed: typed2
});
var and2 = createAnd({
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  not: not2,
  typed: typed2,
  zeros: zeros3
});
var bitOr2 = createBitOr({
  DenseMatrix,
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  typed: typed2
});
var ceil3 = createCeil({
  DenseMatrix,
  config: config3,
  equalScalar,
  matrix: matrix2,
  round: round3,
  typed: typed2,
  zeros: zeros3
});
var compareNatural2 = createCompareNatural({
  compare: compare2,
  typed: typed2
});
var composition2 = createComposition({
  addScalar,
  combinations: combinations3,
  isInteger: isInteger3,
  isNegative: isNegative2,
  isPositive: isPositive2,
  larger: larger2,
  typed: typed2
});
var cross2 = createCross({
  matrix: matrix2,
  multiply: multiply2,
  subtract: subtract2,
  typed: typed2
});
var det2 = createDet({
  divideScalar,
  isZero: isZero2,
  matrix: matrix2,
  multiply: multiply2,
  subtract: subtract2,
  typed: typed2,
  unaryMinus: unaryMinus2
});
var diff3 = createDiff({
  matrix: matrix2,
  number: number101,
  subtract: subtract2,
  typed: typed2
});
var distance2 = createDistance({
  abs: abs3,
  addScalar,
  divideScalar,
  multiplyScalar,
  sqrt: sqrt3,
  subtract: subtract2,
  typed: typed2,
  unaryMinus: unaryMinus2
});
var dotMultiply2 = createDotMultiply({
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  multiplyScalar,
  typed: typed2
});
var FibonacciHeap = createFibonacciHeapClass({
  larger: larger2,
  smaller: smaller2
});
var fix2 = createFix({
  Complex: Complex2,
  DenseMatrix,
  ceil: ceil3,
  equalScalar,
  floor: floor3,
  matrix: matrix2,
  typed: typed2,
  zeros: zeros3
});
var index = createIndex({
  Index,
  typed: typed2
});
var intersect2 = createIntersect({
  abs: abs3,
  add: add3,
  addScalar,
  config: config3,
  divideScalar,
  equalScalar,
  flatten: flatten3,
  isNumeric: isNumeric2,
  isZero: isZero2,
  matrix: matrix2,
  multiply: multiply2,
  multiplyScalar,
  smaller: smaller2,
  subtract: subtract2,
  typed: typed2
});
var lcm2 = createLcm({
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  typed: typed2
});
var log1p3 = createLog1p({
  Complex: Complex2,
  config: config3,
  divideScalar,
  log: log5,
  typed: typed2
});
var lsolve2 = createLsolve({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix: matrix2,
  multiplyScalar,
  subtract: subtract2,
  typed: typed2
});
var max4 = createMax({
  config: config3,
  larger: larger2,
  numeric: numeric3,
  typed: typed2
});
var qr2 = createQr({
  addScalar,
  complex: complex3,
  conj: conj2,
  divideScalar,
  equal: equal2,
  identity: identity2,
  isZero: isZero2,
  matrix: matrix2,
  multiplyScalar,
  sign: sign4,
  sqrt: sqrt3,
  subtract: subtract2,
  typed: typed2,
  unaryMinus: unaryMinus2,
  zeros: zeros3
});
var range3 = createRange({
  bignumber: bignumber2,
  matrix: matrix2,
  config: config3,
  larger: larger2,
  largerEq: largerEq2,
  smaller: smaller2,
  smallerEq: smallerEq2,
  typed: typed2
});
var row3 = createRow({
  Index,
  matrix: matrix2,
  range: range3,
  typed: typed2
});
var setCartesian2 = createSetCartesian({
  DenseMatrix,
  Index,
  compareNatural: compareNatural2,
  size: size2,
  subset: subset3,
  typed: typed2
});
var setDistinct2 = createSetDistinct({
  DenseMatrix,
  Index,
  compareNatural: compareNatural2,
  size: size2,
  subset: subset3,
  typed: typed2
});
var setIsSubset2 = createSetIsSubset({
  Index,
  compareNatural: compareNatural2,
  size: size2,
  subset: subset3,
  typed: typed2
});
var setPowerset2 = createSetPowerset({
  Index,
  compareNatural: compareNatural2,
  size: size2,
  subset: subset3,
  typed: typed2
});
var slu2 = createSlu({
  SparseMatrix,
  abs: abs3,
  add: add3,
  divideScalar,
  larger: larger2,
  largerEq: largerEq2,
  multiply: multiply2,
  subtract: subtract2,
  transpose: transpose2,
  typed: typed2
});
var Spa = createSpaClass({
  FibonacciHeap,
  addScalar,
  equalScalar
});
var sum4 = createSum({
  add: add3,
  config: config3,
  numeric: numeric3,
  typed: typed2
});
var usolveAll2 = createUsolveAll({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix: matrix2,
  multiplyScalar,
  subtract: subtract2,
  typed: typed2
});
var atan23 = createAtan2({
  BigNumber,
  DenseMatrix,
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  typed: typed2
});
var column3 = createColumn({
  Index,
  matrix: matrix2,
  range: range3,
  typed: typed2
});
var lsolveAll2 = createLsolveAll({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix: matrix2,
  multiplyScalar,
  subtract: subtract2,
  typed: typed2
});
var setDifference2 = createSetDifference({
  DenseMatrix,
  Index,
  compareNatural: compareNatural2,
  size: size2,
  subset: subset3,
  typed: typed2
});
var setMultiplicity2 = createSetMultiplicity({
  Index,
  compareNatural: compareNatural2,
  size: size2,
  subset: subset3,
  typed: typed2
});
var setSymDifference2 = createSetSymDifference({
  Index,
  concat: concat3,
  setDifference: setDifference2,
  size: size2,
  subset: subset3,
  typed: typed2
});
var sort2 = createSort({
  compare: compare2,
  compareNatural: compareNatural2,
  matrix: matrix2,
  typed: typed2
});
var inv2 = createInv({
  abs: abs3,
  addScalar,
  det: det2,
  divideScalar,
  identity: identity2,
  matrix: matrix2,
  multiply: multiply2,
  typed: typed2,
  unaryMinus: unaryMinus2
});
var lup2 = createLup({
  DenseMatrix,
  Spa,
  SparseMatrix,
  abs: abs3,
  addScalar,
  divideScalar,
  equalScalar,
  larger: larger2,
  matrix: matrix2,
  multiplyScalar,
  subtract: subtract2,
  typed: typed2,
  unaryMinus: unaryMinus2
});
var pinv2 = createPinv({
  Complex: Complex2,
  add: add3,
  ctranspose: ctranspose2,
  deepEqual: deepEqual2,
  divideScalar,
  dot: dot2,
  dotDivide: dotDivide2,
  equal: equal2,
  inv: inv2,
  matrix: matrix2,
  multiply: multiply2,
  typed: typed2
});
var pow3 = createPow({
  Complex: Complex2,
  config: config3,
  fraction: fraction2,
  identity: identity2,
  inv: inv2,
  matrix: matrix2,
  multiply: multiply2,
  number: number101,
  typed: typed2
});
var setIntersect2 = createSetIntersect({
  DenseMatrix,
  Index,
  compareNatural: compareNatural2,
  size: size2,
  subset: subset3,
  typed: typed2
});
var setUnion2 = createSetUnion({
  Index,
  concat: concat3,
  setIntersect: setIntersect2,
  setSymDifference: setSymDifference2,
  size: size2,
  subset: subset3,
  typed: typed2
});
var sqrtm2 = createSqrtm({
  abs: abs3,
  add: add3,
  identity: identity2,
  inv: inv2,
  map: map10,
  max: max4,
  multiply: multiply2,
  size: size2,
  sqrt: sqrt3,
  subtract: subtract2,
  typed: typed2
});
var Unit = createUnitClass({
  BigNumber,
  Complex: Complex2,
  Fraction: Fraction2,
  abs: abs3,
  addScalar,
  config: config3,
  divideScalar,
  equal: equal2,
  fix: fix2,
  format: format5,
  isNumeric: isNumeric2,
  multiplyScalar,
  number: number101,
  pow: pow3,
  round: round3,
  subtract: subtract2
});
var vacuumImpedance = createVacuumImpedance({
  BigNumber,
  Unit,
  config: config3
});
var wienDisplacement = createWienDisplacement({
  BigNumber,
  Unit,
  config: config3
});
var atomicMass = createAtomicMass({
  BigNumber,
  Unit,
  config: config3
});
var bohrMagneton = createBohrMagneton({
  BigNumber,
  Unit,
  config: config3
});
var boltzmann = createBoltzmann({
  BigNumber,
  Unit,
  config: config3
});
var conductanceQuantum = createConductanceQuantum({
  BigNumber,
  Unit,
  config: config3
});
var createUnit2 = createCreateUnit({
  Unit,
  typed: typed2
});
var deuteronMass = createDeuteronMass({
  BigNumber,
  Unit,
  config: config3
});
var dotPow2 = createDotPow({
  DenseMatrix,
  concat: concat3,
  equalScalar,
  matrix: matrix2,
  pow: pow3,
  typed: typed2
});
var electricConstant = createElectricConstant({
  BigNumber,
  Unit,
  config: config3
});
var elementaryCharge = createElementaryCharge({
  BigNumber,
  Unit,
  config: config3
});
var expm2 = createExpm({
  abs: abs3,
  add: add3,
  identity: identity2,
  inv: inv2,
  multiply: multiply2,
  typed: typed2
});
var faraday = createFaraday({
  BigNumber,
  Unit,
  config: config3
});
var fft2 = createFft({
  addScalar,
  ceil: ceil3,
  conj: conj2,
  divideScalar,
  dotDivide: dotDivide2,
  exp: exp3,
  i: i2,
  log2: log25,
  matrix: matrix2,
  multiplyScalar,
  pow: pow3,
  tau: tau3,
  typed: typed2
});
var gamma2 = createGamma({
  BigNumber,
  Complex: Complex2,
  config: config3,
  multiplyScalar,
  pow: pow3,
  typed: typed2
});
var gravitationConstant = createGravitationConstant({
  BigNumber,
  Unit,
  config: config3
});
var hartreeEnergy = createHartreeEnergy({
  BigNumber,
  Unit,
  config: config3
});
var ifft2 = createIfft({
  conj: conj2,
  dotDivide: dotDivide2,
  fft: fft2,
  typed: typed2
});
var klitzing = createKlitzing({
  BigNumber,
  Unit,
  config: config3
});
var loschmidt = createLoschmidt({
  BigNumber,
  Unit,
  config: config3
});
var magneticConstant = createMagneticConstant({
  BigNumber,
  Unit,
  config: config3
});
var molarMass = createMolarMass({
  BigNumber,
  Unit,
  config: config3
});
var molarPlanckConstant = createMolarPlanckConstant({
  BigNumber,
  Unit,
  config: config3
});
var neutronMass = createNeutronMass({
  BigNumber,
  Unit,
  config: config3
});
var nuclearMagneton = createNuclearMagneton({
  BigNumber,
  Unit,
  config: config3
});
var planckCharge = createPlanckCharge({
  BigNumber,
  Unit,
  config: config3
});
var planckLength = createPlanckLength({
  BigNumber,
  Unit,
  config: config3
});
var planckTemperature = createPlanckTemperature({
  BigNumber,
  Unit,
  config: config3
});
var protonMass = createProtonMass({
  BigNumber,
  Unit,
  config: config3
});
var reducedPlanckConstant = createReducedPlanckConstant({
  BigNumber,
  Unit,
  config: config3
});
var rydberg = createRydberg({
  BigNumber,
  Unit,
  config: config3
});
var secondRadiation = createSecondRadiation({
  BigNumber,
  Unit,
  config: config3
});
var speedOfLight = createSpeedOfLight({
  BigNumber,
  Unit,
  config: config3
});
var stefanBoltzmann = createStefanBoltzmann({
  BigNumber,
  Unit,
  config: config3
});
var thomsonCrossSection = createThomsonCrossSection({
  BigNumber,
  Unit,
  config: config3
});
var avogadro = createAvogadro({
  BigNumber,
  Unit,
  config: config3
});
var bohrRadius = createBohrRadius({
  BigNumber,
  Unit,
  config: config3
});
var coulomb = createCoulomb({
  BigNumber,
  Unit,
  config: config3
});
var divide3 = createDivide({
  divideScalar,
  equalScalar,
  inv: inv2,
  matrix: matrix2,
  multiply: multiply2,
  typed: typed2
});
var electronMass = createElectronMass({
  BigNumber,
  Unit,
  config: config3
});
var factorial2 = createFactorial({
  gamma: gamma2,
  typed: typed2
});
var firstRadiation = createFirstRadiation({
  BigNumber,
  Unit,
  config: config3
});
var gasConstant = createGasConstant({
  BigNumber,
  Unit,
  config: config3
});
var inverseConductanceQuantum = createInverseConductanceQuantum({
  BigNumber,
  Unit,
  config: config3
});
var lusolve2 = createLusolve({
  DenseMatrix,
  lsolve: lsolve2,
  lup: lup2,
  matrix: matrix2,
  slu: slu2,
  typed: typed2,
  usolve: usolve2
});
var magneticFluxQuantum = createMagneticFluxQuantum({
  BigNumber,
  Unit,
  config: config3
});
var molarMassC12 = createMolarMassC12({
  BigNumber,
  Unit,
  config: config3
});
var multinomial2 = createMultinomial({
  add: add3,
  divide: divide3,
  factorial: factorial2,
  isInteger: isInteger3,
  isPositive: isPositive2,
  multiply: multiply2,
  typed: typed2
});
var permutations2 = createPermutations({
  factorial: factorial2,
  typed: typed2
});
var planckMass = createPlanckMass({
  BigNumber,
  Unit,
  config: config3
});
var polynomialRoot2 = createPolynomialRoot({
  add: add3,
  cbrt: cbrt5,
  divide: divide3,
  equalScalar,
  im: im2,
  isZero: isZero2,
  multiply: multiply2,
  re: re2,
  sqrt: sqrt3,
  subtract: subtract2,
  typeOf: typeOf3,
  typed: typed2,
  unaryMinus: unaryMinus2
});
var setSize2 = createSetSize({
  compareNatural: compareNatural2,
  typed: typed2
});
var stirlingS22 = createStirlingS2({
  bignumber: bignumber2,
  addScalar,
  combinations: combinations3,
  divideScalar,
  factorial: factorial2,
  isInteger: isInteger3,
  isNegative: isNegative2,
  larger: larger2,
  multiplyScalar,
  number: number101,
  pow: pow3,
  subtract: subtract2,
  typed: typed2
});
var unit2 = createUnitFunction({
  Unit,
  typed: typed2
});
var bellNumbers2 = createBellNumbers({
  addScalar,
  isInteger: isInteger3,
  isNegative: isNegative2,
  stirlingS2: stirlingS22,
  typed: typed2
});
var eigs2 = createEigs({
  abs: abs3,
  add: add3,
  addScalar,
  atan: atan5,
  bignumber: bignumber2,
  column: column3,
  complex: complex3,
  config: config3,
  cos: cos3,
  diag: diag2,
  divideScalar,
  dot: dot2,
  equal: equal2,
  flatten: flatten3,
  im: im2,
  inv: inv2,
  larger: larger2,
  matrix: matrix2,
  matrixFromColumns: matrixFromColumns2,
  multiply: multiply2,
  multiplyScalar,
  number: number101,
  qr: qr2,
  re: re2,
  sin: sin3,
  smaller: smaller2,
  sqrt: sqrt3,
  subtract: subtract2,
  typed: typed2,
  usolve: usolve2,
  usolveAll: usolveAll2
});
var fermiCoupling = createFermiCoupling({
  BigNumber,
  Unit,
  config: config3
});
var gravity = createGravity({
  BigNumber,
  Unit,
  config: config3
});
var kldivergence2 = createKldivergence({
  divide: divide3,
  dotDivide: dotDivide2,
  isNumeric: isNumeric2,
  log: log5,
  map: map10,
  matrix: matrix2,
  multiply: multiply2,
  sum: sum4,
  typed: typed2
});
var mean3 = createMean({
  add: add3,
  divide: divide3,
  typed: typed2
});
var molarVolume = createMolarVolume({
  BigNumber,
  Unit,
  config: config3
});
var planckConstant = createPlanckConstant({
  BigNumber,
  Unit,
  config: config3
});
var quantumOfCirculation = createQuantumOfCirculation({
  BigNumber,
  Unit,
  config: config3
});
var variance3 = createVariance({
  add: add3,
  apply: apply2,
  divide: divide3,
  isNaN: isNaN3,
  multiply: multiply2,
  subtract: subtract2,
  typed: typed2
});
var classicalElectronRadius = createClassicalElectronRadius({
  BigNumber,
  Unit,
  config: config3
});
var median2 = createMedian({
  add: add3,
  compare: compare2,
  divide: divide3,
  partitionSelect: partitionSelect2,
  typed: typed2
});
var planckTime = createPlanckTime({
  BigNumber,
  Unit,
  config: config3
});
var std3 = createStd({
  map: map10,
  sqrt: sqrt3,
  typed: typed2,
  variance: variance3
});
var mad2 = createMad({
  abs: abs3,
  map: map10,
  median: median2,
  subtract: subtract2,
  typed: typed2
});
var norm2 = createNorm({
  abs: abs3,
  add: add3,
  conj: conj2,
  ctranspose: ctranspose2,
  eigs: eigs2,
  equalScalar,
  larger: larger2,
  matrix: matrix2,
  multiply: multiply2,
  pow: pow3,
  smaller: smaller2,
  sqrt: sqrt3,
  typed: typed2
});
var rotationMatrix2 = createRotationMatrix({
  BigNumber,
  DenseMatrix,
  SparseMatrix,
  addScalar,
  config: config3,
  cos: cos3,
  matrix: matrix2,
  multiplyScalar,
  norm: norm2,
  sin: sin3,
  typed: typed2,
  unaryMinus: unaryMinus2
});
var rotate2 = createRotate({
  multiply: multiply2,
  rotationMatrix: rotationMatrix2,
  typed: typed2
});
var schur2 = createSchur({
  identity: identity2,
  matrix: matrix2,
  multiply: multiply2,
  norm: norm2,
  qr: qr2,
  subtract: subtract2,
  typed: typed2
});
var sylvester2 = createSylvester({
  abs: abs3,
  add: add3,
  concat: concat3,
  identity: identity2,
  index,
  lusolve: lusolve2,
  matrix: matrix2,
  matrixFromColumns: matrixFromColumns2,
  multiply: multiply2,
  range: range3,
  schur: schur2,
  subset: subset3,
  subtract: subtract2,
  transpose: transpose2,
  typed: typed2
});
var lyap2 = createLyap({
  matrix: matrix2,
  multiply: multiply2,
  sylvester: sylvester2,
  transpose: transpose2,
  typed: typed2
});

// ../../node_modules/mathjs/lib/esm/entry/impureFunctionsAny.generated.js
var extends6 = __toESM(require_extends(), 1);
var math = {};
var mathWithTransform = {};
var classes = {};
var Node = createNode({
  mathWithTransform
});
var ObjectNode = createObjectNode({
  Node
});
var OperatorNode = createOperatorNode({
  Node
});
var ParenthesisNode = createParenthesisNode({
  Node
});
var RelationalNode = createRelationalNode({
  Node
});
var ArrayNode = createArrayNode({
  Node
});
var BlockNode = createBlockNode({
  Node,
  ResultSet
});
var ConditionalNode = createConditionalNode({
  Node
});
var ConstantNode = createConstantNode({
  Node
});
var RangeNode = createRangeNode({
  Node
});
var reviver = createReviver({
  classes
});
var Chain = createChainClass({
  math,
  typed: typed2
});
var FunctionAssignmentNode = createFunctionAssignmentNode({
  Node,
  typed: typed2
});
var chain = createChain({
  Chain,
  typed: typed2
});
var AccessorNode = createAccessorNode({
  Node,
  subset: subset3
});
var IndexNode = createIndexNode({
  Node,
  size: size2
});
var AssignmentNode = createAssignmentNode({
  matrix: matrix2,
  Node,
  subset: subset3
});
var SymbolNode = createSymbolNode({
  Unit,
  Node,
  math
});
var FunctionNode = createFunctionNode({
  Node,
  SymbolNode,
  math
});
var parse = createParse({
  AccessorNode,
  ArrayNode,
  AssignmentNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  FunctionAssignmentNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  RangeNode,
  RelationalNode,
  SymbolNode,
  config: config3,
  numeric: numeric3,
  typed: typed2
});
var resolve3 = createResolve({
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  parse,
  typed: typed2
});
var simplifyConstant2 = createSimplifyConstant({
  bignumber: bignumber2,
  fraction: fraction2,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  SymbolNode,
  config: config3,
  mathWithTransform,
  matrix: matrix2,
  typed: typed2
});
var compile = createCompile({
  parse,
  typed: typed2
});
var evaluate2 = createEvaluate({
  parse,
  typed: typed2
});
var Help = createHelpClass({
  parse
});
var Parser = createParserClass({
  evaluate: evaluate2
});
var simplifyCore2 = createSimplifyCore({
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add: add3,
  divide: divide3,
  equal: equal2,
  isZero: isZero2,
  multiply: multiply2,
  parse,
  pow: pow3,
  subtract: subtract2,
  typed: typed2
});
var help2 = createHelp({
  Help,
  mathWithTransform,
  typed: typed2
});
var simplify2 = createSimplify({
  bignumber: bignumber2,
  fraction: fraction2,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add: add3,
  config: config3,
  divide: divide3,
  equal: equal2,
  isZero: isZero2,
  mathWithTransform,
  matrix: matrix2,
  multiply: multiply2,
  parse,
  pow: pow3,
  resolve: resolve3,
  simplifyConstant: simplifyConstant2,
  simplifyCore: simplifyCore2,
  subtract: subtract2,
  typed: typed2
});
var symbolicEqual2 = createSymbolicEqual({
  OperatorNode,
  parse,
  simplify: simplify2,
  typed: typed2
});
var derivative2 = createDerivative({
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  config: config3,
  equal: equal2,
  isZero: isZero2,
  numeric: numeric3,
  parse,
  simplify: simplify2,
  typed: typed2
});
var parser = createParser({
  Parser,
  typed: typed2
});
var leafCount2 = createLeafCount({
  parse,
  typed: typed2
});
var rationalize2 = createRationalize({
  bignumber: bignumber2,
  fraction: fraction2,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add: add3,
  config: config3,
  divide: divide3,
  equal: equal2,
  isZero: isZero2,
  mathWithTransform,
  matrix: matrix2,
  multiply: multiply2,
  parse,
  pow: pow3,
  simplify: simplify2,
  simplifyConstant: simplifyConstant2,
  simplifyCore: simplifyCore2,
  subtract: subtract2,
  typed: typed2
});
extends6.default(math, {
  e: e3,
  false: _false,
  fineStructure,
  i: i2,
  Infinity: _Infinity,
  LN10: LN103,
  LOG10E: LOG10E2,
  NaN: _NaN,
  null: _null,
  phi: phi3,
  SQRT1_2: SQRT1_22,
  sackurTetrode,
  tau: tau3,
  true: _true,
  E: e3,
  version: version5,
  efimovFactor,
  LN2: LN22,
  pi: pi3,
  replacer,
  reviver,
  SQRT2: SQRT22,
  typed: typed2,
  unaryPlus: unaryPlus2,
  PI: pi3,
  weakMixingAngle,
  abs: abs3,
  acos: acos3,
  acot: acot2,
  acsc: acsc2,
  addScalar,
  arg: arg2,
  asech: asech2,
  asinh: asinh4,
  atan: atan5,
  atanh: atanh4,
  bignumber: bignumber2,
  bitNot: bitNot2,
  boolean: boolean2,
  clone: clone4,
  combinations: combinations3,
  complex: complex3,
  conj: conj2,
  cosh: cosh4,
  coth: coth2,
  csc: csc2,
  cube: cube2,
  equalScalar,
  erf: erf2,
  exp: exp3,
  expm1: expm14,
  filter: filter3,
  forEach: forEach3,
  format: format5,
  getMatrixDataType: getMatrixDataType2,
  hex: hex2,
  im: im2,
  isInteger: isInteger3,
  isNegative: isNegative2,
  isPositive: isPositive2,
  isZero: isZero2,
  LOG2E: LOG2E2,
  lgamma: lgamma2,
  log10: log105,
  log2: log25,
  map: map10,
  multiplyScalar,
  not: not2,
  number: number101,
  oct: oct2,
  pickRandom: pickRandom2,
  print: print2,
  random: random3,
  re: re2,
  sec: sec2,
  sign: sign4,
  sin: sin3,
  splitUnit: splitUnit2,
  square: square2,
  string: string29,
  tan: tan3,
  typeOf: typeOf3,
  acosh: acosh4,
  acsch: acsch2,
  apply: apply2,
  asec: asec2,
  bin: bin2,
  chain,
  combinationsWithRep: combinationsWithRep2,
  cos: cos3,
  csch: csch2,
  isNaN: isNaN3,
  isPrime: isPrime2,
  randomInt: randomInt2,
  sech: sech2,
  sinh: sinh4,
  sparse: sparse2,
  sqrt: sqrt3,
  tanh: tanh4,
  unaryMinus: unaryMinus2,
  acoth: acoth2,
  cot: cot2,
  fraction: fraction2,
  isNumeric: isNumeric2,
  matrix: matrix2,
  matrixFromFunction: matrixFromFunction2,
  mode: mode2,
  numeric: numeric3,
  prod: prod2,
  reshape: reshape3,
  size: size2,
  squeeze: squeeze3,
  subset: subset3,
  transpose: transpose2,
  xgcd: xgcd2,
  zeros: zeros3,
  asin: asin3,
  cbrt: cbrt5,
  concat: concat3,
  count: count2,
  ctranspose: ctranspose2,
  diag: diag2,
  divideScalar,
  dotDivide: dotDivide2,
  equal: equal2,
  flatten: flatten3,
  gcd: gcd2,
  hasNumericValue: hasNumericValue2,
  identity: identity2,
  kron: kron2,
  largerEq: largerEq2,
  leftShift: leftShift2,
  matrixFromColumns: matrixFromColumns2,
  mod: mod3,
  nthRoot: nthRoot2,
  ones: ones2,
  resize: resize3,
  rightArithShift: rightArithShift2,
  round: round3,
  smaller: smaller2,
  to: to2,
  unequal: unequal2,
  xor: xor2,
  add: add3,
  bitAnd: bitAnd2,
  bitXor: bitXor3,
  catalan: catalan2,
  compare: compare2,
  compareText: compareText3,
  cumsum: cumsum3,
  deepEqual: deepEqual2,
  dot: dot2,
  equalText: equalText2,
  floor: floor3,
  hypot: hypot3,
  invmod: invmod2,
  larger: larger2,
  log: log5,
  matrixFromRows: matrixFromRows2,
  min: min4,
  multiply: multiply2,
  nthRoots: nthRoots2,
  or: or2,
  partitionSelect: partitionSelect2,
  quantileSeq: quantileSeq2,
  rightLogShift: rightLogShift2,
  smallerEq: smallerEq2,
  subtract: subtract2,
  trace: trace2,
  usolve: usolve2,
  and: and2,
  bitOr: bitOr2,
  ceil: ceil3,
  compareNatural: compareNatural2,
  composition: composition2,
  cross: cross2,
  det: det2,
  diff: diff3,
  distance: distance2,
  dotMultiply: dotMultiply2,
  fix: fix2,
  index,
  intersect: intersect2,
  lcm: lcm2,
  log1p: log1p3,
  lsolve: lsolve2,
  max: max4,
  qr: qr2,
  range: range3,
  row: row3,
  setCartesian: setCartesian2,
  setDistinct: setDistinct2,
  setIsSubset: setIsSubset2,
  setPowerset: setPowerset2,
  slu: slu2,
  sum: sum4,
  usolveAll: usolveAll2,
  atan2: atan23,
  column: column3,
  lsolveAll: lsolveAll2,
  setDifference: setDifference2,
  setMultiplicity: setMultiplicity2,
  setSymDifference: setSymDifference2,
  sort: sort2,
  inv: inv2,
  lup: lup2,
  pinv: pinv2,
  pow: pow3,
  setIntersect: setIntersect2,
  setUnion: setUnion2,
  sqrtm: sqrtm2,
  vacuumImpedance,
  wienDisplacement,
  atomicMass,
  bohrMagneton,
  boltzmann,
  conductanceQuantum,
  createUnit: createUnit2,
  deuteronMass,
  dotPow: dotPow2,
  electricConstant,
  elementaryCharge,
  expm: expm2,
  faraday,
  fft: fft2,
  gamma: gamma2,
  gravitationConstant,
  hartreeEnergy,
  ifft: ifft2,
  klitzing,
  loschmidt,
  magneticConstant,
  molarMass,
  molarPlanckConstant,
  neutronMass,
  nuclearMagneton,
  planckCharge,
  planckLength,
  planckTemperature,
  protonMass,
  reducedPlanckConstant,
  rydberg,
  secondRadiation,
  speedOfLight,
  stefanBoltzmann,
  thomsonCrossSection,
  avogadro,
  bohrRadius,
  coulomb,
  divide: divide3,
  electronMass,
  factorial: factorial2,
  firstRadiation,
  gasConstant,
  inverseConductanceQuantum,
  lusolve: lusolve2,
  magneticFluxQuantum,
  molarMassC12,
  multinomial: multinomial2,
  permutations: permutations2,
  planckMass,
  polynomialRoot: polynomialRoot2,
  setSize: setSize2,
  stirlingS2: stirlingS22,
  unit: unit2,
  bellNumbers: bellNumbers2,
  eigs: eigs2,
  fermiCoupling,
  gravity,
  kldivergence: kldivergence2,
  mean: mean3,
  molarVolume,
  planckConstant,
  quantumOfCirculation,
  variance: variance3,
  classicalElectronRadius,
  median: median2,
  parse,
  planckTime,
  resolve: resolve3,
  simplifyConstant: simplifyConstant2,
  std: std3,
  compile,
  evaluate: evaluate2,
  mad: mad2,
  simplifyCore: simplifyCore2,
  help: help2,
  norm: norm2,
  rotationMatrix: rotationMatrix2,
  simplify: simplify2,
  symbolicEqual: symbolicEqual2,
  derivative: derivative2,
  parser,
  rotate: rotate2,
  leafCount: leafCount2,
  rationalize: rationalize2,
  schur: schur2,
  sylvester: sylvester2,
  lyap: lyap2,
  config: config3
});
extends6.default(mathWithTransform, math, {
  filter: createFilterTransform({
    typed: typed2
  }),
  forEach: createForEachTransform({
    typed: typed2
  }),
  map: createMapTransform({
    typed: typed2
  }),
  apply: createApplyTransform({
    isInteger: isInteger3,
    typed: typed2
  }),
  subset: createSubsetTransform({
    matrix: matrix2,
    typed: typed2
  }),
  concat: createConcatTransform({
    isInteger: isInteger3,
    matrix: matrix2,
    typed: typed2
  }),
  max: createMaxTransform({
    config: config3,
    larger: larger2,
    numeric: numeric3,
    typed: typed2
  }),
  sum: createSumTransform({
    add: add3,
    config: config3,
    numeric: numeric3,
    typed: typed2
  }),
  min: createMinTransform({
    config: config3,
    numeric: numeric3,
    smaller: smaller2,
    typed: typed2
  }),
  cumsum: createCumSumTransform({
    add: add3,
    typed: typed2,
    unaryPlus: unaryPlus2
  }),
  diff: createDiffTransform({
    bignumber: bignumber2,
    matrix: matrix2,
    number: number101,
    subtract: subtract2,
    typed: typed2
  }),
  index: createIndexTransform({
    Index
  }),
  range: createRangeTransform({
    bignumber: bignumber2,
    matrix: matrix2,
    config: config3,
    larger: larger2,
    largerEq: largerEq2,
    smaller: smaller2,
    smallerEq: smallerEq2,
    typed: typed2
  }),
  row: createRowTransform({
    Index,
    matrix: matrix2,
    range: range3,
    typed: typed2
  }),
  column: createColumnTransform({
    Index,
    matrix: matrix2,
    range: range3,
    typed: typed2
  }),
  mean: createMeanTransform({
    add: add3,
    divide: divide3,
    typed: typed2
  }),
  variance: createVarianceTransform({
    add: add3,
    apply: apply2,
    divide: divide3,
    isNaN: isNaN3,
    multiply: multiply2,
    subtract: subtract2,
    typed: typed2
  }),
  std: createStdTransform({
    map: map10,
    sqrt: sqrt3,
    typed: typed2,
    variance: variance3
  })
});
extends6.default(classes, {
  BigNumber,
  Complex: Complex2,
  Fraction: Fraction2,
  Matrix,
  Node,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  Range,
  RelationalNode,
  ResultSet,
  ArrayNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  DenseMatrix,
  RangeNode,
  Chain,
  FunctionAssignmentNode,
  SparseMatrix,
  AccessorNode,
  IndexNode,
  AssignmentNode,
  ImmutableDenseMatrix,
  Index,
  FibonacciHeap,
  Spa,
  Unit,
  SymbolNode,
  FunctionNode,
  Help,
  Parser
});
Chain.createProxy(math);

// ../../node_modules/@dice-roller/rpg-dice-roller/lib/esm/bundle.js
var int32 = function(engine) {
  return engine.next() | 0;
};
var add4 = function(distribution, addend) {
  if (addend === 0) {
    return distribution;
  } else {
    return (engine) => distribution(engine) + addend;
  }
};
var int53 = function(engine) {
  const high = engine.next() | 0;
  const low = engine.next() >>> 0;
  return (high & UINT21_MAX) * UINT32_SIZE + low + (high & UINT21_SIZE ? -SMALLEST_UNSAFE_INTEGER : 0);
};
var int53Full = function(engine) {
  while (true) {
    const high = engine.next() | 0;
    if (high & 4194304) {
      if ((high & 8388607) === 4194304 && (engine.next() | 0) === 0) {
        return SMALLEST_UNSAFE_INTEGER;
      }
    } else {
      const low = engine.next() >>> 0;
      return (high & UINT21_MAX) * UINT32_SIZE + low + (high & UINT21_SIZE ? -SMALLEST_UNSAFE_INTEGER : 0);
    }
  }
};
var uint32 = function(engine) {
  return engine.next() >>> 0;
};
var uint53 = function(engine) {
  const high = engine.next() & UINT21_MAX;
  const low = engine.next() >>> 0;
  return high * UINT32_SIZE + low;
};
var uint53Full = function(engine) {
  while (true) {
    const high = engine.next() | 0;
    if (high & UINT21_SIZE) {
      if ((high & UINT21_MAX) === 0 && (engine.next() | 0) === 0) {
        return SMALLEST_UNSAFE_INTEGER;
      }
    } else {
      const low = engine.next() >>> 0;
      return (high & UINT21_MAX) * UINT32_SIZE + low;
    }
  }
};
var isPowerOfTwoMinusOne = function(value) {
  return (value + 1 & value) === 0;
};
var bitmask = function(masking) {
  return (engine) => engine.next() & masking;
};
var downscaleToLoopCheckedRange = function(range4) {
  const extendedRange = range4 + 1;
  const maximum = extendedRange * Math.floor(UINT32_SIZE / extendedRange);
  return (engine) => {
    let value = 0;
    do {
      value = engine.next() >>> 0;
    } while (value >= maximum);
    return value % extendedRange;
  };
};
var downscaleToRange = function(range4) {
  if (isPowerOfTwoMinusOne(range4)) {
    return bitmask(range4);
  } else {
    return downscaleToLoopCheckedRange(range4);
  }
};
var isEvenlyDivisibleByMaxInt32 = function(value) {
  return (value | 0) === 0;
};
var upscaleWithHighMasking = function(masking) {
  return (engine) => {
    const high = engine.next() & masking;
    const low = engine.next() >>> 0;
    return high * UINT32_SIZE + low;
  };
};
var upscaleToLoopCheckedRange = function(extendedRange) {
  const maximum = extendedRange * Math.floor(SMALLEST_UNSAFE_INTEGER / extendedRange);
  return (engine) => {
    let ret = 0;
    do {
      const high = engine.next() & UINT21_MAX;
      const low = engine.next() >>> 0;
      ret = high * UINT32_SIZE + low;
    } while (ret >= maximum);
    return ret % extendedRange;
  };
};
var upscaleWithinU53 = function(range4) {
  const extendedRange = range4 + 1;
  if (isEvenlyDivisibleByMaxInt32(extendedRange)) {
    const highRange = (extendedRange / UINT32_SIZE | 0) - 1;
    if (isPowerOfTwoMinusOne(highRange)) {
      return upscaleWithHighMasking(highRange);
    }
  }
  return upscaleToLoopCheckedRange(extendedRange);
};
var upscaleWithinI53AndLoopCheck = function(min5, max5) {
  return (engine) => {
    let ret = 0;
    do {
      const high = engine.next() | 0;
      const low = engine.next() >>> 0;
      ret = (high & UINT21_MAX) * UINT32_SIZE + low + (high & UINT21_SIZE ? -SMALLEST_UNSAFE_INTEGER : 0);
    } while (ret < min5 || ret > max5);
    return ret;
  };
};
var integer = function(min5, max5) {
  min5 = Math.floor(min5);
  max5 = Math.floor(max5);
  if (min5 < -SMALLEST_UNSAFE_INTEGER || !isFinite(min5)) {
    throw new RangeError(`Expected min to be at least ${-SMALLEST_UNSAFE_INTEGER}`);
  } else if (max5 > SMALLEST_UNSAFE_INTEGER || !isFinite(max5)) {
    throw new RangeError(`Expected max to be at most ${SMALLEST_UNSAFE_INTEGER}`);
  }
  const range4 = max5 - min5;
  if (range4 <= 0 || !isFinite(range4)) {
    return () => min5;
  } else if (range4 === UINT32_MAX) {
    if (min5 === 0) {
      return uint32;
    } else {
      return add4(int32, min5 + INT32_SIZE);
    }
  } else if (range4 < UINT32_MAX) {
    return add4(downscaleToRange(range4), min5);
  } else if (range4 === LARGEST_SAFE_INTEGER) {
    return add4(uint53, min5);
  } else if (range4 < LARGEST_SAFE_INTEGER) {
    return add4(upscaleWithinU53(range4), min5);
  } else if (max5 - 1 - min5 === LARGEST_SAFE_INTEGER) {
    return add4(uint53Full, min5);
  } else if (min5 === -SMALLEST_UNSAFE_INTEGER && max5 === SMALLEST_UNSAFE_INTEGER) {
    return int53Full;
  } else if (min5 === -SMALLEST_UNSAFE_INTEGER && max5 === LARGEST_SAFE_INTEGER) {
    return int53;
  } else if (min5 === -LARGEST_SAFE_INTEGER && max5 === SMALLEST_UNSAFE_INTEGER) {
    return add4(int53, 1);
  } else if (max5 === SMALLEST_UNSAFE_INTEGER) {
    return add4(upscaleWithinI53AndLoopCheck(min5 - 1, max5 - 1), 1);
  } else {
    return upscaleWithinI53AndLoopCheck(min5, max5);
  }
};
var isLeastBitTrue = function(engine) {
  return (engine.next() & 1) === 1;
};
var lessThan = function(distribution, value) {
  return (engine) => distribution(engine) < value;
};
var probability = function(percentage) {
  if (percentage <= 0) {
    return () => false;
  } else if (percentage >= 1) {
    return () => true;
  } else {
    const scaled = percentage * UINT32_SIZE;
    if (scaled % 1 === 0) {
      return lessThan(int32, scaled - INT32_SIZE | 0);
    } else {
      return lessThan(uint53, Math.round(percentage * SMALLEST_UNSAFE_INTEGER));
    }
  }
};
var bool = function(numerator, denominator) {
  if (denominator == null) {
    if (numerator == null) {
      return isLeastBitTrue;
    }
    return probability(numerator);
  } else {
    if (numerator <= 0) {
      return () => false;
    } else if (numerator >= denominator) {
      return () => true;
    }
    return lessThan(integer(0, denominator - 1), numerator);
  }
};
var date = function(start, end) {
  const distribution = integer(+start, +end);
  return (engine) => new Date(distribution(engine));
};
var die = function(sideCount) {
  return integer(1, sideCount);
};
var dice = function(sideCount, dieCount) {
  const distribution = die(sideCount);
  return (engine) => {
    const result = [];
    for (let i3 = 0;i3 < dieCount; ++i3) {
      result.push(distribution(engine));
    }
    return result;
  };
};
var string30 = function(pool = DEFAULT_STRING_POOL) {
  const poolLength = pool.length;
  if (!poolLength) {
    throw new Error("Expected pool not to be an empty string");
  }
  const distribution = integer(0, poolLength - 1);
  return (engine, length) => {
    let result = "";
    for (let i3 = 0;i3 < length; ++i3) {
      const j = distribution(engine);
      result += pool.charAt(j);
    }
    return result;
  };
};
var hex3 = function(uppercase) {
  if (uppercase) {
    return upperHex;
  } else {
    return lowerHex;
  }
};
var convertSliceArgument = function(value, length) {
  if (value < 0) {
    return Math.max(value + length, 0);
  } else {
    return Math.min(value, length);
  }
};
var toInteger = function(value) {
  const num = +value;
  if (num < 0) {
    return Math.ceil(num);
  } else {
    return Math.floor(num);
  }
};
var pick = function(engine, source, begin, end) {
  const length = source.length;
  if (length === 0) {
    throw new RangeError("Cannot pick from an empty array");
  }
  const start = begin == null ? 0 : convertSliceArgument(toInteger(begin), length);
  const finish = end === undefined ? length : convertSliceArgument(toInteger(end), length);
  if (start >= finish) {
    throw new RangeError(`Cannot pick between bounds ${start} and ${finish}`);
  }
  const distribution = integer(start, finish - 1);
  return source[distribution(engine)];
};
var multiply3 = function(distribution, multiplier) {
  if (multiplier === 1) {
    return distribution;
  } else if (multiplier === 0) {
    return () => 0;
  } else {
    return (engine) => distribution(engine) * multiplier;
  }
};
var realZeroToOneExclusive = function(engine) {
  return uint53(engine) / SMALLEST_UNSAFE_INTEGER;
};
var realZeroToOneInclusive = function(engine) {
  return uint53Full(engine) / SMALLEST_UNSAFE_INTEGER;
};
var real = function(min5, max5, inclusive = false) {
  if (!isFinite(min5)) {
    throw new RangeError("Expected min to be a finite number");
  } else if (!isFinite(max5)) {
    throw new RangeError("Expected max to be a finite number");
  }
  return add4(multiply3(inclusive ? realZeroToOneInclusive : realZeroToOneExclusive, max5 - min5), min5);
};
var shuffle = function(engine, array59, downTo = 0) {
  const length = array59.length;
  if (length) {
    for (let i3 = length - 1 >>> 0;i3 > downTo; --i3) {
      const distribution = integer(0, i3);
      const j = distribution(engine);
      if (i3 !== j) {
        const tmp = array59[i3];
        array59[i3] = array59[j];
        array59[j] = tmp;
      }
    }
  }
  return array59;
};
var sample = function(engine, population, sampleSize) {
  if (sampleSize < 0 || sampleSize > population.length || !isFinite(sampleSize)) {
    throw new RangeError("Expected sampleSize to be within 0 and the length of the population");
  }
  if (sampleSize === 0) {
    return [];
  }
  const clone5 = sliceArray.call(population);
  const length = clone5.length;
  if (length === sampleSize) {
    return shuffle(engine, clone5, 0);
  }
  const tailLength = length - sampleSize;
  return shuffle(engine, clone5, tailLength - 1).slice(tailLength);
};
var zeroPad = function(text, zeroCount) {
  return stringRepeat("0", zeroCount - text.length) + text;
};
var uuid4 = function(engine) {
  const a = engine.next() >>> 0;
  const b = engine.next() | 0;
  const c = engine.next() | 0;
  const d = engine.next() >>> 0;
  return zeroPad(a.toString(16), 8) + "-" + zeroPad((b & 65535).toString(16), 4) + "-" + zeroPad((b >> 4 & 4095 | 16384).toString(16), 4) + "-" + zeroPad((c & 16383 | 32768).toString(16), 4) + "-" + zeroPad((c >> 4 & 65535).toString(16), 4) + zeroPad(d.toString(16), 8);
};
var createEntropy = function(engine = nativeMath, length = 16) {
  const array59 = [];
  array59.push(new Date().getTime() | 0);
  for (let i3 = 1;i3 < length; ++i3) {
    array59[i3] = engine.next() | 0;
  }
  return array59;
};
var refreshData = function(data) {
  let k = 0;
  let tmp = 0;
  for (;(k | 0) < ARRAY_SIZE_MINUS_M; k = k + 1 | 0) {
    tmp = data[k] & INT32_SIZE | data[k + 1 | 0] & INT32_MAX;
    data[k] = data[k + M | 0] ^ tmp >>> 1 ^ (tmp & 1 ? A : 0);
  }
  for (;(k | 0) < ARRAY_MAX; k = k + 1 | 0) {
    tmp = data[k] & INT32_SIZE | data[k + 1 | 0] & INT32_MAX;
    data[k] = data[k - ARRAY_SIZE_MINUS_M | 0] ^ tmp >>> 1 ^ (tmp & 1 ? A : 0);
  }
  tmp = data[ARRAY_MAX] & INT32_SIZE | data[0] & INT32_MAX;
  data[ARRAY_MAX] = data[M - 1] ^ tmp >>> 1 ^ (tmp & 1 ? A : 0);
};
var temper = function(value) {
  value ^= value >>> 11;
  value ^= value << 7 & 2636928640;
  value ^= value << 15 & 4022730752;
  return value ^ value >>> 18;
};
var seedWithArray = function(data, source) {
  let i3 = 1;
  let j = 0;
  const sourceLength = source.length;
  let k = Math.max(sourceLength, ARRAY_SIZE) | 0;
  let previous = data[0] | 0;
  for (;(k | 0) > 0; --k) {
    data[i3] = previous = (data[i3] ^ imul(previous ^ previous >>> 30, 1664525)) + (source[j] | 0) + (j | 0) | 0;
    i3 = i3 + 1 | 0;
    ++j;
    if ((i3 | 0) > ARRAY_MAX) {
      data[0] = data[ARRAY_MAX];
      i3 = 1;
    }
    if (j >= sourceLength) {
      j = 0;
    }
  }
  for (k = ARRAY_MAX;(k | 0) > 0; --k) {
    data[i3] = previous = (data[i3] ^ imul(previous ^ previous >>> 30, 1566083941)) - i3 | 0;
    i3 = i3 + 1 | 0;
    if ((i3 | 0) > ARRAY_MAX) {
      data[0] = data[ARRAY_MAX];
      i3 = 1;
    }
  }
  data[0] = INT32_SIZE;
};
var peg$subclass = function(child, parent) {
  function C() {
    this.constructor = child;
  }
  C.prototype = parent.prototype;
  child.prototype = new C;
};
var peg$SyntaxError = function(message, expected, found, location) {
  var self2 = Error.call(this, message);
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
  }
  self2.expected = expected;
  self2.found = found;
  self2.location = location;
  self2.name = "SyntaxError";
  return self2;
};
var peg$padEnd = function(str, targetLength, padString) {
  padString = padString || " ";
  if (str.length > targetLength) {
    return str;
  }
  targetLength -= str.length;
  padString += padString.repeat(targetLength);
  return str + padString.slice(0, targetLength);
};
var peg$parse = function(input, options) {
  options = options !== undefined ? options : {};
  var peg$FAILED = {};
  var peg$source = options.grammarSource;
  var peg$startRuleFunctions = { Main: peg$parseMain };
  var peg$startRuleFunction = peg$parseMain;
  var peg$c0 = "{";
  var peg$c1 = ",";
  var peg$c2 = "}";
  var peg$c3 = "d";
  var peg$c4 = "d%";
  var peg$c5 = "dF";
  var peg$c6 = ".";
  var peg$c7 = "!";
  var peg$c8 = "p";
  var peg$c9 = "k";
  var peg$c10 = "max";
  var peg$c11 = "min";
  var peg$c12 = "r";
  var peg$c13 = "o";
  var peg$c14 = "u";
  var peg$c15 = "cs";
  var peg$c16 = "cf";
  var peg$c17 = "s";
  var peg$c18 = "a";
  var peg$c19 = "f";
  var peg$c20 = "!=";
  var peg$c21 = "<=";
  var peg$c22 = ">=";
  var peg$c23 = "=";
  var peg$c24 = "<>";
  var peg$c25 = ">";
  var peg$c26 = "<";
  var peg$c27 = "(";
  var peg$c28 = ")";
  var peg$c29 = "abs";
  var peg$c30 = "ceil";
  var peg$c31 = "cos";
  var peg$c32 = "exp";
  var peg$c33 = "floor";
  var peg$c34 = "log";
  var peg$c35 = "round";
  var peg$c36 = "sign";
  var peg$c37 = "sin";
  var peg$c38 = "sqrt";
  var peg$c39 = "tan";
  var peg$c40 = "pow";
  var peg$c41 = "-";
  var peg$c42 = "**";
  var peg$c43 = "*";
  var peg$c44 = "^";
  var peg$c45 = "%";
  var peg$c46 = "/";
  var peg$c47 = "+";
  var peg$c48 = "/*";
  var peg$c49 = "*/";
  var peg$c50 = "[";
  var peg$c51 = "]";
  var peg$c52 = "//";
  var peg$c53 = "#";
  var peg$r0 = /^[12]/;
  var peg$r1 = /^[lh]/;
  var peg$r2 = /^[.]/;
  var peg$r3 = /^[1-9]/;
  var peg$r4 = /^[0-9]/;
  var peg$r5 = /^[^\]]/;
  var peg$r6 = /^[\n\r\u2028\u2029]/;
  var peg$r7 = /^[ \t\n\r]/;
  var peg$e0 = peg$literalExpectation("{", false);
  var peg$e1 = peg$literalExpectation(",", false);
  var peg$e2 = peg$literalExpectation("}", false);
  var peg$e3 = peg$literalExpectation("d", false);
  var peg$e4 = peg$literalExpectation("d%", false);
  var peg$e5 = peg$literalExpectation("dF", false);
  var peg$e6 = peg$literalExpectation(".", false);
  var peg$e7 = peg$classExpectation(["1", "2"], false, false);
  var peg$e8 = peg$literalExpectation("!", false);
  var peg$e9 = peg$literalExpectation("p", false);
  var peg$e10 = peg$classExpectation(["l", "h"], false, false);
  var peg$e11 = peg$literalExpectation("k", false);
  var peg$e12 = peg$literalExpectation("max", false);
  var peg$e13 = peg$literalExpectation("min", false);
  var peg$e14 = peg$literalExpectation("r", false);
  var peg$e15 = peg$literalExpectation("o", false);
  var peg$e16 = peg$literalExpectation("u", false);
  var peg$e17 = peg$literalExpectation("cs", false);
  var peg$e18 = peg$literalExpectation("cf", false);
  var peg$e19 = peg$literalExpectation("s", false);
  var peg$e20 = peg$literalExpectation("a", false);
  var peg$e21 = peg$literalExpectation("f", false);
  var peg$e22 = peg$literalExpectation("!=", false);
  var peg$e23 = peg$literalExpectation("<=", false);
  var peg$e24 = peg$literalExpectation(">=", false);
  var peg$e25 = peg$literalExpectation("=", false);
  var peg$e26 = peg$literalExpectation("<>", false);
  var peg$e27 = peg$literalExpectation(">", false);
  var peg$e28 = peg$literalExpectation("<", false);
  var peg$e29 = peg$literalExpectation("(", false);
  var peg$e30 = peg$literalExpectation(")", false);
  var peg$e31 = peg$literalExpectation("abs", false);
  var peg$e32 = peg$literalExpectation("ceil", false);
  var peg$e33 = peg$literalExpectation("cos", false);
  var peg$e34 = peg$literalExpectation("exp", false);
  var peg$e35 = peg$literalExpectation("floor", false);
  var peg$e36 = peg$literalExpectation("log", false);
  var peg$e37 = peg$literalExpectation("round", false);
  var peg$e38 = peg$literalExpectation("sign", false);
  var peg$e39 = peg$literalExpectation("sin", false);
  var peg$e40 = peg$literalExpectation("sqrt", false);
  var peg$e41 = peg$literalExpectation("tan", false);
  var peg$e42 = peg$literalExpectation("pow", false);
  var peg$e43 = peg$literalExpectation("-", false);
  var peg$e44 = peg$classExpectation(["."], false, false);
  var peg$e45 = peg$classExpectation([["1", "9"]], false, false);
  var peg$e46 = peg$classExpectation([["0", "9"]], false, false);
  var peg$e47 = peg$literalExpectation("**", false);
  var peg$e48 = peg$literalExpectation("*", false);
  var peg$e49 = peg$literalExpectation("^", false);
  var peg$e50 = peg$literalExpectation("%", false);
  var peg$e51 = peg$literalExpectation("/", false);
  var peg$e52 = peg$literalExpectation("+", false);
  var peg$e53 = peg$otherExpectation("comment");
  var peg$e54 = peg$literalExpectation("/*", false);
  var peg$e55 = peg$literalExpectation("*/", false);
  var peg$e56 = peg$anyExpectation();
  var peg$e57 = peg$literalExpectation("[", false);
  var peg$e58 = peg$classExpectation(["]"], true, false);
  var peg$e59 = peg$literalExpectation("]", false);
  var peg$e60 = peg$literalExpectation("//", false);
  var peg$e61 = peg$literalExpectation("#", false);
  var peg$e62 = peg$classExpectation(["\n", "\r", "\u2028", "\u2029"], false, false);
  var peg$e63 = peg$otherExpectation("whitespace");
  var peg$e64 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false);
  var peg$e65 = peg$otherExpectation("whitespace or comment");
  var peg$f0 = function(expr, exprs, modifiers, descriptions) {
    return new RollGroup([
      expr,
      ...exprs.map((v) => v[3])
    ], Object.assign({}, ...modifiers.map((item) => {
      return { [item.name]: item };
    })), descriptions.find((o) => o instanceof Description));
  };
  var peg$f1 = function(die2, modifiers, descriptions) {
    die2.modifiers = Object.assign({}, ...modifiers.map((item) => {
      return { [item.name]: item };
    }));
    die2.description = descriptions.find((o) => o instanceof Description);
    return die2;
  };
  var peg$f2 = function(qty, sides) {
    return new StandardDice(sides, qty || 1);
  };
  var peg$f3 = function(qty) {
    return new PercentileDice(qty || 1);
  };
  var peg$f4 = function(qty, sides) {
    return new FudgeDice(sides ? parseInt(sides[1], 10) : 2, qty || 1);
  };
  var peg$f5 = function(compound, penetrate, comparePoint) {
    return new ExplodeModifier(comparePoint, !!compound, !!penetrate);
  };
  var peg$f6 = function(successCP, failureCP) {
    return new TargetModifier(successCP, failureCP);
  };
  var peg$f7 = function(end, qty) {
    return new DropModifier(end || "l", qty);
  };
  var peg$f8 = function(end, qty) {
    return new KeepModifier(end || "h", qty);
  };
  var peg$f9 = function(max5) {
    return new MaxModifier(max5);
  };
  var peg$f10 = function(min5) {
    return new MinModifier(min5);
  };
  var peg$f11 = function(once, comparePoint) {
    return new ReRollModifier(!!once, comparePoint);
  };
  var peg$f12 = function(once, comparePoint) {
    return new UniqueModifier(!!once, comparePoint);
  };
  var peg$f13 = function(comparePoint) {
    return new CriticalSuccessModifier(comparePoint);
  };
  var peg$f14 = function(comparePoint) {
    return new CriticalFailureModifier(comparePoint);
  };
  var peg$f15 = function(dir) {
    return new SortingModifier(dir || "a");
  };
  var peg$f16 = function(comparePoint) {
    return comparePoint;
  };
  var peg$f17 = function(operator, value) {
    return new ComparePoint(operator, value);
  };
  var peg$f18 = function(l, expr, r) {
    return evaluate3(text());
  };
  var peg$f19 = function(head, tail) {
    head = Array.isArray(head) ? head : [head];
    return [
      ...head,
      ...tail.map(([, value, , factor]) => {
        return [
          value,
          factor
        ];
      }).flat(2)
    ];
  };
  var peg$f20 = function(l, expr, r) {
    return [l, ...expr, r];
  };
  var peg$f21 = function(func, expr) {
    return [
      `${func}(`,
      ...expr,
      ")"
    ];
  };
  var peg$f22 = function(func, expr1, expr2) {
    return [
      `${func}(`,
      ...expr1,
      ",",
      ...expr2,
      ")"
    ];
  };
  var peg$f23 = function() {
    return parseFloat(text());
  };
  var peg$f24 = function() {
    return parseInt(text(), 10);
  };
  var peg$f25 = function() {
    return parseInt(text(), 10);
  };
  var peg$f26 = function() {
    return "^";
  };
  var peg$f27 = function(text2) {
    return new Description(text2.flat().join(""), Description.types.MULTILINE);
  };
  var peg$f28 = function(text2) {
    return new Description(text2.flat().join(""), Description.types.MULTILINE);
  };
  var peg$f29 = function(text2) {
    return new Description(text2.flat().join(""), Description.types.INLINE);
  };
  var peg$currPos = 0;
  var peg$savedPos = 0;
  var peg$posDetailsCache = [{ line: 1, column: 1 }];
  var peg$maxFailPos = 0;
  var peg$maxFailExpected = [];
  var peg$silentFails = 0;
  var peg$result;
  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }
    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }
  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }
  function peg$literalExpectation(text2, ignoreCase) {
    return { type: "literal", text: text2, ignoreCase };
  }
  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts, inverted, ignoreCase };
  }
  function peg$anyExpectation() {
    return { type: "any" };
  }
  function peg$endExpectation() {
    return { type: "end" };
  }
  function peg$otherExpectation(description) {
    return { type: "other", description };
  }
  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos];
    var p;
    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }
      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column
      };
      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }
        p++;
      }
      peg$posDetailsCache[pos] = details;
      return details;
    }
  }
  function peg$computeLocation(startPos, endPos, offset) {
    var startPosDetails = peg$computePosDetails(startPos);
    var endPosDetails = peg$computePosDetails(endPos);
    var res = {
      source: peg$source,
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
    if (offset && peg$source && typeof peg$source.offset === "function") {
      res.start = peg$source.offset(res.start);
      res.end = peg$source.offset(res.end);
    }
    return res;
  }
  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) {
      return;
    }
    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }
    peg$maxFailExpected.push(expected);
  }
  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
  }
  function peg$parseMain() {
    var s0;
    s0 = peg$parseExpression();
    return s0;
  }
  function peg$parseRollGroup() {
    var s0, s1, s3, s4, s5, s6, s7, s8, s9;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c0;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e0);
      }
    }
    if (s1 !== peg$FAILED) {
      peg$parse_();
      s3 = peg$parseExpression();
      if (s3 !== peg$FAILED) {
        s4 = [];
        s5 = peg$currPos;
        s6 = peg$parse_();
        if (input.charCodeAt(peg$currPos) === 44) {
          s7 = peg$c1;
          peg$currPos++;
        } else {
          s7 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s7 !== peg$FAILED) {
          s8 = peg$parse_();
          s9 = peg$parseExpression();
          if (s9 !== peg$FAILED) {
            s6 = [s6, s7, s8, s9];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$currPos;
          s6 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 44) {
            s7 = peg$c1;
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
          }
          if (s7 !== peg$FAILED) {
            s8 = peg$parse_();
            s9 = peg$parseExpression();
            if (s9 !== peg$FAILED) {
              s6 = [s6, s7, s8, s9];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
        }
        s5 = peg$parse_();
        if (input.charCodeAt(peg$currPos) === 125) {
          s6 = peg$c2;
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s6 !== peg$FAILED) {
          s7 = [];
          s8 = peg$parseModifier();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parseModifier();
          }
          s8 = peg$parse__();
          peg$savedPos = s0;
          s0 = peg$f0(s3, s4, s7, s8);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseDice() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    s1 = peg$parseStandardDie();
    if (s1 === peg$FAILED) {
      s1 = peg$parsePercentileDie();
      if (s1 === peg$FAILED) {
        s1 = peg$parseFudgeDie();
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseModifier();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseModifier();
      }
      s3 = peg$parse__();
      peg$savedPos = s0;
      s0 = peg$f1(s1, s2, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseStandardDie() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    s1 = peg$parseIntegerOrExpression();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (input.charCodeAt(peg$currPos) === 100) {
      s2 = peg$c3;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e3);
      }
    }
    if (s2 !== peg$FAILED) {
      s3 = peg$parseIntegerOrExpression();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f2(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parsePercentileDie() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = peg$parseIntegerOrExpression();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (input.substr(peg$currPos, 2) === peg$c4) {
      s2 = peg$c4;
      peg$currPos += 2;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e4);
      }
    }
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f3(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseFudgeDie() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    s1 = peg$parseIntegerOrExpression();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (input.substr(peg$currPos, 2) === peg$c5) {
      s2 = peg$c5;
      peg$currPos += 2;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e5);
      }
    }
    if (s2 !== peg$FAILED) {
      s3 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 46) {
        s4 = peg$c6;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e6);
        }
      }
      if (s4 !== peg$FAILED) {
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f4(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseModifier() {
    var s0;
    s0 = peg$parseExplodeModifier();
    if (s0 === peg$FAILED) {
      s0 = peg$parseTargetModifier();
      if (s0 === peg$FAILED) {
        s0 = peg$parseDropModifier();
        if (s0 === peg$FAILED) {
          s0 = peg$parseKeepModifier();
          if (s0 === peg$FAILED) {
            s0 = peg$parseReRollModifier();
            if (s0 === peg$FAILED) {
              s0 = peg$parseUniqueModifier();
              if (s0 === peg$FAILED) {
                s0 = peg$parseCriticalSuccessModifier();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseCriticalFailureModifier();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseSortingModifier();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseMaxModifier();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseMinModifier();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return s0;
  }
  function peg$parseExplodeModifier() {
    var s0, s1, s2, s3, s4;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 33) {
      s1 = peg$c7;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e8);
      }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 33) {
        s2 = peg$c7;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e8);
        }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (input.charCodeAt(peg$currPos) === 112) {
        s3 = peg$c8;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e9);
        }
      }
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parseComparePoint();
      if (s4 === peg$FAILED) {
        s4 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f5(s2, s3, s4);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseTargetModifier() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = peg$parseComparePoint();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseFailComparePoint();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f6(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseDropModifier() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 100) {
      s1 = peg$c3;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e3);
      }
    }
    if (s1 !== peg$FAILED) {
      if (peg$r1.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e10);
        }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseIntegerNumber();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f7(s2, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseKeepModifier() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 107) {
      s1 = peg$c9;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e11);
      }
    }
    if (s1 !== peg$FAILED) {
      if (peg$r1.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e10);
        }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseIntegerNumber();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f8(s2, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseMaxModifier() {
    var s0, s1, s2;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3) === peg$c10) {
      s1 = peg$c10;
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e12);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseFloatNumber();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f9(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseMinModifier() {
    var s0, s1, s2;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3) === peg$c11) {
      s1 = peg$c11;
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e13);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseFloatNumber();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f10(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseReRollModifier() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 114) {
      s1 = peg$c12;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e14);
      }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 111) {
        s2 = peg$c13;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e15);
        }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseComparePoint();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f11(s2, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseUniqueModifier() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 117) {
      s1 = peg$c14;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e16);
      }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 111) {
        s2 = peg$c13;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e15);
        }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseComparePoint();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f12(s2, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseCriticalSuccessModifier() {
    var s0, s1, s2;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c15) {
      s1 = peg$c15;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e17);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseComparePoint();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f13(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseCriticalFailureModifier() {
    var s0, s1, s2;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c16) {
      s1 = peg$c16;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e18);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseComparePoint();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f14(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseSortingModifier() {
    var s0, s1, s2;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 115) {
      s1 = peg$c17;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e19);
      }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 97) {
        s2 = peg$c18;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e20);
        }
      }
      if (s2 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 100) {
          s2 = peg$c3;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f15(s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseFailComparePoint() {
    var s0, s1, s2;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 102) {
      s1 = peg$c19;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e21);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseComparePoint();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f16(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseComparePoint() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = peg$parseCompareOperator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseFloatNumber();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f17(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseCompareOperator() {
    var s0;
    if (input.substr(peg$currPos, 2) === peg$c20) {
      s0 = peg$c20;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e22);
      }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c21) {
        s0 = peg$c21;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e23);
        }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c22) {
          s0 = peg$c22;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e24);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s0 = peg$c23;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e25);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c24) {
              s0 = peg$c24;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e26);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 62) {
                s0 = peg$c25;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e27);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 60) {
                  s0 = peg$c26;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e28);
                  }
                }
              }
            }
          }
        }
      }
    }
    return s0;
  }
  function peg$parseIntegerOrExpression() {
    var s0, s1, s3, s4, s5, s6, s7, s8, s9, s10;
    s0 = peg$parseIntegerNumber();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c27;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e29);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$parse_();
        s3 = peg$currPos;
        s4 = peg$parseFloatNumber();
        if (s4 !== peg$FAILED) {
          s5 = [];
          s6 = peg$currPos;
          s7 = peg$parse_();
          s8 = peg$parseOperator();
          if (s8 !== peg$FAILED) {
            s9 = peg$parse_();
            s10 = peg$parseFloatNumber();
            if (s10 !== peg$FAILED) {
              s7 = [s7, s8, s9, s10];
              s6 = s7;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$currPos;
              s7 = peg$parse_();
              s8 = peg$parseOperator();
              if (s8 !== peg$FAILED) {
                s9 = peg$parse_();
                s10 = peg$parseFloatNumber();
                if (s10 !== peg$FAILED) {
                  s7 = [s7, s8, s9, s10];
                  s6 = s7;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            }
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 41) {
            s5 = peg$c28;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e30);
            }
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f18();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    return s0;
  }
  function peg$parseExpression() {
    var s0, s1, s2, s3, s4, s5, s6, s7;
    s0 = peg$currPos;
    s1 = peg$parseFactor();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      s5 = peg$parseOperator();
      if (s5 !== peg$FAILED) {
        s6 = peg$parse_();
        s7 = peg$parseFactor();
        if (s7 !== peg$FAILED) {
          s4 = [s4, s5, s6, s7];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        s5 = peg$parseOperator();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          s7 = peg$parseFactor();
          if (s7 !== peg$FAILED) {
            s4 = [s4, s5, s6, s7];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      peg$savedPos = s0;
      s0 = peg$f19(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseFactor() {
    var s0, s1, s3, s5;
    s0 = peg$parseMathFunction();
    if (s0 === peg$FAILED) {
      s0 = peg$parseDice();
      if (s0 === peg$FAILED) {
        s0 = peg$parseFloatNumber();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c27;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e29);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$parse_();
            s3 = peg$parseExpression();
            if (s3 !== peg$FAILED) {
              peg$parse_();
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c28;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e30);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f20(s1, s3, s5);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseRollGroup();
          }
        }
      }
    }
    return s0;
  }
  function peg$parseMathFunction() {
    var s0, s1, s2, s4, s6, s8, s10;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3) === peg$c29) {
      s1 = peg$c29;
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e31);
      }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 4) === peg$c30) {
        s1 = peg$c30;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e32);
        }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c31) {
          s1 = peg$c31;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e33);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c32) {
            s1 = peg$c32;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c33) {
              s1 = peg$c33;
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e35);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c34) {
                s1 = peg$c34;
                peg$currPos += 3;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e36);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 5) === peg$c35) {
                  s1 = peg$c35;
                  peg$currPos += 5;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e37);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 4) === peg$c36) {
                    s1 = peg$c36;
                    peg$currPos += 4;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e38);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 3) === peg$c37) {
                      s1 = peg$c37;
                      peg$currPos += 3;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e39);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 4) === peg$c38) {
                        s1 = peg$c38;
                        peg$currPos += 4;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e40);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 3) === peg$c39) {
                          s1 = peg$c39;
                          peg$currPos += 3;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e41);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c27;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e29);
        }
      }
      if (s2 !== peg$FAILED) {
        peg$parse_();
        s4 = peg$parseExpression();
        if (s4 !== peg$FAILED) {
          peg$parse_();
          if (input.charCodeAt(peg$currPos) === 41) {
            s6 = peg$c28;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e30);
            }
          }
          if (s6 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s1, s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c40) {
        s1 = peg$c40;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e42);
        }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c10) {
          s1 = peg$c10;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c11) {
            s1 = peg$c11;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e13);
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 40) {
          s2 = peg$c27;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e29);
          }
        }
        if (s2 !== peg$FAILED) {
          peg$parse_();
          s4 = peg$parseExpression();
          if (s4 !== peg$FAILED) {
            peg$parse_();
            if (input.charCodeAt(peg$currPos) === 44) {
              s6 = peg$c1;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            if (s6 !== peg$FAILED) {
              peg$parse_();
              s8 = peg$parseExpression();
              if (s8 !== peg$FAILED) {
                peg$parse_();
                if (input.charCodeAt(peg$currPos) === 41) {
                  s10 = peg$c28;
                  peg$currPos++;
                } else {
                  s10 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e30);
                  }
                }
                if (s10 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f22(s1, s4, s8);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    return s0;
  }
  function peg$parseFloatNumber() {
    var s0, s2, s3, s4, s5;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      peg$currPos++;
    } else {
      if (peg$silentFails === 0) {
        peg$fail(peg$e43);
      }
    }
    s2 = peg$parseNumber();
    if (s2 !== peg$FAILED) {
      s3 = peg$currPos;
      if (peg$r2.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e44);
        }
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parseNumber();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f23();
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseIntegerNumber() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (peg$r3.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e45);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$r4.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e46);
        }
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        if (peg$r4.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e46);
          }
        }
      }
      peg$savedPos = s0;
      s0 = peg$f24();
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseNumber() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = [];
    if (peg$r4.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e46);
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$r4.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e46);
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f25();
    }
    s0 = s1;
    return s0;
  }
  function peg$parseOperator() {
    var s0, s1;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c42) {
      s1 = peg$c42;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e47);
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f26();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 42) {
        s0 = peg$c43;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e48);
        }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 94) {
          s0 = peg$c44;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e49);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 37) {
            s0 = peg$c45;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e50);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s0 = peg$c46;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e51);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 43) {
                s0 = peg$c47;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e52);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 45) {
                  s0 = peg$c41;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e43);
                  }
                }
              }
            }
          }
        }
      }
    }
    return s0;
  }
  function peg$parseComment() {
    var s0;
    peg$silentFails++;
    s0 = peg$parseMultiLineComment();
    if (s0 === peg$FAILED) {
      s0 = peg$parseSingleLineComment();
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      if (peg$silentFails === 0) {
        peg$fail(peg$e53);
      }
    }
    return s0;
  }
  function peg$parseMultiLineComment() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c48) {
      s1 = peg$c48;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e54);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      if (input.substr(peg$currPos, 2) === peg$c49) {
        s5 = peg$c49;
        peg$currPos += 2;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e55);
        }
      }
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = undefined;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e56);
          }
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c49) {
          s5 = peg$c49;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e55);
          }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = undefined;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e56);
            }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (input.substr(peg$currPos, 2) === peg$c49) {
        s3 = peg$c49;
        peg$currPos += 2;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e55);
        }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f27(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c50;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e57);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$r5.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e58);
          }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$r5.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e58);
            }
          }
        }
        if (input.charCodeAt(peg$currPos) === 93) {
          s3 = peg$c51;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e59);
          }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f28(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    return s0;
  }
  function peg$parseSingleLineComment() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c52) {
      s1 = peg$c52;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e60);
      }
    }
    if (s1 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c53;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e61);
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      s5 = peg$parseLineTerminator();
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = undefined;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e56);
          }
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parseLineTerminator();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = undefined;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e56);
            }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      peg$savedPos = s0;
      s0 = peg$f29(s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseLineTerminator() {
    var s0;
    if (peg$r6.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e62);
      }
    }
    return s0;
  }
  function peg$parseWhiteSpace() {
    var s0;
    peg$silentFails++;
    if (peg$r7.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e64);
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      if (peg$silentFails === 0) {
        peg$fail(peg$e63);
      }
    }
    return s0;
  }
  function peg$parse_() {
    var s0, s1;
    s0 = [];
    s1 = peg$parseWhiteSpace();
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      s1 = peg$parseWhiteSpace();
    }
    return s0;
  }
  function peg$parse__() {
    var s0, s1;
    peg$silentFails++;
    s0 = [];
    s1 = peg$parseWhiteSpace();
    if (s1 === peg$FAILED) {
      s1 = peg$parseComment();
    }
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      s1 = peg$parseWhiteSpace();
      if (s1 === peg$FAILED) {
        s1 = peg$parseComment();
      }
    }
    peg$silentFails--;
    s1 = peg$FAILED;
    if (peg$silentFails === 0) {
      peg$fail(peg$e65);
    }
    return s0;
  }
  peg$result = peg$startRuleFunction();
  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }
    throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
  }
};

class CompareOperatorError extends TypeError {
  constructor(operator) {
    super(`Operator "${operator}" is invalid`);
    if (TypeError.captureStackTrace) {
      TypeError.captureStackTrace(this, CompareOperatorError);
    }
    this.name = "CompareOperatorError";
    this.operator = operator;
  }
}

class DataFormatError extends Error {
  constructor(data) {
    super(`Invalid data format: ${data}`);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, DataFormatError);
    }
    this.name = "ImportError";
    this.data = data;
  }
}

class DieActionValueError extends Error {
  constructor(die2, action = null) {
    super(`Die "${die2}" must have more than 1 possible value to ${action || "do this action"}`);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, DieActionValueError);
    }
    this.name = "DieActionValueError";
    this.action = action;
    this.die = die2;
  }
}

class NotationError extends Error {
  constructor(notation) {
    super(`Notation "${notation}" is invalid`);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, NotationError);
    }
    this.name = "NotationError";
    this.notation = notation;
  }
}

class RequiredArgumentError extends Error {
  constructor(argumentName = null) {
    super(`Missing argument${argumentName ? ` "${argumentName}"` : ""}`);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, RequiredArgumentError);
    }
    this.argumentName = argumentName;
  }
}
var compareNumbers = (a, b, operator) => {
  const aNum = Number(a);
  const bNum = Number(b);
  let result;
  if (Number.isNaN(aNum) || Number.isNaN(bNum)) {
    return false;
  }
  switch (operator) {
    case "=":
    case "==":
      result = aNum === bNum;
      break;
    case "<":
      result = aNum < bNum;
      break;
    case ">":
      result = aNum > bNum;
      break;
    case "<=":
      result = aNum <= bNum;
      break;
    case ">=":
      result = aNum >= bNum;
      break;
    case "!":
    case "!=":
    case "<>":
      result = aNum !== bNum;
      break;
    default:
      result = false;
      break;
  }
  return result;
};
var evaluate3 = (equation) => evaluate2(equation);
var isNumeric3 = (val) => {
  if (typeof val !== "number" && typeof val !== "string") {
    return false;
  }
  return !Number.isNaN(val) && Number.isFinite(Number(val));
};
var isSafeNumber = (val) => {
  if (!isNumeric3(val)) {
    return false;
  }
  const castVal = Number(val);
  return castVal <= Number.MAX_SAFE_INTEGER && castVal >= Number.MIN_SAFE_INTEGER;
};
var sumArray = (numbers) => !Array.isArray(numbers) ? 0 : numbers.reduce((prev, current) => prev + (isNumeric3(current) ? parseFloat(`${current}`) : 0), 0);
var toFixed3 = (num, precision = 0) => parseFloat(parseFloat(`${num}`).toFixed(precision || 0));
var SMALLEST_UNSAFE_INTEGER = 9007199254740992;
var LARGEST_SAFE_INTEGER = SMALLEST_UNSAFE_INTEGER - 1;
var UINT32_MAX = -1 >>> 0;
var UINT32_SIZE = UINT32_MAX + 1;
var INT32_SIZE = UINT32_SIZE / 2;
var INT32_MAX = INT32_SIZE - 1;
var UINT21_SIZE = 1 << 21;
var UINT21_MAX = UINT21_SIZE - 1;
var DEFAULT_STRING_POOL = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-";
var LOWER_HEX_POOL = "0123456789abcdef";
var lowerHex = string30(LOWER_HEX_POOL);
var upperHex = string30(LOWER_HEX_POOL.toUpperCase());
var sliceArray = Array.prototype.slice;
var stringRepeat = (() => {
  try {
    if ("x".repeat(3) === "xxx") {
      return (pattern, count3) => pattern.repeat(count3);
    }
  } catch (_) {
  }
  return (pattern, count3) => {
    let result = "";
    while (count3 > 0) {
      if (count3 & 1) {
        result += pattern;
      }
      count3 >>= 1;
      pattern += pattern;
    }
    return result;
  };
})();
var nativeMath = {
  next() {
    return Math.random() * UINT32_SIZE | 0;
  }
};

class Random {
  constructor(engine = nativeMath) {
    this.engine = engine;
  }
  int32() {
    return int32(this.engine);
  }
  uint32() {
    return uint32(this.engine);
  }
  uint53() {
    return uint53(this.engine);
  }
  uint53Full() {
    return uint53Full(this.engine);
  }
  int53() {
    return int53(this.engine);
  }
  int53Full() {
    return int53Full(this.engine);
  }
  integer(min5, max5) {
    return integer(min5, max5)(this.engine);
  }
  realZeroToOneInclusive() {
    return realZeroToOneInclusive(this.engine);
  }
  realZeroToOneExclusive() {
    return realZeroToOneExclusive(this.engine);
  }
  real(min5, max5, inclusive = false) {
    return real(min5, max5, inclusive)(this.engine);
  }
  bool(numerator, denominator) {
    return bool(numerator, denominator)(this.engine);
  }
  pick(source, begin, end) {
    return pick(this.engine, source, begin, end);
  }
  shuffle(array59) {
    return shuffle(this.engine, array59);
  }
  sample(population, sampleSize) {
    return sample(this.engine, population, sampleSize);
  }
  die(sideCount) {
    return die(sideCount)(this.engine);
  }
  dice(sideCount, dieCount) {
    return dice(sideCount, dieCount)(this.engine);
  }
  uuid4() {
    return uuid4(this.engine);
  }
  string(length, pool) {
    return string30(pool)(this.engine, length);
  }
  hex(length, uppercase) {
    return hex3(uppercase)(this.engine, length);
  }
  date(start, end) {
    return date(start, end)(this.engine);
  }
}
var I32Array = (() => {
  try {
    const buffer = new ArrayBuffer(4);
    const view = new Int32Array(buffer);
    view[0] = INT32_SIZE;
    if (view[0] === -INT32_SIZE) {
      return Int32Array;
    }
  } catch (_) {
  }
  return Array;
})();
var data = null;
var COUNT = 128;
var index$3 = COUNT;
var browserCrypto = {
  next() {
    if (index$3 >= COUNT) {
      if (data === null) {
        data = new I32Array(COUNT);
      }
      crypto.getRandomValues(data);
      index$3 = 0;
    }
    return data[index$3++] | 0;
  }
};
var imul = (() => {
  try {
    if (Math.imul(UINT32_MAX, 5) === -5) {
      return Math.imul;
    }
  } catch (_) {
  }
  const UINT16_MAX = 65535;
  return (a, b) => {
    const ah = a >>> 16 & UINT16_MAX;
    const al = a & UINT16_MAX;
    const bh = b >>> 16 & UINT16_MAX;
    const bl = b & UINT16_MAX;
    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
  };
})();
var ARRAY_SIZE = 624;
var ARRAY_MAX = ARRAY_SIZE - 1;
var M = 397;
var ARRAY_SIZE_MINUS_M = ARRAY_SIZE - M;
var A = 2567483615;

class MersenneTwister19937 {
  constructor() {
    this.data = new I32Array(ARRAY_SIZE);
    this.index = 0;
    this.uses = 0;
  }
  static seed(initial) {
    return new MersenneTwister19937().seed(initial);
  }
  static seedWithArray(source) {
    return new MersenneTwister19937().seedWithArray(source);
  }
  static autoSeed() {
    return MersenneTwister19937.seedWithArray(createEntropy());
  }
  next() {
    if ((this.index | 0) >= ARRAY_SIZE) {
      refreshData(this.data);
      this.index = 0;
    }
    const value = this.data[this.index];
    this.index = this.index + 1 | 0;
    this.uses += 1;
    return temper(value) | 0;
  }
  getUseCount() {
    return this.uses;
  }
  discard(count3) {
    if (count3 <= 0) {
      return this;
    }
    this.uses += count3;
    if ((this.index | 0) >= ARRAY_SIZE) {
      refreshData(this.data);
      this.index = 0;
    }
    while (count3 + this.index > ARRAY_SIZE) {
      count3 -= ARRAY_SIZE - this.index;
      refreshData(this.data);
      this.index = 0;
    }
    this.index = this.index + count3 | 0;
    return this;
  }
  seed(initial) {
    let previous = 0;
    this.data[0] = previous = initial | 0;
    for (let i3 = 1;i3 < ARRAY_SIZE; i3 = i3 + 1 | 0) {
      this.data[i3] = previous = imul(previous ^ previous >>> 30, 1812433253) + i3 | 0;
    }
    this.index = ARRAY_SIZE;
    this.uses = 0;
    return this;
  }
  seedWithArray(source) {
    this.seed(19650218);
    seedWithArray(this.data, source);
    return this;
  }
}
var data$1 = null;
var COUNT$1 = 128;
var index$1$1 = COUNT$1;
var nodeCrypto = {
  next() {
    if (index$1$1 >= COUNT$1) {
      data$1 = new Int32Array(new Int8Array(__require("crypto").randomBytes(4 * COUNT$1)).buffer);
      index$1$1 = 0;
    }
    return data$1[index$1$1++] | 0;
  }
};
var engineSymbol = Symbol("engine");
var randomSymbol = Symbol("random");
var maxEngine = {
  range: [],
  next() {
    return this.range[1] - this.range[0];
  }
};
var minEngine = {
  next() {
    return 0;
  }
};
var engines = {
  browserCrypto,
  nodeCrypto,
  MersenneTwister19937,
  nativeMath,
  min: minEngine,
  max: maxEngine
};

class NumberGenerator {
  constructor(engine = nativeMath) {
    this.engine = engine || nativeMath;
  }
  get engine() {
    return this[engineSymbol];
  }
  set engine(engine) {
    if (engine && typeof engine.next !== "function") {
      throw new TypeError("engine must have function `next()`");
    }
    this[engineSymbol] = engine || nativeMath;
    this[randomSymbol] = new Random(this[engineSymbol]);
  }
  integer(min5, max5) {
    this[engineSymbol].range = [min5, max5];
    return this[randomSymbol].integer(min5, max5);
  }
  real(min5, max5, inclusive = false) {
    this[engineSymbol].range = [min5, max5];
    return this[randomSymbol].real(min5, max5, inclusive);
  }
}
var generator = new NumberGenerator;
var operatorSymbol = Symbol("operator");
var valueSymbol$1 = Symbol("value");

class ComparePoint {
  constructor(operator, value) {
    if (!operator) {
      throw new RequiredArgumentError("operator");
    } else if (!value && value !== 0) {
      throw new RequiredArgumentError("value");
    }
    this.operator = operator;
    this.value = value;
  }
  static isValidOperator(operator) {
    return typeof operator === "string" && /^(?:[<>!]?=|[<>]|<>)$/.test(operator);
  }
  set operator(operator) {
    if (!this.constructor.isValidOperator(operator)) {
      throw new CompareOperatorError(operator);
    }
    this[operatorSymbol] = operator;
  }
  get operator() {
    return this[operatorSymbol];
  }
  set value(value) {
    if (!isNumeric3(value)) {
      throw new TypeError("value must be a finite number");
    }
    this[valueSymbol$1] = Number(value);
  }
  get value() {
    return this[valueSymbol$1];
  }
  isMatch(value) {
    return compareNumbers(value, this.value, this.operator);
  }
  toJSON() {
    const { operator, value } = this;
    return {
      operator,
      type: "compare-point",
      value
    };
  }
  toString() {
    return `${this.operator}${this.value}`;
  }
}

class Modifier {
  constructor() {
    this.order = 999;
  }
  get name() {
    return "modifier";
  }
  get notation() {
    return "";
  }
  get maxIterations() {
    return 1000;
  }
  run(results, _context) {
    return results;
  }
  toJSON() {
    const { notation, name: name302 } = this;
    return {
      name: name302,
      notation,
      type: "modifier"
    };
  }
  toString() {
    return this.notation;
  }
}
var comparePointSymbol = Symbol("compare-point");

class ComparisonModifier extends Modifier {
  constructor(comparePoint) {
    super();
    if (comparePoint) {
      this.comparePoint = comparePoint;
    }
  }
  get comparePoint() {
    return this[comparePointSymbol];
  }
  set comparePoint(comparePoint) {
    if (!(comparePoint instanceof ComparePoint)) {
      throw new TypeError("comparePoint must be instance of ComparePoint");
    }
    this[comparePointSymbol] = comparePoint;
  }
  get name() {
    return "comparison";
  }
  get notation() {
    return `${this.comparePoint || ""}`;
  }
  isComparePoint(value) {
    if (!this.comparePoint) {
      return false;
    }
    return this.comparePoint.isMatch(value);
  }
  toJSON() {
    const { comparePoint } = this;
    return Object.assign(super.toJSON(), {
      comparePoint
    });
  }
}
var compoundSymbol = Symbol("compound");
var penetrateSymbol = Symbol("penetrate");

class ExplodeModifier extends ComparisonModifier {
  constructor(comparePoint = null, compound = false, penetrate = false) {
    super(comparePoint);
    this[compoundSymbol] = !!compound;
    this[penetrateSymbol] = !!penetrate;
    this.order = 3;
  }
  get compound() {
    return this[compoundSymbol];
  }
  get name() {
    return "explode";
  }
  get notation() {
    return `!${this.compound ? "!" : ""}${this.penetrate ? "p" : ""}${super.notation}`;
  }
  get penetrate() {
    return this[penetrateSymbol];
  }
  run(results, _context) {
    if (_context.min === _context.max) {
      throw new DieActionValueError(_context, "explode");
    }
    const parsedResults = results;
    parsedResults.rolls = results.rolls.map((roll) => {
      const subRolls = [roll];
      let compareValue = roll.value;
      for (let i3 = 0;i3 < this.maxIterations && this.isComparePoint(compareValue); i3++) {
        const prevRoll = subRolls[subRolls.length - 1];
        const rollResult = _context.rollOnce();
        compareValue = rollResult.value;
        prevRoll.modifiers.add("explode");
        if (this.penetrate) {
          prevRoll.modifiers.add("penetrate");
          rollResult.value -= 1;
        }
        subRolls.push(rollResult);
      }
      if (this.compound && subRolls.length > 1) {
        roll.value = sumArray(subRolls.map((result) => result.value));
        roll.modifiers = [
          "explode",
          "compound"
        ];
        if (this.penetrate) {
          roll.modifiers.add("penetrate");
        }
        return roll;
      }
      return subRolls;
    }).flat();
    return parsedResults;
  }
  toJSON() {
    const { compound, penetrate } = this;
    return Object.assign(super.toJSON(), {
      compound,
      penetrate
    });
  }
}
var textSymbol = Symbol("text");
var typeSymbol = Symbol("type");

class Description {
  static types = {
    MULTILINE: "multiline",
    INLINE: "inline"
  };
  constructor(text, type = this.constructor.types.INLINE) {
    this.text = text;
    this.type = type;
  }
  get text() {
    return this[textSymbol];
  }
  set text(text) {
    if (typeof text === "object") {
      throw new TypeError("Description text is invalid");
    } else if (!text && text !== 0 || `${text}`.trim() === "") {
      throw new TypeError("Description text cannot be empty");
    }
    this[textSymbol] = `${text}`.trim();
  }
  get type() {
    return this[typeSymbol];
  }
  set type(type) {
    const types4 = Object.values(this.constructor.types);
    if (typeof type !== "string") {
      throw new TypeError("Description type must be a string");
    } else if (!types4.includes(type)) {
      throw new RangeError(`Description type must be one of; ${types4.join(", ")}`);
    }
    this[typeSymbol] = type;
  }
  toJSON() {
    const { text, type } = this;
    return {
      text,
      type
    };
  }
  toString() {
    if (this.type === this.constructor.types.INLINE) {
      return `# ${this.text}`;
    }
    return `[${this.text}]`;
  }
}
var descriptionSymbol = Symbol("description");

class HasDescription {
  constructor(text = null) {
    this.description = text;
  }
  get description() {
    return this[descriptionSymbol] || null;
  }
  set description(description) {
    if (!description && description !== 0) {
      this[descriptionSymbol] = null;
    } else if (description instanceof Description) {
      this[descriptionSymbol] = description;
    } else if (typeof description === "string") {
      this[descriptionSymbol] = new Description(description);
    } else {
      throw new TypeError(`description must be of type Description, string or null. Received ${typeof description}`);
    }
  }
  toJSON() {
    const { description } = this;
    return {
      description
    };
  }
  toString() {
    if (this.description) {
      return `${this.description}`;
    }
    return "";
  }
}
var flags = {
  compound: "!",
  explode: "!",
  "critical-failure": "__",
  "critical-success": "**",
  drop: "d",
  max: "v",
  min: "^",
  penetrate: "p",
  "re-roll": "r",
  "re-roll-once": "ro",
  "target-failure": "_",
  "target-success": "*",
  unique: "u",
  "unique-once": "uo"
};
var getModifierFlags = (...modifiers) => [...modifiers].reduce((acc, modifier) => {
  let name302;
  if (modifier instanceof Modifier) {
    name302 = modifier.name;
  } else {
    name302 = modifier;
  }
  return acc + (flags[name302] || name302);
}, "");
var calculationValueSymbol$1 = Symbol("calculation-value");
var modifiersSymbol$3 = Symbol("modifiers");
var initialValueSymbol = Symbol("initial-value");
var useInTotalSymbol$1 = Symbol("use-in-total");
var valueSymbol = Symbol("value");

class RollResult {
  constructor(value, modifiers = [], useInTotal = true) {
    if (isNumeric3(value)) {
      this[initialValueSymbol] = Number(value);
      this.modifiers = modifiers || [];
      this.useInTotal = useInTotal;
    } else if (value && typeof value === "object" && !Array.isArray(value)) {
      const initialVal = isNumeric3(value.initialValue) ? value.initialValue : value.value;
      if (!isNumeric3(initialVal)) {
        throw new TypeError(`Result value is invalid: ${initialVal}`);
      }
      this[initialValueSymbol] = Number(initialVal);
      if (isNumeric3(value.value) && Number(value.value) !== this[initialValueSymbol]) {
        this.value = value.value;
      }
      if (isNumeric3(value.calculationValue) && parseFloat(`${value.calculationValue}`) !== this.value) {
        this.calculationValue = value.calculationValue;
      }
      this.modifiers = value.modifiers || modifiers || [];
      this.useInTotal = typeof value.useInTotal === "boolean" ? value.useInTotal : useInTotal || false;
    } else if (value === Infinity) {
      throw new RangeError("Result value must be a finite number");
    } else {
      throw new TypeError(`Result value is invalid: ${value}`);
    }
  }
  get calculationValue() {
    return isNumeric3(this[calculationValueSymbol$1]) ? parseFloat(this[calculationValueSymbol$1]) : this.value;
  }
  set calculationValue(value) {
    const isValNumeric = isNumeric3(value);
    if (value === Infinity) {
      throw new RangeError("Result calculation value must be a finite number");
    }
    if (value && !isValNumeric) {
      throw new TypeError(`Result calculation value is invalid: ${value}`);
    }
    this[calculationValueSymbol$1] = isValNumeric ? parseFloat(`${value}`) : null;
  }
  get initialValue() {
    return this[initialValueSymbol];
  }
  get modifierFlags() {
    return getModifierFlags(...this.modifiers);
  }
  get modifiers() {
    return this[modifiersSymbol$3];
  }
  set modifiers(value) {
    if ((Array.isArray(value) || value instanceof Set) && [...value].every((item) => typeof item === "string")) {
      this[modifiersSymbol$3] = new Set([...value]);
      return;
    }
    if (!value && value !== 0) {
      this[modifiersSymbol$3] = new Set;
      return;
    }
    throw new TypeError(`modifiers must be a Set or array of modifier names: ${value}`);
  }
  get useInTotal() {
    return !!this[useInTotalSymbol$1];
  }
  set useInTotal(value) {
    this[useInTotalSymbol$1] = !!value;
  }
  get value() {
    return isNumeric3(this[valueSymbol]) ? this[valueSymbol] : this[initialValueSymbol];
  }
  set value(value) {
    if (value === Infinity) {
      throw new RangeError("Result value must be a finite number");
    }
    if (!isNumeric3(value)) {
      throw new TypeError(`Result value is invalid: ${value}`);
    }
    this[valueSymbol] = Number(value);
  }
  toJSON() {
    const {
      calculationValue,
      initialValue,
      modifierFlags,
      modifiers,
      useInTotal,
      value
    } = this;
    return {
      calculationValue,
      initialValue,
      modifierFlags,
      modifiers: [...modifiers],
      type: "result",
      useInTotal,
      value
    };
  }
  toString() {
    return this.value + this.modifierFlags;
  }
}
var rollsSymbol$1 = Symbol("rolls");

class RollResults {
  constructor(rolls = []) {
    this.rolls = rolls;
  }
  get length() {
    return this.rolls.length || 0;
  }
  get rolls() {
    return [...this[rollsSymbol$1]];
  }
  set rolls(rolls) {
    if (!rolls || !Array.isArray(rolls)) {
      throw new TypeError(`rolls must be an array: ${rolls}`);
    }
    this[rollsSymbol$1] = [];
    rolls.forEach((result) => {
      this.addRoll(result);
    });
  }
  get value() {
    return this.rolls.reduce((v, roll) => v + (roll.useInTotal ? roll.calculationValue : 0), 0);
  }
  addRoll(value) {
    const result = value instanceof RollResult ? value : new RollResult(value);
    this[rollsSymbol$1].push(result);
  }
  toJSON() {
    const { rolls, value } = this;
    return {
      rolls,
      type: "roll-results",
      value
    };
  }
  toString() {
    return `[${this.rolls.join(", ")}]`;
  }
}
var onceSymbol$1 = Symbol("once");

class ReRollModifier extends ComparisonModifier {
  constructor(once = false, comparePoint = null) {
    super(comparePoint);
    this.once = !!once;
    this.order = 4;
  }
  get name() {
    return "re-roll";
  }
  get notation() {
    return `r${this.once ? "o" : ""}${super.notation}`;
  }
  get once() {
    return !!this[onceSymbol$1];
  }
  set once(value) {
    this[onceSymbol$1] = !!value;
  }
  run(results, _context) {
    if (_context.min === _context.max) {
      throw new DieActionValueError(_context, "re-roll");
    }
    results.rolls.map((roll) => {
      for (let i3 = 0;i3 < this.maxIterations && this.isComparePoint(roll.value); i3++) {
        const rollResult = _context.rollOnce();
        roll.value = rollResult.value;
        roll.modifiers.add(`re-roll${this.once ? "-once" : ""}`);
        if (this.once) {
          break;
        }
      }
      return roll;
    });
    return results;
  }
  toJSON() {
    const { once } = this;
    return Object.assign(super.toJSON(), {
      once
    });
  }
}
var modifiersSymbol$2 = Symbol("modifiers");
var qtySymbol$1 = Symbol("qty");
var sidesSymbol = Symbol("sides");
var minSymbol$1 = Symbol("min-value");
var maxSymbol$1 = Symbol("max-value");

class StandardDice extends HasDescription {
  constructor(sides, qty = 1, modifiers = null, min5 = 1, max5 = null, description = null) {
    super(description);
    if (!sides && sides !== 0) {
      throw new RequiredArgumentError("sides");
    } else if (sides === Infinity) {
      throw new RangeError("numerical sides must be finite number");
    } else if (isNumeric3(sides)) {
      if (sides < 1 || !isSafeNumber(sides)) {
        throw new RangeError("numerical sides must be a positive finite number");
      }
    } else if (typeof sides !== "string") {
      throw new TypeError("non-numerical sides must be a string");
    }
    if (!isNumeric3(qty)) {
      throw new TypeError("qty must be a positive finite integer");
    } else if (qty < 1 || qty > 999) {
      throw new RangeError("qty must be between 1 and 999");
    }
    let minVal = min5;
    if (minVal === null || minVal === undefined) {
      minVal = 1;
    } else if (!isNumeric3(minVal)) {
      throw new TypeError("min must a finite number");
    } else if (!isSafeNumber(minVal)) {
      throw new RangeError("min must a finite number");
    }
    if (max5 && !isNumeric3(max5)) {
      throw new TypeError("max must a finite number");
    } else if (max5 && !isSafeNumber(max5)) {
      throw new RangeError("max must a finite number");
    }
    this[qtySymbol$1] = parseInt(`${qty}`, 10);
    this[sidesSymbol] = sides;
    if (modifiers) {
      this.modifiers = modifiers;
    }
    this[minSymbol$1] = parseInt(minVal, 10);
    this[maxSymbol$1] = max5 ? parseInt(`${max5}`, 10) : sides;
  }
  get average() {
    return (this.min + this.max) / 2;
  }
  get modifiers() {
    if (this[modifiersSymbol$2]) {
      return new Map([...this[modifiersSymbol$2]].sort((a, b) => a[1].order - b[1].order));
    }
    return null;
  }
  set modifiers(value) {
    let modifiers;
    if (value instanceof Map) {
      modifiers = value;
    } else if (Array.isArray(value)) {
      modifiers = new Map(value.map((modifier) => [modifier.name, modifier]));
    } else if (typeof value === "object") {
      modifiers = new Map(Object.entries(value));
    } else {
      throw new TypeError("modifiers should be a Map, array, or an Object containing Modifiers");
    }
    if (modifiers.size && [...modifiers.entries()].some((entry) => !(entry[1] instanceof Modifier))) {
      throw new TypeError("modifiers must only contain Modifier instances");
    }
    this[modifiersSymbol$2] = modifiers;
    this[modifiersSymbol$2].forEach((modifier) => {
      if (modifier instanceof ExplodeModifier && !modifier.comparePoint) {
        modifier.comparePoint = new ComparePoint("=", this.max);
      } else if (modifier instanceof ReRollModifier && !modifier.comparePoint) {
        modifier.comparePoint = new ComparePoint("=", this.min);
      }
    });
  }
  get max() {
    return this[maxSymbol$1];
  }
  get min() {
    return this[minSymbol$1];
  }
  get name() {
    return "standard";
  }
  get notation() {
    let notation = `${this.qty}d${this.sides}`;
    if (this.modifiers && this.modifiers.size) {
      notation += [...this.modifiers.values()].reduce((acc, modifier) => acc + modifier.notation, "");
    }
    return notation;
  }
  get qty() {
    return this[qtySymbol$1];
  }
  get sides() {
    return this[sidesSymbol];
  }
  roll() {
    const rollResult = new RollResults;
    for (let i3 = 0;i3 < this.qty; i3++) {
      rollResult.addRoll(this.rollOnce());
    }
    (this.modifiers || []).forEach((modifier) => {
      modifier.run(rollResult, this);
    });
    return rollResult;
  }
  rollOnce() {
    return new RollResult(generator.integer(this.min, this.max));
  }
  toJSON() {
    const {
      average,
      max: max5,
      min: min5,
      modifiers,
      name: name302,
      notation,
      qty,
      sides
    } = this;
    return Object.assign(super.toJSON(), {
      average,
      max: max5,
      min: min5,
      modifiers,
      name: name302,
      notation,
      qty,
      sides,
      type: "die"
    });
  }
  toString() {
    return `${this.notation}${this.description ? ` ${this.description}` : ""}`;
  }
}

class FudgeDice extends StandardDice {
  constructor(nonBlanks = 2, qty = 1, modifiers = null, description = null) {
    let numNonBlanks = nonBlanks;
    if (!numNonBlanks && numNonBlanks !== 0) {
      numNonBlanks = 2;
    } else if (numNonBlanks !== 1 && numNonBlanks !== 2) {
      throw new RangeError("nonBlanks must be 1 or 2");
    }
    super(numNonBlanks, qty, modifiers, -1, 1, description);
  }
  get name() {
    return "fudge";
  }
  get nonBlanks() {
    return super.sides;
  }
  get sides() {
    return `F.${this.nonBlanks}`;
  }
  rollOnce() {
    let total = 0;
    if (this.nonBlanks === 2) {
      total = generator.integer(1, 3) - 2;
    } else if (this.nonBlanks === 1) {
      const num = generator.integer(1, 6);
      if (num === 1) {
        total = -1;
      } else if (num === 6) {
        total = 1;
      }
    }
    return new RollResult(total);
  }
}

class PercentileDice extends StandardDice {
  constructor(qty = 1, modifiers = null, sidesAsNumber = false, description = null) {
    super(100, qty, modifiers, null, null, description);
    this.sidesAsNumber = !!sidesAsNumber;
  }
  get name() {
    return "percentile";
  }
  get sides() {
    return this.sidesAsNumber ? super.sides : "%";
  }
}
class CriticalFailureModifier extends ComparisonModifier {
  constructor(comparePoint) {
    super(comparePoint);
    this.order = 10;
  }
  get name() {
    return "critical-failure";
  }
  get notation() {
    return `cf${super.notation}`;
  }
  run(results, _context) {
    results.rolls.forEach((roll) => {
      if (this.isComparePoint(roll.value)) {
        roll.modifiers.add("critical-failure");
      }
      return roll;
    });
    return results;
  }
}

class CriticalSuccessModifier extends ComparisonModifier {
  constructor(comparePoint) {
    super(comparePoint);
    this.order = 9;
  }
  get name() {
    return "critical-success";
  }
  get notation() {
    return `cs${super.notation}`;
  }
  run(results, _context) {
    results.rolls.forEach((roll) => {
      if (this.isComparePoint(roll.value)) {
        roll.modifiers.add("critical-success");
      }
      return roll;
    });
    return results;
  }
}
var calculationValueSymbol = Symbol("calculation-value");
var isRollGroupSymbol = Symbol("is-roll-group");
var modifiersSymbol$1 = Symbol("modifiers");
var resultsSymbol = Symbol("results");
var useInTotalSymbol = Symbol("use-in-total");

class ResultGroup {
  constructor(results = [], modifiers = [], isRollGroup = false, useInTotal = true) {
    this.isRollGroup = isRollGroup;
    this.modifiers = modifiers;
    this.results = results;
    this.useInTotal = useInTotal;
  }
  get calculationValue() {
    return isNumeric3(this[calculationValueSymbol]) ? parseFloat(this[calculationValueSymbol]) : this.value;
  }
  set calculationValue(value) {
    const isValNumeric = isNumeric3(value);
    if (value === Infinity) {
      throw new RangeError("Results calculation value must be a finite number");
    }
    if (value && !isValNumeric) {
      throw new TypeError(`Results calculation value is invalid: ${value}`);
    }
    this[calculationValueSymbol] = isValNumeric ? parseFloat(`${value}`) : null;
  }
  get isRollGroup() {
    return this[isRollGroupSymbol];
  }
  set isRollGroup(value) {
    this[isRollGroupSymbol] = !!value;
  }
  get length() {
    return this.results.length || 0;
  }
  get modifierFlags() {
    return getModifierFlags(...this.modifiers);
  }
  get modifiers() {
    return this[modifiersSymbol$1];
  }
  set modifiers(value) {
    if ((Array.isArray(value) || value instanceof Set) && [...value].every((item) => typeof item === "string")) {
      this[modifiersSymbol$1] = new Set([...value]);
    } else if (!value && value !== 0) {
      this[modifiersSymbol$1] = new Set;
    } else {
      throw new TypeError(`modifiers must be a Set or array of modifier names: ${value}`);
    }
  }
  get results() {
    return [...this[resultsSymbol]];
  }
  set results(results) {
    if (!results || !Array.isArray(results)) {
      throw new TypeError(`results must be an array: ${results}`);
    }
    this[resultsSymbol] = [];
    results.forEach((result) => {
      this.addResult(result);
    });
  }
  get useInTotal() {
    return !!this[useInTotalSymbol];
  }
  set useInTotal(value) {
    this[useInTotalSymbol] = !!value;
  }
  get value() {
    if (!this.results.length) {
      return 0;
    }
    const value = this.results.reduce((v, result) => {
      let val = result;
      if (result instanceof ResultGroup) {
        val = result.useInTotal ? result.calculationValue : 0;
      } else if (result instanceof RollResults) {
        val = result.value;
      }
      return v + val;
    }, typeof this.results[0] === "string" ? "" : 0);
    if (typeof value === "string") {
      return evaluate3(value);
    }
    return value;
  }
  addResult(value) {
    let val;
    if (value instanceof ResultGroup || value instanceof RollResults) {
      val = value;
    } else if (typeof value === "string" || isNumeric3(value)) {
      val = value;
    } else {
      throw new TypeError("value must be one of ResultGroup, RollResults, string, or number");
    }
    this[resultsSymbol].push(val);
  }
  toJSON() {
    const {
      calculationValue,
      isRollGroup,
      modifierFlags,
      modifiers,
      results,
      useInTotal,
      value
    } = this;
    return {
      calculationValue,
      isRollGroup,
      modifierFlags,
      modifiers: [...modifiers],
      results,
      type: "result-group",
      useInTotal,
      value
    };
  }
  toString() {
    let output;
    if (this.isRollGroup) {
      output = `{${this.results.join(", ")}}`;
    } else {
      output = this.results.join("");
    }
    if (this.modifierFlags) {
      output = `(${output})${this.modifierFlags}`;
    }
    return output;
  }
}
var endSymbol = Symbol("end");
var qtySymbol = Symbol("qty");

class KeepModifier extends Modifier {
  constructor(end = "h", qty = 1) {
    super();
    this.end = end;
    this.qty = qty;
    this.order = 6;
  }
  get end() {
    return this[endSymbol];
  }
  set end(value) {
    if (value !== "h" && value !== "l") {
      throw new RangeError('End must be "h" or "l"');
    }
    this[endSymbol] = value;
  }
  get name() {
    return `keep-${this.end}`;
  }
  get notation() {
    return `k${this.end}${this.qty}`;
  }
  get qty() {
    return this[qtySymbol];
  }
  set qty(value) {
    if (value === Infinity) {
      throw new RangeError("qty must be a finite number");
    }
    if (!isNumeric3(value) || value < 1) {
      throw new TypeError("qty must be a positive finite integer");
    }
    this[qtySymbol] = Math.floor(value);
  }
  rangeToDrop(_results) {
    if (this.end === "h") {
      return [0, _results.length - this.qty];
    }
    return [this.qty, _results.length];
  }
  run(results, _context) {
    let modifiedRolls;
    let rollIndexes;
    if (results instanceof ResultGroup) {
      modifiedRolls = results.results;
      if (modifiedRolls.length === 1 && modifiedRolls[0] instanceof ResultGroup) {
        rollIndexes = modifiedRolls[0].results.map((result, index2) => {
          if (result instanceof RollResults) {
            return result.rolls.map((subResult, subIndex) => ({
              value: subResult.value,
              index: [index2, subIndex]
            }));
          }
          return null;
        }).flat().filter(Boolean);
      } else {
        rollIndexes = [...modifiedRolls].map((roll, index2) => ({
          value: roll.value,
          index: index2
        }));
      }
    } else {
      modifiedRolls = results.rolls;
      rollIndexes = [...modifiedRolls].map((roll, index2) => ({
        value: roll.value,
        index: index2
      }));
    }
    rollIndexes = rollIndexes.sort((a, b) => a.value - b.value).map((rollIndex) => rollIndex.index).slice(...this.rangeToDrop(rollIndexes));
    rollIndexes.forEach((rollIndex) => {
      let roll;
      if (Array.isArray(rollIndex)) {
        roll = modifiedRolls[0].results[rollIndex[0]].rolls[rollIndex[1]];
      } else {
        roll = modifiedRolls[rollIndex];
      }
      roll.modifiers.add("drop");
      roll.useInTotal = false;
    });
    return results;
  }
  toJSON() {
    const { end, qty } = this;
    return Object.assign(super.toJSON(), {
      end,
      qty
    });
  }
}

class DropModifier extends KeepModifier {
  constructor(end = "l", qty = 1) {
    super(end, qty);
    this.order = 7;
  }
  get name() {
    return `drop-${this.end}`;
  }
  get notation() {
    return `d${this.end}${this.qty}`;
  }
  rangeToDrop(_results) {
    if (this.end === "h") {
      return [_results.length - this.qty, _results.length];
    }
    return [0, this.qty];
  }
}
var maxSymbol = Symbol("max");

class MaxModifier extends Modifier {
  constructor(max5) {
    super();
    this.max = max5;
    this.order = 2;
  }
  get max() {
    return this[maxSymbol];
  }
  set max(value) {
    if (!isNumeric3(value)) {
      throw new TypeError("max must be a number");
    }
    this[maxSymbol] = parseFloat(`${value}`);
  }
  get name() {
    return "max";
  }
  get notation() {
    return `max${this.max}`;
  }
  run(results, _context) {
    const parsedResults = results;
    parsedResults.rolls = results.rolls.map((roll) => {
      const parsedRoll = roll;
      if (roll.value > this.max) {
        parsedRoll.value = this.max;
        parsedRoll.modifiers.add("max");
      }
      return parsedRoll;
    });
    return parsedResults;
  }
  toJSON() {
    const { max: max5 } = this;
    return Object.assign(super.toJSON(), {
      max: max5
    });
  }
}
var minSymbol = Symbol("min");

class MinModifier extends Modifier {
  constructor(min5) {
    super();
    this.min = min5;
    this.order = 1;
  }
  get min() {
    return this[minSymbol];
  }
  set min(value) {
    if (!isNumeric3(value)) {
      throw new TypeError("min must be a number");
    }
    this[minSymbol] = parseFloat(`${value}`);
  }
  get name() {
    return "min";
  }
  get notation() {
    return `min${this.min}`;
  }
  run(results, _context) {
    const parsedResults = results;
    parsedResults.rolls = results.rolls.map((roll) => {
      const parsedRoll = roll;
      if (roll.value < this.min) {
        parsedRoll.value = this.min;
        parsedRoll.modifiers.add("min");
      }
      return parsedRoll;
    });
    return parsedResults;
  }
  toJSON() {
    const { min: min5 } = this;
    return Object.assign(super.toJSON(), {
      min: min5
    });
  }
}
var directionSymbol = Symbol("direction");

class SortingModifier extends Modifier {
  constructor(direction = "a") {
    super();
    this.direction = direction;
    this.order = 11;
  }
  get direction() {
    return this[directionSymbol];
  }
  set direction(value) {
    if (value !== "a" && value !== "d") {
      throw new RangeError('Direction must be "a" (Ascending) or "d" (Descending)');
    }
    this[directionSymbol] = value;
  }
  get name() {
    return "sorting";
  }
  get notation() {
    return `s${this.direction}`;
  }
  run(results, _context) {
    let resultsKey;
    if (results instanceof ResultGroup) {
      resultsKey = "results";
    } else {
      resultsKey = "rolls";
    }
    results[resultsKey] = results[resultsKey].sort((a, b) => {
      if (this.direction === "d") {
        return b.value - a.value;
      }
      return a.value - b.value;
    });
    if (results instanceof ResultGroup) {
      results[resultsKey] = results[resultsKey].map((subRoll) => {
        if (subRoll instanceof ResultGroup || subRoll instanceof RollResults) {
          return this.run(subRoll, _context);
        }
        return subRoll;
      });
    }
    return results;
  }
  toJSON() {
    const { direction } = this;
    return Object.assign(super.toJSON(), {
      direction
    });
  }
}
var failureCPSymbol = Symbol("failure-cp");

class TargetModifier extends ComparisonModifier {
  constructor(successCP, failureCP = null) {
    super(successCP);
    this.failureComparePoint = failureCP;
    this.order = 8;
  }
  get failureComparePoint() {
    return this[failureCPSymbol];
  }
  set failureComparePoint(comparePoint) {
    if (comparePoint && !(comparePoint instanceof ComparePoint)) {
      throw new TypeError("failure comparePoint must be instance of ComparePoint or null");
    }
    this[failureCPSymbol] = comparePoint || null;
  }
  get name() {
    return "target";
  }
  get notation() {
    return `${super.notation}${this.failureComparePoint ? `f${this.failureComparePoint}` : ""}`;
  }
  get successComparePoint() {
    return this.comparePoint;
  }
  set successComparePoint(value) {
    super.comparePoint = value;
  }
  getStateValue(value) {
    if (this.isSuccess(value)) {
      return 1;
    }
    if (this.isFailure(value)) {
      return -1;
    }
    return 0;
  }
  isFailure(value) {
    return this.failureComparePoint ? this.failureComparePoint.isMatch(value) : false;
  }
  isNeutral(value) {
    return !this.isSuccess(value) && !this.isFailure(value);
  }
  isSuccess(value) {
    return this.isComparePoint(value);
  }
  run(results, _context) {
    let rolls;
    if (results instanceof ResultGroup) {
      rolls = results.results;
    } else {
      rolls = results.rolls;
    }
    rolls.forEach((roll) => {
      if (this.isSuccess(roll.value)) {
        roll.modifiers.add("target-success");
      } else if (this.isFailure(roll.value)) {
        roll.modifiers.add("target-failure");
      }
      roll.calculationValue = this.getStateValue(roll.value);
    });
    return results;
  }
  toJSON() {
    const { failureComparePoint, successComparePoint } = this;
    const result = super.toJSON();
    delete result.comparePoint;
    return Object.assign(result, {
      failureComparePoint,
      successComparePoint
    });
  }
}
var onceSymbol = Symbol("once");
var isDuplicate = (value, index2, collection47, notFirst = false) => {
  const i3 = collection47.map((e4) => e4.value).indexOf(value.value);
  return notFirst ? i3 < index2 : i3 !== index2;
};

class UniqueModifier extends ComparisonModifier {
  constructor(once = false, comparePoint = null) {
    super(comparePoint);
    this.once = !!once;
    this.order = 5;
  }
  get name() {
    return "unique";
  }
  get notation() {
    return `u${this.once ? "o" : ""}${super.notation}`;
  }
  get once() {
    return !!this[onceSymbol];
  }
  set once(value) {
    this[onceSymbol] = !!value;
  }
  run(results, _context) {
    if (_context.min === _context.max) {
      throw new DieActionValueError(_context, "re-roll");
    }
    results.rolls.forEach((roll, index2, collection47) => {
      if (index2 === 0) {
        return;
      }
      for (let i3 = 0;i3 < this.maxIterations && (!this.comparePoint || this.isComparePoint(roll.value)) && isDuplicate(roll, index2, collection47, true); i3++) {
        const rollResult = _context.rollOnce();
        roll.value = rollResult.value;
        roll.modifiers.add(`unique${this.once ? "-once" : ""}`);
        if (this.once) {
          break;
        }
      }
    });
    return results;
  }
  toJSON() {
    const { once } = this;
    return Object.assign(super.toJSON(), {
      once
    });
  }
}
var isBase64 = (val) => {
  try {
    return !!(val && btoa(atob(val)) === val);
  } catch (e4) {
    return false;
  }
};
var isJson = (val) => {
  try {
    const parsed = val ? JSON.parse(val) : false;
    return !!(parsed && typeof parsed === "object");
  } catch (e4) {
    return false;
  }
};
var expressionsSymbol$1 = Symbol("expressions");
var modifiersSymbol = Symbol("modifiers");

class RollGroup extends HasDescription {
  constructor(expressions = [], modifiers = [], description = null) {
    super(description);
    this.expressions = expressions;
    this.modifiers = modifiers;
  }
  get expressions() {
    return [...this[expressionsSymbol$1] || []];
  }
  set expressions(expressions) {
    if (!expressions) {
      throw new RequiredArgumentError("expressions");
    }
    if (!Array.isArray(expressions)) {
      throw new TypeError(`expressions must be an array: ${expressions}`);
    }
    this[expressionsSymbol$1] = [];
    expressions.forEach((expression) => {
      if (!expression || !Array.isArray(expression)) {
        throw new TypeError(`Expressions must be an array of arrays: ${expressions}`);
      }
      if (expression.length === 0) {
        throw new TypeError(`Sub expressions cannot be empty: ${expressions}`);
      }
      if (!expression.every((value) => value instanceof StandardDice || typeof value === "string" || typeof value === "number")) {
        throw new TypeError("Sub expression items must be Dice, numbers, or strings");
      }
      this[expressionsSymbol$1].push(expression);
    });
  }
  get modifiers() {
    if (this[modifiersSymbol]) {
      return new Map([...this[modifiersSymbol]].sort((a, b) => a[1].order - b[1].order));
    }
    return null;
  }
  set modifiers(value) {
    let modifiers;
    if (value instanceof Map) {
      modifiers = value;
    } else if (Array.isArray(value)) {
      modifiers = new Map(value.map((modifier) => [modifier.name, modifier]));
    } else if (typeof value === "object") {
      modifiers = new Map(Object.entries(value));
    } else {
      throw new TypeError("modifiers should be a Map, array, or an Object containing Modifiers");
    }
    if (modifiers.size && [...modifiers.entries()].some((entry) => !(entry[1] instanceof Modifier))) {
      throw new TypeError("modifiers must only contain Modifier instances");
    }
    this[modifiersSymbol] = modifiers;
  }
  get notation() {
    let notation = this.expressions.map((expression) => expression.reduce((acc, e4) => acc + e4, "")).join(", ");
    notation = `{${notation}}`;
    if (this.modifiers && this.modifiers.size) {
      notation += [...this.modifiers.values()].reduce((acc, modifier) => acc + modifier.notation, "");
    }
    return notation;
  }
  roll() {
    const rollResults = new ResultGroup(this.expressions.map((subRoll) => {
      const result = subRoll.map((expression) => {
        if (expression instanceof StandardDice) {
          return expression.roll();
        }
        return expression;
      });
      return new ResultGroup(result);
    }));
    rollResults.isRollGroup = true;
    (this.modifiers || []).forEach((modifier) => {
      modifier.run(rollResults, this);
    });
    return rollResults;
  }
  toJSON() {
    const { modifiers, notation, expressions } = this;
    return Object.assign(super.toJSON(), {
      expressions,
      modifiers,
      notation,
      type: "group"
    });
  }
  toString() {
    return `${this.notation}${this.description ? ` ${this.description}` : ""}`;
  }
}
peg$subclass(peg$SyntaxError, Error);
peg$SyntaxError.prototype.format = function(sources) {
  var str = "Error: " + this.message;
  if (this.location) {
    var src = null;
    var k;
    for (k = 0;k < sources.length; k++) {
      if (sources[k].source === this.location.source) {
        src = sources[k].text.split(/\r\n|\n|\r/g);
        break;
      }
    }
    var s = this.location.start;
    var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
    var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
    if (src) {
      var e4 = this.location.end;
      var filler = peg$padEnd("", offset_s.line.toString().length, " ");
      var line = src[s.line - 1];
      var last = s.line === e4.line ? e4.column : line.length + 1;
      var hatLen = last - s.column || 1;
      str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
    } else {
      str += "\n at " + loc;
    }
  }
  return str;
};
peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function(expectation) {
      return "\"" + literalEscape(expectation.text) + "\"";
    },
    class: function(expectation) {
      var escapedParts = expectation.parts.map(function(part) {
        return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
      });
      return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
    },
    any: function() {
      return "any character";
    },
    end: function() {
      return "end of input";
    },
    other: function(expectation) {
      return expectation.description;
    }
  };
  function hex4(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }
  function literalEscape(s) {
    return s.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
      return "\\x0" + hex4(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
      return "\\x" + hex4(ch);
    });
  }
  function classEscape(s) {
    return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
      return "\\x0" + hex4(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
      return "\\x" + hex4(ch);
    });
  }
  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }
  function describeExpected(expected2) {
    var descriptions = expected2.map(describeExpectation);
    var i3, j;
    descriptions.sort();
    if (descriptions.length > 0) {
      for (i3 = 1, j = 1;i3 < descriptions.length; i3++) {
        if (descriptions[i3 - 1] !== descriptions[i3]) {
          descriptions[j] = descriptions[i3];
          j++;
        }
      }
      descriptions.length = j;
    }
    switch (descriptions.length) {
      case 1:
        return descriptions[0];
      case 2:
        return descriptions[0] + " or " + descriptions[1];
      default:
        return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
    }
  }
  function describeFound(found2) {
    return found2 ? "\"" + literalEscape(found2) + "\"" : "end of input";
  }
  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

class Parser2 {
  static parse(notation) {
    if (!notation) {
      throw new RequiredArgumentError("notation");
    }
    if (typeof notation !== "string") {
      throw new TypeError("Notation must be a string");
    }
    return peg$parse(notation);
  }
}
var exportFormats = Object.freeze({
  BASE_64: 1,
  JSON: 0,
  OBJECT: 2
});
var notationSymbol = Symbol("notation");
var maxTotalSymbol = Symbol("maxTotal");
var minTotalSymbol = Symbol("minTotal");
var expressionsSymbol = Symbol("expressions");
var rollMethodSymbol = Symbol("roll-method");
var rollsSymbol = Symbol("rolls");
var setRollsSymbol = Symbol("set-rolls");
var totalSymbol = Symbol("total");
var calculateTotal = (results) => toFixed3(results.calculationValue, 2);

class DiceRoll {
  constructor(notation) {
    if (!notation) {
      throw new RequiredArgumentError("notation");
    }
    this[expressionsSymbol] = [];
    if (notation instanceof Object && !Array.isArray(notation)) {
      if (!notation.notation) {
        throw new RequiredArgumentError("notation");
      } else if (typeof notation.notation !== "string") {
        throw new NotationError(notation.notation);
      } else if (notation.rolls) {
        this[setRollsSymbol](notation.rolls);
      }
      this[notationSymbol] = notation.notation;
      this[expressionsSymbol] = Parser2.parse(this.notation);
      if (!this.hasRolls()) {
        this.roll();
      }
    } else if (typeof notation === "string") {
      this[notationSymbol] = notation;
      this[expressionsSymbol] = Parser2.parse(this.notation);
      this.roll();
    } else {
      throw new NotationError(notation);
    }
  }
  get averageTotal() {
    return (this.maxTotal + this.minTotal) / 2;
  }
  get maxTotal() {
    if (!this.hasExpressions()) {
      return 0;
    }
    if (!this[maxTotalSymbol]) {
      const rolls = this[rollMethodSymbol](engines.max);
      this[maxTotalSymbol] = calculateTotal(rolls);
    }
    return this[maxTotalSymbol];
  }
  get minTotal() {
    if (!this.hasExpressions()) {
      return 0;
    }
    if (!this[minTotalSymbol]) {
      const rolls = this[rollMethodSymbol](engines.min);
      this[minTotalSymbol] = calculateTotal(rolls);
    }
    return this[minTotalSymbol];
  }
  get notation() {
    return this[notationSymbol];
  }
  get output() {
    let output = `${this.notation}: `;
    if (this.hasRolls()) {
      output += `${this[rollsSymbol]} = ${this.total}`;
    } else {
      output += "No dice rolled";
    }
    return output;
  }
  get rolls() {
    return this[rollsSymbol] ? this[rollsSymbol].results : [];
  }
  get total() {
    if (!this[totalSymbol] && this.hasRolls()) {
      this[totalSymbol] = calculateTotal(this[rollsSymbol]);
    }
    return this[totalSymbol] || 0;
  }
  export(format6 = exportFormats.JSON) {
    switch (format6) {
      case exportFormats.BASE_64:
        return btoa(this.export(exportFormats.JSON));
      case exportFormats.JSON:
        return JSON.stringify(this);
      case exportFormats.OBJECT:
        return JSON.parse(this.export(exportFormats.JSON));
      default:
        throw new TypeError(`Invalid export format "${format6}"`);
    }
  }
  hasExpressions() {
    return this[expressionsSymbol] && this[expressionsSymbol].length > 0;
  }
  hasRolls() {
    return this.hasExpressions() && this.rolls.length > 0;
  }
  roll() {
    this[totalSymbol] = 0;
    this[rollsSymbol] = this[rollMethodSymbol]();
    return this.rolls;
  }
  toJSON() {
    const {
      averageTotal,
      maxTotal,
      minTotal,
      notation,
      output,
      rolls,
      total
    } = this;
    return {
      averageTotal,
      maxTotal,
      minTotal,
      notation,
      output,
      rolls,
      total,
      type: "dice-roll"
    };
  }
  toString() {
    return this.output;
  }
  static import(data2) {
    if (!data2) {
      throw new RequiredArgumentError("data");
    } else if (isJson(data2)) {
      return DiceRoll.import(JSON.parse(data2));
    } else if (isBase64(data2)) {
      return DiceRoll.import(atob(data2));
    } else if (typeof data2 === "object") {
      return new DiceRoll(data2);
    } else {
      throw new DataFormatError(data2);
    }
  }
  [rollMethodSymbol](engine) {
    let oEngine;
    if (engine) {
      oEngine = generator.engine;
      generator.engine = engine;
    }
    const results = new ResultGroup(this[expressionsSymbol].map((expression) => {
      if (expression instanceof StandardDice || expression instanceof RollGroup) {
        return expression.roll();
      }
      return expression;
    }).filter((value) => !!value || value === 0));
    if (engine) {
      generator.engine = oEngine;
    }
    return results;
  }
  [setRollsSymbol](rolls) {
    if (rolls instanceof ResultGroup) {
      this[rollsSymbol] = rolls;
    } else if (rolls instanceof RollResults) {
      this[rollsSymbol] = new ResultGroup([rolls]);
    } else if (Array.isArray(rolls)) {
      this[rollsSymbol] = new ResultGroup(rolls.map((roll) => {
        if (roll instanceof ResultGroup || roll instanceof RollResults) {
          return roll;
        }
        if (Array.isArray(roll)) {
          return new RollResults(roll);
        }
        if (typeof roll === "object") {
          if (Array.isArray(roll.results)) {
            return new ResultGroup(roll.results, roll.modifiers || [], roll.isRollGroup || false, typeof roll.useInTotal === "boolean" ? roll.useInTotal : true);
          }
          if (Array.isArray(roll.rolls)) {
            return new RollResults(roll.rolls);
          }
        }
        return roll;
      }));
    } else {
      throw new TypeError("Rolls must be a valid result object, or an array");
    }
  }
}
var logSymbol = Symbol("log");

// ../../packages/dicecore/lib/dice/utils/index.js
function convertSuccessLevel2CustomTextKey(level) {
  switch (level) {
    case "\u5927\u5931\u8D25":
      return "test.worst";
    case "\u5927\u6210\u529F":
      return "test.best";
    case "\u5931\u8D25":
      return "test.fail";
    case "\u6781\u96BE\u6210\u529F":
      return "test.exsuccess";
    case "\u56F0\u96BE\u6210\u529F":
      return "test.hardsuccess";
    case "\u6210\u529F":
      return "test.success";
  }
}
function removeTrailingOneSpace(str) {
  if (str.endsWith(" ")) {
    return str.slice(0, str.length - 1);
  } else {
    return str;
  }
}
var AtUserPattern = /^<at id="(\d+)"\/>/;
var at = (userId) => `<at id="${userId}"/>`;

// ../../packages/dicecore/lib/dice/base.js
class BasePtDiceRoll {
  rawExpression;
  context;
  inlineRolls;
  get config() {
    return ConfigProvider.INSTANCE.getConfig(this.context.channelUnionId);
  }
  get selfCard() {
    return CardProvider.INSTANCE.getCard(this.context.channelUnionId, this.context.userId);
  }
  get defaultRoll() {
    return this.config.defaultRoll(this.selfCard);
  }
  get hasInlineRolls() {
    return this.inlineRolls.length > 0;
  }
  constructor(fullExp, context2, inlineRolls = []) {
    this.rawExpression = fullExp;
    this.context = context2;
    this.inlineRolls = inlineRolls;
  }
  applyToCard() {
    return [];
  }
  decide(context2) {
    return this.config.decideRoll(context2);
  }
  t(key, args = {}) {
    return this.config.formatCustomText(key, { ...this._commonTArgs, ...args }, this);
  }
  ts(level, args) {
    if (!level)
      return "";
    return this.t(convertSuccessLevel2CustomTextKey(level), args);
  }
  get _commonTArgs() {
    return {
      "": this.context.username,
      "": this.selfCard?.name ?? this.context.username,
      "at": this.context.userId === "system" ? this.context.username : at(this.context.userId)
    };
  }
  hasPermission(control) {
    const userRole = this.context.userRole;
    if (control === "none") {
      return false;
    } else if (control === "all") {
      return true;
    } else {
      return userRole !== "user";
    }
  }
  linkCard(cardId, userId) {
    CardProvider.INSTANCE.linkCard(this.context.channelUnionId, cardId, userId);
  }
  queryCard(query = {}) {
    return CardProvider.INSTANCE.queryCard(query);
  }
  emitter = mitt_default();
  emitDiceRollEvent(type) {
    this.emitter.emit(type, this);
  }
  addDiceRollEventListener({ before, after }) {
    if (before) {
      this.emitter.on("BeforeDiceRoll", before);
    }
    if (after) {
      this.emitter.on("AfterDiceRoll", after);
    }
  }
  removeDiceRollEventListener({ before, after }) {
    if (before) {
      this.emitter.off("BeforeDiceRoll", before);
    }
    if (after) {
      this.emitter.off("AfterDiceRoll", after);
    }
  }
}

// ../../packages/dicecore/lib/dice/utils/parseDescription.js
function parseDescriptions(rawExp, flag = ParseFlags.PARSE_EXP | ParseFlags.PARSE_TEMPVALUE) {
  let exp4 = "", desc = rawExp.trim(), tempValue = NaN;
  if (flag & ParseFlags.PARSE_EXP) {
    const index2 = desc.search(/[\p{Unified_Ideograph}\s]/u);
    const [_exp, _desc = ""] = index2 < 0 ? [desc] : [desc.slice(0, index2), desc.slice(index2)];
    exp4 = _exp;
    desc = _desc.trim();
  }
  if (flag & ParseFlags.PARSE_TEMPVALUE) {
    const index2 = desc.search(/(\d+)$/);
    const [_desc, _tempValue = ""] = index2 < 0 ? [desc] : [desc.slice(0, index2), desc.slice(index2)];
    desc = _desc.trim();
    tempValue = parseInt(_tempValue, 10);
  }
  return [exp4, desc, tempValue];
}
function parseDescriptions2(rawExp, flag = ParseFlagsAll) {
  let exp4 = "", desc = rawExp.trim();
  if (flag & ParseFlags.PARSE_EXP) {
    const index2 = desc.search(/[\p{Unified_Ideograph}\s]/u);
    const [_exp, _desc = ""] = index2 < 0 ? [desc] : [desc.slice(0, index2), desc.slice(index2)];
    exp4 = _exp;
    desc = _desc.trim();
  }
  const regexParts = [
    /(?<skill>[^\d\s,;+-]+)?/,
    flag & ParseFlags.PARSE_TEMPVALUE ? /(?<tempValue>\d+)?/ : undefined,
    flag & ParseFlags.PARSE_MODIFIEDVALUE ? /(?<modified>[+-]\s*\d+)?/ : undefined
  ];
  const regex = new RegExp(regexParts.filter((p) => !!p).map((p) => p.source).join("\\s*"), "g");
  const matchResult = [...desc.matchAll(regex)].map((entry) => entry.groups || {}).filter(({ skill, tempValue, modified }) => skill || tempValue || modified).map((groups) => {
    const skill = groups.skill || "";
    const tempValue = parseInt(groups.tempValue, 10);
    const modifiedValue = parseInt((groups.modified || "").replace(/\s+/g, ""));
    return { skill, tempValue, modifiedValue };
  });
  return { exp: exp4, skills: matchResult };
}
var ParseFlags = Object.freeze({
  PARSE_EXP: 1,
  PARSE_TEMPVALUE: 2,
  PARSE_MODIFIEDVALUE: 4
});
var ParseFlagsAll = ParseFlags.PARSE_EXP | ParseFlags.PARSE_TEMPVALUE | ParseFlags.PARSE_MODIFIEDVALUE;

// ../../packages/dicecore/lib/dice/standard/index.js
class StandardDiceRoll extends BasePtDiceRoll {
  times = 1;
  hidden = false;
  quiet = false;
  vsFlag = false;
  isAlias = false;
  expression = "";
  skillsForTest = [];
  get description() {
    return this.skillsForTest.map((item) => item.skill).join("\uFF0C");
  }
  rolls = [];
  roll() {
    this.parse();
    this.emitDiceRollEvent("BeforeDiceRoll");
    this.doRoll();
    this.emitDiceRollEvent("AfterDiceRoll");
    return this;
  }
  doRoll() {
    for (let i3 = 0;i3 < this.times; i3++) {
      const roll = new DiceRoll(this.expression);
      this.rolls.push({
        roll,
        tests: this.skillsForTest.map(({ skill, tempValue, modifiedValue }) => {
          let cardEntry;
          if (!isNaN(tempValue)) {
            cardEntry = { input: skill, key: skill, value: tempValue, isTemp: true };
          } else {
            cardEntry = this.selfCard?.getEntry(skill);
          }
          let targetValue;
          let result;
          if (cardEntry) {
            targetValue = cardEntry.value + (modifiedValue || 0);
            result = this.decide({ baseValue: cardEntry.value, targetValue, roll: roll.total });
          }
          return { skill, targetValue, cardEntry, result };
        })
      });
    }
  }
  parse() {
    const removeAlias = this.parseAlias(this.rawExpression).trim();
    const removeR = removeAlias.startsWith("r") ? removeAlias.slice(1).trim() : removeAlias;
    const removeFlags = this.parseFlags(removeR).trim();
    this.parseDescriptions(removeFlags);
    this.detectDefaultRoll();
    console.log("[Dice] \u539F\u59CB\u6307\u4EE4", this.rawExpression, "|\u89E3\u6790\u6307\u4EE4", this.expression, "|\u63CF\u8FF0", JSON.stringify(this.skillsForTest), "|\u6697\u9AB0", this.hidden, "|\u7701\u7565", this.quiet, "|\u5BF9\u6297", this.vsFlag, "|\u6B21\u6570", this.times);
  }
  parseAlias(expression) {
    const parsed = this.config.parseAliasRoll_expression(expression, this.context, this.inlineRolls);
    if (parsed && expression !== parsed.expression) {
      this.isAlias = true;
      this.expression = parsed.expression;
      return parsed.rest;
    }
    return expression;
  }
  parseFlags(expression) {
    const match = expression.match(/^(h|q|v|x\d+|\s)*/);
    if (match) {
      const flags2 = match[0];
      if (flags2.includes("h"))
        this.hidden = true;
      if (flags2.includes("q"))
        this.quiet = true;
      if (flags2.includes("v"))
        this.vsFlag = true;
      const timesMatch = flags2.match(/x(\d+)/);
      if (timesMatch) {
        const times = parseInt(timesMatch[1], 10);
        this.times = Math.max(1, Math.min(100, times));
      }
      return expression.slice(flags2.length);
    }
    return expression;
  }
  parseDescriptions(expression) {
    if (this.isAlias) {
      const { skills: skills2 } = parseDescriptions2(expression, ParseFlagsAll ^ ParseFlags.PARSE_EXP);
      this.skillsForTest.push(...skills2);
      return;
    }
    const { exp: exp4, skills } = parseDescriptions2(expression);
    if (!exp4 && skills.length === 1 && isNaN(skills[0].tempValue) && isNaN(skills[0].modifiedValue)) {
      const ability = this.selfCard?.getAbility(skills[0].skill);
      if (ability) {
        this.expression = parseTemplate2(ability.value, this.context, this.inlineRolls);
        this.skillsForTest.push(skills[0]);
        return;
      }
    }
    this.expression = exp4;
    this.skillsForTest.push(...skills);
  }
  detectDefaultRoll() {
    if (this.expression === "" || this.expression === "d") {
      this.expression = this.defaultRoll;
    }
  }
  get output() {
    const headLine = this.t("roll.start", this.getRollStartArgs());
    const inlineRollLines = [];
    if (this.hasInlineRolls && !this.quiet) {
      const inlineLines = this.inlineRolls.map((roll, i3) => {
        return this.t(i3 === 0 ? "roll.inline.first" : "roll.inline.middle") + roll.output;
      });
      inlineRollLines.push(...inlineLines, this.t("roll.inline.last"));
    }
    const rollLines = this.rolls.map((rollResult) => {
      const roll = rollResult.roll;
      const lines2 = [this.t(this.quiet ? "roll.result.quiet" : "roll.result", this.getFormatArgs(roll))];
      if (rollResult.tests.length === 1) {
        const { tests: [test] } = rollResult;
        const testResult = this.ts(test.result?.level, this.getFormatArgs(roll, test));
        lines2[0] += testResult;
      } else {
        rollResult.tests.forEach((test) => {
          const testResult = this.ts(test.result?.level, this.getFormatArgs(roll, test));
          if (testResult) {
            lines2.push(`${test.skill} ${roll.total}${testResult}`);
          }
        });
      }
      return lines2;
    });
    const lines = [headLine, ...inlineRollLines];
    if (rollLines.length === 1) {
      const lastLine = lines[lines.length - 1];
      const [first, ...rest] = rollLines[0];
      lines[lines.length - 1] = `${removeTrailingOneSpace(lastLine)} ${first}`;
      lines.push(...rest);
    } else {
      lines.push(...rollLines.flat());
    }
    if (this.vsFlag && this.eligibleForOpposedRoll) {
      lines.push(this.t("roll.vs.prompt"));
    }
    return lines.map((line) => line.trim()).join("\n");
  }
  get eligibleForOpposedRoll() {
    return false;
  }
  getRollStartArgs() {
    const hasTest = this.rolls.some((roll) => roll.tests.some((test) => !!test.result));
    return {
      "": this.description,
      "": this.rawExpression,
      "": hasTest,
      "": !hasTest
    };
  }
  getFormatArgs(roll, test) {
    return {
      "": this.rawExpression,
      "": test?.skill,
      "": test?.targetValue,
      "": roll.total,
      "": roll.notation,
      "": roll.output
    };
  }
}

// ../../packages/dicecore/lib/dice/standard/inline.js
class InlineDiceRoll extends StandardDiceRoll {
  diceRoll = undefined;
  doRoll() {
    this.diceRoll = new DiceRoll(this.expression);
  }
  get total() {
    return this.diceRoll.total;
  }
  get output() {
    const roll = this.diceRoll;
    return `${this.description.trim()} ${this.t(this.quiet ? "roll.result.quiet" : "roll.result", this.getFormatArgs(roll))}`.trim();
  }
  applyToCard() {
    return [];
  }
}

// ../../packages/dicecore/lib/dice/utils/parseTemplate.js
function parseTemplate2(expression, context2, history, source, depth = 0) {
  debug(depth, "\u89E3\u6790\u539F\u59CB\u8868\u8FBE\u5F0F:", expression);
  if (depth > 99)
    throw new Error("stackoverflow in parseTemplate!!");
  const config7 = ConfigProvider.INSTANCE.getConfig(context2.channelUnionId);
  if (source !== "message_template") {
    const diceCommand = { command: expression, context: context2 };
    config7.hook_beforeParseDiceRoll(diceCommand);
    expression = diceCommand.command;
  }
  const selfCard = CardProvider.INSTANCE.getCard(context2.channelUnionId, context2.userId);
  const getEntry = (key) => selfCard?.getEntry(key)?.value ?? "";
  const getAbility = (key) => selfCard?.getAbility(key)?.value ?? "";
  expression = expression.replace(ENTRY_REGEX, (_, key1, key2) => {
    const key = key1 ?? key2 ?? "";
    const abilityExpression = getAbility(key);
    if (abilityExpression) {
      debug(depth, "\u9012\u5F52\u89E3\u6790 ability:", key, "=", abilityExpression);
      const parsedAbility = parseTemplate2(abilityExpression, context2, history, undefined, depth + 1);
      const dice2 = new InlineDiceRoll(`${parsedAbility.trim()} ${key}`, context2).roll();
      debug(depth, "\u6C42\u503C ability:", dice2.total);
      history.push(dice2);
      return dice2.hidden ? "" : String(dice2.total);
    }
    const skillValue = getEntry(key);
    debug(depth, "\u89E3\u6790 attribute:", key, "=", skillValue);
    return String(skillValue ?? "");
  });
  const thisLevelInlineRolls = [];
  while (INLINE_ROLL_REGEX.test(expression)) {
    expression = expression.replace(INLINE_ROLL_REGEX, (_, notation) => {
      debug(depth, "\u5FAA\u73AF\u89E3\u6790 inline:", notation);
      notation = notation.replace(HISTORY_ROLL_REGEX, (_2, index2) => {
        const historyRoll = thisLevelInlineRolls[Number(index2) - 1];
        const result = historyRoll ? String(historyRoll.total) : "";
        debug(depth, `\u66FF\u6362 $${index2} =`, result);
        return result;
      });
      const dice2 = new InlineDiceRoll(notation.trim(), context2).roll();
      debug(depth, "\u6C42\u503C inline:", dice2.total);
      history.push(dice2);
      thisLevelInlineRolls.push(dice2);
      return dice2.hidden ? "" : String(dice2.total);
    });
  }
  expression = expression.replace(HISTORY_ROLL_REGEX, (_, index2) => {
    const historyRoll = thisLevelInlineRolls[Number(index2) - 1];
    const result = historyRoll ? String(historyRoll.total) : "";
    debug(depth, `\u66FF\u6362 $${index2} =`, result);
    return result;
  });
  debug(depth, "\u89E3\u6790\u7ED3\u679C:", expression);
  return expression;
}
var debug = function(depth, tag2, ...args) {
  const indent = new Array(depth).fill("__").join("");
  console.log(indent + tag2, ...args);
};
var ENTRY_REGEX = /\$\{(.*?)\}|\$([a-zA-Z\p{Unified_Ideograph}]+)/gu;
var INLINE_ROLL_REGEX = /\[\[([^[\]]+)]]/;
var HISTORY_ROLL_REGEX = /\$(\d+)/g;

// ../../packages/dicecore/lib/config/helpers/alias.js
function parseAliasForExpression(processors, expression, context2, inlineRolls, depth = 0) {
  if (depth > 99)
    throw new Error("\u522B\u540D\u6307\u4EE4\u5D4C\u5957\u8FC7\u6DF1\uFF0C\u53EF\u80FD\u89E6\u53D1\u6B7B\u5FAA\u73AF\uFF0C\u8BF7\u68C0\u67E5\u4F60\u7684\u522B\u540D\u6307\u4EE4\u914D\u7F6E\uFF01");
  for (const config7 of processors) {
    if (!config7.command)
      continue;
    if (config7.scope !== "expression")
      continue;
    let match = null;
    let replacement = undefined;
    if (config7.trigger === "naive") {
      const naiveParsedCommand = NaiveCommandCache.get(config7.command);
      if (!naiveParsedCommand)
        continue;
      const regex = naiveParsedCommand.regex;
      match = expression.match(regex);
      if (!match)
        continue;
      const paramsList = Object.keys(naiveParsedCommand.defaultValues).join(",");
      const userParams = combineReplaceParams(match.groups, naiveParsedCommand.defaultValues);
      const replacer2 = StringReplacerCache.get(`${paramsList}|${config7.replacer}`);
      try {
        replacement = replacer2?.(userParams);
      } catch (e4) {
        console.error("[Config] \u89E3\u6790\u522B\u540D\u6307\u4EE4\u5931\u8D25", e4?.message, "command=", config7.command);
      }
    } else {
      const regex = RegexCommandCache.get(config7.command);
      if (!regex)
        continue;
      match = expression.match(regex);
      if (!match)
        continue;
      try {
        replacement = config7.replacer(match);
      } catch (e4) {
        console.error("[Config] \u89E3\u6790\u522B\u540D\u6307\u4EE4\u5931\u8D25", e4?.message, "command=", config7.command);
      }
    }
    if (!replacement)
      break;
    console.log("[Dice] \u89E3\u6790\u522B\u540D:", match[0], "=", replacement);
    const parsed = parseTemplate2(replacement, context2, inlineRolls);
    return {
      expression: parseAliasForExpression(processors, parsed, context2, inlineRolls, depth + 1).expression,
      rest: expression.slice(match[0].length)
    };
  }
  return { expression, rest: "" };
}
var combineReplaceParams = function(matchGroup, defaultValues = {}) {
  if (!matchGroup)
    return defaultValues;
  const userParams = Object.keys(matchGroup).reduce((obj, varname) => {
    const value = parseInt(matchGroup[varname], 10);
    return isNaN(value) ? obj : Object.assign(obj, { [varname]: value });
  }, {});
  return { ...defaultValues, ...userParams };
};
var NaiveCommandCache = new SyncLruCache({
  max: 50,
  fetchMethod: (expression) => {
    const defaultValues = {};
    const parsed = expression.replace(/\{\{\s*([^{}]*)\s*\}\}/g, (_, key) => {
      const [_name, _defaultValue = ""] = key.split("=");
      const name302 = _name.trim();
      defaultValues[name302] = parseInt(_defaultValue.trim(), 10) || 1;
      return `(?<${name302}>\\d*)`;
    });
    return { regex: new RegExp(`^${parsed}`), defaultValues };
  }
});
var StringReplacerCache = new SyncLruCache({
  max: 50,
  fetchMethod: (expression) => {
    const [paramsList, funcBody] = expression.split("|");
    const templateString = funcBody.replace(/\{\{\s*([^{}]*)\s*\}\}/g, "${$1}");
    return new Function("context", `"use strict"; const {${paramsList}} = context; return \`${templateString}\``);
  }
});
var RegexCommandCache = new SyncLruCache({
  max: 50,
  fetchMethod: (expression) => new RegExp(`^${expression}`)
});

// ../../packages/dicecore/lib/version.js
var VERSION_CODE2 = 41;

// ../../packages/dicecore/lib/config/default.js
function getInitialDefaultConfig() {
  const customReplies = getEmbedCustomReply();
  const aliasRolls = getEmbedAliasRoll();
  const rollDeciders = getEmbedRollDecider();
  const customText = getEmbedCustomText();
  const customReplyPlugins = [
    "io.paotuan.plugin.namegen.name",
    "io.paotuan.plugin.insane.ti",
    "io.paotuan.plugin.insane.li",
    "io.paotuan.plugin.cardgen.coc",
    "io.paotuan.plugin.cardgen.dnd",
    "io.paotuan.plugin.draw.draw"
  ];
  return {
    version: VERSION_CODE2,
    botOwner: null,
    defaultRoll: { expression: "d100", preferCard: true },
    specialDice: getSpecialDiceConfig(),
    customReplyIds: customReplies.map((item) => ({ id: `${embedPluginId}.${item.id}`, enabled: true })).concat(customReplyPlugins.map((id) => ({ id, enabled: true }))),
    aliasRollIds: aliasRolls.map((item) => ({ id: `${embedPluginId}.${item.id}`, enabled: true })),
    rollDeciderId: `${embedPluginId}.${rollDeciders[0].id}`,
    rollDeciderIds: rollDeciders.map((item) => `${embedPluginId}.${item.id}`),
    customTextIds: [],
    hookIds: {
      onReceiveCommand: [],
      beforeParseDiceRoll: [],
      onCardEntryChange: [],
      onMessageReaction: [],
      beforeDiceRoll: [],
      afterDiceRoll: []
    },
    embedPlugin: {
      id: embedPluginId,
      customReply: customReplies,
      aliasRoll: aliasRolls,
      rollDecider: rollDeciders,
      customText: [customText]
    },
    plugins: [],
    lastModified: 0
  };
}
function getEmbedCustomReply() {
  return [
    {
      id: "jrrp",
      name: "\u4ECA\u65E5\u8FD0\u52BF",
      description: "\u4F7F\u7528 /jrrp \u67E5\u8BE2\u4ECA\u65E5\u8FD0\u52BF",
      command: "jrrp",
      trigger: "exact",
      items: [
        {
          weight: 1,
          reply: "{{at}}\u4ECA\u5929\u7684\u5E78\u8FD0\u6307\u6570\u662F [[d100]] !"
        }
      ]
    },
    {
      id: "gacha",
      name: "\u7B80\u5355\u62BD\u5361",
      description: "\u4F7F\u7528\u4E0D\u540C\u6743\u91CD\u8FDB\u884C\u62BD\u5361\u7684\u4F8B\u5B50",
      command: "\u62BD\u5361",
      trigger: "exact",
      items: [
        {
          weight: 2,
          reply: "{{at}}\u62BD\u5230\u4E86 \u2605\u2605\u2605\u2605\u2605\u2605"
        },
        {
          weight: 8,
          reply: "{{at}}\u62BD\u5230\u4E86 \u2605\u2605\u2605\u2605\u2605"
        },
        {
          weight: 48,
          reply: "{{at}}\u62BD\u5230\u4E86 \u2605\u2605\u2605\u2605"
        },
        {
          weight: 42,
          reply: "{{at}}\u62BD\u5230\u4E86 \u2605\u2605\u2605"
        }
      ]
    },
    {
      id: "fudu",
      name: "\u590D\u8BFB\u673A",
      description: "\u4F7F\u7528\u6B63\u5219\u5339\u914D\u7684\u4F8B\u5B50",
      command: "\u590D\u8BFB\\s*(?<content>.+)",
      trigger: "regex",
      items: [
        {
          weight: 1,
          reply: "{{content}}"
        }
      ]
    },
    {
      id: "help",
      name: "\u5E2E\u52A9\u6587\u6863",
      description: "\u4F7F\u7528 /help \u67E5\u770B\u5E2E\u52A9\u6587\u6863\u5730\u5740",
      command: "help",
      trigger: "exact",
      items: [
        {
          weight: 1,
          reply: `\u8DD1\u56E2IO\u673A\u5668\u4EBA {{version}}
\u6307\u4EE4\u6587\u6863\u8BF7\u79FB\u6B65\u7F51\u5740: paotuan[\u70B9]io/dice`
        }
      ]
    }
  ];
}
function getEmbedAliasRoll() {
  return [
    {
      id: "ra",
      name: "ra",
      description: "\u517C\u5BB9\u6307\u4EE4\uFF0C\u7B49\u4EF7\u4E8E d%",
      scope: "expression",
      command: "ra",
      trigger: "naive",
      replacer: "d%"
    },
    {
      id: "rc",
      name: "rc",
      description: "\u517C\u5BB9\u6307\u4EE4\uFF0C\u7B49\u4EF7\u4E8E d%",
      scope: "expression",
      command: "rc",
      trigger: "naive",
      replacer: "d%"
    },
    {
      id: "rb",
      name: "\u5956\u52B1\u9AB0\uFF08rb\uFF09",
      description: "rb - \u4E00\u4E2A\u5956\u52B1\u9AB0\uFF0CrbX - X\u4E2A\u5956\u52B1\u9AB0",
      scope: "expression",
      command: "rb{{X}}",
      trigger: "naive",
      replacer: "{{X+1}}d%kl1"
    },
    {
      id: "rp",
      name: "\u60E9\u7F5A\u9AB0\uFF08rp\uFF09",
      description: "rp - \u4E00\u4E2A\u60E9\u7F5A\u9AB0\uFF0CrpX - X\u4E2A\u60E9\u7F5A\u9AB0",
      scope: "expression",
      command: "rp{{X}}",
      trigger: "naive",
      replacer: "{{X+1}}d%kh1"
    },
    {
      id: "wwa",
      name: "\u9AB0\u6C60\uFF08wwXaY\uFF09",
      description: "\u6295 X \u4E2A d10\uFF0C\u6BCF\u6709\u4E00\u4E2A\u9AB0\u5B50 \u2265 Y\uFF0C\u5219\u53EF\u591A\u6295\u4E00\u6B21\u3002\u6700\u540E\u8BA1\u7B97\u70B9\u6570 \u2265 8 \u7684\u9AB0\u5B50\u6570",
      scope: "expression",
      command: "ww{{X}}a{{Y=10}}",
      trigger: "naive",
      replacer: "{{X}}d10!>={{Y}}>=8"
    },
    {
      id: "ww",
      name: "\u9AB0\u6C60\uFF08wwX\uFF09",
      description: "\u9AB0\u6C60\uFF08wwXaY\uFF09\u7684\u7B80\u5199\uFF0C\u9ED8\u8BA4 Y=10",
      scope: "expression",
      command: "ww{{X}}",
      trigger: "naive",
      replacer: "ww{{X}}a10"
    }
  ];
}
function getEmbedRollDecider() {
  return [
    {
      id: "coc0",
      name: "COC \u9ED8\u8BA4\u89C4\u5219",
      description: "\u51FA 1 \u5927\u6210\u529F\uFF1B\u4E0D\u6EE1 50 \u51FA 96-100 \u5927\u5931\u8D25\uFF0C\u6EE1 50 \u51FA 100 \u5927\u5931\u8D25",
      rules: [
        { level: "\u5927\u5931\u8D25", expression: "(targetValue < 50 && roll > 95) || (targetValue >= 50 && roll == 100)" },
        { level: "\u5927\u6210\u529F", expression: "roll == 1" },
        { level: "\u5931\u8D25", expression: "roll > targetValue" },
        { level: "\u6781\u96BE\u6210\u529F", expression: "roll <= targetValue && roll <= baseValue / 5" },
        { level: "\u56F0\u96BE\u6210\u529F", expression: "roll <= targetValue && roll <= baseValue / 2" },
        { level: "\u6210\u529F", expression: "roll <= targetValue" }
      ]
    },
    {
      id: "dnd0",
      name: "DND \u9ED8\u8BA4\u89C4\u5219",
      description: "\u5927\u4E8E\u7B49\u4E8E DC \u6210\u529F\uFF0C\u5C0F\u4E8E DC \u5931\u8D25",
      rules: [
        { level: "\u5931\u8D25", expression: "roll < targetValue" },
        { level: "\u6210\u529F", expression: "roll >= targetValue" }
      ]
    },
    {
      id: "coc1",
      name: "COC \u89C4\u5219 1",
      description: "\u4E0D\u6EE1 50 \u51FA 1 \u5927\u6210\u529F\uFF0C\u6EE1 50 \u51FA 1-5 \u5927\u6210\u529F\uFF1B\u4E0D\u6EE1 50 \u51FA 96-100 \u5927\u5931\u8D25\uFF0C\u6EE1 50 \u51FA 100 \u5927\u5931\u8D25",
      rules: [
        { level: "\u5927\u5931\u8D25", expression: "(targetValue < 50 && roll > 95) || (targetValue >= 50 && roll == 100)" },
        { level: "\u5927\u6210\u529F", expression: "(targetValue < 50 && roll == 1) || (targetValue >= 50 && roll <= 5)" },
        { level: "\u5931\u8D25", expression: "roll > targetValue" },
        { level: "\u6781\u96BE\u6210\u529F", expression: "roll <= targetValue && roll <= baseValue / 5" },
        { level: "\u56F0\u96BE\u6210\u529F", expression: "roll <= targetValue && roll <= baseValue / 2" },
        { level: "\u6210\u529F", expression: "roll <= targetValue" }
      ]
    },
    {
      id: "coc2",
      name: "COC \u89C4\u5219 2",
      description: "\u51FA 1-5 \u4E14 \u2264 \u6210\u529F\u7387\u5927\u6210\u529F\uFF1B\u51FA 100 \u6216\u51FA 96-99 \u4E14 > \u6210\u529F\u7387\u5927\u5931\u8D25",
      rules: [
        { level: "\u5927\u5931\u8D25", expression: "roll == 100 || (roll > 95 && roll > targetValue)" },
        { level: "\u5927\u6210\u529F", expression: "roll <= 5 && roll <= targetValue" },
        { level: "\u5931\u8D25", expression: "roll > targetValue" },
        { level: "\u6781\u96BE\u6210\u529F", expression: "roll <= targetValue && roll <= baseValue / 5" },
        { level: "\u56F0\u96BE\u6210\u529F", expression: "roll <= targetValue && roll <= baseValue / 2" },
        { level: "\u6210\u529F", expression: "roll <= targetValue" }
      ]
    },
    {
      id: "coc3",
      name: "COC \u89C4\u5219 3",
      description: "\u51FA 1-5 \u5927\u6210\u529F\uFF1B\u51FA 96-100 \u5927\u5931\u8D25",
      rules: [
        { level: "\u5927\u5931\u8D25", expression: "roll > 95" },
        { level: "\u5927\u6210\u529F", expression: "roll <= 5" },
        { level: "\u5931\u8D25", expression: "roll > targetValue" },
        { level: "\u6781\u96BE\u6210\u529F", expression: "roll <= targetValue && roll <= baseValue / 5" },
        { level: "\u56F0\u96BE\u6210\u529F", expression: "roll <= targetValue && roll <= baseValue / 2" },
        { level: "\u6210\u529F", expression: "roll <= targetValue" }
      ]
    },
    {
      id: "coc4",
      name: "COC \u89C4\u5219 4",
      description: "\u51FA 1-5 \u4E14 \u2264 \u6210\u529F\u7387/10 \u5927\u6210\u529F\uFF1B\u4E0D\u6EE1 50 \u51FA \u2265 96+\u6210\u529F\u7387/10 \u5927\u5931\u8D25\uFF0C\u6EE1 50 \u51FA 100 \u5927\u5931\u8D25",
      rules: [
        { level: "\u5927\u5931\u8D25", expression: "(targetValue < 50 && roll >= 96 + targetValue / 10) || (targetValue >= 50 && roll == 100)" },
        { level: "\u5927\u6210\u529F", expression: "roll <= 5 && roll <= targetValue / 10" },
        { level: "\u5931\u8D25", expression: "roll > targetValue" },
        { level: "\u6781\u96BE\u6210\u529F", expression: "roll <= targetValue && roll <= baseValue / 5" },
        { level: "\u56F0\u96BE\u6210\u529F", expression: "roll <= targetValue && roll <= baseValue / 2" },
        { level: "\u6210\u529F", expression: "roll <= targetValue" }
      ]
    },
    {
      id: "coc5",
      name: "COC \u89C4\u5219 5",
      description: "\u51FA 1-2 \u4E14 < \u6210\u529F\u7387/5 \u5927\u6210\u529F\uFF1B\u4E0D\u6EE1 50 \u51FA 96-100 \u5927\u5931\u8D25\uFF0C\u6EE1 50 \u51FA 99-100 \u5927\u5931\u8D25",
      rules: [
        { level: "\u5927\u5931\u8D25", expression: "(targetValue < 50 && roll >= 96) || (targetValue >= 50 && roll >= 99)" },
        { level: "\u5927\u6210\u529F", expression: "roll <= 2 && roll < targetValue / 5" },
        { level: "\u5931\u8D25", expression: "roll > targetValue" },
        { level: "\u6781\u96BE\u6210\u529F", expression: "roll <= targetValue && roll <= baseValue / 5" },
        { level: "\u56F0\u96BE\u6210\u529F", expression: "roll <= targetValue && roll <= baseValue / 2" },
        { level: "\u6210\u529F", expression: "roll <= targetValue" }
      ]
    },
    {
      id: "deltagreen",
      name: "\u7EFF\u8272\u4E09\u89D2\u6D32\u89C4\u5219",
      description: "\u51FA 1\uFF0C\u6216\u4E2A\u4F4D\u6570 = \u5341\u4F4D\u6570\u4E14 \u2264 \u6210\u529F\u7387\u5219\u5927\u6210\u529F\uFF1B\u51FA 100\uFF0C\u6216\u4E2A\u4F4D\u6570 = \u5341\u4F4D\u6570\u4E14 > \u6210\u529F\u7387\u5219\u5927\u5931\u8D25",
      rules: [
        { level: "\u5927\u5931\u8D25", expression: "roll == 100 || (roll % 11 == 0 && roll > targetValue)" },
        { level: "\u5927\u6210\u529F", expression: "roll == 1 || (roll % 11 == 0 && roll <= targetValue)" },
        { level: "\u5931\u8D25", expression: "roll > targetValue" },
        { level: "\u6781\u96BE\u6210\u529F", expression: "roll <= targetValue && roll <= baseValue / 5" },
        { level: "\u56F0\u96BE\u6210\u529F", expression: "roll <= targetValue && roll <= baseValue / 2" },
        { level: "\u6210\u529F", expression: "roll <= targetValue" }
      ]
    }
  ];
}
function getEmbedCustomText() {
  const s = (text) => [{ text, weight: 1 }];
  const texts = {
    "roll.start": s("{{\u7528\u6237\u540D}} \uD83C\uDFB2 {{\u63CF\u8FF0}}"),
    "roll.inline.first": s("\u5148\u662F \uD83C\uDFB2 "),
    "roll.inline.middle": s("\u7136\u540E \uD83C\uDFB2 "),
    "roll.inline.last": s("\u6700\u540E \uD83C\uDFB2 "),
    "roll.result": s("{{\u63B7\u9AB0\u8F93\u51FA}}"),
    "roll.result.quiet": s("{{\u63B7\u9AB0\u8868\u8FBE\u5F0F}} = {{\u63B7\u9AB0\u7ED3\u679C}}"),
    "roll.hidden": s("{{\u7528\u6237\u540D}} \u5728\u5E37\u5E55\u540E\u9762\u5077\u5077\u5730 \uD83C\uDFB2 {{\u63CF\u8FF0}}\uFF0C\u731C\u731C\u7ED3\u679C\u662F\u4EC0\u4E48"),
    "test.worst": s(" \u5927\u5931\u8D25"),
    "test.best": s(" \u5927\u6210\u529F"),
    "test.fail": s(" / {{\u76EE\u6807\u503C}} \u5931\u8D25"),
    "test.exsuccess": s(" / {{\u76EE\u6807\u503C}} \u6210\u529F"),
    "test.hardsuccess": s(" / {{\u76EE\u6807\u503C}} \u6210\u529F"),
    "test.success": s(" / {{\u76EE\u6807\u503C}} \u6210\u529F"),
    "roll.vs.prompt": s("> \u56DE\u590D\u672C\u6761\u6D88\u606F\u4EE5\u8FDB\u884C\u5BF9\u6297"),
    "roll.vs.result": s("{{#\u80DC}}\uD83D\uDFE9{{/\u80DC}}{{#\u8D1F}}\uD83D\uDFE5{{/\u8D1F}}{{#\u5E73}}\uD83D\uDFE8{{/\u5E73}} {{\u7528\u6237\u540D}} {{\u63CF\u8FF0}}{{#coc}}({{\u6280\u80FD\u503C}}) {{\u6210\u529F\u7B49\u7EA7}}{{/coc}}{{#dnd}} {{\u63B7\u9AB0\u7ED3\u679C}}{{/dnd}} \u2194\uFE0F {{\u5BF9\u65B9\u7528\u6237\u540D}} {{\u5BF9\u65B9\u63CF\u8FF0}}{{#coc}}({{\u5BF9\u65B9\u6280\u80FD\u503C}}) {{\u5BF9\u65B9\u6210\u529F\u7B49\u7EA7}}{{/coc}}{{#dnd}} {{\u5BF9\u65B9\u63B7\u9AB0\u7ED3\u679C}}{{/dnd}} {{#\u5BF9\u65B9\u80DC}}\uD83D\uDFE9{{/\u5BF9\u65B9\u80DC}}{{#\u5BF9\u65B9\u8D1F}}\uD83D\uDFE5{{/\u5BF9\u65B9\u8D1F}}{{#\u5BF9\u65B9\u5E73}}\uD83D\uDFE8{{/\u5BF9\u65B9\u5E73}}"),
    "roll.ds.best": s(" \u8D77\u6B7B\u56DE\u751F\uFF0CHP+1"),
    "roll.ds.worst": s(" \u4E8C\u6B21\u5931\u8D25"),
    "roll.ds.tostable": s(`
\u6210\u529F\u4E09\u6B21\uFF0C\u4F24\u52BF\u7A33\u5B9A\u4E86`),
    "roll.ds.todeath": s(`
\u5931\u8D25\u4E09\u6B21\uFF0C\u53BB\u4E16\u4E86`),
    "roll.en.empty": s("{{\u7528\u6237\u540D}} \u5F53\u524D\u6682\u65E0\u53EF\u6210\u957F\u7684\u6280\u80FD\u6216\u4E0D\u652F\u6301\u6210\u957F"),
    "roll.en.list": s(`{{\u7528\u6237\u540D}} \u5F53\u524D\u53EF\u6210\u957F\u7684\u6280\u80FD\uFF1A
{{#\u6280\u80FD\u5217\u8868}}{{\u6280\u80FD\u540D}}{{^last}}\u3001{{/last}}{{/\u6280\u80FD\u5217\u8868}}`),
    "roll.en.extra": s(`
{{\u63CF\u8FF0}}\u53D8\u5316\uFF1A{{\u65E7\u503C}} \u2192 {{\u65B0\u503C}}`),
    "roll.en.mark": s(`{{\u7528\u6237\u540D}} \u5DF2{{#\u6DFB\u52A0}}\u6DFB\u52A0{{/\u6DFB\u52A0}}{{^\u6DFB\u52A0}}\u79FB\u9664{{/\u6DFB\u52A0}}\u4EE5\u4E0B\u6280\u80FD\u6210\u957F\u6807\u8BB0\uFF1A
{{#\u6280\u80FD\u5217\u8868}}{{\u6280\u80FD\u540D}}{{^last}}\u3001{{/last}}{{/\u6280\u80FD\u5217\u8868}}`),
    "roll.en.markclear": s("{{\u7528\u6237\u540D}} \u5DF2\u79FB\u9664\u6240\u6709\u7684\u6280\u80FD\u6210\u957F\u6807\u8BB0"),
    "roll.ri.unsupported": s("\u5F53\u524D\u573A\u666F\u4E0D\u652F\u6301\u5148\u653B\u5217\u8868"),
    "roll.ri.del": s("{{\u7528\u6237\u540D}} \u5220\u9664\u5148\u653B\uFF1A{{#\u4EBA\u7269\u5217\u8868}}{{\u4EBA\u7269\u540D}}{{^last}}\u3001{{/last}}{{/\u4EBA\u7269\u5217\u8868}}"),
    "roll.ri.clear": s("*\u5148\u653B\u5217\u8868\u5DF2\u6E05\u7A7A"),
    "roll.sc.unsupported": s(" \u2026\u2026\u672A\u6307\u5B9A\u7406\u667A\u503C\uFF0C\u6210\u529F\u4E86\u5417\uFF1F"),
    "roll.sc.extra": s(`
{{#\u63B7\u9AB0\u7ED3\u679C}}\u7406\u667A\u53D8\u5316\uFF1A{{\u65E7\u503C}} \u2192 {{\u65B0\u503C}}{{/\u63B7\u9AB0\u7ED3\u679C}}`),
    "card.empty": s("{{at\u7528\u6237}}\u6CA1\u6709\u5173\u8054\u4EBA\u7269\u5361"),
    "card.nopermission": s("{{\u7528\u6237\u540D}} \u6CA1\u6709\u64CD\u4F5C\u4EBA\u7269\u5361\u7684\u6743\u9650"),
    "roll.st.prompt": s("{{at\u7528\u6237}}\u8BF7\u6307\u5B9A\u60F3\u8981\u8BBE\u7F6E\u7684\u5C5E\u6027\u540D\u4E0E\u5C5E\u6027\u503C"),
    "roll.st.show": s(`{{at\u7528\u6237}}({{\u4EBA\u7269\u5361\u540D}}):
{{#\u6761\u76EE\u5217\u8868}}{{\u6761\u76EE}}{{^last}} {{/last}}{{/\u6761\u76EE\u5217\u8868}}`),
    "roll.st.set": s(`{{at\u7528\u6237}}({{\u4EBA\u7269\u5361\u540D}}) \u8BBE\u7F6E:
{{#\u6761\u76EE\u5217\u8868}}{{\u6761\u76EE}}{{^last}}
{{/last}}{{/\u6761\u76EE\u5217\u8868}}`),
    "nn.show": s("{{at\u7528\u6237}}\u5F53\u524D{{#\u4EBA\u7269\u5361\u540D}}\u5DF2\u5173\u8054\u4EBA\u7269\u5361\uFF1A{{\u4EBA\u7269\u5361\u540D}}{{/\u4EBA\u7269\u5361\u540D}}{{^\u4EBA\u7269\u5361\u540D}}\u672A\u5173\u8054\u4EBA\u7269\u5361{{/\u4EBA\u7269\u5361\u540D}}"),
    "nn.link": s("{{at\u7528\u6237}}\u5DF2\u5173\u8054\u4EBA\u7269\u5361\uFF1A{{\u4EBA\u7269\u5361\u540D}}"),
    "nn.clear": s("{{at\u7528\u6237}}\u5DF2\u53D6\u6D88\u5173\u8054\u4EBA\u7269\u5361"),
    "nn.search": s(`{{at\u7528\u6237}}\u8BF7\u9009\u62E9\u60F3\u8981\u5173\u8054\u7684\u4EBA\u7269\u5361\uFF1A
{{#\u4EBA\u7269\u5361\u5217\u8868}}{{\u4EBA\u7269\u5361\u540D}}{{^last}}
{{/last}}{{/\u4EBA\u7269\u5361\u5217\u8868}}
{{^\u4EBA\u7269\u5361\u5217\u8868}}\u672A\u627E\u5230\u540D\u5B57\u5305\u542B{{\u5173\u952E\u8BCD}}\u7684\u4EBA\u7269\u5361{{/\u4EBA\u7269\u5361\u5217\u8868}}`)
  };
  return { id: "default", name: "\u9ED8\u8BA4\u6587\u6848", texts };
}
function getSpecialDiceConfig() {
  return {
    enDice: { enabled: true },
    scDice: { enabled: true },
    riDice: { enabled: true, baseRoll: "d20" },
    stDice: { enabled: true, writable: "all" },
    dsDice: { enabled: true },
    nnDice: { enabled: true, writable: "all" },
    opposeDice: { enabled: true },
    inMessageDice: { enabled: true }
  };
}
var embedPluginId = "io.paotuan.embed";

// ../../node_modules/mustache/mustache.mjs
var isFunction2 = function(object36) {
  return typeof object36 === "function";
};
var typeStr = function(obj) {
  return isArray2(obj) ? "array" : typeof obj;
};
var escapeRegExp = function(string31) {
  return string31.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
};
var hasProperty = function(obj, propName) {
  return obj != null && typeof obj === "object" && propName in obj;
};
var primitiveHasOwnProperty = function(primitive, propName) {
  return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
};
var testRegExp = function(re3, string31) {
  return regExpTest.call(re3, string31);
};
var isWhitespace = function(string31) {
  return !testRegExp(nonSpaceRe, string31);
};
var escapeHtml = function(string31) {
  return String(string31).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
    return entityMap[s];
  });
};
var parseTemplate4 = function(template, tags) {
  if (!template)
    return [];
  var lineHasNonSpace = false;
  var sections = [];
  var tokens = [];
  var spaces = [];
  var hasTag = false;
  var nonSpace = false;
  var indentation = "";
  var tagIndex = 0;
  function stripSpace() {
    if (hasTag && !nonSpace) {
      while (spaces.length)
        delete tokens[spaces.pop()];
    } else {
      spaces = [];
    }
    hasTag = false;
    nonSpace = false;
  }
  var openingTagRe, closingTagRe, closingCurlyRe;
  function compileTags(tagsToCompile) {
    if (typeof tagsToCompile === "string")
      tagsToCompile = tagsToCompile.split(spaceRe, 2);
    if (!isArray2(tagsToCompile) || tagsToCompile.length !== 2)
      throw new Error("Invalid tags: " + tagsToCompile);
    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
    closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
    closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
  }
  compileTags(tags || mustache.tags);
  var scanner = new Scanner(template);
  var start, type, value, chr, token, openSection;
  while (!scanner.eos()) {
    start = scanner.pos;
    value = scanner.scanUntil(openingTagRe);
    if (value) {
      for (var i3 = 0, valueLength = value.length;i3 < valueLength; ++i3) {
        chr = value.charAt(i3);
        if (isWhitespace(chr)) {
          spaces.push(tokens.length);
          indentation += chr;
        } else {
          nonSpace = true;
          lineHasNonSpace = true;
          indentation += " ";
        }
        tokens.push(["text", chr, start, start + 1]);
        start += 1;
        if (chr === "\n") {
          stripSpace();
          indentation = "";
          tagIndex = 0;
          lineHasNonSpace = false;
        }
      }
    }
    if (!scanner.scan(openingTagRe))
      break;
    hasTag = true;
    type = scanner.scan(tagRe) || "name";
    scanner.scan(whiteRe);
    if (type === "=") {
      value = scanner.scanUntil(equalsRe);
      scanner.scan(equalsRe);
      scanner.scanUntil(closingTagRe);
    } else if (type === "{") {
      value = scanner.scanUntil(closingCurlyRe);
      scanner.scan(curlyRe);
      scanner.scanUntil(closingTagRe);
      type = "&";
    } else {
      value = scanner.scanUntil(closingTagRe);
    }
    if (!scanner.scan(closingTagRe))
      throw new Error("Unclosed tag at " + scanner.pos);
    if (type == ">") {
      token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
    } else {
      token = [type, value, start, scanner.pos];
    }
    tagIndex++;
    tokens.push(token);
    if (type === "#" || type === "^") {
      sections.push(token);
    } else if (type === "/") {
      openSection = sections.pop();
      if (!openSection)
        throw new Error('Unopened section "' + value + '" at ' + start);
      if (openSection[1] !== value)
        throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
    } else if (type === "name" || type === "{" || type === "&") {
      nonSpace = true;
    } else if (type === "=") {
      compileTags(value);
    }
  }
  stripSpace();
  openSection = sections.pop();
  if (openSection)
    throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
  return nestTokens(squashTokens(tokens));
};
var squashTokens = function(tokens) {
  var squashedTokens = [];
  var token, lastToken;
  for (var i3 = 0, numTokens = tokens.length;i3 < numTokens; ++i3) {
    token = tokens[i3];
    if (token) {
      if (token[0] === "text" && lastToken && lastToken[0] === "text") {
        lastToken[1] += token[1];
        lastToken[3] = token[3];
      } else {
        squashedTokens.push(token);
        lastToken = token;
      }
    }
  }
  return squashedTokens;
};
var nestTokens = function(tokens) {
  var nestedTokens = [];
  var collector = nestedTokens;
  var sections = [];
  var token, section;
  for (var i3 = 0, numTokens = tokens.length;i3 < numTokens; ++i3) {
    token = tokens[i3];
    switch (token[0]) {
      case "#":
      case "^":
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case "/":
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
    }
  }
  return nestedTokens;
};
var Scanner = function(string31) {
  this.string = string31;
  this.tail = string31;
  this.pos = 0;
};
var Context2 = function(view, parentContext) {
  this.view = view;
  this.cache = { ".": this.view };
  this.parent = parentContext;
};
var Writer = function() {
  this.templateCache = {
    _cache: {},
    set: function set(key, value) {
      this._cache[key] = value;
    },
    get: function get(key) {
      return this._cache[key];
    },
    clear: function clear() {
      this._cache = {};
    }
  };
};
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */
var objectToString = Object.prototype.toString;
var isArray2 = Array.isArray || function isArrayPolyfill(object36) {
  return objectToString.call(object36) === "[object Array]";
};
var regExpTest = RegExp.prototype.test;
var nonSpaceRe = /\S/;
var entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
var whiteRe = /\s*/;
var spaceRe = /\s+/;
var equalsRe = /\s*=/;
var curlyRe = /\s*\}/;
var tagRe = /#|\^|\/|>|\{|&|=|!/;
Scanner.prototype.eos = function eos() {
  return this.tail === "";
};
Scanner.prototype.scan = function scan(re3) {
  var match = this.tail.match(re3);
  if (!match || match.index !== 0)
    return "";
  var string31 = match[0];
  this.tail = this.tail.substring(string31.length);
  this.pos += string31.length;
  return string31;
};
Scanner.prototype.scanUntil = function scanUntil(re3) {
  var index2 = this.tail.search(re3), match;
  switch (index2) {
    case -1:
      match = this.tail;
      this.tail = "";
      break;
    case 0:
      match = "";
      break;
    default:
      match = this.tail.substring(0, index2);
      this.tail = this.tail.substring(index2);
  }
  this.pos += match.length;
  return match;
};
Context2.prototype.push = function push(view) {
  return new Context2(view, this);
};
Context2.prototype.lookup = function lookup2(name302) {
  var cache = this.cache;
  var value;
  if (cache.hasOwnProperty(name302)) {
    value = cache[name302];
  } else {
    var context2 = this, intermediateValue, names, index2, lookupHit = false;
    while (context2) {
      if (name302.indexOf(".") > 0) {
        intermediateValue = context2.view;
        names = name302.split(".");
        index2 = 0;
        while (intermediateValue != null && index2 < names.length) {
          if (index2 === names.length - 1)
            lookupHit = hasProperty(intermediateValue, names[index2]) || primitiveHasOwnProperty(intermediateValue, names[index2]);
          intermediateValue = intermediateValue[names[index2++]];
        }
      } else {
        intermediateValue = context2.view[name302];
        lookupHit = hasProperty(context2.view, name302);
      }
      if (lookupHit) {
        value = intermediateValue;
        break;
      }
      context2 = context2.parent;
    }
    cache[name302] = value;
  }
  if (isFunction2(value))
    value = value.call(this.view);
  return value;
};
Writer.prototype.clearCache = function clearCache() {
  if (typeof this.templateCache !== "undefined") {
    this.templateCache.clear();
  }
};
Writer.prototype.parse = function parse2(template, tags) {
  var cache = this.templateCache;
  var cacheKey = template + ":" + (tags || mustache.tags).join(":");
  var isCacheEnabled = typeof cache !== "undefined";
  var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;
  if (tokens == undefined) {
    tokens = parseTemplate4(template, tags);
    isCacheEnabled && cache.set(cacheKey, tokens);
  }
  return tokens;
};
Writer.prototype.render = function render(template, view, partials, config7) {
  var tags = this.getConfigTags(config7);
  var tokens = this.parse(template, tags);
  var context2 = view instanceof Context2 ? view : new Context2(view, undefined);
  return this.renderTokens(tokens, context2, partials, template, config7);
};
Writer.prototype.renderTokens = function renderTokens(tokens, context2, partials, originalTemplate, config7) {
  var buffer = "";
  var token, symbol, value;
  for (var i3 = 0, numTokens = tokens.length;i3 < numTokens; ++i3) {
    value = undefined;
    token = tokens[i3];
    symbol = token[0];
    if (symbol === "#")
      value = this.renderSection(token, context2, partials, originalTemplate, config7);
    else if (symbol === "^")
      value = this.renderInverted(token, context2, partials, originalTemplate, config7);
    else if (symbol === ">")
      value = this.renderPartial(token, context2, partials, config7);
    else if (symbol === "&")
      value = this.unescapedValue(token, context2);
    else if (symbol === "name")
      value = this.escapedValue(token, context2, config7);
    else if (symbol === "text")
      value = this.rawValue(token);
    if (value !== undefined)
      buffer += value;
  }
  return buffer;
};
Writer.prototype.renderSection = function renderSection(token, context2, partials, originalTemplate, config7) {
  var self2 = this;
  var buffer = "";
  var value = context2.lookup(token[1]);
  function subRender(template) {
    return self2.render(template, context2, partials, config7);
  }
  if (!value)
    return;
  if (isArray2(value)) {
    for (var j = 0, valueLength = value.length;j < valueLength; ++j) {
      buffer += this.renderTokens(token[4], context2.push(value[j]), partials, originalTemplate, config7);
    }
  } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
    buffer += this.renderTokens(token[4], context2.push(value), partials, originalTemplate, config7);
  } else if (isFunction2(value)) {
    if (typeof originalTemplate !== "string")
      throw new Error("Cannot use higher-order sections without the original template");
    value = value.call(context2.view, originalTemplate.slice(token[3], token[5]), subRender);
    if (value != null)
      buffer += value;
  } else {
    buffer += this.renderTokens(token[4], context2, partials, originalTemplate, config7);
  }
  return buffer;
};
Writer.prototype.renderInverted = function renderInverted(token, context2, partials, originalTemplate, config7) {
  var value = context2.lookup(token[1]);
  if (!value || isArray2(value) && value.length === 0)
    return this.renderTokens(token[4], context2, partials, originalTemplate, config7);
};
Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
  var filteredIndentation = indentation.replace(/[^ \t]/g, "");
  var partialByNl = partial.split("\n");
  for (var i3 = 0;i3 < partialByNl.length; i3++) {
    if (partialByNl[i3].length && (i3 > 0 || !lineHasNonSpace)) {
      partialByNl[i3] = filteredIndentation + partialByNl[i3];
    }
  }
  return partialByNl.join("\n");
};
Writer.prototype.renderPartial = function renderPartial(token, context2, partials, config7) {
  if (!partials)
    return;
  var tags = this.getConfigTags(config7);
  var value = isFunction2(partials) ? partials(token[1]) : partials[token[1]];
  if (value != null) {
    var lineHasNonSpace = token[6];
    var tagIndex = token[5];
    var indentation = token[4];
    var indentedValue = value;
    if (tagIndex == 0 && indentation) {
      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
    }
    var tokens = this.parse(indentedValue, tags);
    return this.renderTokens(tokens, context2, partials, indentedValue, config7);
  }
};
Writer.prototype.unescapedValue = function unescapedValue(token, context2) {
  var value = context2.lookup(token[1]);
  if (value != null)
    return value;
};
Writer.prototype.escapedValue = function escapedValue(token, context2, config7) {
  var escape2 = this.getConfigEscape(config7) || mustache.escape;
  var value = context2.lookup(token[1]);
  if (value != null)
    return typeof value === "number" && escape2 === mustache.escape ? String(value) : escape2(value);
};
Writer.prototype.rawValue = function rawValue(token) {
  return token[1];
};
Writer.prototype.getConfigTags = function getConfigTags(config7) {
  if (isArray2(config7)) {
    return config7;
  } else if (config7 && typeof config7 === "object") {
    return config7.tags;
  } else {
    return;
  }
};
Writer.prototype.getConfigEscape = function getConfigEscape(config7) {
  if (config7 && typeof config7 === "object" && !isArray2(config7)) {
    return config7.escape;
  } else {
    return;
  }
};
var mustache = {
  name: "mustache.js",
  version: "4.2.0",
  tags: ["{{", "}}"],
  clearCache: undefined,
  escape: undefined,
  parse: undefined,
  render: undefined,
  Scanner: undefined,
  Context: undefined,
  Writer: undefined,
  set templateCache(cache) {
    defaultWriter.templateCache = cache;
  },
  get templateCache() {
    return defaultWriter.templateCache;
  }
};
var defaultWriter = new Writer;
mustache.clearCache = function clearCache2() {
  return defaultWriter.clearCache();
};
mustache.parse = function parse3(template, tags) {
  return defaultWriter.parse(template, tags);
};
mustache.render = function render2(template, view, partials, config7) {
  if (typeof template !== "string") {
    throw new TypeError('Invalid template! Template should be a "string" ' + 'but "' + typeStr(template) + '" was given as the first ' + "argument for mustache#render(template, view, partials)");
  }
  return defaultWriter.render(template, view, partials, config7);
};
mustache.escape = escapeHtml;
mustache.Scanner = Scanner;
mustache.Context = Context2;
mustache.Writer = Writer;
var mustache_default = mustache;

// ../../packages/dicecore/lib/config/helpers/customText.js
function renderCustomText(customTextMap, key, args, context2) {
  const processor = customTextMap[key];
  if (!processor) {
    console.error(`[Config] \u627E\u4E0D\u5230 ${key} \u7684\u81EA\u5B9A\u4E49\u6587\u6848`);
    return "";
  }
  if (typeof processor === "function") {
    try {
      return processor(args, context2);
    } catch (e4) {
      console.error(`[Config] \u81EA\u5B9A\u4E49\u6587\u6848 ${key} \u5904\u7406\u51FA\u9519`, e4?.message);
      return "";
    }
  } else {
    const replyItem = randomReplyItem(processor);
    let result = mustache_default.render(replyItem.text, args, undefined, { escape: (value) => value });
    const endIndex = result.indexOf("$end$");
    if (endIndex >= 0) {
      result = result.substring(0, endIndex);
    }
    return result;
  }
}
var randomReplyItem = function(items) {
  if (items.length === 1)
    return items[0];
  const totalWeight = items.map((item) => item.weight).reduce((a, b) => a + b, 0);
  let randomWeight = Math.random() * totalWeight;
  for (const item of items) {
    randomWeight -= item.weight;
    if (randomWeight < 0) {
      return item;
    }
  }
  return items[items.length - 1];
};

// ../../packages/dicecore/lib/config/helpers/aliasCommand.js
function parseAliasForCommand(processors, command) {
  let depth = 0;
  let result = command;
  while (true) {
    if (depth > 99)
      throw new Error("\u522B\u540D\u6307\u4EE4\u5D4C\u5957\u8FC7\u6DF1\uFF0C\u53EF\u80FD\u89E6\u53D1\u6B7B\u5FAA\u73AF\uFF0C\u8BF7\u68C0\u67E5\u4F60\u7684\u522B\u540D\u6307\u4EE4\u914D\u7F6E\uFF01");
    depth++;
    let matchedAlias = false;
    for (const config7 of processors) {
      if (!config7.command)
        continue;
      if (config7.scope !== "command")
        continue;
      if (config7.trigger === "startWith") {
        if (result.startsWith(config7.command)) {
          matchedAlias = true;
          if (typeof config7.replacer === "string") {
            result = result.replace(config7.command, config7.replacer);
          } else {
            console.warn("[Alias] unsupported trigger = startWith & replacer = function");
          }
        }
      } else {
        const regex = RegexCommandCache2.get(config7.command);
        if (!regex)
          continue;
        const match = result.match(regex);
        if (!match)
          continue;
        matchedAlias = true;
        if (typeof config7.replacer === "string") {
          const matchGroups = match.groups || {};
          result = mustache_default.render(config7.replacer, matchGroups, undefined, { escape: (value) => value });
        } else {
          result = config7.replacer(match);
        }
      }
    }
    if (!matchedAlias) {
      break;
    }
  }
  return result;
}
var RegexCommandCache2 = new SyncLruCache({
  max: 50,
  fetchMethod: (expression) => new RegExp(expression)
});

// ../../packages/dicecore/lib/config/helpers/hook.js
function handleHooks(processors, arg3) {
  let depth = 0;
  while (true) {
    if (depth > 99) {
      console.warn("hook \u5D4C\u5957\u8FC7\u6DF1\uFF0C\u53EF\u80FD\u51FA\u73B0\u6B7B\u5FAA\u73AF\uFF01");
      break;
    }
    depth++;
    let anyHandled = false;
    for (const processor of processors) {
      const handled = processor.handler(arg3);
      anyHandled ||= handled;
    }
    if (!anyHandled) {
      break;
    }
  }
}
async function handleHooksAsync(processors, arg3) {
  let depth = 0;
  while (true) {
    if (depth > 99) {
      console.warn("hook \u5D4C\u5957\u8FC7\u6DF1\uFF0C\u53EF\u80FD\u51FA\u73B0\u6B7B\u5FAA\u73AF\uFF01");
      break;
    }
    depth++;
    let anyHandled = false;
    for (const processor of processors) {
      const handled = await processor.handler(arg3);
      anyHandled ||= handled;
    }
    if (!anyHandled) {
      break;
    }
  }
}
function handleVoidHooks(processors, arg3) {
  for (const processor of processors) {
    processor.handler(arg3);
  }
}
async function handleLinearHooksAsync(processors, arg3) {
  let anyHandled = false;
  for (const processor of processors) {
    const handled = await processor.handler(arg3);
    anyHandled ||= handled;
  }
  return anyHandled;
}

// ../../packages/dicecore/lib/config/migration/upgrade.js
function upgradeConfig(config7) {
  if (config7.version === 1) {
    const rollDeciders = getEmbedRollDecider();
    config7.embedPlugin.rollDecider = rollDeciders;
    config7.rollDeciderId = `${embedPluginId}.${rollDeciders[0].id}`;
    config7.rollDeciderIds = rollDeciders.map((item) => `${embedPluginId}.${item.id}`);
    config7.version = 2;
  }
  if (config7.version === 2) {
    const aliasRolls = getEmbedAliasRoll();
    config7.embedPlugin.aliasRoll = aliasRolls;
    config7.aliasRollIds = aliasRolls.map((item) => ({ id: `${embedPluginId}.${item.id}`, enabled: true }));
    config7.specialDice = getSpecialDiceConfig();
    config7.version = 3;
  }
  if (config7.version === 3) {
    config7.customReplyIds.push({ id: "io.paotuan.plugin.namegen.name", enabled: true });
    config7.customReplyIds.push({ id: "io.paotuan.plugin.insane.ti", enabled: true });
    config7.customReplyIds.push({ id: "io.paotuan.plugin.insane.li", enabled: true });
    config7.customReplyIds.push({ id: "io.paotuan.plugin.cardgen.coc", enabled: true });
    config7.customReplyIds.push({ id: "io.paotuan.plugin.cardgen.dnd", enabled: true });
    const index2 = config7.embedPlugin.customReply?.findIndex((item) => item.id === "coccardrand");
    if (typeof index2 === "number" && index2 >= 0) {
      config7.embedPlugin.customReply?.splice(index2, 1);
    }
    const index1 = config7.customReplyIds.findIndex((item) => item.id === "io.paotuan.embed.coccardrand");
    if (index1 >= 0) {
      config7.customReplyIds.splice(index1, 1);
    }
    const rules2remove = ["coc1", "coc2", "coc3", "coc4", "coc5", "deltagreen"];
    rules2remove.forEach((id) => {
      const index3 = config7.embedPlugin.rollDecider?.findIndex((item) => item.id === id);
      if (typeof index3 === "number" && index3 >= 0) {
        config7.embedPlugin.rollDecider?.splice(index3, 1);
      }
      const index12 = config7.rollDeciderIds.findIndex((_id) => _id === "io.paotuan.embed." + id);
      if (index12 >= 0) {
        config7.rollDeciderIds.splice(index12, 1);
        if (config7.rollDeciderId === "io.paotuan.embed." + id) {
          config7.rollDeciderId = "io.paotuan.embed.coc0";
        }
      }
    });
    config7.version = 4;
  }
  if (config7.version < 17) {
    const defaultRoll = config7.defaultRoll;
    config7.defaultRoll = { expression: defaultRoll, preferCard: true };
    config7.specialDice.dsDice = { enabled: true };
    config7.version = 17;
  }
  if (config7.version < 21) {
    const oldDeciderConfig = config7.embedPlugin.rollDecider || [];
    config7.embedPlugin.rollDecider = getEmbedRollDecider();
    const decider2insert = oldDeciderConfig.filter((decider) => decider.id !== "coc0" && decider.id !== "dnd0");
    config7.embedPlugin.rollDecider.splice(2, 0, ...decider2insert.map((decider) => ({
      id: decider.id,
      name: decider.name,
      description: decider.description,
      rules: [
        { level: "\u5927\u5931\u8D25", expression: decider.rules.worst.expression },
        { level: "\u5927\u6210\u529F", expression: decider.rules.best.expression },
        { level: "\u5931\u8D25", expression: decider.rules.fail.expression },
        { level: "\u6210\u529F", expression: decider.rules.success.expression }
      ]
    })));
    config7.rollDeciderIds = config7.embedPlugin.rollDecider.map((decider) => `${embedPluginId}.${decider.id}`);
    if (!config7.rollDeciderIds.includes(config7.rollDeciderId)) {
      config7.rollDeciderId = config7.rollDeciderIds[0];
    }
    config7.customTextIds = [];
    const embedText = getEmbedCustomText();
    config7.embedPlugin.customText = [embedText];
    const oldDeciderReplies = [];
    oldDeciderConfig.forEach((decider) => {
      oldDeciderReplies.push(decider.name + "\n" + decider.description);
      const rules = decider.rules;
      oldDeciderReplies.push(rules.worst.expression + " | " + rules.worst.reply);
      oldDeciderReplies.push(rules.best.expression + " | " + rules.best.reply);
      oldDeciderReplies.push(rules.fail.expression + " | " + rules.fail.reply);
      oldDeciderReplies.push(rules.success.expression + " | " + rules.success.reply);
      oldDeciderReplies.push("\n");
    });
    const index2 = config7.embedPlugin.customReply?.findIndex((item) => item.id === "help");
    if (typeof index2 === "number" && index2 < 0) {
      const helpConfig = getEmbedCustomReply().find((item) => item.id === "help");
      if (helpConfig) {
        config7.embedPlugin.customReply.push(helpConfig);
        config7.customReplyIds.push({ id: `${embedPluginId}.help`, enabled: true });
      }
    }
    config7.version = 21;
  }
  if (config7.version < 22) {
    config7.customReplyIds.push({ id: "io.paotuan.plugin.draw.draw", enabled: true });
    const embedText = getEmbedCustomText();
    config7.embedPlugin.customText[0].texts["roll.sc.extra"] = embedText.texts["roll.sc.extra"];
    config7.version = 22;
  }
  if (config7.version < 23) {
    if (config7.embedPlugin.rollDecider) {
      const mistakeIds = [["coc0", "\u5927\u5931\u8D25"], ["coc1", "\u5927\u5931\u8D25"], ["coc1", "\u5927\u6210\u529F"], ["coc4", "\u5927\u5931\u8D25"], ["coc5", "\u5927\u5931\u8D25"]];
      const newestConfig = getEmbedRollDecider();
      const getRule = (config8, id, level) => {
        const item = config8.find((_item) => _item.id === id);
        return item?.rules.find((rule) => rule.level === level);
      };
      mistakeIds.forEach(([id, level]) => {
        const now = getRule(config7.embedPlugin.rollDecider, id, level);
        if (!now)
          return;
        const right = getRule(newestConfig, id, level);
        if (!right)
          return;
        now.expression = right.expression;
      });
    }
    config7.version = 23;
  }
  if (config7.version < 26) {
    config7.botOwner = null;
    config7.version = 26;
  }
  if (config7.version < 29) {
    config7.specialDice.nnDice = { enabled: true, writable: "all" };
    config7.version = 29;
  }
  if (config7.version < 30) {
    config7.version = 30;
  }
  if (config7.version < 32) {
    const embedText = getEmbedCustomText();
    const texts = config7.embedPlugin.customText[0].texts;
    if (Array.isArray(texts["roll.sc.extra"]) && texts["roll.sc.extra"].length === 1 && texts["roll.sc.extra"][0].text === `
{{#\u635F\u5931\u503C}}\u7406\u667A\u53D8\u5316\uFF1A{{\u65E7\u503C}} \u2192 {{\u65B0\u503C}}{{/\u635F\u5931\u503C}}`) {
      texts["roll.sc.extra"] = embedText.texts["roll.sc.extra"];
    }
    texts["roll.en.extra"] = embedText.texts["roll.en.extra"];
    texts["roll.en.mark"] = embedText.texts["roll.en.mark"];
    texts["roll.en.markclear"] = embedText.texts["roll.en.markclear"];
    texts["nn.show"] = embedText.texts["nn.show"];
    texts["nn.link"] = embedText.texts["nn.link"];
    texts["nn.clear"] = embedText.texts["nn.clear"];
    texts["nn.search"] = embedText.texts["nn.search"];
    config7.version = 32;
  }
  if (config7.version < 33) {
    config7.plugins = [];
    config7.customTextIds = config7.customTextIds.map((id) => ({ id, enabled: true }));
    config7.embedPlugin.aliasRoll.forEach((alias) => alias.scope = "expression");
    config7.version = 33;
  }
  if (config7.version < 35) {
    config7.hookIds = {
      onReceiveCommand: [],
      beforeParseDiceRoll: [],
      onCardEntryChange: [],
      onMessageReaction: [],
      beforeDiceRoll: [],
      afterDiceRoll: []
    };
    if (config7.parseRule) {
      config7.hookIds.onReceiveCommand.push({ id: "io.paotuan.plugin.compatible.convertCase-Prefix", enabled: !!config7.parseRule.convertCase });
      config7.hookIds.beforeParseDiceRoll.push({ id: "io.paotuan.plugin.compatible.convertCase", enabled: !!config7.parseRule.convertCase });
      config7.hookIds.beforeParseDiceRoll.push({ id: "io.paotuan.plugin.compatible.detectCardEntry", enabled: !!config7.parseRule.detectCardEntry });
      config7.hookIds.beforeParseDiceRoll.push({ id: "io.paotuan.plugin.compatible.detectDefaultRoll", enabled: !!config7.parseRule.detectDefaultRoll });
    }
    config7.version = 35;
  }
  return config7;
}

// ../../packages/dicecore/lib/config/migration/updateByPlugin.js
var _ensurePluginConfig = function(config7, pluginId) {
  const pluginConfig = config7.plugins.find((_plugin) => _plugin.id === pluginId);
  if (pluginConfig) {
    return pluginConfig;
  }
  const newPluginConfig = { id: pluginId, enabled: true, preference: {} };
  config7.plugins.push(newPluginConfig);
  return config7.plugins.find((_plugin) => _plugin.id === pluginId);
};
function updateConfigByPlugin(config7) {
  const manifest = PluginProvider.INSTANCE.allPlugins;
  const existIds = {
    customReplyIds: new Set,
    aliasRollIds: new Set,
    customTextIds: new Set,
    hookIds: {
      onReceiveCommand: new Set,
      beforeParseDiceRoll: new Set,
      onCardEntryChange: new Set,
      onMessageReaction: new Set,
      beforeDiceRoll: new Set,
      afterDiceRoll: new Set
    }
  };
  manifest.forEach((plugin2) => {
    const pluginConfig = _ensurePluginConfig(config7, plugin2.id);
    const preference = {};
    plugin2.preference?.forEach((pref) => {
      preference[pref.key] = pluginConfig.preference[pref.key] ?? pref.defaultValue;
    });
    pluginConfig.preference = preference;
    if (!pluginConfig.enabled)
      return;
    plugin2.customReply?.forEach((item) => {
      const id = `${plugin2.id}.${item.id}`;
      existIds.customReplyIds.add(id);
      if (!config7.customReplyIds.find((_config) => _config.id === id)) {
        config7.customReplyIds.push({ id, enabled: item.defaultEnabled ?? true });
      }
    });
    plugin2.aliasRoll?.forEach((item) => {
      const id = `${plugin2.id}.${item.id}`;
      existIds.aliasRollIds.add(id);
      if (!config7.aliasRollIds.find((_config) => _config.id === id)) {
        config7.aliasRollIds.push({ id, enabled: item.defaultEnabled ?? true });
      }
    });
    plugin2.customText?.forEach((item) => {
      const id = `${plugin2.id}.${item.id}`;
      existIds.customTextIds.add(id);
      if (!config7.customTextIds.find((_config) => _config.id === id)) {
        config7.customTextIds.push({ id, enabled: item.defaultEnabled ?? true });
      }
    });
    ["onReceiveCommand", "beforeParseDiceRoll", "onCardEntryChange", "onMessageReaction", "beforeDiceRoll", "afterDiceRoll"].forEach((prop) => {
      plugin2.hook?.[prop]?.forEach((item) => {
        const id = `${plugin2.id}.${item.id}`;
        existIds.hookIds[prop].add(id);
        if (!config7.hookIds[prop].find((_config) => _config.id === id)) {
          config7.hookIds[prop].push({ id, enabled: item.defaultEnabled ?? true });
        }
      });
    });
  });
  ["customReplyIds", "aliasRollIds", "customTextIds"].forEach((prop) => {
    config7[prop] = config7[prop].filter((item) => item.id.startsWith("io.paotuan.embed") || existIds[prop].has(item.id));
  });
  ["onReceiveCommand", "beforeParseDiceRoll", "onCardEntryChange", "onMessageReaction", "beforeDiceRoll", "afterDiceRoll"].forEach((prop) => {
    config7.hookIds[prop] = config7.hookIds[prop].filter((item) => existIds.hookIds[prop].has(item.id));
  });
  return config7;
}

// ../../packages/dicecore/lib/dice/special/sc.js
var SC_CARD_ENTRY_NAME = "SAN";

class ScDiceRoll extends BasePtDiceRoll {
  noModify = false;
  expression1 = "";
  expression2 = "";
  description = "";
  tempValue = NaN;
  modifiedValue = NaN;
  scEntry;
  rollSc;
  rollScResult;
  rollLoss;
  oldSan = -1;
  newSan = -1;
  get scLoss() {
    const roll = this.rollLoss;
    if (!roll)
      return 0;
    if (roll.maxTotal > 0) {
      return Math.max(roll.total, 0);
    } else {
      return roll.total;
    }
  }
  get scTargetValue() {
    if (!this.scEntry)
      return;
    return this.scEntry.value + (this.modifiedValue || 0);
  }
  roll() {
    this.parse();
    this.rollLoss = undefined;
    this.rollScResult = undefined;
    this.rollSc = new DiceRoll("d%");
    if (!isNaN(this.tempValue)) {
      this.scEntry = { input: SC_CARD_ENTRY_NAME, key: SC_CARD_ENTRY_NAME, value: this.tempValue, isTemp: true };
    } else {
      this.scEntry = this.selfCard?.getEntry(SC_CARD_ENTRY_NAME);
    }
    if (this.scEntry) {
      this.rollScResult = this.decide({ baseValue: this.scEntry.value, targetValue: this.scTargetValue, roll: this.rollSc.total });
      if (this.rollScResult) {
        if (this.rollScResult.level === "\u5927\u5931\u8D25") {
          const maxLoss = new DiceRoll(this.expression2).maxTotal;
          this.rollLoss = new DiceRoll(String(maxLoss));
        } else {
          this.rollLoss = new DiceRoll(this.rollScResult.success ? this.expression1 : this.expression2);
        }
      }
    }
    return this;
  }
  parse() {
    const removeSc = this.rawExpression.slice(2).trim();
    const removeFlags = this.parseFlags(removeSc);
    this.parseMain(removeFlags);
    this.detectDefaultRoll();
    console.log("[Dice] \u7406\u667A\u68C0\u5B9A \u539F\u59CB\u6307\u4EE4", this.rawExpression, "\u6210\u529F", this.expression1, "\u5931\u8D25", this.expression2, "\u63CF\u8FF0", this.description, "\u4E34\u65F6\u503C", this.tempValue, "noModify", this.noModify);
  }
  parseFlags(expression) {
    if (expression.startsWith("!") || expression.startsWith("\uFF01")) {
      this.noModify = true;
      return expression.slice(1).trim();
    } else {
      return expression;
    }
  }
  parseMain(expression) {
    let exp2andDesc = expression;
    const firstSplitIndex = expression.indexOf("/");
    if (firstSplitIndex >= 0) {
      this.expression1 = expression.slice(0, firstSplitIndex).trim();
      exp2andDesc = expression.slice(firstSplitIndex + 1).trim();
    }
    const { exp: exp4, skills } = parseDescriptions2(exp2andDesc);
    const { skill: desc = "", tempValue = NaN, modifiedValue = NaN } = skills[0] || {};
    this.expression2 = exp4;
    this.expression1 ||= exp4;
    this.description = desc;
    this.tempValue = tempValue;
    this.modifiedValue = modifiedValue;
  }
  detectDefaultRoll() {
    if (this.expression1 === "" || this.expression1 === "d") {
      this.expression1 = "0";
    }
    if (this.expression2 === "" || this.expression2 === "d") {
      this.expression2 = this.defaultRoll;
    }
  }
  get output() {
    const firstArgs = this.getFormatArgs(this.rollSc, this.description, this.scTargetValue);
    const firstStart = this.t("roll.start", firstArgs);
    const firstResult = this.t("roll.result.quiet", firstArgs);
    const firstTest = this.rollScResult ? this.ts(this.rollScResult.level, firstArgs) : this.t("roll.sc.unsupported", firstArgs);
    let line = `${removeTrailingOneSpace(firstStart)} ${firstResult}${firstTest}`;
    if (!this.rollScResult)
      return line;
    const secondArgs = this.getFormatArgs(this.rollLoss, "\u7406\u667A\u635F\u5931");
    const secondStart = this.t("roll.start", secondArgs);
    const secondResult = this.t("roll.result", secondArgs);
    line += `\n${secondStart} ${secondResult}`;
    if (this.oldSan >= 0) {
      const extra = this.t("roll.sc.extra", this.getFormatArgs(this.rollLoss));
      line += extra;
    }
    return line;
  }
  getFormatArgs(roll, skill, targetValue) {
    return {
      "": this.rawExpression,
      "": skill,
      "": targetValue,
      "": roll.total,
      "": roll.notation,
      "": roll.output,
      "": this.oldSan,
      "": this.newSan,
      "": this.scLoss,
      sc: true,
      coc: true
    };
  }
  applyToCard() {
    if (!this.scEntry)
      return [];
    this.oldSan = this.scEntry.value;
    this.newSan = Math.max(0, this.oldSan - this.scLoss);
    if (this.scEntry.isTemp || this.noModify) {
      return [];
    } else {
      const card2 = this.selfCard;
      const updated = card2.setEntry(SC_CARD_ENTRY_NAME, this.newSan);
      this.newSan = card2.getEntry(SC_CARD_ENTRY_NAME).value;
      return updated ? [card2] : [];
    }
  }
}

// ../../packages/dicecore/lib/dice/special/en/en.js
class EnDiceRoll extends BasePtDiceRoll {
  enSkillNames = [];
  tempValue = NaN;
  skill2Growth = {};
  roll() {
    const removeEn = this.rawExpression.slice(2).trim();
    this.parseMain(removeEn);
    this.realRoll();
    return this;
  }
  parseMain(expression) {
    if (!expression) {
      this.enSkillNames = getAllSkillsCanEn(this.selfCard);
    } else {
      const index2 = expression.search(/[\s\d]/);
      if (index2 < 0) {
        this.enSkillNames = [expression];
      } else {
        this.enSkillNames = [expression.slice(0, index2)];
        this.tempValue = parseInt(expression.slice(index2), 10);
      }
    }
    console.log("[Dice] \u6210\u957F\u68C0\u5B9A \u539F\u59CB\u6307\u4EE4", this.rawExpression, "\u6280\u80FD", this.enSkillNames.join("|"), "\u4E34\u65F6\u503C", this.tempValue);
  }
  realRoll() {
    this.enSkillNames.forEach((skill) => {
      let entry;
      if (!isNaN(this.tempValue)) {
        entry = getCocTempEntry(skill, this.tempValue);
      } else if (this.selfCard instanceof CocCard) {
        entry = this.selfCard.getEntry(skill);
      }
      if (!entry)
        return;
      const firstRoll = new DiceRoll("d%");
      const canGrowth = firstRoll.total > Math.min(95, entry.baseValue);
      const secondRoll = canGrowth ? new DiceRoll("d10") : undefined;
      this.skill2Growth[skill] = {
        firstRoll,
        canGrowth,
        targetValue: entry.baseValue,
        secondRoll,
        isTemp: entry.isTemp,
        newValue: entry.baseValue + (secondRoll?.total ?? 0)
      };
    });
  }
  get output() {
    const skillsActualGrowth = Object.keys(this.skill2Growth);
    if (skillsActualGrowth.length === 0) {
      return this.t("roll.en.empty");
    } else {
      const lines = [];
      skillsActualGrowth.forEach((skill) => {
        const result = this.skill2Growth[skill];
        const firstArgs = this.getFormatArgs(skill, result.firstRoll, result.targetValue);
        const firstStart = this.t("roll.start", firstArgs);
        const firstResult = this.t("roll.result.quiet", firstArgs);
        const firstTestResult = result.canGrowth ? result.firstRoll.total > 95 ? "\u5927\u6210\u529F" : "\u6210\u529F" : "\u5931\u8D25";
        const firstTestResultDesc = this.ts(firstTestResult, firstArgs);
        lines.push(`${firstStart} ${firstResult}${firstTestResultDesc}`);
        if (result.canGrowth) {
          const secondArgs = this.getFormatArgs(`${skill}\u6210\u957F`, result.secondRoll);
          const secondStart = this.t("roll.start", secondArgs);
          const secondResult = this.t("roll.result.quiet", secondArgs);
          if (typeof result.newValue === "number") {
            const secondExtra = this.t("roll.en.extra", {
              ...this.getFormatArgs(skill, result.secondRoll),
              "": result.targetValue,
              "": result.newValue,
              "": result.newValue - result.targetValue
            });
            lines.push(`${secondStart} ${secondResult}${secondExtra}`);
          } else {
            lines.push(`${secondStart} ${secondResult}`);
          }
        }
      });
      return lines.join("\n");
    }
  }
  getFormatArgs(skill, roll, targetValue) {
    return {
      "": this.rawExpression,
      "": skill,
      "": targetValue,
      "": roll.total,
      "": roll.notation,
      "": roll.output,
      en: true,
      coc: true
    };
  }
  applyToCard() {
    const card3 = this.selfCard;
    if (!(card3 instanceof CocCard))
      return [];
    let updated = false;
    Object.keys(this.skill2Growth).forEach((skill) => {
      const growthResult = this.skill2Growth[skill];
      if (growthResult.isTemp)
        return;
      if (growthResult.canGrowth) {
        if (card3.setEntry(skill, growthResult.targetValue + growthResult.secondRoll.total)) {
          updated = true;
        }
        const entry = card3.getEntry(skill);
        if (entry) {
          growthResult.newValue = entry.value;
        }
      }
      if (card3.cancelSkillGrowth(skill)) {
        updated = true;
      }
    });
    return updated ? [card3] : [];
  }
}

// ../../packages/dicecore/lib/dice/special/en/list.js
class EnListDiceRoll extends BasePtDiceRoll {
  get isCardUnsupported() {
    return !this.selfCard || !(this.selfCard instanceof CocCard);
  }
  roll() {
    console.log("[Dice] \u6210\u957F\u68C0\u5B9A-\u5217\u51FA \u539F\u59CB\u6307\u4EE4", this.rawExpression);
    return this;
  }
  get output() {
    if (this.isCardUnsupported) {
      return this.t("roll.en.empty");
    }
    const skills = getAllSkillsCanEn(this.selfCard);
    if (skills.length > 0) {
      return this.t("roll.en.list", {
        "": skills.map((_, i3) => ({ "": _, last: i3 === skills.length - 1 })),
        "": skills.length === 1,
        "": skills[0]
      });
    } else {
      return this.t("roll.en.empty");
    }
  }
}

// ../../packages/dicecore/lib/dice/special/en/mark.js
var parseMode = function(expression) {
  if (expression.startsWith("+")) {
    return ["add", expression.slice(1).trim()];
  } else if (expression.startsWith("-")) {
    return ["remove", expression.slice(1).trim()];
  } else {
    return ["clear", ""];
  }
};

class EnMarkDiceRoll extends BasePtDiceRoll {
  mode;
  skillNames = [];
  get isCardUnsupported() {
    return !this.selfCard || !(this.selfCard instanceof CocCard);
  }
  roll() {
    if (this.isCardUnsupported)
      return this;
    const removeEn = this.rawExpression.slice(2).trim();
    const [mode3, removeMode] = parseMode(removeEn);
    this.mode = mode3;
    if (mode3 !== "clear") {
      const segments = removeMode.split(/[,;\s]+/).filter((segment2) => !!segment2.trim());
      this.skillNames.push(...segments);
    }
    return this;
  }
  get output() {
    if (this.isCardUnsupported) {
      return this.t("roll.en.empty");
    }
    if (this.mode !== "clear" && this.skillNames.length === 0) {
      return this.t("roll.en.empty");
    }
    if (this.mode === "clear") {
      return this.t("roll.en.markclear");
    }
    const skills = this.skillNames;
    return this.t("roll.en.mark", {
      "": skills.map((_, i3) => ({ "": _, last: i3 === skills.length - 1 })),
      "": skills.length === 1,
      "": skills[0],
      "": this.mode === "add"
    });
  }
  applyToCard() {
    if (this.isCardUnsupported) {
      return [];
    }
    let updated = false;
    const card5 = this.selfCard;
    if (this.mode === "clear") {
      updated = card5.clearSkillGrowth();
    } else if (this.mode === "add") {
      this.skillNames.forEach((name302) => {
        if (card5.markSkillGrowth(name302)) {
          updated = true;
        }
      });
    } else if (this.mode === "remove") {
      this.skillNames.forEach((name302) => {
        if (card5.cancelSkillGrowth(name302)) {
          updated = true;
        }
      });
    }
    return updated ? [card5] : [];
  }
}

// ../../packages/dicecore/lib/dice/special/en/utils.js
function dispatchEn(expression, context2, inlineRolls = []) {
  if (expression.match(EN_LIST)) {
    return new EnListDiceRoll(expression, context2, inlineRolls);
  } else if (expression.match(EN_MARK)) {
    return new EnMarkDiceRoll(expression, context2, inlineRolls);
  } else {
    return new EnDiceRoll(expression, context2, inlineRolls);
  }
}
function getAllSkillsCanEn(card6) {
  if (card6 instanceof CocCard) {
    const cardData = card6.data;
    return cardData ? Object.keys(cardData.meta.skillGrowth).filter((name302) => cardData.meta.skillGrowth[name302]) : [];
  } else {
    return [];
  }
}
var EN_LIST = /^en\s*(l|list)$/;
var EN_MARK = /^en\s*(\+|-|x|clear|clr)/;

// ../../packages/dicecore/lib/ri/state.js
class DefaultRiState {
  state;
  constructor(map11 = {}) {
    this.state = map11;
  }
  getRiList(channelUnionId) {
    if (!this.state[channelUnionId]) {
      this.state[channelUnionId] = [];
    }
    return this.state[channelUnionId];
  }
  updateRiList(channelUnionId, change) {
    const list2 = this.getRiList(channelUnionId);
    change.forEach((item) => {
      const exist = list2.find((other) => other.type === item.type && other.id === item.id);
      if (exist) {
        Object.assign(exist, item);
      } else if (item.type && item.id) {
        list2.push({
          type: item.type,
          id: item.id,
          name: item.name ?? item.id,
          seq: item.seq ?? NaN,
          seq2: item.seq2 ?? NaN
        });
      }
    });
  }
  removeRiList(channelUnionId, change) {
    const list2 = this.getRiList(channelUnionId);
    change.forEach(({ type, id }) => {
      const index2 = list2.findIndex((item) => item.type === type && item.id === id);
      if (index2 >= 0) {
        list2.splice(index2, 1);
      }
    });
  }
  clearRiList(channelUnionId) {
    this.state[channelUnionId] = [];
  }
  getDescription(channelUnionId) {
    const descList = this.getRiList(channelUnionId).sort((a, b) => {
      const seq1Res = this.compareSeq(a.seq, b.seq);
      return seq1Res === 0 ? this.compareSeq(a.seq2, b.seq2) : seq1Res;
    }).map((entry, i3) => `${i3 + 1}. ${this.getRiName(entry)} \uD83C\uDFB2 ${isNaN(entry.seq) ? "--" : entry.seq}${isNaN(entry.seq2) ? "" : `(${entry.seq2})`}`);
    const lines = ["\u5F53\u524D\u5148\u653B\u5217\u8868\uFF1A", ...descList];
    return lines.join("\n");
  }
  compareSeq(a, b) {
    if (isNaN(a) && isNaN(b))
      return 0;
    if (isNaN(a))
      return 1;
    if (isNaN(b))
      return -1;
    return b - a;
  }
  getRiName(item) {
    return item.type === "npc" ? item.name ?? item.id ?? "" : at(item.id);
  }
}

// ../../packages/dicecore/lib/ri/ri-provider.js
class RiProvider {
  static INSTANCE = new RiProvider;
  _state;
  constructor() {
  }
  get state() {
    if (!this._state) {
      this._state = new DefaultRiState;
    }
    return this._state;
  }
  setState(state2) {
    this._state = state2;
  }
  clearRiList(channelUnionId) {
    this.state.clearRiList(channelUnionId);
  }
  getDescription(channelUnionId) {
    return this.state.getDescription(channelUnionId);
  }
  getRiList(channelUnionId) {
    return this.state.getRiList(channelUnionId);
  }
  removeRiList(channelUnionId, list2) {
    this.state.removeRiList(channelUnionId, list2);
  }
  updateRiList(channelUnionId, list2) {
    this.state.updateRiList(channelUnionId, list2);
  }
  getRiName(item) {
    return this.state.getRiName(item);
  }
}

// ../../packages/dicecore/lib/dice/special/ri.js
class RiDiceRoll extends BasePtDiceRoll {
  rolls = [];
  roll() {
    const removeRi = this.rawExpression.slice(2).trim();
    const segments = removeRi.split(/[,;]+/).filter((segment2) => !!segment2.trim());
    if (segments.length === 0)
      segments.push("");
    console.log("[Dice] \u5148\u653B\u6307\u4EE4 \u539F\u59CB\u6307\u4EE4", this.rawExpression);
    segments.forEach((segment2) => {
      const [exp4, desc] = parseDescriptions(segment2, ParseFlags.PARSE_EXP);
      const type = desc ? "npc" : "actor";
      const baseRoll = (type === "actor" ? this.selfCard?.riDefaultRoll : undefined) ?? "d20";
      const expression = exp4.startsWith("+") || exp4.startsWith("-") ? `${baseRoll}${exp4}` : exp4 || baseRoll;
      const parsed = parseTemplate2(expression, this.context, this.inlineRolls);
      const diceRoll = new DiceRoll(parsed);
      this.rolls.push({
        type,
        id: desc || this.context.userId,
        username: type === "actor" ? this.context.username : undefined,
        roll: diceRoll
      });
    });
    return this;
  }
  get output() {
    return this.rolls.map((item) => {
      const args = {
        "": item.username || item.id,
        "": this.selfCard?.name ?? (item.username || item.id),
        "at": RiProvider.INSTANCE.getRiName(item),
        "": this.rawExpression,
        "": "\u5148\u653B",
        "": item.roll.total,
        "": item.roll.notation,
        "": item.roll.output,
        ri: true
      };
      const head = this.t("roll.start", args);
      const desc = this.t("roll.result", args);
      return `${head} ${desc}`;
    }).join("\n");
  }
  applyToCard() {
    RiProvider.INSTANCE.updateRiList(this.context.channelUnionId, this.rolls.map((item) => ({
      type: item.type,
      id: item.id,
      name: item.username,
      seq: item.roll.total,
      seq2: NaN
    })));
    return [];
  }
}

class RiListDiceRoll extends BasePtDiceRoll {
  clear = false;
  delList = [];
  riListDescription = "";
  roll() {
    const removeInit = this.rawExpression.slice(4).trim();
    if (removeInit === "clear" || removeInit === "clr") {
      this.clear = true;
    } else if (removeInit.startsWith("del")) {
      this.parseDelList(removeInit.slice(3));
    } else if (removeInit.startsWith("rm")) {
      this.parseDelList(removeInit.slice(2));
    }
    console.log("[Dice] \u5148\u653B\u5217\u8868 \u539F\u59CB\u6307\u4EE4", this.rawExpression);
    return this;
  }
  parseDelList(expression) {
    const atSelf = at(this.context.userId);
    const delList = expression.trim().split(/[\s,;]+/).map((name302) => name302 || atSelf);
    const uniqList = Array.from(new Set(delList));
    const uniqDelList = uniqList.length > 0 ? uniqList : [atSelf];
    this.delList = uniqDelList.map((nameOrAt) => {
      const userIdMatch = nameOrAt.match(AtUserPattern);
      if (userIdMatch) {
        return { id: userIdMatch[1], type: "actor" };
      } else {
        return { id: nameOrAt, type: "npc" };
      }
    });
  }
  applyToCard() {
    this.riListDescription = RiProvider.INSTANCE.getDescription(this.context.channelUnionId);
    if (this.clear) {
      RiProvider.INSTANCE.clearRiList(this.context.channelUnionId);
    } else if (this.delList.length > 0) {
      RiProvider.INSTANCE.updateRiList(this.context.channelUnionId, this.delList);
    }
    return [];
  }
  get output() {
    if (this.delList.length > 0) {
      const charaList = this.delList.map((item) => RiProvider.INSTANCE.getRiName(item));
      return this.t("roll.ri.del", {
        "": charaList.map((_, i3) => ({ "": _, last: i3 === charaList.length - 1 })),
        "": charaList.length === 0,
        "": charaList[0]
      });
    } else {
      let listDesc = this.riListDescription;
      if (this.clear) {
        listDesc += "\n" + this.t("roll.ri.clear");
      }
      return listDesc;
    }
  }
}

// ../../packages/dicecore/lib/dice/special/st/st.js
var splitSegment = function(segment2) {
  const index2 = segment2.search(/[\s+\-=\d]/);
  if (index2 < 0)
    return [segment2];
  const name302 = segment2.slice(0, index2).trim();
  let value = segment2.slice(index2).trim();
  if (value.startsWith("=")) {
    value = value.slice(1).trim();
  }
  return [name302, value];
};

class StDiceRoll extends BasePtDiceRoll {
  rolls = [];
  roll() {
    if (!this.selfCard)
      return this;
    const exp4 = this.rawExpression.slice(2).trim();
    this.rollSet(exp4);
    return this;
  }
  get hasEditPermission() {
    return this.hasPermission(this.config.specialDice.stDice.writable);
  }
  rollSet(exp4) {
    const segments = exp4.split(/[,;]+/).filter((segment2) => !!segment2.trim());
    segments.forEach((segment2) => {
      let [name302, value] = splitSegment(segment2);
      if (!name302 || !value)
        return;
      if (this.selfCard instanceof DndCard) {
        const entry = this.selfCard.getEntry(name302);
        if (entry && entry.type === "skills" && entry.postfix === "none") {
          name302 = `${name302}\u4FEE\u6B63`;
        }
      }
      const expression = value.startsWith("+") || value.startsWith("-") ? `\${${name302}}${value}` : value;
      const parsed = parseTemplate2(expression, this.context, this.inlineRolls);
      this.rolls.push({ name: name302, roll: new DiceRoll(parsed) });
    });
  }
  get output() {
    if (!this.selfCard) {
      return this.t("card.empty", this.formatArgs);
    }
    if (!this.hasEditPermission) {
      return this.t("card.nopermission", this.formatArgs);
    }
    if (this.rolls.length === 0) {
      return this.t("roll.st.prompt", this.formatArgs);
    }
    const _ = this.rolls.map((item, i3) => {
      const rollOutput = this.t("roll.result", {
        ...this.formatArgs,
        "": item.roll.total,
        "": item.roll.notation,
        "": item.roll.output
      });
      return { "": `${item.name} ${rollOutput}`, last: i3 === this.rolls.length - 1 };
    });
    return this.t("roll.st.set", {
      ...this.formatArgs,
      "": _,
      "": this.rolls.length === 1,
      "": _[0]
    });
  }
  get formatArgs() {
    return {
      "": this.selfCard?.name,
      "": at(this.context.userId),
      st: true
    };
  }
  applyToCard() {
    if (!this.hasEditPermission)
      return [];
    if (!this.selfCard)
      return [];
    if (this.rolls.length === 0)
      return [];
    let modified = false;
    this.rolls.forEach((item) => {
      const b = this.selfCard.setEntry(item.name, item.roll.total);
      modified ||= b;
    });
    return modified ? [this.selfCard] : [];
  }
}

// ../../packages/dicecore/lib/dice/special/st/show.js
class StShowDiceRoll extends BasePtDiceRoll {
  shows = [];
  showSummary = false;
  roll() {
    if (!this.selfCard)
      return this;
    const exp4 = this.rawExpression.replace(/^st\s*show/, "").trim();
    this.rollShow(exp4);
    return this;
  }
  rollShow(exp4) {
    const segments = exp4.split(/[,;]+/).filter((segment2) => !!segment2.trim());
    if (segments.length > 0) {
      this.shows.push(...segments.map((name302) => this.selfCard.getEntryDisplay(name302)));
    } else {
      this.shows.push(this.selfCard.getSummary());
      this.showSummary = true;
    }
  }
  get output() {
    if (!this.selfCard) {
      return this.t("card.empty", this.formatArgs);
    }
    return this.t("roll.st.show", {
      ...this.formatArgs,
      "": this.shows.map((_, i3) => ({ "": _, last: i3 === this.shows.length - 1 })),
      "": this.shows.length === 1,
      "": this.shows[0],
      "": this.showSummary
    });
  }
  get formatArgs() {
    return {
      "": this.selfCard?.name,
      "": at(this.context.userId),
      st: true
    };
  }
}

// ../../packages/dicecore/lib/dice/special/st/stAbility.js
var splitSegment2 = function(segment2) {
  if (segment2.startsWith("&")) {
    segment2 = segment2.slice(1);
  }
  const index2 = segment2.indexOf("=");
  if (index2 >= 0) {
    const name302 = segment2.slice(0, index2).trim();
    const value = segment2.slice(index2 + 1).trim();
    return [name302, value];
  }
  const index22 = segment2.search(/[^\p{Unified_Ideograph}]/u);
  if (index22 >= 0) {
    const name302 = segment2.slice(0, index22).trim();
    const value = segment2.slice(index22).trim();
    return [name302, value];
  }
  return [segment2];
};

class StAbilityDiceRoll extends BasePtDiceRoll {
  abilities = [];
  roll() {
    if (!this.selfCard)
      return this;
    const exp4 = this.rawExpression.slice(2).trim();
    this.rollSet(exp4);
    return this;
  }
  get hasEditPermission() {
    return this.hasPermission(this.config.specialDice.stDice.writable);
  }
  rollSet(exp4) {
    const segments = exp4.split(/[,;]+/).map((segment2) => segment2.trim()).filter((segment2) => !!segment2);
    segments.forEach((segment2) => {
      const [name302, value] = splitSegment2(segment2);
      if (!name302 || !value)
        return;
      this.abilities.push({ name: name302, value });
    });
  }
  get output() {
    if (!this.selfCard) {
      return this.t("card.empty", this.formatArgs);
    }
    if (!this.hasEditPermission) {
      return this.t("card.nopermission", this.formatArgs);
    }
    if (this.abilities.length === 0) {
      return this.t("roll.st.prompt", this.formatArgs);
    }
    const _ = this.abilities.map((item, i3) => {
      return { "": `${item.name} ${item.value}`, last: i3 === this.abilities.length - 1 };
    });
    return this.t("roll.st.set", {
      ...this.formatArgs,
      "": _,
      "": this.abilities.length === 1,
      "": _[0]
    });
  }
  get formatArgs() {
    return {
      "": this.selfCard?.name,
      "": at(this.context.userId),
      st: true
    };
  }
  applyToCard() {
    if (!this.hasEditPermission)
      return [];
    if (!this.selfCard)
      return [];
    if (this.abilities.length === 0)
      return [];
    let modified = false;
    this.abilities.forEach((item) => {
      const b = this.selfCard.setAbility(item.name, item.value);
      modified ||= b;
    });
    return modified ? [this.selfCard] : [];
  }
}

// ../../packages/dicecore/lib/dice/special/st/utils.js
function dispatchSt(expression, context2, inlineRolls = []) {
  if (expression.match(ST_SHOW)) {
    return new StShowDiceRoll(expression, context2, inlineRolls);
  } else if (expression.match(ST_SET_ABILITY)) {
    return new StAbilityDiceRoll(expression, context2, inlineRolls);
  } else {
    return new StDiceRoll(expression, context2, inlineRolls);
  }
}
var ST_SHOW = /^st\s*show/;
var ST_SET_ABILITY = /^st\s*&/;

// ../../packages/dicecore/lib/dice/special/ds.js
class DsDiceRoll extends BasePtDiceRoll {
  diceRoll = new DiceRoll("d20");
  isBest = this.diceRoll.total === 20;
  isWorst = this.diceRoll.total === 1;
  isSuccess = this.diceRoll.total >= 10;
  toStable = false;
  toDeath = false;
  roll() {
    return this;
  }
  get formatArgs() {
    return {
      "": this.rawExpression,
      "": "\u6B7B\u4EA1\u8C41\u514D",
      "": 10,
      "": this.diceRoll.total,
      "": this.diceRoll.notation,
      "": this.diceRoll.output,
      ds: true,
      dnd: true
    };
  }
  get decideResult() {
    if (this.isBest) {
      return this.t("roll.ds.best", this.formatArgs);
    } else if (this.isWorst) {
      return this.t("roll.ds.worst", this.formatArgs);
    } else if (this.isSuccess) {
      return this.ts("\u6210\u529F", this.formatArgs);
    } else {
      return this.ts("\u5931\u8D25", this.formatArgs);
    }
  }
  get output() {
    const headLine = this.t("roll.start", this.formatArgs);
    const output = this.t("roll.result", this.formatArgs);
    const firstLine = `${headLine} ${output}${this.decideResult}`;
    if (this.toStable) {
      return firstLine + this.t("roll.ds.tostable", this.formatArgs);
    } else if (this.toDeath) {
      return firstLine + this.t("roll.ds.todeath", this.formatArgs);
    } else {
      return firstLine;
    }
  }
  applyToCard() {
    if (!(this.selfCard instanceof DndCard)) {
      return [];
    }
    const card8 = this.selfCard;
    if (this.isBest) {
      card8.HP += 1;
      card8.data.meta.deathSaving.success = 0;
      card8.data.meta.deathSaving.failure = 0;
    } else if (this.isWorst) {
      card8.data.meta.deathSaving.failure += 2;
    } else if (this.isSuccess) {
      card8.data.meta.deathSaving.success++;
    } else {
      card8.data.meta.deathSaving.failure++;
    }
    if (card8.data.meta.deathSaving.success >= 3) {
      this.toStable = true;
      card8.data.meta.deathSaving.success = 0;
      card8.data.meta.deathSaving.failure = 0;
    } else if (card8.data.meta.deathSaving.failure >= 3) {
      this.toDeath = true;
    }
    return [card8];
  }
}

// ../../packages/dicecore/lib/dice/special/nn/show.js
class NnShowDiceRoll extends BasePtDiceRoll {
  roll() {
    return this;
  }
  get output() {
    return this.t("nn.show", { "": this.selfCard?.name });
  }
}

// ../../packages/dicecore/lib/dice/special/nn/clear.js
class NnClearDiceRoll extends BasePtDiceRoll {
  originCardName;
  get hasLinkPermission() {
    return this.hasPermission(this.config.specialDice.nnDice.writable);
  }
  roll() {
    this.originCardName = this.selfCard?.name;
    return this;
  }
  get output() {
    if (!this.hasLinkPermission) {
      return this.t("card.nopermission");
    } else {
      return this.t("nn.clear", { "": this.originCardName });
    }
  }
  applyToCard() {
    if (!this.hasLinkPermission)
      return [];
    if (this.selfCard) {
      this.linkCard(this.selfCard.name, undefined);
    }
    return [];
  }
}

// ../../packages/dicecore/lib/dice/special/nn/link.js
class NnLinkDiceRoll extends BasePtDiceRoll {
  keyword = "";
  availableCards = [];
  get targetCard() {
    return this.availableCards.length === 1 ? this.availableCards[0] : undefined;
  }
  get targetCardName() {
    return this.targetCard?.name;
  }
  get hasLinkPermission() {
    return this.hasPermission(this.config.specialDice.nnDice.writable);
  }
  roll() {
    this.keyword = this.rawExpression.slice(2).trim();
    this.availableCards = this.queryCard({ name: this.keyword, isTemplate: false });
    return this;
  }
  get output() {
    if (!this.hasLinkPermission) {
      return this.t("card.nopermission");
    } else if (this.availableCards.length === 0) {
      return this.t("nn.search", { "": [], "": this.keyword });
    } else if (this.targetCardName) {
      return this.t("nn.link", { "": this.targetCardName, "": this.keyword });
    } else {
      const availableList = this.availableCards.map((card8, i3) => ({ "": card8.name, last: i3 === this.availableCards.length - 1 }));
      return this.t("nn.search", { "": availableList, "": this.keyword });
    }
  }
  applyToCard() {
    if (!this.hasLinkPermission)
      return [];
    if (this.availableCards.length === 1) {
      this.linkCard(this.targetCardName, this.context.userId);
    }
    return [];
  }
}

// ../../packages/dicecore/lib/dice/special/nn/utils.js
function dispatchNn(expression, context2, inlineRolls = []) {
  if (expression.match(NN_CLEAR)) {
    return new NnClearDiceRoll(expression, context2, inlineRolls);
  } else if (expression === "nn") {
    return new NnShowDiceRoll(expression, context2, inlineRolls);
  } else {
    return new NnLinkDiceRoll(expression, context2, inlineRolls);
  }
}
var NN_CLEAR = /^nn\s*(x|clear|clr)$/;

// ../../packages/dicecore/lib/dice/standard/coc.js
class CocDiceRoll extends StandardDiceRoll {
  skills2growth = [];
  get selfCard() {
    return super.selfCard;
  }
  doRoll() {
    for (let i3 = 0;i3 < this.times; i3++) {
      const roll = new DiceRoll(this.expression);
      this.rolls.push({
        roll,
        tests: this.skillsForTest.map(({ skill, tempValue, modifiedValue }) => {
          let cardEntry;
          if (!isNaN(tempValue)) {
            cardEntry = getCocTempEntry(skill, tempValue);
          } else {
            cardEntry = this.selfCard?.getEntry(skill);
          }
          let result;
          if (cardEntry) {
            cardEntry.value += modifiedValue || 0;
            result = this.decide({ baseValue: cardEntry.baseValue, targetValue: cardEntry.value, roll: roll.total });
            if (!cardEntry.isTemp && !((modifiedValue || 0) > 0) && !this.expression.endsWith("kl1") && cardEntry.type === "skills" && result?.success) {
              this.skills2growth.push(cardEntry.key);
            }
          }
          return { skill, targetValue: cardEntry?.value, cardEntry, result };
        })
      });
    }
  }
  applyToCard() {
    const card9 = this.selfCard;
    if (!card9)
      return [];
    const uniqSkills = Array.from(new Set(this.skills2growth));
    let needUpdate = false;
    if (!this.vsFlag) {
      uniqSkills.forEach((skill) => {
        const updated = card9.markSkillGrowth(skill);
        needUpdate ||= updated;
      });
    }
    return needUpdate ? [card9] : [];
  }
  get eligibleForOpposedRoll() {
    if (this.hidden)
      return false;
    return this.rolls.length === 1 && this.rolls[0].tests.length === 1 && !!this.rolls[0].tests[0].result;
  }
  getSuccessLevelForOpposedRoll() {
    const rollResult = this.rolls[0];
    const test = rollResult.tests[0];
    const decideResult = test.result;
    const entry = test.cardEntry;
    return {
      "": this.context.username,
      "": this.selfCard?.name ?? this.context.username,
      "at": this.context.userId === "system" ? this.context.username : at(this.context.userId),
      "": entry.key,
      "": rollResult.roll.total,
      "": rollResult.roll.notation,
      "": rollResult.roll.output,
      "": entry.baseValue,
      "": entry.value,
      "": decideResult.level,
      "": ["\u5927\u6210\u529F", "\u6781\u96BE\u6210\u529F", "\u56F0\u96BE\u6210\u529F", "\u6210\u529F"].includes(decideResult.level),
      "": decideResult.level === "\u5927\u6210\u529F",
      "": decideResult.level === "\u6781\u96BE\u6210\u529F",
      "": decideResult.level === "\u56F0\u96BE\u6210\u529F",
      "": decideResult.level === "\u6210\u529F",
      "": decideResult.level === "\u5931\u8D25",
      "": decideResult.level === "\u5927\u5931\u8D25"
    };
  }
  getRollStartArgs() {
    return { ...super.getRollStartArgs(), coc: true };
  }
  getFormatArgs(roll, test) {
    const _test = test?.cardEntry;
    return {
      ...super.getFormatArgs(roll, test),
      coc: true,
      "": _test?.difficulty === "hard",
      "": _test?.difficulty === "ex",
      "": _test?.difficulty === "normal"
    };
  }
}

// ../../packages/dicecore/lib/dice/standard/cocOppose.js
var compareCocSuccessLevel = function(a, b) {
  return _successLevelCode[a] - _successLevelCode[b];
};

class CocOpposedDiceRoll extends CocDiceRoll {
  _opposedRoll;
  constructor(fullExp, context2, opposedRoll, inlineRolls = []) {
    super(fullExp, context2, inlineRolls);
    this._opposedRoll = opposedRoll;
  }
  parseDescriptions(expression) {
    super.parseDescriptions(expression);
    if (this.skillsForTest.length === 0) {
      this.skillsForTest.push(this._opposedRoll.skillsForTest[0]);
    }
  }
  get output() {
    const opposedResult = this.opposedRoll(this._opposedRoll);
    if (opposedResult) {
      return super.output + "\n" + opposedResult;
    } else {
      return super.output;
    }
  }
  applyToCard() {
    return [];
  }
  opposedRoll(other) {
    if (!(other instanceof CocDiceRoll))
      return "";
    if (!this.eligibleForOpposedRoll || !other.eligibleForOpposedRoll)
      return "";
    const selfResult = this.getSuccessLevelForOpposedRoll();
    const otherResult = other.getSuccessLevelForOpposedRoll();
    const selfSuccess = (() => {
      if (!selfResult[""]) {
        return "lose";
      } else {
        if (selfResult[""] === otherResult[""]) {
          if (selfResult[""] === otherResult[""])
            return "draw";
          return selfResult[""] > otherResult[""] ? "win" : "lose";
        } else {
          return compareCocSuccessLevel(selfResult[""], otherResult[""]) > 0 ? "win" : "lose";
        }
      }
    })();
    const otherSuccess = (() => {
      if (selfSuccess === "lose") {
        return !otherResult[""] ? "lose" : "win";
      } else {
        return selfSuccess === "draw" ? "draw" : "lose";
      }
    })();
    const _otherArgs = Object.entries(otherResult).reduce((o, [k, v]) => Object.assign(o, { ["\u5BF9\u65B9" + k]: v }), {});
    const args = {
      ...selfResult,
      ..._otherArgs,
      "": selfSuccess === "win",
      "": selfSuccess === "lose",
      "": selfSuccess === "draw",
      "": otherSuccess === "win",
      "": otherSuccess === "lose",
      "": otherSuccess === "draw",
      coc: true
    };
    return this.t("roll.vs.result", args);
  }
}
var _successLevelCode = {
  "\u5927\u5931\u8D25": -2,
  "\u5931\u8D25": -1,
  "\u6210\u529F": 1,
  "\u56F0\u96BE\u6210\u529F": 2,
  "\u6781\u96BE\u6210\u529F": 3,
  "\u5927\u6210\u529F": 4
};

// ../../packages/dicecore/lib/dice/standard/dnd.js
class DndDiceRoll extends StandardDiceRoll {
  get selfCard() {
    return super.selfCard;
  }
  doRoll() {
    for (let i3 = 0;i3 < this.times; i3++) {
      if (this.skillsForTest.length === 0) {
        this.rolls.push({ roll: new DiceRoll(this.expression), tests: [] });
        continue;
      }
      this.skillsForTest.forEach(({ skill, tempValue: dc, modifiedValue }) => {
        const entry = this.selfCard?.getEntry(skill);
        let finalExpression;
        if (entry && entry.type === "props" && entry.postfix === "none") {
          const modifiedValue2 = this.selfCard?.getEntry(`${entry.key}\u8C03\u6574`)?.value;
          finalExpression = typeof modifiedValue2 === "number" ? `${this.expression}+${modifiedValue2}` : this.expression;
        } else if (entry && entry.type === "skills" && entry.postfix === "none") {
          const propName = getPropOfSkill(entry.key);
          const modifiedValue2 = this.selfCard?.getEntry(`${propName}\u8C03\u6574`)?.value;
          const skillValue = this.selfCard?.getEntry(`${entry.key}\u4FEE\u6B63`)?.value;
          const experiencedValue = this.selfCard?.data.meta.experienced[entry.key] ? this.selfCard.data.basic[""] : 0;
          const addition = `+{${modifiedValue2}}[${propName}]` + (skillValue ? `+{${skillValue}}[\u4FEE\u6B63]` : "") + (experiencedValue ? `+{${experiencedValue}}[\u719F\u7EC3]` : "");
          finalExpression = `${this.expression}${addition}`;
        } else if (entry && entry.type === "props" && entry.postfix === "saving") {
          finalExpression = `${this.expression}+${entry.value}`;
        } else {
          finalExpression = this.expression;
        }
        const roll = new DiceRoll(finalExpression);
        let result = undefined;
        const targetValue = dc + (modifiedValue || 0);
        if (!isNaN(dc)) {
          result = this.decide({ baseValue: dc, targetValue, roll: roll.total });
        }
        this.rolls.push({ roll, tests: [{ skill, targetValue, cardEntry: entry, result }] });
      });
    }
  }
  get eligibleForOpposedRoll() {
    if (this.hidden)
      return false;
    return this.rolls.length === 1;
  }
  getDataForOpposedRoll() {
    const rollResult = this.rolls[0];
    const test = rollResult.tests[0];
    return {
      "": this.context.username,
      "": this.selfCard?.name ?? this.context.username,
      "at": this.context.userId === "system" ? this.context.username : at(this.context.userId),
      "": test?.skill ?? "",
      "": rollResult.roll.total,
      "": rollResult.roll.notation,
      "": rollResult.roll.output
    };
  }
  getRollStartArgs() {
    return { ...super.getRollStartArgs(), dnd: true };
  }
  getFormatArgs(roll, test) {
    return { ...super.getFormatArgs(roll, test), dnd: true };
  }
}

// ../../packages/dicecore/lib/dice/standard/dndOppose.js
class DndOpposedRoll extends DndDiceRoll {
  _opposedRoll;
  constructor(fullExp, context2, opposedRoll, inlineRolls = []) {
    super(fullExp, context2, inlineRolls);
    this._opposedRoll = opposedRoll;
  }
  parseDescriptions(expression) {
    super.parseDescriptions(expression);
    if (this.skillsForTest.length === 0 && this._opposedRoll.skillsForTest.length > 0) {
      const skill = this._opposedRoll.skillsForTest[0].skill;
      this.skillsForTest.push({ skill, tempValue: NaN, modifiedValue: NaN });
    }
  }
  get output() {
    const opposedResult = this.calculateResult(this._opposedRoll);
    if (opposedResult) {
      return super.output + "\n" + opposedResult;
    } else {
      return super.output;
    }
  }
  calculateResult(other) {
    if (!(other instanceof DndDiceRoll))
      return "";
    if (!this.eligibleForOpposedRoll || !other.eligibleForOpposedRoll)
      return "";
    const selfResult = this.getDataForOpposedRoll();
    const otherResult = other.getDataForOpposedRoll();
    const selfSuccess = selfResult[""] > otherResult[""] ? "win" : selfResult[""] === otherResult[""] ? "draw" : "lose";
    const otherSuccess = selfResult[""] > otherResult[""] ? "lose" : selfResult[""] === otherResult[""] ? "draw" : "win";
    const _otherArgs = Object.entries(otherResult).reduce((o, [k, v]) => Object.assign(o, { ["\u5BF9\u65B9" + k]: v }), {});
    const args = {
      ...selfResult,
      ..._otherArgs,
      "": selfSuccess === "win",
      "": selfSuccess === "lose",
      "": selfSuccess === "draw",
      "": otherSuccess === "win",
      "": otherSuccess === "lose",
      "": otherSuccess === "draw",
      dnd: true
    };
    return this.t("roll.vs.result", args);
  }
}

// ../../packages/dicecore/lib/dice/utils/create.js
function createDiceRoll(userCommand, opposedRoll, listeners = {}) {
  const { command: expression, context: context2 } = userCommand;
  const selfCard = CardProvider.INSTANCE.getCard(context2.channelUnionId, context2.userId);
  const config7 = ConfigProvider.INSTANCE.getConfig(context2.channelUnionId);
  const specialDiceConfig = config7.specialDice;
  const inlineRolls = [];
  if (expression.startsWith("sc") && specialDiceConfig.scDice.enabled) {
    const parsedExpression = parseTemplate2(expression, context2, inlineRolls);
    return new ScDiceRoll(parsedExpression, context2, inlineRolls).roll();
  } else if (expression.startsWith("en") && specialDiceConfig.enDice.enabled) {
    return dispatchEn(expression, context2, inlineRolls).roll();
  } else if (expression.startsWith("ri") && specialDiceConfig.riDice.enabled) {
    return new RiDiceRoll(expression, context2, inlineRolls).roll();
  } else if (expression.startsWith("init") && specialDiceConfig.riDice.enabled) {
    const parsedExpression = parseTemplate2(expression, context2, inlineRolls);
    return new RiListDiceRoll(parsedExpression, context2, inlineRolls).roll();
  } else if (expression.startsWith("st") && specialDiceConfig.stDice.enabled) {
    return dispatchSt(expression, context2, inlineRolls).roll();
  } else if (["ds", "\u6B7B\u4EA1\u8C41\u514D"].includes(expression) && specialDiceConfig.dsDice.enabled) {
    return new DsDiceRoll(expression, context2, inlineRolls).roll();
  } else if (expression.startsWith("nn") && specialDiceConfig.nnDice.enabled) {
    return dispatchNn(expression, context2, inlineRolls).roll();
  } else {
    const roller = (() => {
      const parsedExpression = parseTemplate2(expression, context2, inlineRolls);
      if (opposedRoll && specialDiceConfig.opposeDice.enabled) {
        const opposedType = getOpposedType(opposedRoll, selfCard);
        if (opposedType === "coc") {
          return new CocOpposedDiceRoll(parsedExpression, context2, opposedRoll, inlineRolls);
        } else if (opposedType === "dnd") {
          return new DndOpposedRoll(parsedExpression, context2, opposedRoll, inlineRolls);
        }
      }
      if (selfCard instanceof GeneralCard) {
        return new StandardDiceRoll(parsedExpression, context2, inlineRolls);
      } else if (selfCard instanceof DndCard) {
        return new DndDiceRoll(parsedExpression, context2, inlineRolls);
      } else {
        return new CocDiceRoll(parsedExpression, context2, inlineRolls);
      }
    })();
    roller.addDiceRollEventListener(listeners);
    roller.roll();
    roller.removeDiceRollEventListener(listeners);
    return roller;
  }
}
var getOpposedType = function(opposedRoll, selfCard) {
  if (!selfCard) {
    if (opposedRoll instanceof CocDiceRoll)
      return "coc";
    if (opposedRoll instanceof DndDiceRoll)
      return "dnd";
    return;
  }
  if (selfCard.type === "coc" && opposedRoll instanceof CocDiceRoll)
    return "coc";
  if (selfCard.type === "dnd" && opposedRoll instanceof DndDiceRoll)
    return "dnd";
  return;
};

// ../../packages/dicecore/lib/config/helpers/customReply.js
async function handleCustomReply(processors, { command, context: context2 }) {
  for (const processor of processors) {
    const matchGroups = isMatch(processor, command);
    if (!matchGroups)
      continue;
    const reply = await parseMessage(processor, matchGroups, context2);
    return [true, reply];
  }
  return [false, undefined];
}
async function parseMessage(processor, matchGroups, context2) {
  try {
    if (!processor.items && !processor.handler)
      throw new Error("\u6CA1\u6709\u5904\u7406\u81EA\u5B9A\u4E49\u56DE\u590D\u7684\u65B9\u6CD5");
    const handler = processor.handler ?? randomReplyItem2(processor.items).reply;
    const username = context2.username;
    const userId = context2.userId;
    const userRole = context2.userRole;
    const channelUnionId = context2.channelUnionId;
    const replyFunc = typeof handler === "function" ? handler : (env2, _matchGroup) => {
      return mustache_default.render(handler, { ...env2, ..._matchGroup }, undefined, { escape: (value) => value });
    };
    const card11 = CardProvider.INSTANCE.getCard(channelUnionId, userId);
    const env = {
      ...context2,
      nick: username,
      "": username,
      "": card11?.name ?? username,
      at: at(userId),
      "at": at(userId)
    };
    const template = await replyFunc(env, matchGroups);
    return parseTemplate2(template, { userId, username, userRole, channelUnionId }, [], "message_template");
  } catch (e4) {
    console.error("[Config] \u81EA\u5B9A\u4E49\u56DE\u590D\u5904\u7406\u51FA\u9519", e4?.message);
    return;
  }
}
var isMatch = function(processor, command) {
  switch (processor.trigger) {
    case "exact":
      return processor.command === command ? {} : false;
    case "startWith":
      return command.startsWith(processor.command) ? {} : false;
    case "include":
      return command.includes(processor.command) ? {} : false;
    case "regex": {
      const regex = new RegExp(processor.command);
      const match = command.match(regex);
      return match ? match.groups || {} : false;
    }
  }
};
var randomReplyItem2 = function(items) {
  if (items.length === 1)
    return items[0];
  const totalWeight = items.map((item) => item.weight).reduce((a, b) => a + b, 0);
  let randomWeight = Math.random() * totalWeight;
  for (const item of items) {
    randomWeight -= item.weight;
    if (randomWeight < 0) {
      return item;
    }
  }
  return items[items.length - 1];
};

// ../../packages/dicecore/lib/config/config.js
class ChannelConfig {
  config;
  constructor(config7) {
    this.config = updateConfigByPlugin(upgradeConfig(config7));
  }
  get botOwner() {
    return this.config.botOwner;
  }
  defaultRoll(card11) {
    const fromCard = this.config.defaultRoll.preferCard ? card11?.defaultRoll : undefined;
    return fromCard || this.config.defaultRoll.expression || "d%";
  }
  get specialDice() {
    return this.config.specialDice;
  }
  get embedCustomReplyMap() {
    const items = this.config.embedPlugin.customReply;
    if (!items)
      return {};
    const embedPluginId2 = this.config.embedPlugin.id;
    return items.reduce((obj, item) => Object.assign(obj, { [`${embedPluginId2}.${item.id}`]: item }), {});
  }
  get customReplyProcessors() {
    return this.config.customReplyIds.filter((item) => item.enabled).map((item) => this.embedCustomReplyMap[item.id] || PluginProvider.INSTANCE.getPluginItem(item.id)).filter((conf) => !!conf);
  }
  async handleCustomReply(command) {
    return await handleCustomReply(this.customReplyProcessors, command);
  }
  get embedRollDeciderMap() {
    const items = this.config.embedPlugin.rollDecider;
    if (!items)
      return {};
    const embedPluginId2 = this.config.embedPlugin.id;
    return items.reduce((obj, item) => Object.assign(obj, { [`${embedPluginId2}.${item.id}`]: item }), {});
  }
  get rollDecider() {
    const currentId = this.config.rollDeciderId;
    if (!currentId)
      return;
    return this.embedRollDeciderMap[currentId];
  }
  decideRoll(context2) {
    return decideRoll(this.rollDecider, context2);
  }
  get embedAliasRollMap() {
    const items = this.config.embedPlugin.aliasRoll;
    if (!items)
      return {};
    const embedPluginId2 = this.config.embedPlugin.id;
    return items.reduce((obj, item) => Object.assign(obj, { [`${embedPluginId2}.${item.id}`]: item }), {});
  }
  get aliasRollProcessors() {
    return this.config.aliasRollIds.filter((item) => item.enabled).map((item) => this.embedAliasRollMap[item.id] || PluginProvider.INSTANCE.getPluginItem(item.id));
  }
  get aliasRollProcessors_expression() {
    return this.aliasRollProcessors.filter((conf) => conf?.scope === "expression");
  }
  get aliasRollProcessors_command() {
    return this.aliasRollProcessors.filter((conf) => conf?.scope === "command");
  }
  parseAliasRoll_expression(expression, context2, inlineRolls) {
    return parseAliasForExpression(this.aliasRollProcessors_expression, expression, context2, inlineRolls);
  }
  parseAliasRoll_command(command) {
    return parseAliasForCommand(this.aliasRollProcessors_command, command);
  }
  get customTextMap() {
    const embed = this.config.embedPlugin.customText?.[0] ?? getEmbedCustomText();
    const pluginList = this.config.customTextIds.filter((item) => item.enabled).map((item) => PluginProvider.INSTANCE.getPluginItem(item.id));
    const validConfigList = [embed, ...pluginList].filter((conf) => !!conf);
    return validConfigList.map((config7) => config7.texts).reduce((all, textMap) => Object.assign(all, textMap), {});
  }
  formatCustomText(key, args, context2) {
    return renderCustomText(this.customTextMap, key, args, context2);
  }
  getHookProcessors(prop) {
    return this.config.hookIds[prop].filter((item) => item.enabled).map((item) => PluginProvider.INSTANCE.getPluginItem(item.id)).filter((conf) => !!conf);
  }
  async hook_onReceiveCommand(result) {
    console.log("[Hook] \u6536\u5230\u6307\u4EE4");
    await handleHooksAsync(this.getHookProcessors("onReceiveCommand"), result);
  }
  hook_beforeParseDiceRoll(diceCommand) {
    console.log("[Hook] \u89E3\u6790\u9AB0\u5B50\u6307\u4EE4\u524D");
    handleHooks(this.getHookProcessors("beforeParseDiceRoll"), diceCommand);
  }
  hook_onCardEntryChange(e4) {
    console.log("[Hook] \u4EBA\u7269\u5361\u6570\u503C\u53D8\u5316");
    handleVoidHooks(this.getHookProcessors("onCardEntryChange"), e4);
  }
  hook_onMessageReaction(e4) {
    console.log("[Hook] \u6536\u5230\u8868\u60C5\u8868\u6001");
    return handleLinearHooksAsync(this.getHookProcessors("onMessageReaction"), e4);
  }
  hook_beforeDiceRoll(roll) {
    console.log("[Hook] \u63B7\u9AB0/\u68C0\u5B9A\u524D");
    handleHooks(this.getHookProcessors("beforeDiceRoll"), roll);
  }
  hook_afterDiceRoll(roll) {
    console.log("[Hook] \u63B7\u9AB0/\u68C0\u5B9A\u540E");
    handleVoidHooks(this.getHookProcessors("afterDiceRoll"), roll);
  }
}

// ../../packages/dicecore/lib/config/config-provider.js
class ConfigProvider {
  static INSTANCE = new ConfigProvider;
  configMap = new Map;
  constructor() {
    eventBus.on("plugins-added", () => this._updateByPlugin());
  }
  _updateByPlugin() {
    for (const [id, channelConfig] of this.configMap.entries()) {
      this.register(id, channelConfig.config);
    }
  }
  register(id, config8) {
    this.configMap.set(id, new ChannelConfig(config8));
  }
  unregister(id) {
    this.configMap.delete(id);
  }
  get defaultConfig() {
    if (!this.configMap.has("default")) {
      this.register("default", getInitialDefaultConfig());
    }
    return this.configMap.get("default");
  }
  getConfig(id) {
    return this.configMap.get(id) || this.defaultConfig;
  }
}
// ../../packages/dicecore/lib/main/dispatch.js
async function dispatchCommand(userCommand, options = {}) {
  const { context: context2 } = userCommand;
  const config8 = ConfigProvider.INSTANCE.getConfig(context2.channelUnionId);
  const cardEntryChangeListener = (event) => {
    config8.hook_onCardEntryChange({ event, context: context2 });
  };
  eventBus.on("card-entry-change", cardEntryChangeListener);
  try {
    await config8.hook_onReceiveCommand(userCommand);
    userCommand.command = config8.parseAliasRoll_command(userCommand.command);
    const [handled, reply] = await config8.handleCustomReply(userCommand);
    if (handled) {
      return { type: "customReply", reply };
    }
    if (options.interceptor) {
      const [handled2, payload] = await options.interceptor(userCommand);
      if (handled2) {
        return { type: "interceptor", payload };
      }
    }
    const opposedRoll = await options.getOpposedRoll?.(userCommand);
    return tryRollDice(config8, userCommand, opposedRoll);
  } finally {
    eventBus.off("card-entry-change", cardEntryChangeListener);
  }
}
async function dispatchReaction(userCommand, options = {}) {
  const { context: context2 } = userCommand;
  const config8 = ConfigProvider.INSTANCE.getConfig(context2.channelUnionId);
  const cardEntryChangeListener = (event) => {
    config8.hook_onCardEntryChange({ event, context: context2 });
  };
  eventBus.on("card-entry-change", cardEntryChangeListener);
  try {
    const handled = await config8.hook_onMessageReaction(userCommand);
    if (handled)
      return;
    const command = await options.getReactionCommand?.(userCommand);
    if (!command)
      return;
    userCommand.command = command;
    const opposedRoll = await options.getOpposedRoll?.(userCommand);
    return tryRollDice(config8, userCommand, opposedRoll);
  } finally {
    eventBus.off("card-entry-change", cardEntryChangeListener);
  }
}
var tryRollDice = function(config8, userCommand, opposedRoll) {
  try {
    const roller = createDiceRoll(userCommand, opposedRoll, {
      before: (roll) => config8.hook_beforeDiceRoll(roll),
      after: (roll) => config8.hook_afterDiceRoll(roll)
    });
    const affectedCards = roller.applyToCard();
    return { type: "dice", diceRoll: roller, affectedCards };
  } catch (e4) {
    console.log("[Dice] \u672A\u8BC6\u522B\u8868\u8FBE\u5F0F", e4?.message);
    return { type: "dice" };
  }
};

// D:/workspace/qqchannel-bot/node_modules/@paotuan/dicecore/lib/index.js
var PluginProvider2 = PluginProvider.INSTANCE;
var ConfigProvider2 = ConfigProvider.INSTANCE;
var CardProvider2 = CardProvider.INSTANCE;
var RiProvider2 = RiProvider.INSTANCE;
var Events = eventBus;

// src/app/dispatcher.ts
function dispatch2(client, server, request) {
  switch (request.cmd) {
    case "bot/loginV2":
      return handleLoginV2(client, server, request.data);
    case "channel/listen":
      return handleListenToChannel(client, server, request.data);
    case "channel/create":
      return handleChannelCreate(client, server, request.data);
    case "card/import":
      return handleCardImport(client, server, request.data);
    case "card/delete":
      handleCardDelete(client, server, request.data);
      break;
    case "card/link":
      return handleCardLink(client, server, request.data);
    case "channel/config":
      return handleChannelConfig(client, server, request.data);
    case "channel/config/reset":
      return handleResetChannelConfig(client, server);
    case "scene/sendBattleLog":
      return handleSceneSendBattleLog(client, server, request.data);
    case "scene/sendMapImage":
      return handleSceneSendMapImage(client, server, request.data);
    case "ri/set":
      return handleRiSet(client, server, request.data);
    case "ri/delete":
      return handleRiDelete(client, server, request.data);
    case "dice/roll":
      return handleManualDiceRoll(client, server, request.data);
    case "user/delete":
      return handleUserDelete(client, server, request.data);
    case "plugin/reload":
      return handlePluginReload(client, server, request.data);
  }
}
async function handleLoginV2(client, server, data2) {
  console.log("\u673A\u5668\u4EBA\u767B\u5F55\uFF1A", getBotId(data2.platform, data2.appid));
  try {
    const bot = await server.bots.login(data2);
    client.bindToBot(bot.id);
    client.send({ cmd: "bot/loginV2", success: true, data: null });
    client.autorun((ws) => {
      if (bot.botInfo) {
        ws.send({ cmd: "bot/info", success: true, data: bot.botInfo });
      }
    });
    client.autorun((ws) => {
      const channels = bot.guilds.all.map((guild) => guild.allChannels.map((channel) => ({
        id: channel.id,
        name: channel.name,
        type: channel.type,
        guildId: channel.guildId,
        guildName: guild.name,
        guildIcon: guild.icon
      }))).flat();
      ws.send({ cmd: "channel/list", success: true, data: channels });
    });
    client.autorun((ws) => {
      ws.send({ cmd: "plugin/list", success: true, data: server.plugin.pluginListManifest });
    });
  } catch (e4) {
    client.send({ cmd: "bot/loginV2", success: false, data: null });
  }
}
var handleListenToChannel = function(client, server, data2) {
  console.log("\u9009\u62E9\u9891\u9053\uFF1A", data2.channelId);
  client.listenTo(data2.channelId, data2.guildId);
  client.autorun((ws) => {
    const bot = ws.bot;
    if (bot) {
      const guild = bot.guilds.find(ws.listenToGuildId);
      if (guild) {
        const users = guild.allUsers.map((user) => ({
          id: user.id,
          nick: user.name,
          username: user.name,
          avatar: user.avatar,
          bot: user.isBot,
          deleted: user.deleted
        }));
        ws.send({ cmd: "user/list", success: true, data: users });
      }
    }
  });
  client.autorun((ws) => {
    const channel = ws.listenToChannelUnionId;
    if (channel) {
      const linkMap = server.cards.getLinkMap(channel);
      const data3 = Object.entries(linkMap).map(([userId, cardName]) => ({ userId, cardName }));
      ws.send({ cmd: "card/link", success: true, data: data3 });
    } else {
      ws.send({ cmd: "card/link", success: true, data: [] });
    }
  });
  client.autorun((ws) => {
    const channelId = ws.listenToChannelUnionId;
    if (channelId) {
      const config8 = server.config.getChannelConfig(channelId).config;
      ws.send({ cmd: "channel/config", success: true, data: { config: config8 } });
    }
  });
  client.autorun((ws) => {
    const bot = ws.bot;
    const channelId = ws.listenToChannelUnionId;
    if (bot && channelId) {
      const list3 = RiProvider2.getRiList(channelId);
      ws.send({ cmd: "ri/list", success: true, data: list3 });
    }
  });
};
async function handleChannelCreate(client, server, data2) {
  const bot = client.bot;
  if (bot) {
    const guild = bot.guilds.find(data2.guildId);
    if (guild) {
      const success = await guild.createChannel(data2.name);
      client.send({ cmd: "channel/create", success, data: success ? "\u521B\u5EFA\u6210\u529F" : "\u521B\u5EFA\u5931\u8D25" });
      return;
    }
  }
  client.send({ cmd: "channel/create", success: false, data: "\u627E\u4E0D\u5230\u9891\u9053\u4FE1\u606F" });
}
var handleCardImport = function(client, server, data2) {
  server.cards.importCard(client, data2);
};
var handleCardDelete = function(client, server, data2) {
  server.cards.deleteCard(client, data2);
};
var handleCardLink = function(client, server, data2) {
  if (!client.listenToChannelId)
    return;
  server.cards.handleLinkCard(client, data2);
};
var handleChannelConfig = function(client, server, data2) {
  if (!client.listenToChannelUnionId)
    return;
  server.config.saveChannelConfig(client.listenToChannelUnionId, data2);
};
var handleResetChannelConfig = function(client, server) {
  if (!client.listenToChannelUnionId)
    return;
  server.config.resetChannelConfig(client);
};
async function handleSceneSendBattleLog(client, server, data2) {
  const bot = client.bot;
  if (bot) {
    const channel = bot.guilds.findChannel(client.listenToChannelId, client.listenToGuildId);
    if (channel) {
      const resp = await channel.sendMessage(data2.content);
      if (resp) {
        client.send({ cmd: "scene/sendBattleLog", success: true, data: "" });
        return;
      }
    }
  }
  client.send({ cmd: "scene/sendBattleLog", success: false, data: "\u53D1\u9001\u5931\u8D25" });
}
async function handleSceneSendMapImage(client, server, data2) {
  const bot = client.bot;
  if (bot) {
    const channel = bot.guilds.findChannel(client.listenToChannelId, client.listenToGuildId);
    if (channel) {
      const resp = await channel.sendRawImageMessage(data2.data);
      if (resp) {
        client.send({ cmd: "scene/sendMapImage", success: true, data: "" });
        return;
      }
    }
  }
  client.send({ cmd: "scene/sendMapImage", success: false, data: "\u53D1\u9001\u5931\u8D25" });
}
var handleRiSet = function(client, server, data2) {
  data2.seq = data2.seq === null ? NaN : data2.seq;
  data2.seq2 = data2.seq2 === null ? NaN : data2.seq2;
  const bot = client.bot;
  const channelUnionId = client.listenToChannelUnionId;
  if (bot && channelUnionId) {
    RiProvider2.updateRiList(channelUnionId, [data2]);
  }
};
var handleRiDelete = function(client, server, data2) {
  const bot = client.bot;
  const channelUnionId = client.listenToChannelUnionId;
  if (bot && channelUnionId) {
    RiProvider2.removeRiList(channelUnionId, [data2]);
  }
};
async function handleManualDiceRoll(client, server, data2) {
  const bot = client.bot;
  if (bot) {
    await bot.commandHandler.manualDiceRollFromWeb(client, data2);
    client.send({ cmd: "dice/roll", success: true, data: "" });
  }
}
var handleUserDelete = function(client, server, data2) {
  const bot = client.bot;
  if (bot) {
    const guild = bot.guilds.find(client.listenToGuildId);
    if (guild) {
      guild.deleteUsersBatch(data2.ids);
    }
  }
};
var handlePluginReload = function(client, server, data2) {
  server.plugin.manualReloadPlugins(data2);
  client.send({ cmd: "plugin/reload", success: true, data: "" });
};

// src/app/wss.ts
var import_mobx13 = __toESM(require_dist(), 1);

// src/service/card.ts
var import_fast_glob = __toESM(require_out4(), 1);
var import_mobx2 = __toESM(require_dist(), 1);
import fs2 from "fs";

// src/utils.ts
var import_node_fetch = __toESM(require_lib19(), 1);
import fs from "fs";
import path from "path";
function removeBackspaces(str) {
  let index2 = str.indexOf("\b");
  while (index2 >= 0) {
    const left = str.substring(0, index2 - 1);
    const right = str.substring(index2 + 1);
    str = (left + right).trim();
    index2 = str.indexOf("\b");
  }
  return str;
}
function copyFolderSync(from, to3) {
  if (!fs.existsSync(to3))
    fs.mkdirSync(to3);
  fs.readdirSync(from).forEach((element) => {
    if (fs.lstatSync(path.join(from, element)).isFile()) {
      fs.copyFileSync(path.join(from, element), path.join(to3, element));
    } else {
      copyFolderSync(path.join(from, element), path.join(to3, element));
    }
  });
}
function resolveRootDir(dirName) {
  if (true) {
    return `../../${dirName}`;
  } else {
  }
}

// src/service/card.ts
var saveCardFile = function(cardData) {
  if (!fs2.existsSync(CARD_DIR)) {
    fs2.mkdirSync(CARD_DIR);
  }
  const cardName = cardData.name;
  fs2.writeFile(`${CARD_DIR}/${cardName}.json`, JSON.stringify(cardData), (e4) => {
    if (e4) {
      console.error("[Card] \u4EBA\u7269\u5361\u5199\u6587\u4EF6\u5931\u8D25", e4);
    }
  });
};
var deleteCardFile = function(name302) {
  try {
    if (!fs2.existsSync(CARD_DIR)) {
      return;
    }
    fs2.unlinkSync(`${CARD_DIR}/${name302}.json`);
    console.log("[Card] \u5220\u9664\u4EBA\u7269\u5361\u6210\u529F");
  } catch (e4) {
    console.error("[Card] \u5220\u9664\u4EBA\u7269\u5361\u5931\u8D25", e4);
  }
};
var saveLinkFile = function(link3) {
  if (!fs2.existsSync(CARD_DIR)) {
    fs2.mkdirSync(CARD_DIR);
  }
  fs2.writeFile(`${CARD_DIR}${LINK_FILE_NAME}`, JSON.stringify(link3), (e4) => {
    if (e4) {
      console.error("[Card] \u4EBA\u7269\u5361\u5199\u5173\u8054\u5931\u8D25", e4);
    }
  });
};
var CARD_DIR = resolveRootDir("cards");
var LINK_FILE_NAME = "/__link.json";

class CardManager {
  wss;
  cardMap = {};
  channelLinkMap = {};
  emitter = mitt_default();
  get cardList() {
    return Object.values(this.cardMap);
  }
  constructor(wss) {
    import_mobx2.makeAutoObservable(this);
    this.wss = wss;
    this.initCardFiles();
    CardProvider2.setLinker(new DefaultCardLinker(this.channelLinkMap));
    Events.on("card-entry-change", (event) => this.emitter.emit("EntryChange", event));
    Events.on("card-link-change", () => saveLinkFile(this.channelLinkMap));
  }
  initCardFiles() {
    try {
      console.log("[Card] \u5F00\u59CB\u8BFB\u53D6\u4EBA\u7269\u5361");
      if (!fs2.existsSync(CARD_DIR)) {
        return;
      }
      const filesPath = import_fast_glob.globSync(`${CARD_DIR}/*.json`, { stats: true });
      const files = filesPath.map((path2) => ({ created: path2.stats?.birthtimeMs, modified: path2.stats?.mtimeMs, path: path2.path }));
      files.forEach((file) => {
        const str = fs2.readFileSync(file.path, "utf8");
        if (file.path.endsWith(LINK_FILE_NAME)) {
          try {
            const link3 = JSON.parse(str);
            Object.assign(this.channelLinkMap, link3);
          } catch (e4) {
            console.log("[Card] \u4EBA\u7269\u5361\u5173\u8054 \u89E3\u6790\u5931\u8D25");
          }
        } else {
          try {
            const card12 = handleCardUpgrade(JSON.parse(str));
            if (!card12.created && file.created) {
              card12.created = file.created;
            }
            if (!card12.lastModified && file.modified) {
              card12.lastModified = file.modified;
            }
            this.cardMap[card12.name] = card12;
            CardProvider2.registerCard(card12.name, this.cardMap[card12.name]);
          } catch (e4) {
            console.log(`[Card] ${file.path} \u89E3\u6790\u5931\u8D25`, e4);
          }
        }
      });
    } catch (e4) {
      console.error("[Card] \u4EBA\u7269\u5361\u5217\u8868\u5931\u8D25", e4);
    }
  }
  importCard(client, req) {
    const { card: card12 } = req;
    const cardName = card12.name;
    console.log("[Card] \u4FDD\u5B58\u4EBA\u7269\u5361", cardName);
    this.cardMap[cardName] = card12;
    CardProvider2.registerCard(cardName, this.cardMap[cardName]);
    saveCardFile(this.cardMap[cardName]);
    this.wss.sendToChannel(client.listenToChannelUnionId, { cmd: "card/import", success: true, data: null });
  }
  saveCard(card12) {
    saveCardFile(card12.data);
  }
  deleteCard(client, req) {
    const { cardName } = req;
    console.log("[Card] \u5220\u9664\u4EBA\u7269\u5361", cardName);
    delete this.cardMap[cardName];
    CardProvider2.unregisterCard(cardName);
    deleteCardFile(cardName);
  }
  handleLinkCard(client, req) {
    const { cardName, userId } = req;
    const channelUnionId = client.listenToChannelUnionId;
    if (channelUnionId) {
      console.log("[Card] \u5173\u8054\u4EBA\u7269\u5361", req);
      this.linkCard(channelUnionId, cardName, userId ?? undefined);
    }
  }
  getLinkMap(channelUnionId) {
    return CardProvider2.getLinkMap(channelUnionId);
  }
  getCard(channelUnionId, userId) {
    return CardProvider2.getCard(channelUnionId, userId);
  }
  linkCard(channelUnionId, cardName, userId) {
    CardProvider2.linkCard(channelUnionId, cardName, userId);
  }
  queryCard(query = {}) {
    return CardProvider2.queryCard(query);
  }
  addCardEntryChangeListener(listener) {
    this.emitter.on("EntryChange", listener);
  }
  removeCardEntryChangeListener(listener) {
    this.emitter.off("EntryChange", listener);
  }
}

// src/service/config.ts
var import_fast_glob2 = __toESM(require_out4(), 1);
var import_mobx3 = __toESM(require_dist(), 1);
import fs3 from "fs";
var import_lodash = __toESM(require_lodash(), 1);
var saveConfigFile = function(name302, config8) {
  if (!fs3.existsSync(CONFIG_DIR)) {
    fs3.mkdirSync(CONFIG_DIR);
  }
  fs3.writeFile(`${CONFIG_DIR}/${name302}.json`, JSON.stringify(config8), (e4) => {
    if (e4) {
      console.error("[Config] \u914D\u7F6E\u5199\u6587\u4EF6\u5931\u8D25", e4);
    }
  });
};
var deleteConfigFile = function(name302) {
  try {
    if (!fs3.existsSync(CONFIG_DIR)) {
      return;
    }
    const filePath = `${CONFIG_DIR}/${name302}.json`;
    if (!fs3.existsSync(filePath)) {
      return;
    }
    fs3.unlinkSync(filePath);
  } catch (e4) {
    console.error("[Config] \u5220\u9664\u914D\u7F6E\u5931\u8D25", e4);
  }
};
var CONFIG_DIR = resolveRootDir("config");

class ConfigManager {
  wss;
  configMap = {};
  defaultConfig;
  configMapV1 = {};
  constructor(wss) {
    import_mobx3.makeAutoObservable(this);
    this.wss = wss;
    this.initConfig();
  }
  getChannelConfig(channelUnionId) {
    if (channelUnionId === "default") {
      return ConfigProvider2.defaultConfig;
    } else if (this.configMap[channelUnionId]) {
      return ConfigProvider2.getConfig(channelUnionId);
    } else if (channelUnionId.startsWith("qqguild_")) {
      const channelId = channelUnionId.split("_").at(-1);
      if (this.configMapV1[channelId]) {
        console.log("[Config] \u8FC1\u79FB\u65E7\u7248\u672C\u914D\u7F6E\uFF1A", channelUnionId);
        const config8 = this.configMapV1[channelId];
        delete this.configMapV1[channelId];
        deleteConfigFile(channelId);
        this.saveChannelConfig(channelUnionId, { config: config8, setDefault: false });
        return ConfigProvider2.getConfig(channelUnionId);
      }
    }
    return ConfigProvider2.defaultConfig;
  }
  saveChannelConfig(channelUnionId, { config: config8, setDefault }) {
    console.log("[Config] \u4FDD\u5B58\u914D\u7F6E\uFF0C\u8BBE\u4E3A\u9ED8\u8BA4\u914D\u7F6E\uFF1A", setDefault);
    this.configMap[channelUnionId] = import_lodash.cloneDeep(config8);
    ConfigProvider2.register(channelUnionId, this.configMap[channelUnionId]);
    saveConfigFile(channelUnionId, config8);
    if (setDefault) {
      this.defaultConfig = import_lodash.cloneDeep(config8);
      ConfigProvider2.register("default", this.defaultConfig);
      saveConfigFile("default", config8);
    }
  }
  resetChannelConfig(client) {
    console.log("[Config] \u91CD\u7F6E\u4E3A\u9ED8\u8BA4\u914D\u7F6E");
    const channelUnionId = client.listenToChannelUnionId;
    if (!channelUnionId)
      return;
    delete this.configMap[channelUnionId];
    deleteConfigFile(channelUnionId);
  }
  initConfig() {
    try {
      console.log("[Config] \u5F00\u59CB\u8BFB\u53D6\u914D\u7F6E");
      if (fs3.existsSync(CONFIG_DIR)) {
        const files = import_fast_glob2.globSync(`${CONFIG_DIR}/*.json`);
        files.forEach((filename) => {
          try {
            const str = fs3.readFileSync(filename, "utf8");
            const config8 = JSON.parse(str);
            const name302 = filename.match(/config\/(.+)\.json$/)[1];
            if (name302 === "default") {
              this.defaultConfig = config8;
              ConfigProvider2.register("default", this.defaultConfig);
            } else {
              const unionId = asChannelUnionId(name302);
              if (unionId) {
                this.configMap[unionId] = config8;
                ConfigProvider2.register(unionId, this.configMap[unionId]);
              } else {
                this.configMapV1[name302] = config8;
              }
            }
          } catch (e4) {
            console.log(`[Config] ${filename} \u89E3\u6790\u5931\u8D25`, e4);
          }
        });
      }
    } catch (e4) {
      console.error("[Config] \u8BFB\u53D6\u914D\u7F6E\u5217\u8868\u5931\u8D25", e4);
    }
    if (!this.defaultConfig) {
      this.defaultConfig = ConfigProvider2.defaultConfig.config;
      ConfigProvider2.register("default", this.defaultConfig);
    }
  }
}
// ../../packages/types/lib/version.js
var VERSION_NAME = "v2.0.0-alpha.4";
var VERSION_CODE3 = 41;
// src/service/plugin.ts
var import_mobx4 = __toESM(require_dist(), 1);
var import_lodash2 = __toESM(require_lodash(), 1);
import fs4 from "fs";
import path2 from "path";
function handlePluginCompatibility(plugin3) {
  plugin3.aliasRoll?.forEach((r) => {
    r.scope ||= "expression";
  });
}
function withDefaults(pluginItem) {
  return {
    id: pluginItem.id,
    name: pluginItem.name,
    description: pluginItem.description ?? "",
    defaultEnabled: pluginItem.defaultEnabled ?? true
  };
}
var INTERNAL_PLUGIN_DIR = path2.resolve("./src/plugins");
var PLUGIN_DIR = "./plugins";

class PluginManager {
  wss;
  pluginMap = {};
  constructor(wss) {
    import_mobx4.makeAutoObservable(this, { wss: false });
    this.wss = wss;
    const pluginNames = this.extractOfficialPluginsIfNeed();
    this.loadPlugins(pluginNames);
    if (false) {
    }
  }
  getPluginRegisterContext(pluginId) {
    const wss = this.wss;
    return {
      versionName: VERSION_NAME,
      versionCode: VERSION_CODE3,
      roll: (exp4) => new DiceRoll(exp4),
      render: (arg1, arg22, arg3) => mustache_default.render(arg1, arg22, arg3, { escape: (value) => value }),
      getCard: ({ channelUnionId, userId }) => this.wss.cards.getCard(channelUnionId, userId),
      saveCard: (card12) => this.wss.cards.saveCard(card12),
      getLinkedCardUserList: ({ channelUnionId }) => Object.keys(this.wss.cards.getLinkMap(channelUnionId)),
      linkCard: ({ channelUnionId, userId }, cardName) => {
        if (userId && !cardName) {
          const cardName2 = this.wss.cards.getCard(channelUnionId, userId)?.name;
          if (cardName2) {
            this.wss.cards.linkCard(channelUnionId, cardName2, userId);
          }
        } else if (cardName && !userId) {
          this.wss.cards.linkCard(channelUnionId, cardName, userId);
        } else if (!cardName) {
          throw new Error("\u5FC5\u987B\u4F20\u5165 userId \u6216 cardName");
        } else {
          this.wss.cards.linkCard(channelUnionId, cardName, userId);
        }
      },
      queryCard: (query) => this.wss.cards.queryCard(query),
      sendMessageToChannel: ({ platform: platform2, channelId, guildId, botId, userId, username, userRole }, msg, options = {}) => {
        const bot = this.wss.bots.find(botId);
        const channel = bot?.guilds.findChannel(channelId, guildId);
        if (!channel || !bot)
          throw new Error(`\u627E\u4E0D\u5230\u9891\u9053\uFF0CbotId=${botId}, guildId=${guildId}, channelId=${channelId}`);
        if (typeof options === "string") {
          options = { msgType: options };
        }
        const { msgType = "text", skipParse = false } = options;
        if (msgType === "text") {
          const channelUnionId = getChannelUnionId(platform2, guildId, channelId);
          const content = skipParse ? msg : parseTemplate2(msg, { userId, username, userRole, channelUnionId }, [], "message_template");
          return channel.sendMessage(content);
        } else {
          return channel.sendMessage(`<img src="${msg}"/>`);
        }
      },
      sendMessageToUser: ({ platform: platform2, channelId, guildId, botId, userId, username, userRole }, msg, options = {}) => {
        const bot = this.wss.bots.find(botId);
        const user = bot?.guilds.findUser(userId, guildId);
        if (!user || !bot)
          throw new Error(`\u627E\u4E0D\u5230\u7528\u6237\uFF0CbotId=${botId}, guildId=${guildId}, userId=${userId}`);
        if (typeof options === "string") {
          options = { msgType: options };
        }
        const { msgType = "text", skipParse = false } = options;
        if (msgType === "text") {
          const channelUnionId = getChannelUnionId(platform2, guildId, channelId);
          const content = skipParse ? msg : parseTemplate2(msg, { userId, username, userRole, channelUnionId }, [], "message_template");
          return user.sendMessage(content);
        } else {
          return user.sendMessage(`<img src="${msg}"/>`);
        }
      },
      sendMessage: async (env, msg, options = {}) => {
        const bot = this.wss.bots.find(env.botId);
        if (!bot)
          return;
        const command = { command: "", context: env };
        const { msgType = "text", skipParse = false } = options;
        if (msgType === "text") {
          const content = skipParse ? msg : parseTemplate2(msg, env, [], "message_template");
          return bot.commandHandler.sendMessage(command, content);
        } else {
          return bot.commandHandler.sendMessage(command, `<img src="${msg}"/>`);
        }
      },
      getConfig: ({ platform: platform2, guildId, channelId }) => {
        const channelUnionId = getChannelUnionId(platform2, guildId, channelId);
        return wss.config.getChannelConfig(channelUnionId).config;
      },
      getPreference: ({ platform: platform2, guildId, channelId }) => {
        const channelUnionId = getChannelUnionId(platform2, guildId, channelId);
        const channelConfig = wss.config.getChannelConfig(channelUnionId);
        const pluginConfig = channelConfig.config.plugins.find((plugin3) => plugin3.id === pluginId);
        return pluginConfig?.preference ?? {};
      },
      dispatchUserCommand: async (parsed) => {
        return this.wss.bots.find(parsed.context.botId)?.commandHandler.handleCommand(parsed);
      },
      _context: wss,
      _: import_lodash2.default
    };
  }
  extractOfficialPluginsIfNeed() {
    console.log("[Plugin] \u5F00\u59CB\u52A0\u8F7D\u63D2\u4EF6");
    if (true) {
      const internalPluginNames2 = fs4.readdirSync(INTERNAL_PLUGIN_DIR, { withFileTypes: true }).filter((d) => d.isDirectory()).map((d) => d.name);
      return internalPluginNames2;
    }
    if (!fs4.existsSync(PLUGIN_DIR)) {
      fs4.mkdirSync(PLUGIN_DIR);
    }
    const pluginNames = new Set(fs4.readdirSync(PLUGIN_DIR, { withFileTypes: true }).filter((d) => d.isDirectory()).map((d) => d.name));
    const internalPluginNames = fs4.readdirSync(INTERNAL_PLUGIN_DIR, { withFileTypes: true }).filter((d) => d.isDirectory()).map((d) => d.name);
    internalPluginNames.forEach((pluginName2) => {
      if (!pluginNames.has(pluginName2)) {
        copyFolderSync(path2.join(INTERNAL_PLUGIN_DIR, pluginName2), path2.join(PLUGIN_DIR, pluginName2));
        pluginNames.add(pluginName2);
      }
    });
    return Array.from(pluginNames);
  }
  loadPlugins(pluginNames) {
    const newPlugins = [];
    PluginProvider2.register(newPlugins);
  }
  _loadPlugin(pluginName) {
    try {
      const fullPath = path2.join(INTERNAL_PLUGIN_DIR, pluginName, "index.js");
      eval("delete require.cache[fullPath]");
      const context = this.getPluginRegisterContext(pluginName);
      const plugin = eval("require(fullPath)(context)");
      plugin.id ||= pluginName;
      handlePluginCompatibility(plugin);
      console.log("[Plugin] \u52A0\u8F7D\u63D2\u4EF6", plugin.id);
      this.pluginMap[plugin.id] = plugin;
      return plugin;
    } catch (e4) {
      console.error(`[Plugin] \u52A0\u8F7D\u63D2\u4EF6 ${pluginName} \u51FA\u9519\uFF1A`, e4);
      return;
    }
  }
  checkOfficialPluginsUpdate() {
    const plugins2reload = [];
    Object.entries(officialPluginsVersions).forEach(([name302, version9]) => {
      const currentVersion = this.pluginMap[name302]?.version;
      if (!currentVersion)
        return;
      if (version9 > currentVersion) {
        console.log(`[Plugin] \u68C0\u6D4B\u5230\u63D2\u4EF6 ${name302} \u6709\u66F4\u65B0\uFF0C\u5373\u5C06\u8FDB\u884C\u66F4\u65B0\u3002\u82E5\u66F4\u65B0\u540E\u529F\u80FD\u5F02\u5E38\uFF0C\u8BF7\u5C1D\u8BD5\u91CD\u65B0\u542F\u52A8\u8F6F\u4EF6\u3002`);
        copyFolderSync(path2.join(INTERNAL_PLUGIN_DIR, name302), path2.join(PLUGIN_DIR, name302));
        plugins2reload.push(name302);
      }
    });
    if (plugins2reload.length > 0) {
      this.loadPlugins(plugins2reload);
    }
  }
  manualReloadPlugins(pluginNames) {
    if (pluginNames.length > 0) {
      this.loadPlugins(pluginNames);
    } else {
      const pluginNames2 = this.extractOfficialPluginsIfNeed();
      this.loadPlugins(pluginNames2);
    }
  }
  get pluginListManifest() {
    return Object.values(this.pluginMap).map((plugin3) => ({
      id: plugin3.id,
      name: plugin3.name || plugin3.id || "--",
      description: plugin3.description ?? "",
      preference: (plugin3.preference ?? []).map((pref) => ({
        key: pref.key,
        label: pref.label ?? pref.key,
        defaultValue: pref.defaultValue ?? ""
      })),
      customReply: (plugin3.customReply || []).map(withDefaults),
      rollDecider: [],
      aliasRoll: (plugin3.aliasRoll || []).map(withDefaults),
      customText: (plugin3.customText || []).map(withDefaults),
      hook: {
        onReceiveCommand: (plugin3.hook?.onReceiveCommand || []).map(withDefaults),
        beforeParseDiceRoll: (plugin3.hook?.beforeParseDiceRoll || []).map(withDefaults),
        onCardEntryChange: (plugin3.hook?.onCardEntryChange || []).map(withDefaults),
        onMessageReaction: (plugin3.hook?.onMessageReaction || []).map(withDefaults),
        beforeDiceRoll: (plugin3.hook?.beforeDiceRoll || []).map(withDefaults),
        afterDiceRoll: (plugin3.hook?.afterDiceRoll || []).map(withDefaults)
      }
    }));
  }
}
var officialPluginsVersions = {
  "io.paotuan.plugin.namegen": 2,
  "io.paotuan.plugin.insane": 3,
  "io.paotuan.plugin.cardgen": 5,
  "io.paotuan.plugin.draw": 2,
  "io.paotuan.plugin.compatible": 1
};

// ../../node_modules/cosmokit/lib/index.mjs
var noop5 = function() {
};
var isNullable = function(value) {
  return value === null || value === undefined;
};
var isPlainObject2 = function(data2) {
  return data2 && typeof data2 === "object" && !Array.isArray(data2);
};
var filterKeys = function(object36, filter4) {
  return Object.fromEntries(Object.entries(object36).filter(([key, value]) => filter4(key, value)));
};
var mapValues = function(object36, transform) {
  return Object.fromEntries(Object.entries(object36).map(([key, value]) => [key, transform(value, key)]));
};
var pick2 = function(source, keys, forced) {
  if (!keys)
    return { ...source };
  const result = {};
  for (const key of keys) {
    if (forced || source[key] !== undefined)
      result[key] = source[key];
  }
  return result;
};
var omit = function(source, keys) {
  if (!keys)
    return { ...source };
  const result = { ...source };
  for (const key of keys) {
    Reflect.deleteProperty(result, key);
  }
  return result;
};
var defineProperty17 = function(object36, key, value) {
  return Object.defineProperty(object36, key, { writable: true, value, enumerable: false });
};
var contain = function(array1, array210) {
  return array210.every((item) => array1.includes(item));
};
var intersection = function(array1, array210) {
  return array1.filter((item) => array210.includes(item));
};
var difference = function(array1, array210) {
  return array1.filter((item) => !array210.includes(item));
};
var union = function(array1, array210) {
  return Array.from(new Set([...array1, ...array210]));
};
var deduplicate = function(array59) {
  return [...new Set(array59)];
};
var remove = function(list3, item) {
  const index2 = list3.indexOf(item);
  if (index2 >= 0) {
    list3.splice(index2, 1);
    return true;
  } else {
    return false;
  }
};
var makeArray = function(source) {
  return Array.isArray(source) ? source : isNullable(source) ? [] : [source];
};
var is93 = function(type, value) {
  if (arguments.length === 1)
    return (value2) => is93(type, value2);
  return type in globalThis && value instanceof globalThis[type] || Object.prototype.toString.call(value).slice(8, -1) === type;
};
var isArrayBufferLike = function(value) {
  return is93("ArrayBuffer", value) || is93("SharedArrayBuffer", value);
};
var isArrayBufferSource = function(value) {
  return isArrayBufferLike(value) || ArrayBuffer.isView(value);
};
var clone5 = function(source) {
  if (!source || typeof source !== "object")
    return source;
  if (Array.isArray(source))
    return source.map(clone5);
  if (is93("Date", source))
    return new Date(source.valueOf());
  if (is93("RegExp", source))
    return new RegExp(source.source, source.flags);
  if (isArrayBufferLike(source))
    return source.slice(0);
  if (ArrayBuffer.isView(source))
    return source.buffer.slice(source.byteOffset, source.byteOffset + source.byteLength);
  return mapValues(source, clone5);
};
var deepEqual3 = function(a, b, strict) {
  if (a === b)
    return true;
  if (!strict && isNullable(a) && isNullable(b))
    return true;
  if (typeof a !== typeof b)
    return false;
  if (typeof a !== "object")
    return false;
  if (!a || !b)
    return false;
  function check(test, then) {
    return test(a) ? test(b) ? then(a, b) : false : test(b) ? false : undefined;
  }
  __name(check, "check");
  return check(Array.isArray, (a2, b2) => a2.length === b2.length && a2.every((item, index2) => deepEqual3(item, b2[index2]))) ?? check(is93("Date"), (a2, b2) => a2.valueOf() === b2.valueOf()) ?? check(is93("RegExp"), (a2, b2) => a2.source === b2.source && a2.flags === b2.flags) ?? check(isArrayBufferLike, (a2, b2) => {
    if (a2.byteLength !== b2.byteLength)
      return false;
    const viewA = new Uint8Array(a2);
    const viewB = new Uint8Array(b2);
    for (let i3 = 0;i3 < viewA.length; i3++) {
      if (viewA[i3] !== viewB[i3])
        return false;
    }
    return true;
  }) ?? Object.keys({ ...a, ...b }).every((key) => deepEqual3(a[key], b[key], strict));
};
var capitalize = function(source) {
  return source.charAt(0).toUpperCase() + source.slice(1);
};
var uncapitalize = function(source) {
  return source.charAt(0).toLowerCase() + source.slice(1);
};
var camelCase = function(source) {
  return source.replace(/[_-][a-z]/g, (str) => str.slice(1).toUpperCase());
};
var paramCase = function(source) {
  return uncapitalize(source).replace(/_/g, "-").replace(/.[A-Z]+/g, (str) => str[0] + "-" + str.slice(1).toLowerCase());
};
var snakeCase = function(source) {
  return uncapitalize(source).replace(/-/g, "_").replace(/.[A-Z]+/g, (str) => str[0] + "_" + str.slice(1).toLowerCase());
};
var trimSlash = function(source) {
  return source.replace(/\/$/, "");
};
var sanitize = function(source) {
  if (!source.startsWith("/"))
    source = "/" + source;
  return trimSlash(source);
};
var __defProp2 = Object.defineProperty;
var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
__name(noop5, "noop");
__name(isNullable, "isNullable");
__name(isPlainObject2, "isPlainObject");
__name(filterKeys, "filterKeys");
__name(mapValues, "mapValues");
__name(pick2, "pick");
__name(omit, "omit");
__name(defineProperty17, "defineProperty");
__name(contain, "contain");
__name(intersection, "intersection");
__name(difference, "difference");
__name(union, "union");
__name(deduplicate, "deduplicate");
__name(remove, "remove");
__name(makeArray, "makeArray");
__name(is93, "is");
__name(isArrayBufferLike, "isArrayBufferLike");
__name(isArrayBufferSource, "isArrayBufferSource");
var Binary;
((Binary2) => {
  Binary2.is = isArrayBufferLike;
  Binary2.isSource = isArrayBufferSource;
  function fromSource(source) {
    if (ArrayBuffer.isView(source)) {
      return source.buffer.slice(source.byteOffset, source.byteOffset + source.byteLength);
    } else {
      return source;
    }
  }
  Binary2.fromSource = fromSource;
  __name(fromSource, "fromSource");
  function toBase64(source) {
    if (typeof Buffer !== "undefined") {
      return Buffer.from(source).toString("base64");
    }
    let binary = "";
    const bytes = new Uint8Array(source);
    for (let i3 = 0;i3 < bytes.byteLength; i3++) {
      binary += String.fromCharCode(bytes[i3]);
    }
    return btoa(binary);
  }
  Binary2.toBase64 = toBase64;
  __name(toBase64, "toBase64");
  function fromBase64(source) {
    if (typeof Buffer !== "undefined")
      return fromSource(Buffer.from(source, "base64"));
    return Uint8Array.from(atob(source), (c) => c.charCodeAt(0));
  }
  Binary2.fromBase64 = fromBase64;
  __name(fromBase64, "fromBase64");
  function toHex(source) {
    if (typeof Buffer !== "undefined")
      return Buffer.from(source).toString("hex");
    return Array.from(new Uint8Array(source), (byte) => byte.toString(16).padStart(2, "0")).join("");
  }
  Binary2.toHex = toHex;
  __name(toHex, "toHex");
  function fromHex(source) {
    if (typeof Buffer !== "undefined")
      return fromSource(Buffer.from(source, "hex"));
    const hex4 = source.length % 2 === 0 ? source : source.slice(0, source.length - 1);
    const buffer = [];
    for (let i3 = 0;i3 < hex4.length; i3 += 2) {
      buffer.push(parseInt(`${hex4[i3]}${hex4[i3 + 1]}`, 16));
    }
    return Uint8Array.from(buffer).buffer;
  }
  Binary2.fromHex = fromHex;
  __name(fromHex, "fromHex");
})(Binary || (Binary = {}));
var base64ToArrayBuffer = Binary.fromBase64;
var arrayBufferToBase64 = Binary.toBase64;
var hexToArrayBuffer = Binary.fromHex;
var arrayBufferToHex = Binary.toHex;
__name(clone5, "clone");
__name(deepEqual3, "deepEqual");
__name(capitalize, "capitalize");
__name(uncapitalize, "uncapitalize");
__name(camelCase, "camelCase");
__name(paramCase, "paramCase");
__name(snakeCase, "snakeCase");
var camelize = camelCase;
var hyphenate = paramCase;
__name(trimSlash, "trimSlash");
__name(sanitize, "sanitize");
var Time;
((Time2) => {
  Time2.millisecond = 1;
  Time2.second = 1000;
  Time2.minute = Time2.second * 60;
  Time2.hour = Time2.minute * 60;
  Time2.day = Time2.hour * 24;
  Time2.week = Time2.day * 7;
  let timezoneOffset = (new Date()).getTimezoneOffset();
  function setTimezoneOffset(offset) {
    timezoneOffset = offset;
  }
  Time2.setTimezoneOffset = setTimezoneOffset;
  __name(setTimezoneOffset, "setTimezoneOffset");
  function getTimezoneOffset() {
    return timezoneOffset;
  }
  Time2.getTimezoneOffset = getTimezoneOffset;
  __name(getTimezoneOffset, "getTimezoneOffset");
  function getDateNumber(date2 = new Date, offset) {
    if (typeof date2 === "number")
      date2 = new Date(date2);
    if (offset === undefined)
      offset = timezoneOffset;
    return Math.floor((date2.valueOf() / Time2.minute - offset) / 1440);
  }
  Time2.getDateNumber = getDateNumber;
  __name(getDateNumber, "getDateNumber");
  function fromDateNumber(value, offset) {
    const date2 = new Date(value * Time2.day);
    if (offset === undefined)
      offset = timezoneOffset;
    return new Date(+date2 + offset * Time2.minute);
  }
  Time2.fromDateNumber = fromDateNumber;
  __name(fromDateNumber, "fromDateNumber");
  const numeric4 = /\d+(?:\.\d+)?/.source;
  const timeRegExp = new RegExp(`^${[
    "w(?:eek(?:s)?)?",
    "d(?:ay(?:s)?)?",
    "h(?:our(?:s)?)?",
    "m(?:in(?:ute)?(?:s)?)?",
    "s(?:ec(?:ond)?(?:s)?)?"
  ].map((unit3) => `(${numeric4}${unit3})?`).join("")}\$`);
  function parseTime(source) {
    const capture = timeRegExp.exec(source);
    if (!capture)
      return 0;
    return (parseFloat(capture[1]) * Time2.week || 0) + (parseFloat(capture[2]) * Time2.day || 0) + (parseFloat(capture[3]) * Time2.hour || 0) + (parseFloat(capture[4]) * Time2.minute || 0) + (parseFloat(capture[5]) * Time2.second || 0);
  }
  Time2.parseTime = parseTime;
  __name(parseTime, "parseTime");
  function parseDate(date2) {
    const parsed = parseTime(date2);
    if (parsed) {
      date2 = Date.now() + parsed;
    } else if (/^\d{1,2}(:\d{1,2}){1,2}$/.test(date2)) {
      date2 = `${(new Date()).toLocaleDateString()}-${date2}`;
    } else if (/^\d{1,2}-\d{1,2}-\d{1,2}(:\d{1,2}){1,2}$/.test(date2)) {
      date2 = `${(new Date()).getFullYear()}-${date2}`;
    }
    return date2 ? new Date(date2) : new Date;
  }
  Time2.parseDate = parseDate;
  __name(parseDate, "parseDate");
  function format6(ms) {
    const abs4 = Math.abs(ms);
    if (abs4 >= Time2.day - Time2.hour / 2) {
      return Math.round(ms / Time2.day) + "d";
    } else if (abs4 >= Time2.hour - Time2.minute / 2) {
      return Math.round(ms / Time2.hour) + "h";
    } else if (abs4 >= Time2.minute - Time2.second / 2) {
      return Math.round(ms / Time2.minute) + "m";
    } else if (abs4 >= Time2.second) {
      return Math.round(ms / Time2.second) + "s";
    }
    return ms + "ms";
  }
  Time2.format = format6;
  __name(format6, "format");
  function toDigits(source, length = 2) {
    return source.toString().padStart(length, "0");
  }
  Time2.toDigits = toDigits;
  __name(toDigits, "toDigits");
  function template(template2, time = new Date) {
    return template2.replace("yyyy", time.getFullYear().toString()).replace("yy", time.getFullYear().toString().slice(2)).replace("MM", toDigits(time.getMonth() + 1)).replace("dd", toDigits(time.getDate())).replace("hh", toDigits(time.getHours())).replace("mm", toDigits(time.getMinutes())).replace("ss", toDigits(time.getSeconds())).replace("SSS", toDigits(time.getMilliseconds(), 3));
  }
  Time2.template = template;
  __name(template, "template");
})(Time || (Time = {}));

// ../../node_modules/@cordisjs/core/lib/index.mjs
var isBailed = function(value) {
  return value !== null && value !== false && value !== undefined;
};
var isConstructor = function(func) {
  if (!func.prototype)
    return false;
  if (func instanceof GeneratorFunction)
    return false;
  if (AsyncGeneratorFunction !== Function && func instanceof AsyncGeneratorFunction)
    return false;
  return true;
};
var resolveConfig = function(plugin3, config8) {
  const schema = plugin3["Config"] || plugin3["schema"];
  if (schema && plugin3["schema"] !== false)
    config8 = schema(config8);
  return config8 ?? {};
};
var isUnproxyable = function(value) {
  return [Map, Set, Date, Promise].some((constructor) => value instanceof constructor);
};
var joinPrototype = function(proto1, proto2) {
  if (proto1 === Object.prototype)
    return proto2;
  const result = Object.create(joinPrototype(Object.getPrototypeOf(proto1), proto2));
  for (const key of Reflect.ownKeys(proto1)) {
    Object.defineProperty(result, key, Object.getOwnPropertyDescriptor(proto1, key));
  }
  return result;
};
var createTraceable = function(ctx, value) {
  const proxy = new Proxy(value, {
    get: (target, name302, receiver) => {
      if (name302 === symbols.origin)
        return ctx;
      return Reflect.get(target, name302, receiver);
    },
    apply: (target, thisArg, args) => {
      return applyTraceable(proxy, target, thisArg, args);
    }
  });
  return proxy;
};
var applyTraceable = function(proxy, value, thisArg, args) {
  if (!value[symbols.invoke])
    return Reflect.apply(value, thisArg, args);
  return value[symbols.invoke].apply(proxy, args);
};
var createCallable = function(name302, proto) {
  const self2 = __name2(function(...args) {
    const proxy = createTraceable(self2[symbols.origin], self2);
    return applyTraceable(proxy, self2, this, args);
  }, "self");
  defineProperty17(self2, "name", name302);
  return Object.setPrototypeOf(self2, proto);
};
var isApplicable = function(object36) {
  return object36 && typeof object36 === "object" && typeof object36.apply === "function";
};
var __defProp3 = Object.defineProperty;
var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
__name2(isBailed, "isBailed");
var Lifecycle = class {
  constructor(root) {
    this.root = root;
    defineProperty17(this, Context3.origin, root);
    defineProperty17(this.on("internal/listener", function(name302, listener, options) {
      const method = options.prepend ? "unshift" : "push";
      if (name302 === "ready") {
        if (!this.lifecycle.isActive)
          return;
        this.scope.ensure(async () => listener());
        return () => false;
      } else if (name302 === "dispose") {
        this.scope.disposables[method](listener);
        defineProperty17(listener, "name", "event <dispose>");
        return () => remove(this.scope.disposables, listener);
      } else if (name302 === "fork") {
        this.scope.runtime.forkables[method](listener);
        return this.scope.collect("event <fork>", () => remove(this.scope.runtime.forkables, listener));
      }
    }), Context3.static, root.scope);
    for (const level of ["info", "error", "warning"]) {
      defineProperty17(this.on(`internal/${level}`, (format6, ...param) => {
        if (this._hooks[`internal/${level}`].length > 1)
          return;
        console.info(format6, ...param);
      }), Context3.static, root.scope);
    }
    defineProperty17(this.on("internal/before-service", function(name302) {
      for (const runtime of this.registry.values()) {
        if (!runtime.using.includes(name302))
          continue;
        const scopes = runtime.isReusable ? runtime.children : [runtime];
        for (const scope3 of scopes) {
          if (!this[symbols.filter](scope3.ctx))
            continue;
          scope3.updateStatus();
          scope3.reset();
        }
      }
    }, { globalThis: true }), Context3.static, root.scope);
    defineProperty17(this.on("internal/service", function(name302) {
      for (const runtime of this.registry.values()) {
        if (!runtime.using.includes(name302))
          continue;
        const scopes = runtime.isReusable ? runtime.children : [runtime];
        for (const scope3 of scopes) {
          if (!this[symbols.filter](scope3.ctx))
            continue;
          scope3.start();
        }
      }
    }, { globalThis: true }), Context3.static, root.scope);
    defineProperty17(this.on("internal/inject", function(name302) {
      let parent = this;
      while (parent.runtime.plugin) {
        for (const key of parent.runtime.inject) {
          if (name302 === Context3.resolveInject(parent, key)[0])
            return true;
        }
        parent = parent.scope.parent;
      }
    }, { globalThis: true }), Context3.static, root.scope);
  }
  static {
    __name2(this, "Lifecycle");
  }
  isActive = false;
  _tasks = new Set;
  _hooks = {};
  async flush() {
    while (this._tasks.size) {
      await Promise.all(Array.from(this._tasks));
    }
  }
  getHooks(name302, thisArg) {
    const hooks = this._hooks[name302] || [];
    return hooks.slice().filter(([context2, callback, options]) => {
      const filter4 = thisArg?.[Context3.filter];
      return options.globalThis || !filter4 || filter4.call(thisArg, context2);
    }).map(([, callback]) => callback);
  }
  prepareEvent(type, args) {
    const thisArg = typeof args[0] === "object" || typeof args[0] === "function" ? args.shift() : null;
    const name302 = args.shift();
    if (name302 !== "internal/event") {
      this.emit("internal/event", type, name302, args, thisArg);
    }
    return [this.getHooks(name302, thisArg), thisArg ?? this[Context3.origin]];
  }
  async parallel(...args) {
    const [hooks, thisArg] = this.prepareEvent("parallel", args);
    await Promise.all(hooks.map(async (callback) => {
      await callback.apply(thisArg, args);
    }));
  }
  emit(...args) {
    const [hooks, thisArg] = this.prepareEvent("emit", args);
    for (const callback of hooks) {
      callback.apply(thisArg, args);
    }
  }
  async serial(...args) {
    const [hooks, thisArg] = this.prepareEvent("serial", args);
    for (const callback of hooks) {
      const result = await callback.apply(thisArg, args);
      if (isBailed(result))
        return result;
    }
  }
  bail(...args) {
    const [hooks, thisArg] = this.prepareEvent("bail", args);
    for (const callback of hooks) {
      const result = callback.apply(thisArg, args);
      if (isBailed(result))
        return result;
    }
  }
  register(label, hooks, listener, options) {
    const caller = this[Context3.origin];
    const method = options.prepend ? "unshift" : "push";
    hooks[method]([caller, listener, options]);
    return caller.state.collect(label, () => this.unregister(hooks, listener));
  }
  unregister(hooks, listener) {
    const index2 = hooks.findIndex(([context2, callback]) => callback === listener);
    if (index2 >= 0) {
      hooks.splice(index2, 1);
      return true;
    }
  }
  on(name302, listener, options) {
    if (typeof options !== "object") {
      options = { prepend: options };
    }
    const caller = this[Context3.origin];
    caller.scope.assertActive();
    const result = this.bail(caller, "internal/listener", name302, listener, options);
    if (result)
      return result;
    const hooks = this._hooks[name302] ||= [];
    const label = typeof name302 === "string" ? `event <${name302}>` : "event (Symbol)";
    return this.register(label, hooks, listener, options);
  }
  once(name302, listener, options) {
    const dispose = this.on(name302, function(...args) {
      dispose();
      return listener.apply(this, args);
    }, options);
    return dispose;
  }
  off(name302, listener) {
    return this.unregister(this._hooks[name302] || [], listener);
  }
  async start() {
    this.isActive = true;
    const hooks = this._hooks.ready || [];
    while (hooks.length) {
      const [context2, callback] = hooks.shift();
      context2.scope.ensure(async () => callback());
    }
    await this.flush();
  }
  async stop() {
    this.isActive = false;
    this.root.scope.reset();
  }
};
var symbols = {
  origin: Symbol.for("cordis.origin"),
  events: Symbol.for("cordis.events"),
  static: Symbol.for("cordis.static"),
  filter: Symbol.for("cordis.filter"),
  expose: Symbol.for("cordis.expose"),
  isolate: Symbol.for("cordis.isolate"),
  internal: Symbol.for("cordis.internal"),
  intercept: Symbol.for("cordis.intercept"),
  setup: Symbol.for("cordis.setup"),
  invoke: Symbol.for("cordis.invoke"),
  extend: Symbol.for("cordis.extend"),
  provide: Symbol.for("cordis.provide"),
  immediate: Symbol.for("cordis.immediate")
};
var GeneratorFunction = function* () {
}.constructor;
var AsyncGeneratorFunction = async function* () {
}.constructor;
__name2(isConstructor, "isConstructor");
__name2(resolveConfig, "resolveConfig");
__name2(isUnproxyable, "isUnproxyable");
__name2(joinPrototype, "joinPrototype");
__name2(createTraceable, "createTraceable");
__name2(applyTraceable, "applyTraceable");
__name2(createCallable, "createCallable");
var CordisError = class _CordisError extends Error {
  constructor(code, message) {
    super(message ?? _CordisError.Code[code]);
    this.code = code;
  }
  static {
    __name2(this, "CordisError");
  }
};
((CordisError2) => {
  CordisError2.Code = {
    INACTIVE_EFFECT: "cannot create effect on inactive context"
  };
})(CordisError || (CordisError = {}));
var EffectScope = class {
  constructor(parent, config8) {
    this.parent = parent;
    this.config = config8;
    this.uid = parent.registry ? parent.registry.counter : 0;
    this.ctx = this.context = parent.extend({ scope: this });
    this.proxy = new Proxy({}, {
      get: (target, key) => Reflect.get(this.config, key)
    });
  }
  static {
    __name2(this, "EffectScope");
  }
  uid;
  ctx;
  disposables = [];
  error;
  status = 0;
  isActive = false;
  context;
  proxy;
  acceptors = [];
  tasks = new Set;
  hasError = false;
  get _config() {
    return this.runtime.isReactive ? this.proxy : this.config;
  }
  assertActive() {
    if (this.uid !== null || this.isActive)
      return;
    throw new CordisError("INACTIVE_EFFECT");
  }
  effect(callback, config8) {
    this.assertActive();
    const result = isConstructor(callback) ? new callback(this.ctx, config8) : callback(this.ctx, config8);
    let disposed = false;
    const original = typeof result === "function" ? result : result.dispose.bind(result);
    const wrapped = __name2((...args) => {
      if (disposed)
        return;
      disposed = true;
      remove(this.disposables, wrapped);
      return original(...args);
    }, "wrapped");
    this.disposables.push(wrapped);
    if (typeof result === "function")
      return wrapped;
    result.dispose = wrapped;
    return result;
  }
  collect(label, callback) {
    const dispose = defineProperty17(() => {
      remove(this.disposables, dispose);
      return callback();
    }, "name", label);
    this.disposables.push(dispose);
    return dispose;
  }
  restart() {
    this.reset();
    this.error = null;
    this.hasError = false;
    this.status = 0;
    this.start();
  }
  _getStatus() {
    if (this.uid === null)
      return 4;
    if (this.hasError)
      return 3;
    if (this.tasks.size)
      return 1;
    if (this.ready)
      return 2;
    return 0;
  }
  updateStatus(callback) {
    const oldValue = this.status;
    callback?.();
    this.status = this._getStatus();
    if (oldValue !== this.status) {
      this.context.emit("internal/status", this, oldValue);
    }
  }
  ensure(callback) {
    const task = callback().catch((reason) => {
      this.context.emit("internal/error", reason);
      this.cancel(reason);
    }).finally(() => {
      this.updateStatus(() => this.tasks.delete(task));
      this.context.events._tasks.delete(task);
    });
    this.updateStatus(() => this.tasks.add(task));
    this.context.events._tasks.add(task);
  }
  cancel(reason) {
    this.error = reason;
    this.updateStatus(() => this.hasError = true);
    this.reset();
  }
  get ready() {
    return this.runtime.using.every((name302) => !isNullable(this.ctx[name302]));
  }
  reset() {
    this.isActive = false;
    this.disposables = this.disposables.splice(0).filter((dispose) => {
      if (this.uid !== null && dispose[Context3.static] === this)
        return true;
      (async () => dispose())().catch((reason) => {
        this.context.emit("internal/error", reason);
      });
    });
  }
  init(error) {
    if (!this.config) {
      this.cancel(error);
    } else {
      this.start();
    }
  }
  start() {
    if (!this.ready || this.isActive || this.uid === null)
      return true;
    this.isActive = true;
    this.updateStatus(() => this.hasError = false);
  }
  accept(...args) {
    const keys = Array.isArray(args[0]) ? args.shift() : null;
    const acceptor = { keys, callback: args[0], ...args[1] };
    return this.effect(() => {
      this.acceptors.push(acceptor);
      if (acceptor.immediate)
        acceptor.callback?.(this.config);
      return () => remove(this.acceptors, acceptor);
    });
  }
  decline(keys) {
    return this.accept(keys, () => true);
  }
  checkUpdate(resolved, forced) {
    if (forced || !this.config)
      return [true, true];
    if (forced === false)
      return [false, false];
    const modified = Object.create(null);
    const checkPropertyUpdate = __name2((key) => {
      const result = modified[key] ??= !deepEqual3(this.config[key], resolved[key]);
      hasUpdate ||= result;
      return result;
    }, "checkPropertyUpdate");
    const ignored = new Set;
    let hasUpdate = false, shouldRestart = false;
    let fallback = this.runtime.isReactive || null;
    for (const { keys, callback, passive } of this.acceptors) {
      if (!keys) {
        fallback ||= !passive;
      } else if (passive) {
        keys?.forEach((key) => ignored.add(key));
      } else {
        let hasUpdate2 = false;
        for (const key of keys) {
          hasUpdate2 ||= checkPropertyUpdate(key);
        }
        if (!hasUpdate2)
          continue;
      }
      const result = callback?.(resolved);
      if (result)
        shouldRestart = true;
    }
    for (const key in { ...this.config, ...resolved }) {
      if (fallback === false)
        continue;
      if (!(key in modified) && !ignored.has(key)) {
        const hasUpdate2 = checkPropertyUpdate(key);
        if (fallback === null)
          shouldRestart ||= hasUpdate2;
      }
    }
    return [hasUpdate, shouldRestart];
  }
};
var ForkScope = class extends EffectScope {
  constructor(parent, runtime, config8, error) {
    super(parent, config8);
    this.runtime = runtime;
    this.dispose = defineProperty17(parent.scope.collect(`fork <${parent.runtime.name}>`, () => {
      this.uid = null;
      this.reset();
      this.context.emit("internal/fork", this);
      const result = remove(runtime.disposables, this.dispose);
      if (remove(runtime.children, this) && !runtime.children.length) {
        parent.registry.delete(runtime.plugin);
      }
      return result;
    }), Context3.static, runtime);
    runtime.children.push(this);
    runtime.disposables.push(this.dispose);
    this.context.emit("internal/fork", this);
    this.init(error);
  }
  static {
    __name2(this, "ForkScope");
  }
  dispose;
  start() {
    if (super.start())
      return true;
    for (const fork of this.runtime.forkables) {
      this.ensure(async () => fork(this.context, this._config));
    }
  }
  update(config8, forced) {
    const oldConfig = this.config;
    const state3 = this.runtime.isForkable ? this : this.runtime;
    if (state3.config !== oldConfig)
      return;
    const resolved = resolveConfig(this.runtime.plugin, config8);
    const [hasUpdate, shouldRestart] = state3.checkUpdate(resolved, forced);
    this.context.emit("internal/before-update", this, config8);
    this.config = resolved;
    state3.config = resolved;
    if (hasUpdate) {
      this.context.emit("internal/update", this, oldConfig);
    }
    if (shouldRestart)
      state3.restart();
  }
};
var MainScope = class extends EffectScope {
  constructor(registry, plugin3, config8, error) {
    super(registry[Context3.origin], config8);
    this.plugin = plugin3;
    registry.set(plugin3, this);
    if (!plugin3) {
      this.name = "root";
      this.isActive = true;
    } else {
      this.setup();
      this.init(error);
    }
  }
  static {
    __name2(this, "MainScope");
  }
  value;
  runtime = this;
  schema;
  name;
  using = [];
  inject = new Set;
  forkables = [];
  children = [];
  isReusable = false;
  isReactive = false;
  get isForkable() {
    return this.forkables.length > 0;
  }
  fork(parent, config8, error) {
    return new ForkScope(parent, this, config8, error);
  }
  dispose() {
    this.uid = null;
    this.reset();
    this.context.emit("internal/runtime", this);
    return true;
  }
  setInject(inject) {
    if (Array.isArray(inject)) {
      for (const name302 of inject) {
        this.using.push(name302);
        this.inject.add(name302);
      }
    } else if (inject) {
      for (const name302 of inject.required || []) {
        this.using.push(name302);
        this.inject.add(name302);
      }
      for (const name302 of inject.optional || []) {
        this.inject.add(name302);
      }
    }
  }
  setup() {
    const { name: name302 } = this.plugin;
    if (name302 && name302 !== "apply")
      this.name = name302;
    this.schema = this.plugin["Config"] || this.plugin["schema"];
    this.setInject(this.plugin["using"] || this.plugin["inject"]);
    this.isReusable = this.plugin["reusable"];
    this.isReactive = this.plugin["reactive"];
    this.context.emit("internal/runtime", this);
    if (this.isReusable) {
      this.forkables.push(this.apply);
    }
  }
  apply = (context2, config8) => {
    if (typeof this.plugin !== "function") {
      return this.plugin.apply(context2, config8);
    } else if (isConstructor(this.plugin)) {
      const instance = new this.plugin(context2, config8);
      const name302 = instance[Context3.expose];
      if (name302) {
        context2.set(name302, instance);
      }
      if (instance["fork"]) {
        this.forkables.push(instance["fork"].bind(instance));
      }
      return instance;
    } else {
      return this.plugin(context2, config8);
    }
  };
  reset() {
    super.reset();
    for (const fork of this.children) {
      fork.reset();
    }
  }
  start() {
    if (super.start())
      return true;
    if (!this.isReusable && this.plugin) {
      this.ensure(async () => this.value = this.apply(this.ctx, this._config));
    }
    for (const fork of this.children) {
      fork.start();
    }
  }
  update(config8, forced) {
    if (this.isForkable) {
      this.context.emit("internal/warning", new Error(`attempting to update forkable plugin "${this.plugin.name}", which may lead to unexpected behavior`));
    }
    const oldConfig = this.config;
    const resolved = resolveConfig(this.runtime.plugin || this.context.constructor, config8);
    const [hasUpdate, shouldRestart] = this.checkUpdate(resolved, forced);
    const state3 = this.children.find((fork) => fork.config === oldConfig);
    this.config = resolved;
    if (state3) {
      this.context.emit("internal/before-update", state3, config8);
      state3.config = resolved;
      if (hasUpdate) {
        this.context.emit("internal/update", state3, oldConfig);
      }
    }
    if (shouldRestart)
      this.restart();
  }
};
__name2(isApplicable, "isApplicable");
var Registry = class {
  constructor(root, config8) {
    this.root = root;
    defineProperty17(this, Context3.origin, root);
    root.scope = new MainScope(this, null, config8);
    root.scope.runtime.isReactive = true;
  }
  static {
    __name2(this, "Registry");
  }
  _counter = 0;
  _internal = new Map;
  get counter() {
    return ++this._counter;
  }
  get size() {
    return this._internal.size;
  }
  resolve(plugin3, assert = false) {
    if (plugin3 === null)
      return plugin3;
    if (typeof plugin3 === "function")
      return plugin3;
    if (isApplicable(plugin3))
      return plugin3.apply;
    if (assert)
      throw new Error('invalid plugin, expect function or object with an "apply" method, received ' + typeof plugin3);
  }
  get(plugin3) {
    const key = this.resolve(plugin3);
    return key && this._internal.get(key);
  }
  has(plugin3) {
    const key = this.resolve(plugin3);
    return !!key && this._internal.has(key);
  }
  set(plugin3, state3) {
    const key = this.resolve(plugin3);
    this._internal.set(key, state3);
  }
  delete(plugin3) {
    const key = this.resolve(plugin3);
    const runtime = key && this._internal.get(key);
    if (!runtime)
      return;
    this._internal.delete(key);
    runtime.dispose();
    return runtime;
  }
  keys() {
    return this._internal.keys();
  }
  values() {
    return this._internal.values();
  }
  entries() {
    return this._internal.entries();
  }
  forEach(callback) {
    return this._internal.forEach(callback);
  }
  using(inject, callback) {
    return this.inject(inject, callback);
  }
  inject(inject, callback) {
    return this.plugin({ inject, apply: callback, name: callback.name });
  }
  plugin(plugin3, config8) {
    this.resolve(plugin3, true);
    const context2 = this[Context3.origin];
    context2.scope.assertActive();
    let error;
    try {
      config8 = resolveConfig(plugin3, config8);
    } catch (reason) {
      context2.emit("internal/error", reason);
      error = reason;
      config8 = null;
    }
    let runtime = this.get(plugin3);
    if (runtime) {
      if (!runtime.isForkable) {
        context2.emit("internal/warning", new Error(`duplicate plugin detected: ${plugin3.name}`));
      }
      return runtime.fork(context2, config8, error);
    }
    runtime = new MainScope(this, plugin3, config8, error);
    return runtime.fork(context2, config8, error);
  }
};
var Context3 = class _Context {
  static {
    __name2(this, "Context");
  }
  static origin = symbols.origin;
  static events = symbols.events;
  static static = symbols.static;
  static filter = symbols.filter;
  static expose = symbols.expose;
  static isolate = symbols.isolate;
  static internal = symbols.internal;
  static intercept = symbols.intercept;
  static current = _Context.origin;
  static is(value) {
    return !!value?.[_Context.is];
  }
  static {
    _Context.is[Symbol.toPrimitive] = () => Symbol.for("cordis.is");
    _Context.prototype[_Context.is] = true;
  }
  static ensureInternal() {
    const ctx = this.prototype || this;
    if (Object.prototype.hasOwnProperty.call(ctx, symbols.internal)) {
      return ctx[symbols.internal];
    }
    const parent = _Context.ensureInternal.call(Object.getPrototypeOf(this));
    return ctx[symbols.internal] = Object.create(parent);
  }
  static resolveInject(ctx, name302) {
    let internal = ctx[symbols.internal][name302];
    while (internal?.type === "alias") {
      name302 = internal.name;
      internal = ctx[symbols.internal][name302];
    }
    return [name302, internal];
  }
  static handler = {
    get(target, prop, ctx) {
      if (typeof prop !== "string")
        return Reflect.get(target, prop, ctx);
      const checkInject = __name2((name2100) => {
        if (Reflect.has(target, name2100))
          return;
        if (["prototype", "then", "registry", "lifecycle"].includes(name2100))
          return;
        if (name2100[0] === "$" || name2100[0] === "_")
          return;
        if (!ctx.runtime.plugin)
          return;
        if (ctx.bail("internal/inject", name2100))
          return;
        ctx.emit("internal/warning", new Error(`property ${name2100} is not registered, declare it as \`inject\` to suppress this warning`));
      }, "checkInject");
      const [name302, internal] = _Context.resolveInject(ctx, prop);
      if (!internal) {
        checkInject(name302);
        return Reflect.get(target, name302, ctx);
      } else if (internal.type === "accessor") {
        return internal.get.call(ctx);
      } else {
        if (!internal.builtin)
          checkInject(name302);
        return ctx.get(name302);
      }
    },
    set(target, prop, value, ctx) {
      if (typeof prop !== "string")
        return Reflect.set(target, prop, value, ctx);
      const [name302, internal] = _Context.resolveInject(ctx, prop);
      if (!internal)
        return Reflect.set(target, name302, value, ctx);
      if (internal.type === "accessor") {
        if (!internal.set)
          return false;
        return internal.set.call(ctx, value);
      } else {
        ctx.set(name302, value);
        return true;
      }
    }
  };
  static associate(object36, name302) {
    return new Proxy(object36, {
      get(target, key, receiver) {
        if (typeof key === "symbol")
          return Reflect.get(target, key, receiver);
        const caller = receiver[symbols.origin];
        if (!caller?.[symbols.internal][`${name302}.${key}`])
          return Reflect.get(target, key, receiver);
        return caller[`${name302}.${key}`];
      },
      set(target, key, value, receiver) {
        if (typeof key === "symbol")
          return Reflect.set(target, key, value, receiver);
        const caller = receiver[symbols.origin];
        if (!caller?.[symbols.internal][`${name302}.${key}`])
          return Reflect.set(target, key, value, receiver);
        caller[`${name302}.${key}`] = value;
        return true;
      }
    });
  }
  constructor(config8) {
    const self2 = new Proxy(this, _Context.handler);
    config8 = resolveConfig(this.constructor, config8);
    self2[symbols.isolate] = Object.create(null);
    self2[symbols.intercept] = Object.create(null);
    self2.root = self2;
    self2.mixin("scope", ["config", "runtime", "effect", "collect", "accept", "decline"]);
    self2.mixin("registry", ["using", "inject", "plugin", "dispose"]);
    self2.mixin("lifecycle", ["on", "once", "off", "after", "parallel", "emit", "serial", "bail", "start", "stop"]);
    self2.provide("registry", new Registry(self2, config8), true);
    self2.provide("lifecycle", new Lifecycle(self2), true);
    const attach = __name2((internal) => {
      if (!internal)
        return;
      attach(Object.getPrototypeOf(internal));
      for (const key of Object.getOwnPropertyNames(internal)) {
        const constructor = internal[key]["prototype"]?.constructor;
        if (!constructor)
          continue;
        self2[internal[key]["key"]] = new constructor(self2, config8);
        defineProperty17(self2[internal[key]["key"]], symbols.origin, self2);
      }
    }, "attach");
    attach(this[symbols.internal]);
    return self2;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Context <${this.name}>`;
  }
  get name() {
    let runtime = this.runtime;
    while (runtime && !runtime.name) {
      runtime = runtime.parent.runtime;
    }
    return runtime?.name;
  }
  get events() {
    return this.lifecycle;
  }
  get state() {
    return this.scope;
  }
  get(name302) {
    const internal = this[symbols.internal][name302];
    if (internal?.type !== "service")
      return;
    const value = this.root[this[symbols.isolate][name302]];
    if (!value || typeof value !== "object" && typeof value !== "function")
      return value;
    if (isUnproxyable(value)) {
      defineProperty17(value, symbols.origin, this);
      return value;
    }
    return createTraceable(this, value);
  }
  set(name302, value) {
    this.provide(name302);
    const key = this[symbols.isolate][name302];
    const oldValue = this.root[key];
    value ??= undefined;
    let dispose = __name2(() => {
    }, "dispose");
    if (oldValue === value)
      return dispose;
    if (!isNullable(value) && !isNullable(oldValue)) {
      throw new Error(`service ${name302} has been registered`);
    }
    const ctx = this;
    if (!isNullable(value)) {
      dispose = ctx.effect(() => () => {
        ctx.set(name302, undefined);
      });
    }
    if (isUnproxyable(value)) {
      ctx.emit("internal/warning", new Error(`service ${name302} is an unproxyable object, which may lead to unexpected behavior`));
    }
    const self2 = Object.create(ctx);
    self2[symbols.filter] = (ctx2) => {
      return ctx[symbols.isolate][name302] === ctx2[symbols.isolate][name302];
    };
    ctx.emit(self2, "internal/before-service", name302, value);
    ctx.root[key] = value;
    if (value instanceof Object) {
      defineProperty17(value, symbols.origin, ctx);
    }
    ctx.emit(self2, "internal/service", name302, oldValue);
    return dispose;
  }
  provide(name302, value, builtin) {
    const internal = _Context.ensureInternal.call(this.root);
    if (name302 in internal)
      return;
    const key = Symbol(name302);
    internal[name302] = { type: "service", builtin };
    this.root[key] = value;
    this.root[_Context.isolate][name302] = key;
  }
  accessor(name302, options) {
    const internal = _Context.ensureInternal.call(this.root);
    internal[name302] ||= { type: "accessor", ...options };
  }
  alias(name302, aliases) {
    const internal = _Context.ensureInternal.call(this.root);
    for (const key of aliases) {
      internal[key] ||= { type: "alias", name: name302 };
    }
  }
  mixin(name302, mixins) {
    const entries = Array.isArray(mixins) ? mixins.map((key) => [key, key]) : Object.entries(mixins);
    for (const [key, value] of entries) {
      this.accessor(value, {
        get() {
          const service = this[name302];
          if (isNullable(service))
            return service;
          const value2 = Reflect.get(service, key);
          if (typeof value2 !== "function")
            return value2;
          return value2.bind(service);
        },
        set(value2) {
          return Reflect.set(this[name302], key, value2);
        }
      });
    }
  }
  extend(meta = {}) {
    return Object.assign(Object.create(this), meta);
  }
  isolate(name302, label) {
    const shadow = Object.create(this[symbols.isolate]);
    shadow[name302] = label ?? Symbol(name302);
    return this.extend({ [symbols.isolate]: shadow });
  }
  intercept(name302, config8) {
    const intercept = Object.create(this[symbols.intercept]);
    intercept[name302] = config8;
    return this.extend({ [symbols.intercept]: intercept });
  }
};
Context3.prototype[Context3.internal] = Object.create(null);
var Service2 = class _Service {
  static {
    __name2(this, "Service");
  }
  static setup = symbols.setup;
  static invoke = symbols.invoke;
  static extend = symbols.extend;
  static provide = symbols.provide;
  static immediate = symbols.immediate;
  start() {
  }
  stop() {
  }
  ctx;
  [symbols.origin];
  name;
  config;
  constructor(...args) {
    let _ctx, name302, immediate, config8;
    if (Context3.is(args[0])) {
      _ctx = args[0];
      if (typeof args[1] === "string") {
        name302 = args[1];
        immediate = args[2];
      } else {
        config8 = args[1];
      }
    } else {
      config8 = args[0];
    }
    name302 ??= this.constructor[symbols.provide];
    immediate ??= this.constructor[symbols.immediate];
    let self2 = this;
    if (self2[symbols.invoke]) {
      self2 = createCallable(name302, joinPrototype(Object.getPrototypeOf(this), Function.prototype));
    }
    if (_ctx) {
      self2.ctx = _ctx;
    } else {
      self2[symbols.setup]();
    }
    self2.name = name302;
    self2.config = config8;
    defineProperty17(self2, symbols.origin, self2.ctx);
    self2.ctx.provide(name302);
    self2.ctx.runtime.name = name302;
    if (immediate) {
      if (_ctx)
        self2[symbols.expose] = name302;
      else
        self2.ctx.set(name302, self2);
    }
    self2.ctx.on("ready", async () => {
      await Promise.resolve();
      await self2.start();
      if (!immediate)
        self2.ctx.set(name302, self2);
    });
    self2.ctx.on("dispose", () => self2.stop());
    return Context3.associate(self2, name302);
  }
  [symbols.filter](ctx) {
    return ctx[symbols.isolate][this.name] === this.ctx[symbols.isolate][this.name];
  }
  [symbols.setup]() {
    this.ctx = new Context3;
  }
  [symbols.extend](props) {
    const caller = this[symbols.origin];
    let self2;
    if (this[_Service.invoke]) {
      self2 = createCallable(this.name, this);
    } else {
      self2 = Object.create(this);
    }
    defineProperty17(self2, symbols.origin, caller);
    return Context3.associate(Object.assign(self2, props), this.name);
  }
  static [Symbol.hasInstance](instance) {
    let constructor = instance.constructor;
    while (constructor) {
      if (constructor === this)
        return true;
      constructor = Object.getPrototypeOf(constructor);
    }
    return false;
  }
};

// ../../node_modules/@cordisjs/logger/lib/index.mjs
var import_reggol = __toESM(require_node(), 1);
var __defProp4 = Object.defineProperty;
var __name3 = (target, value) => __defProp4(target, "name", { value, configurable: true });
var LoggerService = class _LoggerService extends Service2 {
  static {
    __name3(this, "LoggerService");
  }
  static [Service2.provide] = "logger";
  constructor(ctx) {
    super(ctx, "logger", true);
    ctx.on("internal/info", function(format6, ...args) {
      this.logger("app").info(format6, ...args);
    });
    ctx.on("internal/error", function(format6, ...args) {
      this.logger("app").error(format6, ...args);
    });
    ctx.on("internal/warning", function(format6, ...args) {
      this.logger("app").warn(format6, ...args);
    });
  }
  [Service2.invoke](name302) {
    return new import_reggol.default(name302, { [Context3.current]: this });
  }
  static {
    for (const type of ["success", "error", "info", "warn", "debug", "extend"]) {
      _LoggerService.prototype[type] = function(...args) {
        const caller = this[Context3.current];
        return this(caller.name)[type](...args);
      };
    }
  }
};

// ../../node_modules/@cordisjs/timer/lib/index.mjs
var import_cosmokit7 = __toESM(require_lib5(), 1);
var __defProp5 = Object.defineProperty;
var __name4 = (target, value) => __defProp5(target, "name", { value, configurable: true });
var TimerService2 = class extends Service2 {
  static {
    __name4(this, "TimerService");
  }
  constructor(ctx) {
    super(ctx, "timer", true);
    ctx.mixin("timer", ["setTimeout", "setInterval", "sleep", "throttle", "debounce"]);
  }
  setTimeout(callback, delay) {
    const dispose = this[Context3.current].effect(() => {
      const timer = setTimeout(() => {
        dispose();
        callback();
      }, delay);
      return () => clearTimeout(timer);
    });
    return dispose;
  }
  setInterval(callback, delay) {
    return this[Context3.current].effect(() => {
      const timer = setInterval(callback, delay);
      return () => clearInterval(timer);
    });
  }
  sleep(delay) {
    const caller = this[Context3.current];
    return new Promise((resolve4, reject2) => {
      const dispose1 = this.setTimeout(() => {
        dispose1();
        dispose2();
        resolve4();
      }, delay);
      const dispose2 = caller.on("dispose", () => {
        dispose1();
        dispose2();
        reject2(new Error("Context has been disposed"));
      });
    });
  }
  createWrapper(callback, isDisposed = false) {
    const caller = this[Context3.current];
    caller.scope.assertActive();
    let timer;
    const dispose = __name4(() => {
      isDisposed = true;
      import_cosmokit7.remove(caller.scope.disposables, dispose);
      clearTimeout(timer);
    }, "dispose");
    const wrapper = __name4((...args) => {
      clearTimeout(timer);
      timer = callback(args, () => !isDisposed && caller.scope.isActive);
    }, "wrapper");
    wrapper.dispose = dispose;
    caller.scope.disposables.push(dispose);
    return wrapper;
  }
  throttle(callback, delay, noTrailing) {
    let lastCall = -Infinity;
    const execute = __name4((...args) => {
      lastCall = Date.now();
      callback(...args);
    }, "execute");
    return this.createWrapper((args, isActive) => {
      const now = Date.now();
      const remaining = delay - (now - lastCall);
      if (remaining <= 0) {
        execute(...args);
      } else if (isActive()) {
        return setTimeout(execute, remaining, ...args);
      }
    }, noTrailing);
  }
  debounce(callback, delay) {
    return this.createWrapper((args, isActive) => {
      if (!isActive())
        return;
      return setTimeout(callback, delay, ...args);
    });
  }
};

// ../../node_modules/cordis/lib/index.mjs
var import_schemastery = __toESM(require_lib7(), 1);
var src_default = function() {
};
var __defProp6 = Object.defineProperty;
var __name5 = (target, value) => __defProp6(target, "name", { value, configurable: true });
var Context22 = class extends Context3 {
  static {
    __name5(this, "Context");
  }
  baseDir;
  constructor(config8) {
    super(config8);
    this.baseDir = globalThis.process?.cwd() || "";
    this.provide("logger", undefined, true);
    this.provide("timer", undefined, true);
    this.plugin(LoggerService);
    this.plugin(TimerService2);
  }
};
var Service22 = class extends Service2 {
  static {
    __name5(this, "Service");
  }
  logger;
  constructor(...args) {
    super(...args);
    this.logger = this.ctx.logger(this.name);
  }
  [Service2.setup]() {
    this.ctx = new Context22;
  }
};
__name5(src_default, "default");

// ../../node_modules/@cordisjs/plugin-http/lib/adapter/node.js
var import_file_type = __toESM(require_file_type(), 1);
import {fileURLToPath} from "node:url";
import {basename} from "node:path";
import {readFile} from "node:fs/promises";
import {lookup as lookup3} from "node:dns/promises";

// ../../node_modules/ws/wrapper.mjs
var stream2 = __toESM(require_stream(), 1);
var receiver = __toESM(require_receiver(), 1);
var sender = __toESM(require_sender(), 1);
var websocket = __toESM(require_websocket(), 1);
var websocket_server = __toESM(require_websocket_server(), 1);

// ../../node_modules/@cordisjs/plugin-http/lib/adapter/node.js
async function loadFile(url) {
  if (url.startsWith("file://")) {
    const data2 = await readFile(fileURLToPath(url));
    const result = await import_file_type.default.fromBuffer(data2);
    return {
      type: result?.mime,
      mime: result?.mime,
      filename: basename(url),
      data: Binary.fromSource(data2)
    };
  }
}
var __defProp7 = Object.defineProperty;
var __name6 = (target, value) => __defProp7(target, "name", { value, configurable: true });
__name6(loadFile, "loadFile");

// ../../node_modules/@cordisjs/plugin-http/lib/index.js
var import_mime_db = __toESM(require_mime_db(), 1);
var parseIPv4 = function(ip) {
  return ip.split(".").reduce((a, b) => (a << 8n) + BigInt(b), 0n);
};
var parseIPv6 = function(ip) {
  const exp4 = ip.indexOf("::");
  let num = 0n;
  if (exp4 !== -1 && exp4 !== 0) {
    ip.slice(0, exp4).split(":").forEach((piece, i3) => {
      num |= BigInt(`0x${piece}`) << BigInt((7 - i3) * 16);
    });
  }
  if (exp4 === ip.length - 2) {
    return num;
  }
  const rest = exp4 === -1 ? ip : ip.slice(exp4 + 2);
  const v4 = rest.includes(".");
  const pieces = rest.split(":");
  let start = 0;
  if (v4) {
    start += 2;
    const [addr] = pieces.splice(-1, 1);
    num |= parseIPv4(addr);
  }
  pieces.reverse().forEach((piece, i3) => {
    num |= BigInt(`0x${piece}`) << BigInt((start + i3) * 8);
  });
  return num;
};
async function isLocalAddress({ address, family }) {
  if (family !== 4 && family !== 6)
    return false;
  const { bogons, length, parse: parse4 } = family === 4 ? { bogons: bogonV4, length: 32, parse: parseIPv4 } : { bogons: bogonV6, length: 128, parse: parseIPv6 };
  const num = parse4(address);
  for (const bogon of bogons) {
    const [prefix, cidr] = bogon.split("/");
    const mask = (1n << BigInt(cidr)) - 1n << BigInt(length - +cidr);
    if ((num & mask) === parse4(prefix))
      return true;
  }
  return false;
}
var encodeRequest = function(data2) {
  if (data2 instanceof URLSearchParams)
    return [null, data2];
  if (data2 instanceof ArrayBuffer)
    return [null, data2];
  if (ArrayBuffer.isView(data2))
    return [null, data2];
  if (data2 instanceof Blob)
    return [null, data2];
  if (data2 instanceof FormData)
    return [null, data2];
  return ["application/json", JSON.stringify(data2)];
};
var __defProp8 = Object.defineProperty;
var __name7 = (target, value) => __defProp8(target, "name", { value, configurable: true });
var bogonV4 = [
  "0.0.0.0/8",
  "10.0.0.0/8",
  "100.64.0.0/10",
  "127.0.0.0/8",
  "169.254.0.0/16",
  "172.16.0.0/12",
  "192.0.2.0/24",
  "192.88.99.0/24",
  "192.168.0.0/16",
  "198.18.0.0/15",
  "198.51.100.0/24",
  "203.0.113.0/24",
  "224.0.0.0/4",
  "240.0.0.0/4"
];
var bogonV6 = [
  "::/8",
  "0100::/64",
  "2001:2::/48",
  "2001:10::/28",
  "2001:db8::/32",
  "2002::/16",
  "3ffe::/16",
  "fc00::/7",
  "fe80::/10",
  "fec0::/10",
  "ff00::/8"
];
__name7(parseIPv4, "parseIPv4");
__name7(parseIPv6, "parseIPv6");
__name7(isLocalAddress, "isLocalAddress");
var kHTTPError = Symbol.for("cordis.http.error");
var HTTPError = class extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
  static {
    __name7(this, "HTTPError");
  }
  [kHTTPError] = true;
  response;
  static is(error) {
    return !!error?.[kHTTPError];
  }
};
__name7(encodeRequest, "encodeRequest");
var HTTP2 = class _HTTP extends Service22 {
  static {
    __name7(this, "HTTP");
  }
  static Error = HTTPError;
  static isAxiosError = HTTPError.is;
  static [Service22.provide] = "http";
  static [Service22.immediate] = true;
  static {
    for (const method of ["get", "delete"]) {
      defineProperty17(_HTTP.prototype, method, async function(url, config8) {
        const response = await this(url, { method, ...config8 });
        return response.data;
      });
    }
    for (const method of ["patch", "post", "put"]) {
      defineProperty17(_HTTP.prototype, method, async function(url, data2, config8) {
        const response = await this(url, { method, data: data2, ...config8 });
        return response.data;
      });
    }
  }
  isError = HTTPError.is;
  _decoders = Object.create(null);
  constructor(...args) {
    super(args[0], args[1]);
    this.decoder("json", (raw) => raw.json());
    this.decoder("text", (raw) => raw.text());
    this.decoder("blob", (raw) => raw.blob());
    this.decoder("arraybuffer", (raw) => raw.arrayBuffer());
    this.decoder("formdata", (raw) => raw.formData());
    this.decoder("stream", (raw) => raw.body);
    this.ctx.on("http/file", (url, options) => loadFile(url));
  }
  static mergeConfig = (target, source) => ({
    ...target,
    ...source,
    headers: {
      ...target?.headers,
      ...source?.headers
    }
  });
  decoder(type, decoder) {
    return this[Context22.origin].effect(() => {
      this._decoders[type] = decoder;
      return () => delete this._decoders[type];
    });
  }
  extend(config8 = {}) {
    return this[Service22.extend]({
      config: _HTTP.mergeConfig(this.config, config8)
    });
  }
  resolveConfig(init) {
    const caller = this[Context22.origin];
    let result = { headers: {}, ...this.config };
    caller.emit(this, "http/config", result);
    let intercept = caller[Context22.intercept];
    while (intercept) {
      result = _HTTP.mergeConfig(result, intercept.http);
      intercept = Object.getPrototypeOf(intercept);
    }
    result = _HTTP.mergeConfig(result, init);
    return result;
  }
  resolveURL(url, config8, isWebSocket = false) {
    if (config8.endpoint) {
      try {
        new URL(url);
      } catch {
        url = trimSlash(config8.endpoint) + url;
      }
    }
    try {
      url = new URL(url, config8.baseURL);
    } catch (error) {
      throw new TypeError(`Invalid URL: ${url}`);
    }
    if (isWebSocket)
      url.protocol = url.protocol.replace(/^http/, "ws");
    for (const [key, value] of Object.entries(config8.params ?? {})) {
      if (isNullable(value))
        continue;
      url.searchParams.append(key, value);
    }
    return url;
  }
  defaultDecoder(response) {
    const type = response.headers.get("Content-Type");
    if (type?.startsWith("application/json")) {
      return response.json();
    } else if (type?.startsWith("text/")) {
      return response.text();
    } else {
      return response.arrayBuffer();
    }
  }
  async[Service22.invoke](...args) {
    const caller = this[Context22.origin];
    let method;
    if (typeof args[1] === "string" || args[1] instanceof URL) {
      method = args.shift();
    }
    const config8 = this.resolveConfig(args[1]);
    const url = this.resolveURL(args[0], config8);
    method ??= config8.method ?? "GET";
    const controller = new AbortController;
    if (config8.signal) {
      if (config8.signal.aborted) {
        throw config8.signal.reason;
      }
      config8.signal.addEventListener("abort", () => {
        controller.abort(config8.signal.reason);
      });
    }
    const dispose = caller.effect(() => {
      const timer3 = config8.timeout && setTimeout(() => {
        controller.abort(new HTTPError("request timeout", "ETIMEDOUT"));
      }, config8.timeout);
      return (done) => {
        clearTimeout(timer3);
        if (done)
          return;
        controller.abort(new HTTPError("context disposed", "ETIMEDOUT"));
      };
    });
    controller.signal.addEventListener("abort", () => dispose());
    try {
      const headers = new Headers(config8.headers);
      const init = {
        method,
        headers,
        body: config8.data,
        keepalive: config8.keepAlive,
        redirect: config8.redirect,
        signal: controller.signal
      };
      if (config8.data && typeof config8.data === "object") {
        const [type, body] = encodeRequest(config8.data);
        init.body = body;
        if (type && !headers.has("Content-Type")) {
          headers.append("Content-Type", type);
        }
      }
      caller.emit(this, "http/fetch-init", url, init, config8);
      const raw = await fetch(url, init).catch((cause) => {
        if (_HTTP.Error.is(cause))
          throw cause;
        const error = new _HTTP.Error(`fetch ${url} failed`);
        error.cause = cause;
        throw error;
      });
      const response = {
        data: null,
        url: raw.url,
        status: raw.status,
        statusText: raw.statusText,
        headers: raw.headers
      };
      const validateStatus = config8.validateStatus ?? ((status) => status < 400);
      if (!validateStatus(raw.status)) {
        const error = new _HTTP.Error(raw.statusText);
        error.response = response;
        try {
          response.data = await this.defaultDecoder(raw);
        } catch {
        }
        throw error;
      }
      if (config8.responseType) {
        if (!(config8.responseType in this._decoders)) {
          throw new TypeError(`Unknown responseType: ${config8.responseType}`);
        }
        const decoder = this._decoders[config8.responseType];
        response.data = await decoder(raw);
      } else {
        response.data = await this.defaultDecoder(raw);
      }
      return response;
    } finally {
      dispose(true);
    }
  }
  async head(url, config8) {
    const response = await this(url, { method: "HEAD", ...config8 });
    return response.headers;
  }
  axios(...args) {
    const caller = this[Context22.origin];
    caller.emit("internal/warning", "ctx.http.axios() is deprecated, use ctx.http() instead");
    if (typeof args[0] === "string") {
      return this(args[0], args[1]);
    } else {
      return this(args[0].url, args[0]);
    }
  }
  ws(url, init) {
    const caller = this[Context22.origin];
    const config8 = this.resolveConfig(init);
    url = this.resolveURL(url, config8, true);
    let options;
    if (websocket.default !== globalThis.WebSocket) {
      options = {
        handshakeTimeout: config8?.timeout,
        headers: config8?.headers
      };
      caller.emit(this, "http/websocket-init", url, options, config8);
    }
    const socket = new websocket.default(url, options);
    const dispose = caller.on("dispose", () => {
      socket.close(1000, "context disposed");
    });
    socket.addEventListener("close", () => {
      dispose();
    });
    return socket;
  }
  async file(url, options = {}) {
    const task = await this[Context22.origin].serial(this, "http/file", url, options);
    if (task)
      return task;
    const capture = /^data:([\w/-]+);base64,(.*)$/.exec(url);
    if (capture) {
      const [, type2, base64] = capture;
      let name2100 = "file";
      const ext = type2 && import_mime_db.default[type2]?.extensions?.[0];
      if (ext)
        name2100 += `.${ext}`;
      return { type: type2, mime: type2, data: Binary.fromBase64(base64), filename: name2100 };
    }
    const { headers, data: data2, url: responseUrl } = await this(url, {
      method: "GET",
      responseType: "arraybuffer",
      timeout: +options.timeout || undefined
    });
    const type = headers.get("content-type");
    const [, name302] = responseUrl.match(/.+\/([^/?]*)(?=\?)?/);
    return { type, mime: type, filename: name302, data: data2 };
  }
  async isLocal(url) {
    let { hostname, protocol } = new URL(url);
    if (protocol !== "http:" && protocol !== "https:")
      return true;
    if (/^\[.+\]$/.test(hostname)) {
      hostname = hostname.slice(1, -1);
    }
    try {
      const address = await lookup3(hostname);
      return isLocalAddress(address);
    } catch {
      return false;
    }
  }
};

// ../../node_modules/@satorijs/element/lib/index.mjs
var __defProp9 = Object.defineProperty;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __name8 = (target, value) => __defProp9(target, "name", { value, configurable: true });
var __commonJS2 = (cb, mod4) => function __require() {
  return mod4 || (0, cb[__getOwnPropNames2(cb)[0]])((mod4 = { exports: {} }).exports, mod4), mod4.exports;
};
var require_src = __commonJS2({
  "src/index.ts"(exports, module) {
    var kElement = Symbol.for("satori.element");
    var ElementConstructor = class {
      static {
        __name8(this, "ElementConstructor");
      }
      get data() {
        return this.attrs;
      }
      getTagName() {
        if (this.type === "component") {
          return this.attrs.is?.name ?? "component";
        } else {
          return this.type;
        }
      }
      toAttrString() {
        return Object.entries(this.attrs).map(([key, value]) => {
          if (isNullable(value))
            return "";
          key = hyphenate(key);
          if (value === true)
            return ` ${key}`;
          if (value === false)
            return ` no-${key}`;
          return ` ${key}="${Element2.escape("" + value, true)}"`;
        }).join("");
      }
      toString(strip = false) {
        if (this.type === "text" && "content" in this.attrs) {
          return strip ? this.attrs.content : Element2.escape(this.attrs.content);
        }
        const inner = this.children.map((child) => child.toString(strip)).join("");
        if (strip)
          return inner;
        const attrs = this.toAttrString();
        const tag2 = this.getTagName();
        if (!this.children.length)
          return `<${tag2}${attrs}/>`;
        return `<${tag2}${attrs}>${inner}</${tag2}>`;
      }
    };
    defineProperty17(ElementConstructor, "name", "Element");
    defineProperty17(ElementConstructor.prototype, kElement, true);
    function Element2(type, ...args) {
      const el = Object.create(ElementConstructor.prototype);
      const attrs = {}, children = [];
      if (args[0] && typeof args[0] === "object" && !Element2.isElement(args[0]) && !Array.isArray(args[0])) {
        const props = args.shift();
        for (const [key, value] of Object.entries(props)) {
          if (isNullable(value))
            continue;
          if (key === "children") {
            args.push(...makeArray(value));
          } else {
            attrs[camelize(key)] = value;
          }
        }
      }
      for (const child of args) {
        children.push(...Element2.toElementArray(child));
      }
      if (typeof type === "function") {
        attrs.is = type;
        type = "component";
      }
      return Object.assign(el, { type, attrs, children });
    }
    __name8(Element2, "Element");
    var evaluate4 = new Function("expr", "context", `
  try {
    with (context) {
      return eval(expr)
    }
  } catch {}
`);
    ((Element22) => {
      Element22.jsx = Element22;
      Element22.jsxs = Element22;
      Element22.jsxDEV = Element22;
      Element22.Fragment = "template";
      function isElement(source) {
        return source && typeof source === "object" && source[kElement];
      }
      Element22.isElement = isElement;
      __name8(isElement, "isElement");
      function toElement(content) {
        if (typeof content === "string" || typeof content === "number" || typeof content === "boolean") {
          content = "" + content;
          if (content)
            return Element22("text", { content });
        } else if (isElement(content)) {
          return content;
        } else if (!isNullable(content)) {
          throw new TypeError(`Invalid content: ${content}`);
        }
      }
      Element22.toElement = toElement;
      __name8(toElement, "toElement");
      function toElementArray(content) {
        if (Array.isArray(content)) {
          return content.map(toElement).filter((x) => x);
        } else {
          return [toElement(content)].filter((x) => x);
        }
      }
      Element22.toElementArray = toElementArray;
      __name8(toElementArray, "toElementArray");
      function normalize(source, context2) {
        return typeof source === "string" ? parse4(source, context2) : toElementArray(source);
      }
      Element22.normalize = normalize;
      __name8(normalize, "normalize");
      function escape2(source, inline3 = false) {
        const result = (source ?? "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        return inline3 ? result.replace(/"/g, "&quot;") : result;
      }
      Element22.escape = escape2;
      __name8(escape2, "escape");
      function unescape(source) {
        return source.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#(\d+);/g, (_2, code) => code === "38" ? _2 : String.fromCharCode(+code)).replace(/&#x([0-9a-f]+);/gi, (_2, code) => code === "26" ? _2 : String.fromCharCode(parseInt(code, 16))).replace(/&(amp|#38|#x26);/g, "&");
      }
      Element22.unescape = unescape;
      __name8(unescape, "unescape");
      function from(source, options = {}) {
        const elements = parse4(source);
        if (options.caret) {
          if (options.type && elements[0]?.type !== options.type)
            return;
          return elements[0];
        }
        return select(elements, options.type || "*")[0];
      }
      Element22.from = from;
      __name8(from, "from");
      const combRegExp = / *([ >+~]) */g;
      function parseSelector(input) {
        return input.split(",").map((query) => {
          const selectors = [];
          query = query.trim();
          let combCap, combinator = " ";
          while (combCap = combRegExp.exec(query)) {
            selectors.push({ type: query.slice(0, combCap.index), combinator });
            combinator = combCap[1];
            query = query.slice(combCap.index + combCap[0].length);
          }
          selectors.push({ type: query, combinator });
          return selectors;
        });
      }
      Element22.parseSelector = parseSelector;
      __name8(parseSelector, "parseSelector");
      function select(source, query) {
        if (!source || !query)
          return [];
        if (typeof source === "string")
          source = parse4(source);
        if (typeof query === "string")
          query = parseSelector(query);
        if (!query.length)
          return [];
        let adjacent = [];
        const results = [];
        for (const [index2, element] of source.entries()) {
          const inner = [];
          const local = [...query, ...adjacent];
          adjacent = [];
          let matched = false;
          for (const group of local) {
            const { type, combinator } = group[0];
            if (type === element.type || type === "*") {
              if (group.length === 1) {
                matched = true;
              } else if ([" ", ">"].includes(group[1].combinator)) {
                inner.push(group.slice(1));
              } else if (group[1].combinator === "+") {
                adjacent.push(group.slice(1));
              } else {
                query.push(group.slice(1));
              }
            }
            if (combinator === " ") {
              inner.push(group);
            }
          }
          if (matched)
            results.push(source[index2]);
          results.push(...select(element.children, inner));
        }
        return results;
      }
      Element22.select = select;
      __name8(select, "select");
      function interpolate(expr, context2) {
        expr = expr.trim();
        if (!/^[\w.]+$/.test(expr)) {
          return evaluate4(expr, context2) ?? "";
        }
        let value = context2;
        for (const part of expr.split(".")) {
          value = value[part];
          if (isNullable(value))
            return "";
        }
        return value ?? "";
      }
      Element22.interpolate = interpolate;
      __name8(interpolate, "interpolate");
      const tagRegExp1 = /(?<comment><!--[\s\S]*?-->)|(?<tag><(\/?)([^!\s>/]*)([^>]*?)\s*(\/?)>)/;
      const tagRegExp2 = /(?<comment><!--[\s\S]*?-->)|(?<tag><(\/?)([^!\s>/]*)([^>]*?)\s*(\/?)>)|(?<curly>\{(?<derivative>[@:/#][^\s}]*)?[\s\S]*?\})/;
      const attrRegExp1 = /([^\s=]+)(?:="(?<value1>[^"]*)"|='(?<value2>[^']*)')?/g;
      const attrRegExp2 = /([^\s=]+)(?:="(?<value1>[^"]*)"|='(?<value2>[^']*)'|=\{(?<curly>[^}]+)\})?/g;
      let Position;
      ((Position2) => {
        Position2[Position2["OPEN"] = 0] = "OPEN";
        Position2[Position2["CLOSE"] = 1] = "CLOSE";
        Position2[Position2["EMPTY"] = 2] = "EMPTY";
        Position2[Position2["CONTINUE"] = 3] = "CONTINUE";
      })(Position || (Position = {}));
      function parse4(source, context2) {
        const tokens = [];
        function pushText(content) {
          if (content)
            tokens.push(content);
        }
        __name8(pushText, "pushText");
        const tagRegExp = context2 ? tagRegExp2 : tagRegExp1;
        let tagCap;
        let trimStart = true;
        while (tagCap = tagRegExp.exec(source)) {
          const trimEnd = !tagCap.groups.curly;
          parseContent(source.slice(0, tagCap.index), trimStart, trimEnd);
          trimStart = trimEnd;
          source = source.slice(tagCap.index + tagCap[0].length);
          const [_2, , , close, type, extra, empty] = tagCap;
          if (tagCap.groups.comment)
            continue;
          if (tagCap.groups.curly) {
            let name302 = "", position = 2;
            if (tagCap.groups.derivative) {
              name302 = tagCap.groups.derivative.slice(1);
              position = {
                "@": 2,
                "#": 0,
                "/": 1,
                ":": 3
              }[tagCap.groups.derivative[0]];
            }
            tokens.push({
              type: "curly",
              name: name302,
              position,
              source: tagCap.groups.curly,
              extra: tagCap.groups.curly.slice(1 + (tagCap.groups.derivative ?? "").length, -1)
            });
            continue;
          }
          tokens.push({
            type: "angle",
            source: _2,
            name: type || Element22.Fragment,
            position: close ? 1 : empty ? 2 : 0,
            extra
          });
        }
        parseContent(source, trimStart, true);
        function parseContent(source2, trimStart2, trimEnd) {
          source2 = unescape(source2);
          if (trimStart2)
            source2 = source2.replace(/^\s*\n\s*/, "");
          if (trimEnd)
            source2 = source2.replace(/\s*\n\s*$/, "");
          pushText(source2);
        }
        __name8(parseContent, "parseContent");
        return parseTokens(foldTokens(tokens), context2);
      }
      Element22.parse = parse4;
      __name8(parse4, "parse");
      function foldTokens(tokens) {
        const stack = [[{
          type: "angle",
          name: Element22.Fragment,
          position: 0,
          source: "",
          extra: "",
          children: { default: [] }
        }, "default"]];
        function pushToken(...tokens2) {
          const [token, slot] = stack[0];
          token.children[slot].push(...tokens2);
        }
        __name8(pushToken, "pushToken");
        for (const token of tokens) {
          if (typeof token === "string") {
            pushToken(token);
            continue;
          }
          const { name: name302, position } = token;
          if (position === 1) {
            if (stack[0][0].name === name302) {
              stack.shift();
            }
          } else if (position === 3) {
            stack[0][0].children[name302] = [];
            stack[0][1] = name302;
          } else if (position === 0) {
            pushToken(token);
            token.children = { default: [] };
            stack.unshift([token, "default"]);
          } else {
            pushToken(token);
          }
        }
        return stack[stack.length - 1][0].children.default;
      }
      __name8(foldTokens, "foldTokens");
      function parseTokens(tokens, context2) {
        const result = [];
        for (const token of tokens) {
          if (typeof token === "string") {
            result.push(Element22("text", { content: token }));
          } else if (token.type === "angle") {
            const attrs = {};
            const attrRegExp = context2 ? attrRegExp2 : attrRegExp1;
            let attrCap;
            while (attrCap = attrRegExp.exec(token.extra)) {
              const [, key, v1, v2 = v1, v3] = attrCap;
              if (v3) {
                attrs[key] = interpolate(v3, context2);
              } else if (!isNullable(v2)) {
                attrs[key] = unescape(v2);
              } else if (key.startsWith("no-")) {
                attrs[key.slice(3)] = false;
              } else {
                attrs[key] = true;
              }
            }
            result.push(Element22(token.name, attrs, token.children && parseTokens(token.children.default, context2)));
          } else if (!token.name) {
            result.push(...toElementArray(interpolate(token.extra, context2)));
          } else if (token.name === "if") {
            if (evaluate4(token.extra, context2)) {
              result.push(...parseTokens(token.children.default, context2));
            } else {
              result.push(...parseTokens(token.children.else || [], context2));
            }
          } else if (token.name === "each") {
            const [expr, ident] = token.extra.split(/\s+as\s+/);
            const items = interpolate(expr, context2);
            if (!items || !items[Symbol.iterator])
              continue;
            for (const item of items) {
              result.push(...parseTokens(token.children.default, { ...context2, [ident]: item }));
            }
          }
        }
        return result;
      }
      __name8(parseTokens, "parseTokens");
      function visit(element, rules, session) {
        const { type, attrs, children } = element;
        if (typeof rules === "function") {
          return rules(element, session);
        } else {
          let result = rules[typeof type === "string" ? type : ""] ?? rules.default ?? true;
          if (typeof result === "function") {
            result = result(attrs, children, session);
          }
          return result;
        }
      }
      __name8(visit, "visit");
      function transform(source, rules, session) {
        const elements = typeof source === "string" ? parse4(source) : source;
        const output = [];
        elements.forEach((element) => {
          const { type, attrs, children } = element;
          const result = visit(element, rules, session);
          if (result === true) {
            output.push(Element22(type, attrs, transform(children, rules, session)));
          } else if (result !== false) {
            output.push(...toElementArray(result));
          }
        });
        return typeof source === "string" ? output.join("") : output;
      }
      Element22.transform = transform;
      __name8(transform, "transform");
      async function transformAsync(source, rules, session) {
        const elements = typeof source === "string" ? parse4(source) : source;
        const children = (await Promise.all(elements.map(async (element) => {
          const { type, attrs, children: children2 } = element;
          const result = await visit(element, rules, session);
          if (result === true) {
            return [Element22(type, attrs, await transformAsync(children2, rules, session))];
          } else if (result !== false) {
            return toElementArray(result);
          } else {
            return [];
          }
        }))).flat(1);
        return typeof source === "string" ? children.join("") : children;
      }
      Element22.transformAsync = transformAsync;
      __name8(transformAsync, "transformAsync");
      function createFactory(type, ...keys) {
        return (...args) => {
          const element = Element22(type);
          keys.forEach((key, index2) => {
            if (!isNullable(args[index2])) {
              element.attrs[key] = args[index2];
            }
          });
          if (args[keys.length]) {
            Object.assign(element.attrs, args[keys.length]);
          }
          return element;
        };
      }
      __name8(createFactory, "createFactory");
      Element22.warn = __name8(() => {
      }, "warn");
      function createAssetFactory(type) {
        return (src, ...args) => {
          let prefix = "base64://";
          if (typeof args[0] === "string") {
            prefix = `data:${args.shift()};base64,`;
          }
          if (is93("Buffer", src)) {
            src = prefix + src.toString("base64");
          } else if (is93("ArrayBuffer", src)) {
            src = prefix + arrayBufferToBase64(src);
          } else if (ArrayBuffer.isView(src)) {
            src = prefix + arrayBufferToBase64(src.buffer);
          }
          if (src.startsWith("base64://")) {
            (0, Element22.warn)(`protocol "base64:" is deprecated and will be removed in the future, please use "data:" instead`);
          }
          return Element22(type, { ...args[0], src });
        };
      }
      __name8(createAssetFactory, "createAssetFactory");
      Element22.text = createFactory("text", "content");
      Element22.at = createFactory("at", "id");
      Element22.sharp = createFactory("sharp", "id");
      Element22.quote = createFactory("quote", "id");
      Element22.image = createAssetFactory("img");
      Element22.img = createAssetFactory("img");
      Element22.video = createAssetFactory("video");
      Element22.audio = createAssetFactory("audio");
      Element22.file = createAssetFactory("file");
      function i18n(path3, children) {
        return Element22("i18n", typeof path3 === "string" ? { path: path3 } : path3, children);
      }
      Element22.i18n = i18n;
      __name8(i18n, "i18n");
    })(Element2 || (Element2 = {}));
    module.exports = Element2;
  }
});
var lib_default = require_src();
// ../../node_modules/@satorijs/protocol/lib/index.mjs
var exports_lib2 = {};
__export(exports_lib2, {
  WebSocket: () => WebSocket3,
  Status: () => Status,
  Opcode: () => Opcode,
  Methods: () => Methods,
  Channel: () => Channel
});
var Field = function(name302) {
  return { name: name302 };
};
var Method = function(name302, fields, isForm = false) {
  return { name: name302, fields: fields.map(Field), isForm };
};
var __defProp10 = Object.defineProperty;
var __name9 = (target, value) => __defProp10(target, "name", { value, configurable: true });
__name9(Field, "Field");
__name9(Method, "Method");
var Methods = {
  "channel.get": Method("getChannel", ["channel_id", "guild_id"]),
  "channel.list": Method("getChannelList", ["guild_id", "next"]),
  "channel.create": Method("createChannel", ["guild_id", "data"]),
  "channel.update": Method("updateChannel", ["channel_id", "data"]),
  "channel.delete": Method("deleteChannel", ["channel_id"]),
  "channel.mute": Method("muteChannel", ["channel_id", "guild_id", "enable"]),
  "message.create": Method("createMessage", ["channel_id", "content"]),
  "message.update": Method("editMessage", ["channel_id", "message_id", "content"]),
  "message.delete": Method("deleteMessage", ["channel_id", "message_id"]),
  "message.get": Method("getMessage", ["channel_id", "message_id"]),
  "message.list": Method("getMessageList", ["channel_id", "next", "direction", "limit", "order"]),
  "reaction.create": Method("createReaction", ["channel_id", "message_id", "emoji"]),
  "reaction.delete": Method("deleteReaction", ["channel_id", "message_id", "emoji", "user_id"]),
  "reaction.clear": Method("clearReaction", ["channel_id", "message_id", "emoji"]),
  "reaction.list": Method("getReactionList", ["channel_id", "message_id", "emoji", "next"]),
  "upload.create": Method("createUpload", [], true),
  "guild.get": Method("getGuild", ["guild_id"]),
  "guild.list": Method("getGuildList", ["next"]),
  "guild.member.get": Method("getGuildMember", ["guild_id", "user_id"]),
  "guild.member.list": Method("getGuildMemberList", ["guild_id", "next"]),
  "guild.member.kick": Method("kickGuildMember", ["guild_id", "user_id", "permanent"]),
  "guild.member.mute": Method("muteGuildMember", ["guild_id", "user_id", "duration", "reason"]),
  "guild.member.role.set": Method("setGuildMemberRole", ["guild_id", "user_id", "role_id"]),
  "guild.member.role.unset": Method("unsetGuildMemberRole", ["guild_id", "user_id", "role_id"]),
  "guild.role.list": Method("getGuildRoleList", ["guild_id", "next"]),
  "guild.role.create": Method("createGuildRole", ["guild_id", "data"]),
  "guild.role.update": Method("updateGuildRole", ["guild_id", "role_id", "data"]),
  "guild.role.delete": Method("deleteGuildRole", ["guild_id", "role_id"]),
  "login.get": Method("getLogin", []),
  "user.get": Method("getUser", ["user_id"]),
  "user.channel.create": Method("createDirectChannel", ["user_id", "guild_id"]),
  "friend.list": Method("getFriendList", ["next"]),
  "friend.delete": Method("deleteFriend", ["user_id"]),
  "friend.approve": Method("handleFriendRequest", ["message_id", "approve", "comment"]),
  "guild.approve": Method("handleGuildRequest", ["message_id", "approve", "comment"]),
  "guild.member.approve": Method("handleGuildMemberRequest", ["message_id", "approve", "comment"])
};
var Channel;
((Channel2) => {
  let Type;
  ((Type2) => {
    Type2[Type2["TEXT"] = 0] = "TEXT";
    Type2[Type2["DIRECT"] = 1] = "DIRECT";
    Type2[Type2["VOICE"] = 2] = "VOICE";
    Type2[Type2["CATEGORY"] = 3] = "CATEGORY";
  })(Type = Channel2.Type || (Channel2.Type = {}));
})(Channel || (Channel = {}));
var Status = ((Status2) => {
  Status2[Status2["OFFLINE"] = 0] = "OFFLINE";
  Status2[Status2["ONLINE"] = 1] = "ONLINE";
  Status2[Status2["CONNECT"] = 2] = "CONNECT";
  Status2[Status2["DISCONNECT"] = 3] = "DISCONNECT";
  Status2[Status2["RECONNECT"] = 4] = "RECONNECT";
  return Status2;
})(Status || {});
var Opcode = ((Opcode2) => {
  Opcode2[Opcode2["EVENT"] = 0] = "EVENT";
  Opcode2[Opcode2["PING"] = 1] = "PING";
  Opcode2[Opcode2["PONG"] = 2] = "PONG";
  Opcode2[Opcode2["IDENTIFY"] = 3] = "IDENTIFY";
  Opcode2[Opcode2["READY"] = 4] = "READY";
  return Opcode2;
})(Opcode || {});
var WebSocket3;
((WebSocket22) => {
  WebSocket22.CONNECTING = 0;
  WebSocket22.OPEN = 1;
  WebSocket22.CLOSING = 2;
  WebSocket22.CLOSED = 3;
})(WebSocket3 || (WebSocket3 = {}));

// ../../node_modules/@satorijs/core/lib/index.mjs
var defineAccessor = function(prototype, name302, keys) {
  Object.defineProperty(prototype, name302, {
    get() {
      return keys.reduce((data2, key) => data2?.[key], this);
    },
    set(value) {
      if (value === undefined)
        return;
      const _keys = keys.slice();
      const last = _keys.pop();
      const data2 = _keys.reduce((data22, key) => data22[key] ??= {}, this);
      data2[last] = value;
    }
  });
};
var __defProp11 = Object.defineProperty;
var __name10 = (target, value) => __defProp11(target, "name", { value, configurable: true });
var Session = class _Session {
  static {
    __name10(this, "Session");
  }
  static counter = 0;
  id;
  bot;
  app;
  event;
  locales = [];
  constructor(bot, event) {
    event.selfId ??= bot.selfId;
    event.platform ??= bot.platform;
    event.timestamp ??= Date.now();
    this.event = event;
    this.id = ++_Session.counter;
    defineProperty17(this, "bot", bot);
    defineProperty17(this, "app", bot.ctx.root);
    defineProperty17(this, Context22.current, bot.ctx);
    return Context22.associate(this, "session");
  }
  get data() {
    return this.event;
  }
  get isDirect() {
    return this.event.channel.type === Channel.Type.DIRECT;
  }
  set isDirect(value) {
    (this.event.channel ??= {}).type = value ? Channel.Type.DIRECT : Channel.Type.TEXT;
  }
  get author() {
    return {
      ...this.event.user,
      ...this.event.member,
      userId: this.event.user?.id,
      username: this.event.user?.name,
      nickname: this.event.member?.name
    };
  }
  get uid() {
    return `${this.platform}:${this.userId}`;
  }
  get gid() {
    return `${this.platform}:${this.guildId}`;
  }
  get cid() {
    return `${this.platform}:${this.channelId}`;
  }
  get fid() {
    return `${this.platform}:${this.channelId}:${this.userId}`;
  }
  get sid() {
    return `${this.platform}:${this.selfId}`;
  }
  get elements() {
    return this.event.message?.elements;
  }
  set elements(value) {
    this.event.message ??= {};
    this.event.message.elements = value;
  }
  get content() {
    return this.event.message?.elements?.join("");
  }
  set content(value) {
    this.event.message ??= {};
    this.event.message.elements = isNullable(value) ? value : lib_default.parse(value);
  }
  setInternal(type, data2) {
    this.event._type = type;
    this.event._data = data2;
    const internal = Object.create(this.bot.internal);
    defineProperty17(this, type, Object.assign(internal, data2));
  }
  async transform(elements) {
    return await lib_default.transformAsync(elements, ({ type, attrs, children }, session) => {
      const render3 = type === "component" ? attrs.is : this.app.get("component:" + type);
      return render3?.(attrs, children, session) ?? true;
    }, this);
  }
  toJSON() {
    return { ...this.event, id: this.id };
  }
};
__name10(defineAccessor, "defineAccessor");
defineAccessor(Session.prototype, "type", ["event", "type"]);
defineAccessor(Session.prototype, "subtype", ["event", "subtype"]);
defineAccessor(Session.prototype, "subsubtype", ["event", "subsubtype"]);
defineAccessor(Session.prototype, "selfId", ["event", "selfId"]);
defineAccessor(Session.prototype, "platform", ["event", "platform"]);
defineAccessor(Session.prototype, "timestamp", ["event", "timestamp"]);
defineAccessor(Session.prototype, "userId", ["event", "user", "id"]);
defineAccessor(Session.prototype, "channelId", ["event", "channel", "id"]);
defineAccessor(Session.prototype, "channelName", ["event", "channel", "name"]);
defineAccessor(Session.prototype, "guildId", ["event", "guild", "id"]);
defineAccessor(Session.prototype, "guildName", ["event", "guild", "name"]);
defineAccessor(Session.prototype, "messageId", ["event", "message", "id"]);
defineAccessor(Session.prototype, "operatorId", ["event", "operator", "id"]);
defineAccessor(Session.prototype, "roleId", ["event", "role", "id"]);
defineAccessor(Session.prototype, "quote", ["event", "message", "quote"]);
var eventAliases = [
  ["message-created", "message"],
  ["guild-removed", "guild-deleted"],
  ["guild-member-removed", "guild-member-deleted"]
];
var Bot = class {
  constructor(ctx, config8, platform2) {
    this.ctx = ctx;
    this.config = config8;
    this.internal = null;
    this.context = ctx;
    this[Context22.current] = ctx;
    const self2 = Context22.associate(this, "bot");
    ctx.bots.push(self2);
    self2.context.emit("bot-added", self2);
    if (platform2) {
      self2.logger = ctx.logger(platform2);
      self2.platform = platform2;
    }
    this.proxyUrls = [`upload://temp/${ctx.satori.uid}/`];
    this.features = Object.entries(Methods).filter(([, value]) => this[value.name]).map(([key]) => key);
    ctx.on("ready", async () => {
      await Promise.resolve();
      self2.dispatchLoginEvent("login-added");
      return self2.start();
    });
    ctx.on("dispose", () => self2.dispose());
    ctx.on("interaction/button", (session) => {
      const cb = this.callbacks[session.event.button.id];
      if (cb)
        cb(session);
    });
    return self2;
  }
  static {
    __name10(this, "Bot");
  }
  static reusable = true;
  static MessageEncoder;
  self = this;
  user = {};
  isBot = true;
  hidden = false;
  platform;
  features;
  proxyUrls;
  adapter;
  error;
  callbacks = {};
  logger;
  [Context22.current];
  context;
  _status = Status.OFFLINE;
  registerUpload(path3, callback) {
    this.ctx.satori.upload(path3, callback, this.proxyUrls);
  }
  update(login2) {
    const { status, ...rest } = login2;
    Object.assign(this, rest);
    this.status = status;
  }
  dispose() {
    remove(this.ctx.bots, this);
    this.context.emit("bot-removed", this);
    this.dispatchLoginEvent("login-removed");
    return this.stop();
  }
  dispatchLoginEvent(type) {
    const session = this.session();
    session.type = type;
    session.event.login = this.toJSON();
    this.dispatch(session);
  }
  get status() {
    return this._status;
  }
  set status(value) {
    if (value === this._status)
      return;
    this._status = value;
    if (this.ctx.bots?.includes(this)) {
      this.context.emit("bot-status-updated", this);
      this.dispatchLoginEvent("login-updated");
    }
  }
  get isActive() {
    return this._status !== Status.OFFLINE && this._status !== Status.DISCONNECT;
  }
  online() {
    this.status = Status.ONLINE;
    this.error = null;
  }
  offline(error) {
    this.status = Status.OFFLINE;
    this.error = error;
  }
  async start() {
    if (this.isActive)
      return;
    this.status = Status.CONNECT;
    try {
      await this.context.parallel("bot-connect", this);
      await this.adapter?.connect(this);
    } catch (error) {
      this.offline(error);
    }
  }
  async stop() {
    if (!this.isActive)
      return;
    this.status = Status.DISCONNECT;
    try {
      await this.context.parallel("bot-disconnect", this);
      await this.adapter?.disconnect(this);
    } catch (error) {
      this.context.emit("internal/error", error);
    } finally {
      this.offline();
    }
  }
  get sid() {
    return `${this.platform}:${this.selfId}`;
  }
  session(event = {}) {
    return new Session(this, event);
  }
  dispatch(session) {
    if (!this.ctx.lifecycle.isActive)
      return;
    let events = [session.type];
    for (const aliases of eventAliases) {
      if (aliases.includes(session.type)) {
        events = aliases;
        session.type = aliases[0];
        break;
      }
    }
    this.context.emit("internal/session", session);
    if (session.type === "internal") {
      this.context.emit(session.event._type, session.event._data, session.bot);
      return;
    }
    for (const event of events) {
      this.context.emit(session, event, session);
    }
  }
  async createMessage(channelId, content, guildId, options) {
    const { MessageEncoder: MessageEncoder2 } = this.constructor;
    return new MessageEncoder2(this, channelId, guildId, options).send(content);
  }
  async sendMessage(channelId, content, guildId, options) {
    const messages = await this.createMessage(channelId, content, guildId, options);
    return messages.map((message) => message.id);
  }
  async sendPrivateMessage(userId, content, guildId, options) {
    const { id } = await this.createDirectChannel(userId, guildId ?? options?.session?.guildId);
    return this.sendMessage(id, content, null, options);
  }
  async createUpload(...uploads) {
    const ids = [];
    for (const upload of uploads) {
      const id = Math.random().toString(36).slice(2);
      const headers = new Headers;
      headers.set("content-type", upload.type);
      if (upload.filename) {
        headers.set("content-disposition", `attachment; filename="${upload.filename}"`);
      }
      this.ctx.satori._tempStore[id] = {
        status: 200,
        data: upload.data,
        headers
      };
      ids.push(id);
    }
    const timer3 = setTimeout(() => dispose(), 600000);
    const dispose = __name10(() => {
      _dispose();
      clearTimeout(timer3);
      for (const id of ids) {
        delete this.ctx.satori._tempStore[id];
      }
    }, "dispose");
    const _dispose = this[Context22.current].on("dispose", dispose);
    return ids.map((id) => `upload://temp/${this.ctx.satori.uid}/${id}`);
  }
  async supports(name302, session = {}) {
    return !!this[Methods[name302]?.name];
  }
  async checkPermission(name302, session) {
    if (name302.startsWith("bot.")) {
      return this.supports(name302.slice(4), session);
    }
  }
  toJSON() {
    return clone5(pick2(this, ["platform", "selfId", "status", "user", "hidden", "features", "proxyUrls"]));
  }
  async getLogin() {
    return this.toJSON();
  }
  async getSelf() {
    const { user } = await this.getLogin();
    return user;
  }
};
var iterableMethods = [
  "getMessage",
  "getReaction",
  "getFriend",
  "getGuild",
  "getGuildMember",
  "getGuildRole",
  "getChannel"
];
for (const name302 of iterableMethods) {
  Bot.prototype[name302 + "Iter"] = function(...args) {
    let list3;
    if (!this[name302 + "List"])
      throw new Error(`not implemented: ${name302}List`);
    const getList = __name10(async () => {
      list3 = await this[name302 + "List"](...args, list3?.next);
      if (name302 === "getMessage")
        list3.data.reverse();
    }, "getList");
    return {
      async next() {
        if (list3?.data.length)
          return { done: false, value: list3.data.shift() };
        if (list3 && !list3?.next)
          return { done: true, value: undefined };
        await getList();
        return this.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  };
}
defineAccessor(Bot.prototype, "selfId", ["user", "id"]);
defineAccessor(Bot.prototype, "userId", ["user", "id"]);
var Adapter = class {
  constructor(ctx) {
    this.ctx = ctx;
  }
  static {
    __name10(this, "Adapter");
  }
  static schema = false;
  bots = [];
  async connect(bot) {
  }
  async disconnect(bot) {
  }
  fork(ctx, bot) {
    bot.adapter = this;
    this.bots.push(bot);
    ctx.on("dispose", () => {
      remove(this.bots, bot);
    });
  }
};
((Adapter2) => {
  Adapter2.WsClientConfig = import_schemastery.default.object({
    retryTimes: import_schemastery.default.natural().description("\u521D\u6B21\u8FDE\u63A5\u65F6\u7684\u6700\u5927\u91CD\u8BD5\u6B21\u6570\u3002").default(6),
    retryInterval: import_schemastery.default.natural().role("ms").description("\u521D\u6B21\u8FDE\u63A5\u65F6\u7684\u91CD\u8BD5\u65F6\u95F4\u95F4\u9694\u3002").default(5 * Time.second),
    retryLazy: import_schemastery.default.natural().role("ms").description("\u8FDE\u63A5\u5173\u95ED\u540E\u7684\u91CD\u8BD5\u65F6\u95F4\u95F4\u9694\u3002").default(Time.minute)
  }).description("\u8FDE\u63A5\u8BBE\u7F6E");

  class WsClientBase extends Adapter2 {
    constructor(ctx, config8) {
      super(ctx);
      this.config = config8;
    }
    static {
      __name10(this, "WsClientBase");
    }
    socket;
    async start() {
      let _retryCount = 0;
      const logger3 = this.ctx.logger("adapter");
      const { retryTimes, retryInterval, retryLazy } = this.config;
      const reconnect = __name10(async (initial = false) => {
        logger3.debug("websocket client opening");
        let socket;
        try {
          socket = await this.prepare();
        } catch (error) {
          logger3.warn(error);
          return;
        }
        const url = socket.url.replace(/\?.+/, "");
        socket.addEventListener("error", (event) => {
          if (event.message)
            logger3.warn(event.message);
        });
        socket.addEventListener("close", ({ code, reason }) => {
          this.socket = null;
          logger3.debug(`websocket closed with ${code}`);
          if (!this.getActive())
            return;
          const message = reason.toString() || `failed to connect to ${url}, code: ${code}`;
          let timeout = retryInterval;
          if (_retryCount >= retryTimes) {
            if (initial) {
              return this.setStatus(Status.OFFLINE, new Error(message));
            } else {
              timeout = retryLazy;
            }
          }
          _retryCount++;
          this.setStatus(Status.RECONNECT);
          logger3.warn(`${message}, will retry in ${Time.format(timeout)}...`);
          setTimeout(() => {
            if (this.getActive())
              reconnect();
          }, timeout);
        });
        socket.addEventListener("open", () => {
          _retryCount = 0;
          this.socket = socket;
          logger3.info("connect to server: %c", url);
          this.accept(socket);
        });
      }, "reconnect");
      reconnect(true);
    }
    async stop() {
      this.socket?.close();
    }
  }
  Adapter2.WsClientBase = WsClientBase;

  class WsClient2 extends WsClientBase {
    constructor(ctx, bot) {
      super(ctx, bot.config);
      this.bot = bot;
      bot.adapter = this;
    }
    static {
      __name10(this, "WsClient");
    }
    static reusable = true;
    getActive() {
      return this.bot.isActive;
    }
    setStatus(status, error = null) {
      this.bot.status = status;
      this.bot.error = error;
    }
    async connect(bot) {
      this.start();
    }
    async disconnect(bot) {
      this.stop();
    }
  }
  Adapter2.WsClient = WsClient2;
})(Adapter || (Adapter = {}));
var AggregateError = class extends Error {
  constructor(errors, message = "") {
    super(message);
    this.errors = errors;
  }
  static {
    __name10(this, "AggregateError");
  }
};
var MessageEncoder = class {
  constructor(bot, channelId, guildId, options = {}) {
    this.bot = bot;
    this.channelId = channelId;
    this.guildId = guildId;
    this.options = options;
  }
  static {
    __name10(this, "MessageEncoder");
  }
  errors = [];
  results = [];
  session;
  async prepare() {
  }
  async render(elements, flush) {
    for (const element4 of elements) {
      await this.visit(element4);
    }
    if (flush) {
      await this.flush();
    }
  }
  async send(content) {
    this.session = this.bot.session({
      type: "send",
      channel: { id: this.channelId, ...this.options.session?.event.channel },
      guild: this.options.session?.event.guild
    });
    for (const key in this.options.session || {}) {
      if (key === "id" || key === "event")
        continue;
      this.session[key] = this.options.session[key];
    }
    await this.prepare();
    const session = this.options.session ?? this.session;
    this.session.elements = await session.transform(lib_default.normalize(content));
    const btns = lib_default.select(this.session.elements, "button").filter((v) => v.attrs.type !== "link" && !v.attrs.id);
    for (const btn of btns) {
      const r = Math.random().toString(36).slice(2);
      btn.attrs.id ||= r;
      if (typeof btn.attrs.action === "function")
        this.bot.callbacks[btn.attrs.id] = btn.attrs.action;
    }
    if (await this.session.app.serial(this.session, "before-send", this.session, this.options))
      return;
    await this.render(this.session.elements);
    await this.flush();
    if (this.errors.length) {
      throw new AggregateError(this.errors);
    } else {
      return this.results;
    }
  }
};
lib_default.warn = new import_reggol.default("element").warn;
defineProperty17(HTTP2, "Config", import_schemastery.default.object({
  timeout: import_schemastery.default.natural().role("ms").description("\u7B49\u5F85\u8FDE\u63A5\u5EFA\u7ACB\u7684\u6700\u957F\u65F6\u95F4\u3002"),
  proxyAgent: import_schemastery.default.string().description("\u4F7F\u7528\u7684\u4EE3\u7406\u670D\u52A1\u5668\u5730\u5740\u3002"),
  keepAlive: import_schemastery.default.boolean().description("\u662F\u5426\u4FDD\u6301\u8FDE\u63A5\u3002")
}).description("\u8BF7\u6C42\u8BBE\u7F6E"));
HTTP2.createConfig = __name10(function createConfig(endpoint) {
  return import_schemastery.default.object({
    endpoint: import_schemastery.default.string().role("link").description("\u8981\u8FDE\u63A5\u7684\u670D\u52A1\u5668\u5730\u5740\u3002").default(typeof endpoint === "string" ? endpoint : null).required(typeof endpoint === "boolean" ? endpoint : false),
    headers: import_schemastery.default.dict(String).role("table").description("\u8981\u9644\u52A0\u7684\u989D\u5916\u8BF7\u6C42\u5934\u3002"),
    ...this.Config.dict
  }).description("\u8BF7\u6C42\u8BBE\u7F6E");
}, "createConfig");
var SatoriContext = class extends Context22 {
  static {
    __name10(this, "SatoriContext");
  }
  constructor(config8) {
    super(config8);
    this.provide("satori", undefined, true);
    this.plugin(Satori);
  }
};
var Satori = class extends Service22 {
  static {
    __name10(this, "Satori");
  }
  static [Service22.provide] = "satori";
  static [Service22.immediate] = true;
  uid = Math.random().toString(36).slice(2);
  _uploadRoutes = [];
  _tempStore = Object.create(null);
  constructor(ctx) {
    super(ctx);
    ctx.mixin("satori", ["bots", "component"]);
    this.upload(`/temp/${this.uid}/`, async (path3) => {
      const id = path3.split("/").pop();
      return this._tempStore[id] ?? { status: 404 };
    });
    const self2 = this;
    ctx.on("http/file", async function(url, options) {
      if (!url.startsWith("upload://"))
        return;
      const { status, data: data2, headers } = await self2.download(url.slice(9));
      if (status >= 400)
        throw new Error(`Failed to fetch ${url}, status code: ${status}`);
      if (status >= 300) {
        const location = headers?.get("location");
        return this.file(location, options);
      }
      const type = headers?.get("content-type");
      const filename = headers?.get("content-disposition")?.split("filename=")[1];
      return { data: data2, filename, type, mime: type };
    });
  }
  bots = new Proxy([], {
    get(target, prop) {
      if (prop in target || typeof prop === "symbol") {
        return Reflect.get(target, prop);
      }
      return target.find((bot) => bot.sid === prop);
    },
    deleteProperty(target, prop) {
      if (prop in target || typeof prop === "symbol") {
        return Reflect.deleteProperty(target, prop);
      }
      const bot = target.findIndex((bot2) => bot2.sid === prop);
      if (bot < 0)
        return true;
      target.splice(bot, 1);
      return true;
    }
  });
  component(name302, component, options = {}) {
    const render3 = __name10(async (attrs, children, session) => {
      if (options.session && session.type === "send") {
        throw new Error("interactive components is not available outside sessions");
      }
      const result = await component(attrs, children, session);
      return session.transform(lib_default.normalize(result));
    }, "render");
    return this.ctx.set("component:" + name302, render3);
  }
  upload(path3, callback, proxyUrls = []) {
    return this[Context22.current].effect(() => {
      const route = { path: path3, callback };
      this._uploadRoutes.push(route);
      proxyUrls.push(path3);
      return () => {
        remove(this._uploadRoutes, route);
        remove(proxyUrls, path3);
      };
    });
  }
  async download(path3) {
    for (const route of this._uploadRoutes) {
      const paths = makeArray(typeof route.path === "function" ? route.path() : route.path);
      if (paths.some((prefix) => path3.startsWith(prefix))) {
        return route.callback(path3);
      }
    }
    return { status: 404 };
  }
};

// src/adapter/satori.ts
class Context4 extends SatoriContext {
  constructor(config8 = {}) {
    super(config8);
    try {
      this.provide("http", undefined, true);
      this.plugin(HTTP2, config8.request);
    } catch (e4) {
      console.log(e4);
    }
  }
}

// src/adapter/Bot.ts
var import_lodash3 = __toESM(require_lodash(), 1);
var import_mobx12 = __toESM(require_dist(), 1);

// src/model/GuildManager.ts
var import_mobx8 = __toESM(require_dist(), 1);

// src/model/Guild.ts
var import_mobx7 = __toESM(require_dist(), 1);
import fs5 from "fs";

// src/model/Channel.ts
var import_mobx5 = __toESM(require_dist(), 1);

// src/adapter/qqguild-v1.ts
var import_node_fetch2 = __toESM(require_lib19(), 1);
var import_form_data = __toESM(require_form_data(), 1);
var baseUrl = function(bot) {
  if (bot.config.sandbox) {
    return "https://sandbox.api.sgroup.qq.com";
  } else {
    return "https://api.sgroup.qq.com";
  }
};
async function qqguildV1_getMessageContent(bot, channelId, msgId) {
  try {
    const res = await import_node_fetch2.default(`${baseUrl(bot)}/channels/${channelId}/messages/${msgId}`, {
      method: "GET",
      headers: {
        Authorization: `Bot ${bot.config.appid}.${bot.config.token}`
      }
    });
    const resp = await res.json();
    return resp.message.content;
  } catch (e4) {
    console.log(e4);
    return "";
  }
}
async function qqguildV1_sendRawImage(bot, channelId, imgData, replyMsgId) {
  const formData = new import_form_data.default;
  if (replyMsgId)
    formData.append("msg_id", replyMsgId);
  const img = Buffer.from(imgData.split(",")[1], "base64");
  formData.append("file_image", img, "test.png");
  const res = await import_node_fetch2.default(`${baseUrl(bot)}/channels/${channelId}/messages`, {
    method: "POST",
    headers: {
      "Content-Type": formData.getHeaders()["content-type"],
      Authorization: `Bot ${bot.config.appid}.${bot.config.token}`
    },
    body: formData
  });
  const resp = await res.json();
  return resp.id;
}

// src/model/Channel.ts
var ChannelTypeLive_QQ = 10005;

class Channel2 {
  static VALID_TYPES = [exports_lib2.Channel.Type.TEXT, exports_lib2.Channel.Type.VOICE, ChannelTypeLive_QQ];
  id;
  guildId;
  name;
  type;
  lastSession;
  bot;
  constructor(bot, id, guildId, name302, type) {
    import_mobx5.makeAutoObservable(this);
    this.bot = bot;
    this.id = id;
    this.guildId = guildId;
    this.name = name302 || id;
    this.type = type;
  }
  async sendMessage(content, session, recordLog = true) {
    if (!(session instanceof Session)) {
      session = undefined;
    }
    if (!session) {
      session = this.getLastSessionForReply();
    }
    if (content) {
      content = removeBackspaces(content.trim());
    }
    try {
      const res = await this.bot.api.sendMessage(this.id, content, this.guildId, { session });
      const messageId = res.at(-1);
      console.log("[Message] \u53D1\u9001\u6210\u529F " + content);
      if (recordLog) {
        this.sendLogAsync(messageId, content);
      }
      return { id: messageId, content };
    } catch (e4) {
      console.error("[Message] \u53D1\u9001\u5931\u8D25", e4);
      return null;
    }
  }
  async sendRawImageMessage(imgData, recordLog = true) {
    const session = this.getLastSessionForReply();
    const content = `<img src="${imgData}"/>`;
    try {
      const messageId = await (async () => {
        if (this.bot.platform === "qqguild") {
          return await qqguildV1_sendRawImage(this.bot, this.id, imgData, session?.messageId);
        } else {
          const res = await this.bot.api.sendMessage(this.id, content, this.guildId, { session });
          return res.at(-1);
        }
      })();
      console.log("[Message] \u53D1\u9001\u672C\u5730\u56FE\u7247\u6210\u529F");
      if (recordLog) {
        this.sendLogAsync(messageId, content);
      }
      return { id: messageId };
    } catch (e4) {
      console.error("[Message] \u53D1\u9001\u672C\u5730\u56FE\u7247\u5931\u8D25", e4);
      return null;
    }
  }
  async sendLogAsync(msgId, content) {
    if (content) {
      this.bot.logs.onPushMessage(this.guildId, this.id, msgId, content);
    }
  }
  getLastSessionForReply() {
    const lastMsgTime = this.lastSession?.timestamp ? new Date(this.lastSession.timestamp).getTime() : 0;
    const currentTime = new Date().getTime();
    if (currentTime - lastMsgTime <= 5 * 60 * 1000 - 2000) {
      console.log("[Message] \u547D\u4E2D\u88AB\u52A8\u6D88\u606F\u7F13\u5B58");
      return this.lastSession;
    } else {
      this.lastSession = undefined;
      return;
    }
  }
}

// src/model/User.ts
var import_mobx6 = __toESM(require_dist(), 1);
class User {
  id;
  guildId;
  isBot;
  avatar;
  name;
  deleted = false;
  lastSession;
  bot;
  constructor(bot, proto) {
    import_mobx6.makeAutoObservable(this);
    this.id = proto.id;
    this.guildId = proto.guildId;
    this.isBot = proto.isBot;
    this.avatar = proto.avatar;
    this.name = proto.name;
    this.bot = bot;
  }
  async sendMessage(content, session) {
    if (!(session instanceof Session)) {
      session = undefined;
    }
    if (this.bot.platform === "qqguild") {
      if (!session) {
        session = this.getLastSessionForReply();
      }
    } else {
      session = undefined;
    }
    if (content) {
      content = removeBackspaces(content.trim());
    }
    try {
      const res = await this.bot.api.sendPrivateMessage(this.id, content, this.guildId, { session });
      const messageId = res.at(-1);
      console.log("[Message] \u79C1\u4FE1\u53D1\u9001\u6210\u529F " + content);
      return { id: messageId, content };
    } catch (e4) {
      console.error("[Message] \u79C1\u4FE1\u6D88\u606F\u53D1\u9001\u5931\u8D25", e4);
      return null;
    }
  }
  getLastSessionForReply() {
    const lastMsgTime = this.lastSession?.timestamp ? new Date(this.lastSession.timestamp).getTime() : 0;
    const currentTime = new Date().getTime();
    if (currentTime - lastMsgTime <= 5 * 60 * 1000 - 2000) {
      console.log("[Message] \u547D\u4E2D\u88AB\u52A8\u6D88\u606F\u7F13\u5B58");
      return this.lastSession;
    } else {
      this.lastSession = undefined;
      return;
    }
  }
  static createTemp(bot, id, guildId) {
    console.log("[User] create temp, id=", id, "guildId=", guildId);
    return new User(bot, { id, guildId, name: id, avatar: "", isBot: false });
  }
  get toJSON() {
    return {
      id: this.id,
      guildId: this.guildId,
      isBot: this.isBot,
      name: this.name,
      avatar: this.avatar,
      deleted: this.deleted
    };
  }
  static fromJSON(bot, data2) {
    data2.isBot = data2.bot;
    const user = new User(bot, data2);
    user.deleted = data2.deleted;
    return user;
  }
}

// src/model/Guild.ts
var USER_DIR = resolveRootDir("user");

class Guild {
  id;
  name;
  icon;
  bot;
  channelsMap = {};
  usersMap = {};
  channelGroupId4Create;
  constructor(bot, id, name302, icon) {
    import_mobx7.makeAutoObservable(this);
    this.bot = bot;
    this.id = id;
    this.name = name302 || id;
    this.icon = icon || "";
    this.fetchChannels();
    this.loadUsers();
  }
  get allChannels() {
    return Object.values(this.channelsMap);
  }
  get allUsers() {
    return Object.values(this.usersMap);
  }
  findChannel(id) {
    return this.channelsMap[id];
  }
  findUser(id) {
    return this.usersMap[id] ?? User.createTemp(this.bot, id, this.id);
  }
  addChannel(channel) {
    this.channelsMap[channel.id] = new Channel2(this.bot, channel.id, this.id, channel.name, channel.type);
  }
  async createChannel(name302) {
    try {
      const resp = await this.bot.api.createChannel(this.id, { type: exports_lib2.Channel.Type.TEXT, name: name302, parentId: this.channelGroupId4Create });
      this.addChannel({ id: resp.id, name: name302, type: exports_lib2.Channel.Type.TEXT });
      return true;
    } catch (e4) {
      console.error("[Guild] \u521B\u5EFA\u5B50\u9891\u9053\u5931\u8D25", e4);
      return false;
    }
  }
  addOrUpdateUser(author) {
    const authorName = author.nick ?? author.nickname ?? author.name ?? author.username;
    const user = this.usersMap[author.id];
    if (user) {
      let updated = false;
      if (authorName && authorName !== user.name) {
        user.name = authorName;
        updated = true;
      }
      if (author.avatar && author.avatar !== user.avatar) {
        user.avatar = author.avatar;
        updated = true;
      }
      if (user.deleted) {
        user.deleted = false;
        updated = true;
      }
      if (updated) {
        this.saveUsers();
      }
    } else {
      const newUser = new User(this.bot, {
        id: author.id,
        guildId: this.id,
        name: authorName ?? author.id,
        avatar: author.avatar ?? "",
        isBot: author.isBot ?? false
      });
      this.usersMap[newUser.id] = newUser;
      this.saveUsers();
    }
  }
  deleteUser(id) {
    const user = this.usersMap[id];
    if (user && !user.deleted) {
      user.deleted = true;
      this.saveUsers();
    }
  }
  deleteUsersBatch(ids) {
    let updated = false;
    ids.forEach((id) => {
      const user = this.usersMap[id];
      if (user && !user.deleted) {
        user.deleted = true;
        updated = true;
      }
    });
    if (updated) {
      this.saveUsers();
    }
  }
  async fetchChannels() {
    this.channelsMap = {};
    try {
      const list3 = [];
      let nextToken = undefined;
      do {
        const { data: data2, next } = await this.bot.api.getChannelList(this.id, nextToken = undefined);
        list3.push(...data2);
        nextToken = next;
      } while (nextToken);
      import_mobx7.runInAction(() => {
        const channels = list3.filter((channel) => Channel2.VALID_TYPES.includes(channel.type)).map((channel) => new Channel2(this.bot, channel.id, this.id, channel.name, channel.type));
        this.channelsMap = channels.reduce((obj, chan) => Object.assign(obj, { [chan.id]: chan }), {});
        this.detectChannelGroupId4Create(list3);
      });
    } catch (e4) {
      console.error("\u83B7\u53D6\u5B50\u9891\u9053\u4FE1\u606F\u5931\u8D25", e4);
    }
  }
  detectChannelGroupId4Create(list3) {
    if (this.bot.platform !== "qqguild")
      return;
    const categories = list3.filter((channel) => channel.type === exports_lib2.Channel.Type.CATEGORY);
    const qqTextGroup = categories.find((channel) => channel.name === "\u8BA8\u8BBA\u7EC4") || categories.find((channel) => channel.name === "\u6D3B\u52A8");
    if (qqTextGroup) {
      this.channelGroupId4Create = qqTextGroup.id;
      return;
    }
    const hasTextGroup = categories.find((category) => {
      const parentId = category.id;
      return !!list3.find((channel) => channel.type === exports_lib2.Channel.Type.TEXT && channel.parentId === parentId);
    });
    if (hasTextGroup) {
      this.channelGroupId4Create = hasTextGroup.id;
      return;
    }
    console.warn("[Guild] \u672A\u627E\u5230\u7B26\u5408\u6761\u4EF6\u7684\u6587\u5B57\u5B50\u9891\u9053\u5206\u7EC4\uFF0CQQ \u63A5\u53E3\u53EF\u80FD\u6539\u52A8\u3002\u82E5\u521B\u5EFA\u5B50\u9891\u9053\u5931\u8D25\uFF0C\u8BF7\u8054\u7CFB\u5F00\u53D1\u8005");
    this.channelGroupId4Create = categories[0]?.id;
  }
  get userPersistenceFilename() {
    return `${USER_DIR}/${this.bot.platform}_${this.id}.json`;
  }
  saveUsers() {
    const allUsersOfGuild = Object.values(this.usersMap).map((user) => user.toJSON);
    console.log("[Guild] \u4FDD\u5B58\u7528\u6237\u5217\u8868\uFF0Ccount=", allUsersOfGuild.length);
    const data2 = { version: VERSION_CODE3, list: allUsersOfGuild };
    if (!fs5.existsSync(USER_DIR)) {
      fs5.mkdirSync(USER_DIR);
    }
    fs5.writeFile(this.userPersistenceFilename, JSON.stringify(data2), (e4) => {
      if (e4) {
        console.error("[Guild] \u4FDD\u5B58\u7528\u6237\u5217\u8868\u5931\u8D25", e4);
      }
    });
  }
  loadUsers() {
    console.log("[Guild] \u5F00\u59CB\u8BFB\u53D6\u7528\u6237\uFF0CguildId=", this.id);
    const filename = this.userPersistenceFilename;
    if (!fs5.existsSync(filename)) {
      this.tryLoadV1Data();
      return;
    }
    try {
      const str = fs5.readFileSync(filename, "utf8");
      const { version: version9, list: list3 } = JSON.parse(str);
      const users = list3.map((data2) => User.fromJSON(this.bot, data2));
      this.usersMap = users.reduce((obj, user) => Object.assign(obj, { [user.id]: user }), {});
    } catch (e4) {
      console.error(`[Guild] ${filename} \u7528\u6237\u5217\u8868\u89E3\u6790\u5931\u8D25`, e4);
    }
  }
  tryLoadV1Data() {
    if (this.bot.platform !== "qqguild")
      return;
    const filename = `${USER_DIR}/${this.id}.json`;
    if (!fs5.existsSync(filename))
      return;
    try {
      console.log("[Guild] \u5F00\u59CB\u8BFB\u53D6\u65E7\u7248\u7528\u6237\u5217\u8868\uFF0CguildId=", this.id);
      const str = fs5.readFileSync(filename, "utf8");
      const { list: list3 } = JSON.parse(str);
      const users = list3.map((item) => User.fromJSON(this.bot, {
        id: item.id,
        guildId: item.guildId,
        isBot: item.bot,
        name: item.nick || item.username,
        avatar: item.avatar,
        deleted: item.deleted
      }));
      this.usersMap = users.reduce((obj, user) => Object.assign(obj, { [user.id]: user }), {});
      this.saveUsers();
    } catch (e4) {
      console.error(`[Guild] ${filename} \u7528\u6237\u5217\u8868\u89E3\u6790\u5931\u8D25`, e4);
    }
  }
}

// src/model/GuildManager.ts
class GuildManager {
  bot;
  guildsMap = {};
  constructor(bot) {
    import_mobx8.makeAutoObservable(this);
    this.bot = bot;
    this.fetchGuilds();
    this.initEventListeners();
  }
  get all() {
    return Object.values(this.guildsMap);
  }
  find(guildId) {
    return this.guildsMap[guildId];
  }
  findUser(userId, guildId) {
    const guild = this.find(guildId);
    if (!guild) {
      if (this.bot.platform === "kook") {
        return User.createTemp(this.bot, userId, guildId);
      } else {
        console.error("[GuildManager]\u9891\u9053\u4FE1\u606F\u4E0D\u5B58\u5728\uFF0CguildId=", guildId, "userId=", userId);
        return;
      }
    }
    return guild.findUser(userId);
  }
  findChannel(channelId, guildId) {
    const guild = this.find(guildId);
    if (!guild) {
      console.error("[GuildManager]\u9891\u9053\u4FE1\u606F\u4E0D\u5B58\u5728\uFF0CguildId=", guildId, "channelId=", channelId);
      return;
    }
    const channel = guild.findChannel(channelId);
    if (!channel) {
      console.error("[GuildManager]\u5B50\u9891\u9053\u4FE1\u606F\u4E0D\u5B58\u5728\uFF0CguildId=", guildId, "channelId=", channelId);
      return;
    }
    return channel;
  }
  addGuildChannelByMessage(_guild, _channel) {
    if (!_guild || !_channel)
      return;
    const guildId = _guild.id;
    const channelId = _channel.id;
    let guild = this.guildsMap[guildId];
    if (!guild) {
      console.log("Create guild by message, id =", guildId);
      this.addGuild({ id: guildId, name: _guild.name ?? guildId, icon: _guild?.avatar ?? "" });
      guild = this.guildsMap[guildId];
    }
    const channel = guild.findChannel(channelId);
    if (!channel) {
      console.log("Create channel by message, id =", channelId);
      const type = Channel2.VALID_TYPES.includes(_channel.type) ? _channel.type : exports_lib2.Channel.Type.TEXT;
      guild.addChannel({ id: channelId, name: _channel.name ?? channelId, type });
    }
  }
  addOrUpdateUserByMessage(_guild, _author) {
    if (!_guild || !_author)
      return;
    this.addOrUpdateUser(_author, _guild.id);
  }
  async fetchGuilds() {
    this.guildsMap = {};
    try {
      const resp = await this.bot.api.getGuildList();
      const list3 = resp.data.slice(0, 10);
      import_mobx8.runInAction(() => {
        const guilds = list3.map((info) => new Guild(this.bot, info.id, info.name, info.avatar));
        this.guildsMap = guilds.reduce((obj, guild) => Object.assign(obj, { [guild.id]: guild }), {});
      });
    } catch (e4) {
      console.error("\u83B7\u53D6\u9891\u9053\u4FE1\u606F\u5931\u8D25", e4);
    }
  }
  addGuild({ id, name: name302, icon }) {
    this.guildsMap[id] = new Guild(this.bot, id, name302, icon);
  }
  addOrUpdateUser(author, guildId) {
    const guild = this.guildsMap[guildId];
    if (guild) {
      guild.addOrUpdateUser(author);
    }
  }
  deleteUser(userId, guildId) {
    const guild = this.guildsMap[guildId];
    if (guild) {
      guild.deleteUser(userId);
    }
  }
  initEventListeners() {
    this.bot.on("guild-member-added", (session) => this.addOrUpdateUser(session.author, session.guildId));
    this.bot.on("guild-member-updated", (session) => this.addOrUpdateUser(session.author, session.guildId));
    this.bot.on("guild-member-removed", (session) => this.deleteUser(session.userId, session.guildId));
  }
}

// src/service/log.ts
var import_mobx10 = __toESM(require_dist(), 1);

// src/service/logBackground.ts
var import_winston = __toESM(require_winston(), 1);
var import_mobx9 = __toESM(require_dist(), 1);

class LogBackground {
  bot;
  backgroundLogEnabled = {};
  backgroundLoggers = {};
  lastUser = {};
  constructor(bot) {
    import_mobx9.makeAutoObservable(this);
    this.bot = bot;
  }
  get platform() {
    return this.bot.platform;
  }
  getBackgroundLogger(guildId, channelId) {
    const channelUnionId = getChannelUnionId(this.platform, guildId, channelId);
    if (!this.backgroundLoggers[channelUnionId]) {
      const channel = this.bot.guilds.findChannel(channelId, guildId);
      const channelName = channel?.name ?? channelId;
      this.backgroundLoggers[channelUnionId] = import_winston.createLogger({
        format: backgroundLogFormatter,
        transports: new import_winston.transports.File({ filename: `${resolveRootDir("logs")}/${channelName}.txt`, maxsize: 1024 * 1024 })
      });
    }
    return this.backgroundLoggers[channelUnionId];
  }
  logIfNeed(guildId, channelId, logs) {
    const channelUnionId = getChannelUnionId(this.platform, guildId, channelId);
    if (this.backgroundLogEnabled[channelUnionId]) {
      const logger3 = this.getBackgroundLogger(guildId, channelId);
      logs.forEach((log4) => {
        logger3.info({ message: log4, lastUser: this.lastUser[channelUnionId] });
        this.lastUser[channelUnionId] = log4.username || log4.userId;
      });
    }
  }
  setEnabled(channelUnionId, enabled) {
    this.backgroundLogEnabled[channelUnionId] = enabled;
  }
  detectEnabled(userCommand) {
    if (userCommand.context.isDirect) {
      return [false, undefined];
    }
    const expression = userCommand.command;
    if (expression.startsWith("log")) {
      const content = expression.slice(3).trim();
      if (content.startsWith("on")) {
        this.setEnabled(userCommand.context.channelUnionId, true);
        return [true, "\u5DF2\u5F00\u542F\u5F53\u524D\u5B50\u9891\u9053\u7684\u540E\u53F0 log \u5F55\u5236"];
      } else if (content.startsWith("off")) {
        this.setEnabled(userCommand.context.channelUnionId, false);
        return [true, "\u5DF2\u5173\u95ED\u5F53\u524D\u5B50\u9891\u9053\u7684\u540E\u53F0 log \u5F55\u5236"];
      } else {
        return [true, "\u8BF7\u4F7F\u7528 .log on/off \u5F00\u542F\u6216\u5173\u95ED\u540E\u53F0 log \u5F55\u5236\u529F\u80FD"];
      }
    } else {
      return [false, undefined];
    }
  }
}
var backgroundLogFormatter = import_winston.format.printf((info) => {
  const message = info.message;
  const lastUser = info.lastUser;
  const user = message.username || message.userId;
  const content = message.msgType === "text" ? message.content : `[\u56FE\u7247](${message.content})`;
  if (user === lastUser) {
    return content;
  } else {
    const date2 = new Date(Number(message.timestamp));
    const pad2 = (v) => String(v).padStart(2, "0");
    const timestamp = `${date2.getFullYear()}-${pad2(date2.getMonth() + 1)}-${pad2(date2.getDate())} ${pad2(date2.getHours())}:${pad2(date2.getMinutes())}:${pad2(date2.getSeconds())}`;
    return `${user} ${timestamp}\n${content}`;
  }
});

// src/service/log.ts
class LogManager {
  bot;
  logBackground;
  get wss() {
    return this.bot.wss;
  }
  constructor(bot) {
    import_mobx10.makeAutoObservable(this);
    this.bot = bot;
    this.logBackground = new LogBackground(bot);
  }
  get platform() {
    return this.bot.platform;
  }
  onReceivedMessage(session) {
    this.convertElementsToLogs(session.elements, session.messageId, session.userId, session.author.name ?? session.userId, String(session.timestamp), session.channelId, session.guildId);
  }
  onPushMessage(guildId, channelId, msgId, content) {
    const elements = lib_default.parse(content);
    const userId = this.bot.botInfo?.id ?? "";
    const username = this.bot.botInfo?.username ?? userId;
    this.convertElementsToLogs(elements, msgId, userId, username, String(Date.now()), channelId, guildId);
  }
  convertElementsToLogs(elements, msgId, userId, username, timestamp, channelId, guildId) {
    const commonArgs = { msgId, userId, username, timestamp };
    const parsedLogs = [];
    let lastTextLog = undefined;
    const ensureLastLog = () => {
      if (!lastTextLog) {
        const newLog = { ...commonArgs, msgType: "text", content: "" };
        parsedLogs.push(newLog);
        lastTextLog = newLog;
      }
      return lastTextLog;
    };
    elements.forEach((element4) => {
      if (element4.type === "text") {
        const content = element4.attrs.content.trim();
        if (content) {
          const log4 = ensureLastLog();
          log4.content += content;
        }
      } else if (element4.type === "at") {
        const userId2 = element4.attrs.id;
        let name302;
        if (this.bot.botInfo?.id === userId2) {
          name302 = this.bot.botInfo?.username ?? userId2;
        } else {
          const user = this.bot.guilds.findUser(userId2, guildId);
          name302 = user?.name ?? userId2;
        }
        const content = `@${name302} `;
        const log4 = ensureLastLog();
        log4.content += content;
      } else if (element4.type === "img") {
        lastTextLog = undefined;
        parsedLogs.push({ ...commonArgs, msgType: "image", content: element4.attrs.src });
      }
    });
    parsedLogs.forEach((log4, i3) => {
      log4.msgId = `${log4.msgId}-${i3}`;
      this.pushToClients(guildId, channelId, log4);
    });
  }
  pushToClients(guildId, channelId, ...logs) {
    const channelUnionId = getChannelUnionId(this.platform, guildId, channelId);
    this.wss.sendToChannel(channelUnionId, {
      cmd: "log/push",
      success: true,
      data: logs
    });
    this.logBackground.logIfNeed(guildId, channelId, logs);
  }
  handleBackgroundLogCommand(command) {
    return this.logBackground.detectEnabled(command);
  }
}

// src/model/UserCommand.ts
var convertRoleIds = function(ids = []) {
  if (ids.includes("4")) {
    return "admin";
  } else if (ids.includes("2") || ids.includes("5")) {
    return "manager";
  } else {
    return "user";
  }
};

class UserCommand {
  session;
  command;
  substitute;
  bot;
  constructor(bot, session, command, substitute) {
    this.session = session;
    this.command = command;
    this.substitute = substitute;
    this.bot = bot;
  }
  get botId() {
    return this.bot.id;
  }
  get platform() {
    return this.bot.platform;
  }
  get realUser() {
    const session = this.session;
    const author = session.author;
    let username = author.nick ?? author.nickname ?? author.name ?? author.username;
    if (typeof username === "undefined") {
      const user = this.bot.guilds.findUser(session.userId, session.guildId);
      if (user)
        username = user.name;
    }
    return {
      userId: session.userId,
      username: username || session.userId
    };
  }
  get guildId() {
    const session = this.session;
    if (session.isDirect) {
      if (this.platform === "qqguild") {
        return session.guildId.split("_")[0];
      } else if (this.platform === "kook") {
        return session.guildId || "";
      }
    }
    return session.guildId;
  }
  get channelId() {
    const session = this.session;
    if (session.isDirect) {
      return session.channelId.split("_")[1];
    } else {
      return session.channelId;
    }
  }
  get context() {
    const session = this.session;
    const substitute = this.substitute;
    const realUser = this.realUser;
    return {
      botId: this.botId,
      userId: substitute?.userId ?? realUser.userId,
      username: substitute?.username ?? realUser.username,
      userRole: convertRoleIds(session.author.roles),
      msgId: session.messageId,
      platform: this.platform,
      guildId: this.guildId,
      channelId: this.channelId,
      channelUnionId: getChannelUnionId(this.platform, this.guildId, this.channelId),
      replyMsgId: session.event.message?.quote?.id,
      isDirect: session.isDirect,
      realUser
    };
  }
  static fromMessage(bot, session) {
    try {
      const elements = lib_default.transform(session.elements, ({ type, attrs }) => {
        if (type === "at") {
          return true;
        } else if (type === "text") {
          return !!attrs.content.trim();
        } else {
          return false;
        }
      }, session);
      if (elements.length === 0)
        throw new Error;
      const botUserId = bot.botInfo?.id;
      let isInstruction = false;
      if (botUserId && elements[0].type === "at" && elements[0].attrs.id === botUserId) {
        isInstruction = true;
        elements.splice(0, 1);
      }
      const firstElem = elements[0];
      if (firstElem && firstElem.type === "text") {
        let firstSpan = firstElem.attrs.content.trimStart();
        if (firstSpan.startsWith("/") || firstSpan.startsWith(".") || firstSpan.startsWith("\u3002")) {
          isInstruction = true;
          firstSpan = firstSpan.substring(1);
          firstElem.attrs.content = firstSpan;
        }
      }
      if (!isInstruction)
        throw new Error;
      let substitute = undefined;
      const lastElem = elements.at(-1);
      if (lastElem && lastElem.type === "at") {
        const userId = lastElem.attrs.id;
        const user = bot.guilds.findUser(userId, session.guildId);
        const username = user?.name ?? userId;
        substitute = { userId, username };
        elements.splice(-1, 1);
      }
      const fullExp = elements.map((elem) => elem.toString()).join("").trim();
      return new UserCommand(bot, session, fullExp, substitute);
    } catch (e4) {
      return;
    }
  }
  static fromReaction(bot, session) {
    return new UserCommand(bot, session, "", undefined);
  }
}

// src/service/commandHandler.ts
var import_lru_cache2 = __toESM(require_lru_cache2(), 1);
var import_mobx11 = __toESM(require_dist(), 1);
var detectInstruction = function(text) {
  const fullInstMatch = text.match(INST_WRAPPER_REGEX);
  if (fullInstMatch) {
    return fullInstMatch[1];
  }
  const skillMatch = text.match(ATTRIBUTE_REGEX);
  if (skillMatch) {
    const skill = skillMatch[0];
    const difficultyMatch = text.match(DIFFICULTY_REGEX);
    const difficulty = difficultyMatch ? difficultyMatch[0] : "";
    return difficulty + skill;
  }
  return null;
};

class CommandHandler {
  bot;
  msgCache = new import_lru_cache2.default({
    max: 50,
    fetchMethod: async (key) => {
      const [channelId, msgId] = key.split("$$$");
      const content = await (async () => {
        if (this.bot.platform === "qqguild") {
          return await qqguildV1_getMessageContent(this.bot, channelId, msgId);
        } else {
          const message = await this.bot.api.getMessage(channelId, msgId);
          return message.content;
        }
      })();
      const text = content?.trim();
      return { text, instruction: text ? undefined : null };
    }
  });
  opposedRollCache = new import_lru_cache2.default({ max: 50 });
  riListCache = {};
  constructor(bot) {
    import_mobx11.makeAutoObservable(this);
    this.bot = bot;
    RiProvider2.setState(new RiState(this.riListCache));
  }
  async handleCommand(userCommand) {
    const result = await dispatchCommand(userCommand, {
      getOpposedRoll: (c) => this.getOpposedRoll(c),
      interceptor: async (c) => this.bot.logs.handleBackgroundLogCommand(c)
    });
    await this.handleDispatchResult(userCommand, result);
  }
  async handleReaction(userCommand) {
    const result = await dispatchReaction(userCommand, {
      getReactionCommand: (c) => this.getInstruction(c)
    });
    if (result) {
      await this.handleDispatchResult(userCommand, result);
    }
  }
  async manualDiceRollFromWeb(wsClient, { expression, cardData }) {
    const { listenToChannelUnionId: channelUnionId, listenToGuildId: guildId, listenToChannelId: channelId } = wsClient;
    const config8 = this.bot.wss.config.getChannelConfig(channelUnionId);
    const userCommand = {
      command: expression,
      context: {
        botId: this.bot.id,
        userId: MockSystemUserId,
        username: cardData.name,
        userRole: "admin",
        platform: this.bot.platform,
        guildId,
        channelId,
        channelUnionId,
        isDirect: false,
        realUser: {
          userId: config8.botOwner ?? MockSystemUserId,
          username: cardData.name
        }
      }
    };
    CardProvider2.registerCard(MockSystemCardId, cardData);
    CardProvider2.linkCard(channelUnionId, MockSystemCardId, MockSystemUserId);
    const result = await dispatchCommand(userCommand);
    await this.handleDispatchResult(userCommand, result);
  }
  async handleDispatchResult(userCommand, result) {
    let msgSent = false;
    switch (result.type) {
      case "customReply": {
        if (result.reply) {
          this.sendMessage(userCommand, result.reply);
        }
        msgSent = true;
        break;
      }
      case "interceptor":
        if (typeof result.payload === "string") {
          this.sendMessage(userCommand, result.payload);
          msgSent = true;
        }
        break;
      case "dice": {
        if (result.diceRoll) {
          const { context: context2 } = userCommand;
          const roll = result.diceRoll;
          if (roll instanceof StandardDiceRoll && roll.hidden && !context2.isDirect) {
            const channelMsg = roll.t("roll.hidden", { "": roll.description });
            this.sendMessage(userCommand, channelMsg);
            this.sendMessage(userCommand, roll.output, context2.realUser.userId);
          } else {
            const replyMsg = await this.sendMessage(userCommand, roll.output);
            if (replyMsg && roll instanceof StandardDiceRoll && roll.eligibleForOpposedRoll) {
              this.opposedRollCache.set(replyMsg.id, roll);
            }
          }
          msgSent = true;
        }
        if (result.affectedCards) {
          result.affectedCards.forEach((card12) => {
            this.bot.wss.cards.saveCard(card12);
          });
        }
        break;
      }
    }
    if (!msgSent && userCommand.context.isDirect) {
      const selfNick = this.bot.botInfo?.username || "";
      await this.sendMessage(userCommand, `${selfNick}\u5728\u7684\u8BF4`);
    }
  }
  async getOpposedRoll(userCommand) {
    const replyMsgId = userCommand.context.replyMsgId;
    return replyMsgId ? this.opposedRollCache.get(replyMsgId) : undefined;
  }
  async getInstruction(userCommand) {
    const { channelId, msgId } = userCommand.context;
    if (!msgId)
      return;
    const cacheMsg = await this.msgCache.fetch(`${channelId}\$\$\$${msgId}`);
    if (!cacheMsg || cacheMsg.instruction === null)
      return;
    if (typeof cacheMsg.instruction === "undefined") {
      cacheMsg.instruction = detectInstruction(cacheMsg.text || "");
    }
    return cacheMsg.instruction ?? undefined;
  }
  async sendMessage(userCommand, content, forceUserId) {
    let { isDirect, userId } = userCommand.context;
    const { channelId, guildId } = userCommand.context;
    if (forceUserId) {
      isDirect = true;
      userId = forceUserId;
    }
    if (isDirect) {
      const user = this.bot.guilds.findUser(userId, guildId);
      if (!user) {
        console.warn(`[SendMessage] \u627E\u4E0D\u5230\u7528\u6237, userId=${userId}, guildId=${guildId}`);
        return;
      }
      return user.sendMessage(content, userCommand.session);
    } else {
      const channel = this.bot.guilds.findChannel(channelId, guildId);
      if (!channel) {
        console.warn(`[SendMessage] \u627E\u4E0D\u5230\u9891\u9053, channelId=${channelId}, guildId=${guildId}`);
        return;
      }
      return channel.sendMessage(content, userCommand.session);
    }
  }
}
var MockSystemCardId = "__temp_card_id__";
var MockSystemUserId = "__temp_user_id__";

class RiState extends DefaultRiState {
  updateRiList(channelUnionId, change) {
    super.updateRiList(channelUnionId, change.filter((item) => item.id !== MockSystemUserId));
  }
}
var ATTRIBUTE_REGEX = new RegExp("(\u529B\u91CF|\u4F53\u8D28|\u4F53\u578B|\u654F\u6377|\u5916\u8C8C|\u667A\u529B|\u7075\u611F|\u610F\u5FD7|\u6559\u80B2|\u77E5\u8BC6|\u7406\u667A|\u5E78\u8FD0|\u8FD0\u6C14|\u4F1A\u8BA1|\u4EBA\u7C7B\u5B66|\u4F30\u4EF7|\u8003\u53E4\u5B66|\u9B45\u60D1|\u6500\u722C|\u8BA1\u7B97\u673A|\u7535\u8111|\u4FE1\u7528|\u4FE1\u8A89|\u514B\u82CF\u9C81|\u4E54\u88C5|\u95EA\u907F|\u9A7E\u9A76|\u6C7D\u8F66|\u7535\u6C14\u7EF4\u4FEE|\u7535\u5B50\u5B66|\u8BDD\u672F|\u683C\u6597|\u5C04\u51FB|\u6025\u6551|\u5386\u53F2|\u6050\u5413|\u8DF3\u8DC3|\u6BCD\u8BED|\u6CD5\u5F8B|\u56FE\u4E66\u9986|\u8046\u542C|\u9501\u5320|\u5F00\u9501|\u64AC\u9501|\u673A\u68B0\u7EF4\u4FEE|\u533B\u5B66|\u535A\u7269\u5B66|\u9886\u822A|\u5BFC\u822A|\u795E\u79D8\u5B66|\u91CD\u578B|\u8BF4\u670D|\u7CBE\u795E\u5206\u6790|\u5FC3\u7406\u5B66|\u9A91\u672F|\u5999\u624B|\u4FA6\u67E5|\u4FA6\u5BDF|\u6F5C\u884C|\u6E38\u6CF3|\u6295\u63B7|\u8FFD\u8E2A|sc|SC|\u611F\u77E5|\u9B45\u529B|\u8FD0\u52A8|\u4F53\u64CD|\u5DE7\u624B|\u9690\u533F|\u5965\u79D8|\u8C03\u67E5|\u81EA\u7136|\u5B97\u6559|\u9A6F\u517D|\u6D1E\u6089|\u533B\u7597|\u5BDF\u89C9|\u751F\u5B58|\u6C42\u751F|\u6B3A\u7792|\u5A01\u5413|\u8868\u6F14|\u6E38\u8BF4|\u533B\u836F)", "g");
var DIFFICULTY_REGEX = /(||)/;
var INST_WRAPPER_REGEX = /(.+)/;

// src/adapter/Bot.ts
class Bot2 {
  config;
  context = new Context4;
  api;
  _fork;
  wss;
  botInfo = null;
  guilds;
  logs;
  commandHandler;
  listeningChannels = new Map;
  constructor(config8, wss) {
    import_mobx12.makeAutoObservable(this, { listeningChannels: false });
    this.wss = wss;
    this.config = config8;
    this._fork = this.context.plugin(adapterPlugin(config8.platform), adapterConfig(config8));
    this.api = this.context.bots.find((bot) => bot.platform === config8.platform);
    this.fetchBotInfo();
    this.guilds = new GuildManager(this);
    this.logs = new LogManager(this);
    this.commandHandler = new CommandHandler(this);
    this.on("message", async (session) => {
      if (session.userId === this.botInfo?.id)
        return;
      if (!session.isDirect) {
        this.guilds.addGuildChannelByMessage(session.event.guild, session.event.channel);
        this.guilds.addOrUpdateUserByMessage(session.event.guild, session.author);
        if (this.isListening(session.channelId, session.guildId)) {
          this.logs.onReceivedMessage(session);
          if (this.platform === "qqguild") {
            const channel = this.guilds.findChannel(session.channelId, session.guildId);
            channel && (channel.lastSession = session);
          }
          const userCommand = UserCommand.fromMessage(this, session);
          if (!userCommand)
            return;
          await this.commandHandler.handleCommand(userCommand);
        }
      } else {
        if (this.platform === "qqguild") {
          const srcGuildId = session.guildId.split("_")[0];
          const user = this.guilds.findUser(session.userId, srcGuildId);
          user && (user.lastSession = session);
        }
        const userCommand = UserCommand.fromMessage(this, session);
        if (!userCommand)
          return;
        await this.commandHandler.handleCommand(userCommand);
      }
    });
    this.on("reaction-added", async (session) => {
      if (this.isListening(session.channelId, session.guildId)) {
        const userCommand = UserCommand.fromReaction(this, session);
        await this.commandHandler.handleReaction(userCommand);
      }
    });
  }
  get platform() {
    return this.config.platform;
  }
  get appid() {
    return this.config.appid;
  }
  get id() {
    return getBotId(this.platform, this.appid);
  }
  listenTo(channelId, guildId) {
    let set = this.listeningChannels.get(guildId);
    if (!set) {
      set = new Set;
      this.listeningChannels.set(guildId, set);
    }
    set.add(channelId);
  }
  isListening(channelId, guildId) {
    return !!this.listeningChannels.get(guildId)?.has(channelId);
  }
  async fetchBotInfo() {
    try {
      const user = (await this.api.getLogin()).user;
      import_mobx12.runInAction(() => {
        this.botInfo = {
          id: user.id,
          username: (user.name ?? "").replace(/-$/, ""),
          avatar: user.avatar ?? ""
        };
      });
    } catch (e4) {
      console.error("\u83B7\u53D6\u673A\u5668\u4EBA\u4FE1\u606F\u5931\u8D25", e4);
    }
  }
  async start() {
    console.log("\u5F00\u59CB\u8FDE\u63A5\u670D\u52A1\u5668", this.id);
    await this.context.start();
    console.log("\u8FDE\u63A5\u670D\u52A1\u5668\u5B8C\u6210", this.id);
  }
  async disconnect() {
    this._fork.dispose();
    await this.context.stop();
  }
  sameConfigWith(anotherConfig) {
    return import_lodash3.isEqual(this.config, anotherConfig);
  }
  on(name302, listener) {
    this.context.on(name302, listener);
  }
}

// src/adapter/BotManager.ts
class BotManager {
  wss;
  bots = new Map;
  constructor(wss) {
    this.wss = wss;
  }
  async login(config8) {
    const bot = this.find(getBotId(config8.platform, config8.appid));
    if (bot && bot.sameConfigWith(config8)) {
      console.log("\u5DF2\u5B58\u5728\u76F8\u540C\u7684\u673A\u5668\u4EBA\u8FDE\u63A5\uFF0C\u53EF\u76F4\u63A5\u590D\u7528");
      return bot;
    }
    if (bot) {
      console.log("\u673A\u5668\u4EBA\u8FDE\u63A5\u914D\u7F6E\u53D8\u66F4\uFF0C\u91CD\u65B0\u8FDE\u63A5...");
      await bot.disconnect();
    }
    const newBot = new Bot2(config8, this.wss);
    this.bots.set(newBot.id, newBot);
    await newBot.start();
    return newBot;
  }
  find(id) {
    if (!id) {
      return;
    }
    return this.bots.get(id);
  }
}

// ../../node_modules/crossws/dist/shared/crossws.a5db571c.mjs
import require$$0$3 from "events";
import require$$1$1 from "https";
import require$$2 from "http";
import require$$3 from "net";
import require$$4 from "tls";
import require$$1 from "crypto";
import require$$0$2 from "stream";
import require$$7 from "url";
import require$$0 from "zlib";
import require$$0$1 from "buffer";
var getDefaultExportFromCjs = function(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
};
var concat$1 = function(list3, totalLength) {
  if (list3.length === 0)
    return EMPTY_BUFFER$3;
  if (list3.length === 1)
    return list3[0];
  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;
  for (let i3 = 0;i3 < list3.length; i3++) {
    const buf = list3[i3];
    target.set(buf, offset);
    offset += buf.length;
  }
  if (offset < totalLength) {
    return new FastBuffer$2(target.buffer, target.byteOffset, offset);
  }
  return target;
};
var _mask = function(source, mask, output, offset, length) {
  for (let i3 = 0;i3 < length; i3++) {
    output[offset + i3] = source[i3] ^ mask[i3 & 3];
  }
};
var _unmask = function(buffer, mask) {
  for (let i3 = 0;i3 < buffer.length; i3++) {
    buffer[i3] ^= mask[i3 & 3];
  }
};
var toArrayBuffer$1 = function(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }
  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
};
var toBuffer$2 = function(data2) {
  toBuffer$2.readOnly = true;
  if (Buffer.isBuffer(data2))
    return data2;
  let buf;
  if (data2 instanceof ArrayBuffer) {
    buf = new FastBuffer$2(data2);
  } else if (ArrayBuffer.isView(data2)) {
    buf = new FastBuffer$2(data2.buffer, data2.byteOffset, data2.byteLength);
  } else {
    buf = Buffer.from(data2);
    toBuffer$2.readOnly = false;
  }
  return buf;
};
var deflateOnData = function(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
};
var inflateOnData = function(chunk) {
  this[kTotalLength] += chunk.length;
  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
    this[kBuffers].push(chunk);
    return;
  }
  this[kError$1] = new RangeError("Max payload size exceeded");
  this[kError$1].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
  this[kError$1][kStatusCode$2] = 1009;
  this.removeListener("data", inflateOnData);
  this.reset();
};
var inflateOnError = function(err) {
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode$2] = 1007;
  this[kCallback](err);
};
var isValidStatusCode$2 = function(code) {
  return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
};
var _isValidUTF8 = function(buf) {
  const len = buf.length;
  let i3 = 0;
  while (i3 < len) {
    if ((buf[i3] & 128) === 0) {
      i3++;
    } else if ((buf[i3] & 224) === 192) {
      if (i3 + 1 === len || (buf[i3 + 1] & 192) !== 128 || (buf[i3] & 254) === 192) {
        return false;
      }
      i3 += 2;
    } else if ((buf[i3] & 240) === 224) {
      if (i3 + 2 >= len || (buf[i3 + 1] & 192) !== 128 || (buf[i3 + 2] & 192) !== 128 || buf[i3] === 224 && (buf[i3 + 1] & 224) === 128 || buf[i3] === 237 && (buf[i3 + 1] & 224) === 160) {
        return false;
      }
      i3 += 3;
    } else if ((buf[i3] & 248) === 240) {
      if (i3 + 3 >= len || (buf[i3 + 1] & 192) !== 128 || (buf[i3 + 2] & 192) !== 128 || (buf[i3 + 3] & 192) !== 128 || buf[i3] === 240 && (buf[i3 + 1] & 240) === 128 || buf[i3] === 244 && buf[i3 + 1] > 143 || buf[i3] > 244) {
        return false;
      }
      i3 += 4;
    } else {
      return false;
    }
  }
  return true;
};
var queueMicrotaskShim = function(cb) {
  promise.then(cb).catch(throwErrorNextTick);
};
var throwError = function(err) {
  throw err;
};
var throwErrorNextTick = function(err) {
  process.nextTick(throwError, err);
};
var callListener = function(listener, thisArg, event) {
  if (typeof listener === "object" && listener.handleEvent) {
    listener.handleEvent.call(listener, event);
  } else {
    listener.call(thisArg, event);
  }
};
var push2 = function(dest, name302, elem) {
  if (dest[name302] === undefined)
    dest[name302] = [elem];
  else
    dest[name302].push(elem);
};
var parse$1 = function(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i3 = 0;
  for (;i3 < header.length; i3++) {
    code = header.charCodeAt(i3);
    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i3;
      } else if (i3 !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i3;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i3}`);
        }
        if (end === -1)
          end = i3;
        const name302 = header.slice(start, end);
        if (code === 44) {
          push2(offers, name302, params);
          params = Object.create(null);
        } else {
          extensionName = name302;
        }
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i3}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i3;
      } else if (code === 32 || code === 9) {
        if (end === -1 && start !== -1)
          end = i3;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i3}`);
        }
        if (end === -1)
          end = i3;
        push2(params, header.slice(start, end), true);
        if (code === 44) {
          push2(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }
        start = end = -1;
      } else if (code === 61 && start !== -1 && end === -1) {
        paramName = header.slice(start, i3);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i3}`);
      }
    } else {
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i3}`);
        }
        if (start === -1)
          start = i3;
        else if (!mustUnescape)
          mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1)
            start = i3;
        } else if (code === 34 && start !== -1) {
          inQuotes = false;
          end = i3;
        } else if (code === 92) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i3}`);
        }
      } else if (code === 34 && header.charCodeAt(i3 - 1) === 61) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i3;
      } else if (start !== -1 && (code === 32 || code === 9)) {
        if (end === -1)
          end = i3;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i3}`);
        }
        if (end === -1)
          end = i3;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, "");
          mustUnescape = false;
        }
        push2(params, paramName, value);
        if (code === 44) {
          push2(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }
        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i3}`);
      }
    }
  }
  if (start === -1 || inQuotes || code === 32 || code === 9) {
    throw new SyntaxError("Unexpected end of input");
  }
  if (end === -1)
    end = i3;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push2(offers, token, params);
  } else {
    if (paramName === undefined) {
      push2(params, token, true);
    } else if (mustUnescape) {
      push2(params, paramName, token.replace(/\\/g, ""));
    } else {
      push2(params, paramName, token);
    }
    push2(offers, extensionName, params);
  }
  return offers;
};
var format$1 = function(extensions) {
  return Object.keys(extensions).map((extension) => {
    let configurations = extensions[extension];
    if (!Array.isArray(configurations))
      configurations = [configurations];
    return configurations.map((params) => {
      return [extension].concat(Object.keys(params).map((k) => {
        let values = params[k];
        if (!Array.isArray(values))
          values = [values];
        return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
      })).join("; ");
    }).join(", ");
  }).join(", ");
};
var initAsClient = function(websocket2, address, protocols, options) {
  const opts = {
    allowSynchronousEvents: false,
    autoPong: true,
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: "GET",
    host: undefined,
    path: undefined,
    port: undefined
  };
  websocket2._autoPong = opts.autoPong;
  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
  }
  let parsedUrl;
  if (address instanceof URL2) {
    parsedUrl = address;
  } else {
    try {
      parsedUrl = new URL2(address);
    } catch (e4) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
  }
  if (parsedUrl.protocol === "http:") {
    parsedUrl.protocol = "ws:";
  } else if (parsedUrl.protocol === "https:") {
    parsedUrl.protocol = "wss:";
  }
  websocket2._url = parsedUrl.href;
  const isSecure = parsedUrl.protocol === "wss:";
  const isIpcUrl = parsedUrl.protocol === "ws+unix:";
  let invalidUrlMessage;
  if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
    invalidUrlMessage = 'The URL\'s protocol must be one of "ws:", "wss:", ' + '"http:", "https", or "ws+unix:"';
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = "The URL contains a fragment identifier";
  }
  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);
    if (websocket2._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket2, err);
      return;
    }
  }
  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString("base64");
  const request = isSecure ? https.request : http.request;
  const protocolSet = new Set;
  let perMessageDeflate;
  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    "Sec-WebSocket-Version": opts.protocolVersion,
    "Sec-WebSocket-Key": key,
    Connection: "Upgrade",
    Upgrade: "websocket"
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;
  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate2(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
    opts.headers["Sec-WebSocket-Extensions"] = format7({
      [PerMessageDeflate2.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol4 of protocols) {
      if (typeof protocol4 !== "string" || !subprotocolRegex.test(protocol4) || protocolSet.has(protocol4)) {
        throw new SyntaxError("An invalid or duplicated subprotocol was specified");
      }
      protocolSet.add(protocol4);
    }
    opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers["Sec-WebSocket-Origin"] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }
  if (isIpcUrl) {
    const parts = opts.path.split(":");
    opts.socketPath = parts[0];
    opts.path = parts[1];
  }
  let req;
  if (opts.followRedirects) {
    if (websocket2._redirects === 0) {
      websocket2._originalIpc = isIpcUrl;
      websocket2._originalSecure = isSecure;
      websocket2._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
      const headers = options && options.headers;
      options = { ...options, headers: {} };
      if (headers) {
        for (const [key2, value] of Object.entries(headers)) {
          options.headers[key2.toLowerCase()] = value;
        }
      }
    } else if (websocket2.listenerCount("redirect") === 0) {
      const isSameHost = isIpcUrl ? websocket2._originalIpc ? opts.socketPath === websocket2._originalHostOrSocketPath : false : websocket2._originalIpc ? false : parsedUrl.host === websocket2._originalHostOrSocketPath;
      if (!isSameHost || websocket2._originalSecure && !isSecure) {
        delete opts.headers.authorization;
        delete opts.headers.cookie;
        if (!isSameHost)
          delete opts.headers.host;
        opts.auth = undefined;
      }
    }
    if (opts.auth && !options.headers.authorization) {
      options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
    }
    req = websocket2._req = request(opts);
    if (websocket2._redirects) {
      websocket2.emit("redirect", websocket2.url, req);
    }
  } else {
    req = websocket2._req = request(opts);
  }
  if (opts.timeout) {
    req.on("timeout", () => {
      abortHandshake(websocket2, req, "Opening handshake has timed out");
    });
  }
  req.on("error", (err) => {
    if (req === null || req[kAborted])
      return;
    req = websocket2._req = null;
    emitErrorAndClose(websocket2, err);
  });
  req.on("response", (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;
    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
      if (++websocket2._redirects > opts.maxRedirects) {
        abortHandshake(websocket2, req, "Maximum redirects exceeded");
        return;
      }
      req.abort();
      let addr;
      try {
        addr = new URL2(location, address);
      } catch (e4) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose(websocket2, err);
        return;
      }
      initAsClient(websocket2, addr, protocols, options);
    } else if (!websocket2.emit("unexpected-response", req, res)) {
      abortHandshake(websocket2, req, `Unexpected server response: ${res.statusCode}`);
    }
  });
  req.on("upgrade", (res, socket, head) => {
    websocket2.emit("upgrade", res);
    if (websocket2.readyState !== WebSocket4.CONNECTING)
      return;
    req = websocket2._req = null;
    if (res.headers.upgrade.toLowerCase() !== "websocket") {
      abortHandshake(websocket2, socket, "Invalid Upgrade header");
      return;
    }
    const digest = createHash("sha1").update(key + GUID).digest("base64");
    if (res.headers["sec-websocket-accept"] !== digest) {
      abortHandshake(websocket2, socket, "Invalid Sec-WebSocket-Accept header");
      return;
    }
    const serverProt = res.headers["sec-websocket-protocol"];
    let protError;
    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = "Server sent a subprotocol but none was requested";
      } else if (!protocolSet.has(serverProt)) {
        protError = "Server sent an invalid subprotocol";
      }
    } else if (protocolSet.size) {
      protError = "Server sent no subprotocol";
    }
    if (protError) {
      abortHandshake(websocket2, socket, protError);
      return;
    }
    if (serverProt)
      websocket2._protocol = serverProt;
    const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        const message = "Server sent a Sec-WebSocket-Extensions header but no extension " + "was requested";
        abortHandshake(websocket2, socket, message);
        return;
      }
      let extensions;
      try {
        extensions = parse4(secWebSocketExtensions);
      } catch (err) {
        const message = "Invalid Sec-WebSocket-Extensions header";
        abortHandshake(websocket2, socket, message);
        return;
      }
      const extensionNames = Object.keys(extensions);
      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate2.extensionName) {
        const message = "Server indicated an extension that was not requested";
        abortHandshake(websocket2, socket, message);
        return;
      }
      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate2.extensionName]);
      } catch (err) {
        const message = "Invalid Sec-WebSocket-Extensions header";
        abortHandshake(websocket2, socket, message);
        return;
      }
      websocket2._extensions[PerMessageDeflate2.extensionName] = perMessageDeflate;
    }
    websocket2.setSocket(socket, head, {
      allowSynchronousEvents: opts.allowSynchronousEvents,
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });
  if (opts.finishRequest) {
    opts.finishRequest(req, websocket2);
  } else {
    req.end();
  }
};
var emitErrorAndClose = function(websocket2, err) {
  websocket2._readyState = WebSocket4.CLOSING;
  websocket2.emit("error", err);
  websocket2.emitClose();
};
var netConnect = function(options) {
  options.path = options.socketPath;
  return net.connect(options);
};
var tlsConnect = function(options) {
  options.path = undefined;
  if (!options.servername && options.servername !== "") {
    options.servername = net.isIP(options.host) ? "" : options.host;
  }
  return tls.connect(options);
};
var abortHandshake = function(websocket2, stream3, message) {
  websocket2._readyState = WebSocket4.CLOSING;
  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);
  if (stream3.setHeader) {
    stream3[kAborted] = true;
    stream3.abort();
    if (stream3.socket && !stream3.socket.destroyed) {
      stream3.socket.destroy();
    }
    process.nextTick(emitErrorAndClose, websocket2, err);
  } else {
    stream3.destroy(err);
    stream3.once("error", websocket2.emit.bind(websocket2, "error"));
    stream3.once("close", websocket2.emitClose.bind(websocket2));
  }
};
var sendAfterClose = function(websocket2, data2, cb) {
  if (data2) {
    const length = toBuffer(data2).length;
    if (websocket2._socket)
      websocket2._sender._bufferedBytes += length;
    else
      websocket2._bufferedAmount += length;
  }
  if (cb) {
    const err = new Error(`WebSocket is not open: readyState ${websocket2.readyState} ` + `(${readyStates[websocket2.readyState]})`);
    process.nextTick(cb, err);
  }
};
var receiverOnConclude = function(code, reason) {
  const websocket2 = this[kWebSocket];
  websocket2._closeFrameReceived = true;
  websocket2._closeMessage = reason;
  websocket2._closeCode = code;
  if (websocket2._socket[kWebSocket] === undefined)
    return;
  websocket2._socket.removeListener("data", socketOnData);
  process.nextTick(resume, websocket2._socket);
  if (code === 1005)
    websocket2.close();
  else
    websocket2.close(code, reason);
};
var receiverOnDrain = function() {
  const websocket2 = this[kWebSocket];
  if (!websocket2.isPaused)
    websocket2._socket.resume();
};
var receiverOnError = function(err) {
  const websocket2 = this[kWebSocket];
  if (websocket2._socket[kWebSocket] !== undefined) {
    websocket2._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket2._socket);
    websocket2.close(err[kStatusCode]);
  }
  websocket2.emit("error", err);
};
var receiverOnFinish = function() {
  this[kWebSocket].emitClose();
};
var receiverOnMessage = function(data2, isBinary2) {
  this[kWebSocket].emit("message", data2, isBinary2);
};
var receiverOnPing = function(data2) {
  const websocket2 = this[kWebSocket];
  if (websocket2._autoPong)
    websocket2.pong(data2, !this._isServer, NOOP);
  websocket2.emit("ping", data2);
};
var receiverOnPong = function(data2) {
  this[kWebSocket].emit("pong", data2);
};
var resume = function(stream3) {
  stream3.resume();
};
var socketOnClose = function() {
  const websocket2 = this[kWebSocket];
  this.removeListener("close", socketOnClose);
  this.removeListener("data", socketOnData);
  this.removeListener("end", socketOnEnd);
  websocket2._readyState = WebSocket4.CLOSING;
  let chunk;
  if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {
    websocket2._receiver.write(chunk);
  }
  websocket2._receiver.end();
  this[kWebSocket] = undefined;
  clearTimeout(websocket2._closeTimer);
  if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {
    websocket2.emitClose();
  } else {
    websocket2._receiver.on("error", receiverOnFinish);
    websocket2._receiver.on("finish", receiverOnFinish);
  }
};
var socketOnData = function(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
};
var socketOnEnd = function() {
  const websocket2 = this[kWebSocket];
  websocket2._readyState = WebSocket4.CLOSING;
  websocket2._receiver.end();
  this.end();
};
var socketOnError = function() {
  const websocket2 = this[kWebSocket];
  this.removeListener("error", socketOnError);
  this.on("error", NOOP);
  if (websocket2) {
    websocket2._readyState = WebSocket4.CLOSING;
    this.destroy();
  }
};
var bufferUtil$1 = { exports: {} };
var constants3 = {
  BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
  kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
  kListener: Symbol("kListener"),
  kStatusCode: Symbol("status-code"),
  kWebSocket: Symbol("websocket"),
  NOOP: () => {
  }
};
var unmask$1;
var mask;
var { EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants3;
var FastBuffer$2 = Buffer[Symbol.species];
bufferUtil$1.exports = {
  concat: concat$1,
  mask: _mask,
  toArrayBuffer: toArrayBuffer$1,
  toBuffer: toBuffer$2,
  unmask: _unmask
};
if (!process.env.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil = (()=>{throw new Error(`Cannot require module "bufferutil"`);})();
    mask = bufferUtil$1.exports.mask = function(source, mask2, output, offset, length) {
      if (length < 48)
        _mask(source, mask2, output, offset, length);
      else
        bufferUtil.mask(source, mask2, output, offset, length);
    };
    unmask$1 = bufferUtil$1.exports.unmask = function(buffer, mask2) {
      if (buffer.length < 32)
        _unmask(buffer, mask2);
      else
        bufferUtil.unmask(buffer, mask2);
    };
  } catch (e4) {
  }
}
var bufferUtilExports = bufferUtil$1.exports;
var kDone = Symbol("kDone");
var kRun = Symbol("kRun");
var Limiter$1 = class Limiter {
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }
  [kRun]() {
    if (this.pending === this.concurrency)
      return;
    if (this.jobs.length) {
      const job = this.jobs.shift();
      this.pending++;
      job(this[kDone]);
    }
  }
};
var limiter = Limiter$1;
var zlib = require$$0;
var bufferUtil = bufferUtilExports;
var Limiter2 = limiter;
var { kStatusCode: kStatusCode$2 } = constants3;
var FastBuffer$1 = Buffer[Symbol.species];
var TRAILER = Buffer.from([0, 0, 255, 255]);
var kPerMessageDeflate = Symbol("permessage-deflate");
var kTotalLength = Symbol("total-length");
var kCallback = Symbol("callback");
var kBuffers = Symbol("buffers");
var kError$1 = Symbol("error");
var zlibLimiter;
var PerMessageDeflate$3 = class PerMessageDeflate {
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;
    this.params = null;
    if (!zlibLimiter) {
      const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
      zlibLimiter = new Limiter2(concurrency);
    }
  }
  static get extensionName() {
    return "permessage-deflate";
  }
  offer() {
    const params = {};
    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }
    return params;
  }
  accept(configurations) {
    configurations = this.normalizeParams(configurations);
    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
    return this.params;
  }
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }
    if (this._deflate) {
      const callback = this._deflate[kCallback];
      this._deflate.close();
      this._deflate = null;
      if (callback) {
        callback(new Error("The deflate stream was closed while data was being processed"));
      }
    }
  }
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
        return false;
      }
      return true;
    });
    if (!accepted) {
      throw new Error("None of the extension offers can be accepted");
    }
    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === "number") {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === "number") {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
      delete accepted.client_max_window_bits;
    }
    return accepted;
  }
  acceptAsClient(response) {
    const params = response[0];
    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }
    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === "number") {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
      throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
    }
    return params;
  }
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];
        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }
        value = value[0];
        if (key === "client_max_window_bits") {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
          }
        } else if (key === "server_max_window_bits") {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
          }
          value = num;
        } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
          if (value !== true) {
            throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }
        params[key] = value;
      });
    });
    return configurations;
  }
  decompress(data2, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data2, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }
  compress(data2, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data2, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }
  _decompress(data2, fin, callback) {
    const endpoint = this._isServer ? "client" : "server";
    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on("error", inflateOnError);
      this._inflate.on("data", inflateOnData);
    }
    this._inflate[kCallback] = callback;
    this._inflate.write(data2);
    if (fin)
      this._inflate.write(TRAILER);
    this._inflate.flush(() => {
      const err = this._inflate[kError$1];
      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }
      const data3 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }
      callback(null, data3);
    });
  }
  _compress(data2, fin, callback) {
    const endpoint = this._isServer ? "server" : "client";
    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });
      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];
      this._deflate.on("data", deflateOnData);
    }
    this._deflate[kCallback] = callback;
    this._deflate.write(data2);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        return;
      }
      let data3 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
      if (fin) {
        data3 = new FastBuffer$1(data3.buffer, data3.byteOffset, data3.length - 4);
      }
      this._deflate[kCallback] = null;
      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];
      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }
      callback(null, data3);
    });
  }
};
var permessageDeflate = PerMessageDeflate$3;
var validation = { exports: {} };
var isValidUTF8_1;
var { isUtf8 } = require$$0$1;
var tokenChars$1 = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0
];
validation.exports = {
  isValidStatusCode: isValidStatusCode$2,
  isValidUTF8: _isValidUTF8,
  tokenChars: tokenChars$1
};
if (isUtf8) {
  isValidUTF8_1 = validation.exports.isValidUTF8 = function(buf) {
    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
  };
} else if (!process.env.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF8 = (()=>{throw new Error(`Cannot require module "utf-8-validate"`);})();
    isValidUTF8_1 = validation.exports.isValidUTF8 = function(buf) {
      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
    };
  } catch (e4) {
  }
}
var validationExports = validation.exports;
var { Writable } = require$$0$2;
var PerMessageDeflate$2 = permessageDeflate;
var {
  BINARY_TYPES: BINARY_TYPES$1,
  EMPTY_BUFFER: EMPTY_BUFFER$2,
  kStatusCode: kStatusCode$1,
  kWebSocket: kWebSocket$1
} = constants3;
var { concat: concat4, toArrayBuffer, unmask } = bufferUtilExports;
var { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validationExports;
var FastBuffer = Buffer[Symbol.species];
var promise = Promise.resolve();
var queueTask = typeof queueMicrotask === "function" ? queueMicrotask : queueMicrotaskShim;
var GET_INFO = 0;
var GET_PAYLOAD_LENGTH_16 = 1;
var GET_PAYLOAD_LENGTH_64 = 2;
var GET_MASK = 3;
var GET_DATA = 4;
var INFLATING = 5;
var DEFER_EVENT = 6;
var Receiver$1 = class Receiver2 extends Writable {
  constructor(options = {}) {
    super();
    this._allowSynchronousEvents = !!options.allowSynchronousEvents;
    this._binaryType = options.binaryType || BINARY_TYPES$1[0];
    this._extensions = options.extensions || {};
    this._isServer = !!options.isServer;
    this._maxPayload = options.maxPayload | 0;
    this._skipUTF8Validation = !!options.skipUTF8Validation;
    this[kWebSocket$1] = undefined;
    this._bufferedBytes = 0;
    this._buffers = [];
    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;
    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];
    this._errored = false;
    this._loop = false;
    this._state = GET_INFO;
  }
  _write(chunk, encoding, cb) {
    if (this._opcode === 8 && this._state == GET_INFO)
      return cb();
    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }
  consume(n) {
    this._bufferedBytes -= n;
    if (n === this._buffers[0].length)
      return this._buffers.shift();
    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
      return new FastBuffer(buf.buffer, buf.byteOffset, n);
    }
    const dst = Buffer.allocUnsafe(n);
    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;
      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
      }
      n -= buf.length;
    } while (n > 0);
    return dst;
  }
  startLoop(cb) {
    this._loop = true;
    do {
      switch (this._state) {
        case GET_INFO:
          this.getInfo(cb);
          break;
        case GET_PAYLOAD_LENGTH_16:
          this.getPayloadLength16(cb);
          break;
        case GET_PAYLOAD_LENGTH_64:
          this.getPayloadLength64(cb);
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          this.getData(cb);
          break;
        case INFLATING:
        case DEFER_EVENT:
          this._loop = false;
          return;
      }
    } while (this._loop);
    if (!this._errored)
      cb();
  }
  getInfo(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }
    const buf = this.consume(2);
    if ((buf[0] & 48) !== 0) {
      const error = this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
      cb(error);
      return;
    }
    const compressed = (buf[0] & 64) === 64;
    if (compressed && !this._extensions[PerMessageDeflate$2.extensionName]) {
      const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
      cb(error);
      return;
    }
    this._fin = (buf[0] & 128) === 128;
    this._opcode = buf[0] & 15;
    this._payloadLength = buf[1] & 127;
    if (this._opcode === 0) {
      if (compressed) {
        const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        cb(error);
        return;
      }
      if (!this._fragmented) {
        const error = this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
        cb(error);
        return;
      }
      this._opcode = this._fragmented;
    } else if (this._opcode === 1 || this._opcode === 2) {
      if (this._fragmented) {
        const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        cb(error);
        return;
      }
      this._compressed = compressed;
    } else if (this._opcode > 7 && this._opcode < 11) {
      if (!this._fin) {
        const error = this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
        cb(error);
        return;
      }
      if (compressed) {
        const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        cb(error);
        return;
      }
      if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
        const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
        cb(error);
        return;
      }
    } else {
      const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
      cb(error);
      return;
    }
    if (!this._fin && !this._fragmented)
      this._fragmented = this._opcode;
    this._masked = (buf[1] & 128) === 128;
    if (this._isServer) {
      if (!this._masked) {
        const error = this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
        cb(error);
        return;
      }
    } else if (this._masked) {
      const error = this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
      cb(error);
      return;
    }
    if (this._payloadLength === 126)
      this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127)
      this._state = GET_PAYLOAD_LENGTH_64;
    else
      this.haveLength(cb);
  }
  getPayloadLength16(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }
    this._payloadLength = this.consume(2).readUInt16BE(0);
    this.haveLength(cb);
  }
  getPayloadLength64(cb) {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }
    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);
    if (num > Math.pow(2, 53 - 32) - 1) {
      const error = this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
      cb(error);
      return;
    }
    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    this.haveLength(cb);
  }
  haveLength(cb) {
    if (this._payloadLength && this._opcode < 8) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
        cb(error);
        return;
      }
    }
    if (this._masked)
      this._state = GET_MASK;
    else
      this._state = GET_DATA;
  }
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }
    this._mask = this.consume(4);
    this._state = GET_DATA;
  }
  getData(cb) {
    let data2 = EMPTY_BUFFER$2;
    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }
      data2 = this.consume(this._payloadLength);
      if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
        unmask(data2, this._mask);
      }
    }
    if (this._opcode > 7) {
      this.controlMessage(data2, cb);
      return;
    }
    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data2, cb);
      return;
    }
    if (data2.length) {
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data2);
    }
    this.dataMessage(cb);
  }
  decompress(data2, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
    perMessageDeflate.decompress(data2, this._fin, (err, buf) => {
      if (err)
        return cb(err);
      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          cb(error);
          return;
        }
        this._fragments.push(buf);
      }
      this.dataMessage(cb);
      if (this._state === GET_INFO)
        this.startLoop(cb);
    });
  }
  dataMessage(cb) {
    if (!this._fin) {
      this._state = GET_INFO;
      return;
    }
    const messageLength = this._messageLength;
    const fragments = this._fragments;
    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragmented = 0;
    this._fragments = [];
    if (this._opcode === 2) {
      let data2;
      if (this._binaryType === "nodebuffer") {
        data2 = concat4(fragments, messageLength);
      } else if (this._binaryType === "arraybuffer") {
        data2 = toArrayBuffer(concat4(fragments, messageLength));
      } else {
        data2 = fragments;
      }
      if (this._state === INFLATING || this._allowSynchronousEvents) {
        this.emit("message", data2, true);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        queueTask(() => {
          this.emit("message", data2, true);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    } else {
      const buf = concat4(fragments, messageLength);
      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
        const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
        cb(error);
        return;
      }
      if (this._state === INFLATING || this._allowSynchronousEvents) {
        this.emit("message", buf, false);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        queueTask(() => {
          this.emit("message", buf, false);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
  }
  controlMessage(data2, cb) {
    if (this._opcode === 8) {
      if (data2.length === 0) {
        this._loop = false;
        this.emit("conclude", 1005, EMPTY_BUFFER$2);
        this.end();
      } else {
        const code = data2.readUInt16BE(0);
        if (!isValidStatusCode$1(code)) {
          const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
          cb(error);
          return;
        }
        const buf = new FastBuffer(data2.buffer, data2.byteOffset + 2, data2.length - 2);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          cb(error);
          return;
        }
        this._loop = false;
        this.emit("conclude", code, buf);
        this.end();
      }
      this._state = GET_INFO;
      return;
    }
    if (this._allowSynchronousEvents) {
      this.emit(this._opcode === 9 ? "ping" : "pong", data2);
      this._state = GET_INFO;
    } else {
      this._state = DEFER_EVENT;
      queueTask(() => {
        this.emit(this._opcode === 9 ? "ping" : "pong", data2);
        this._state = GET_INFO;
        this.startLoop(cb);
      });
    }
  }
  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
    this._loop = false;
    this._errored = true;
    const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
    Error.captureStackTrace(err, this.createError);
    err.code = errorCode;
    err[kStatusCode$1] = statusCode;
    return err;
  }
};
var receiver2 = Receiver$1;
var { randomFillSync } = require$$1;
var PerMessageDeflate$1 = permessageDeflate;
var { EMPTY_BUFFER: EMPTY_BUFFER$1 } = constants3;
var { isValidStatusCode } = validationExports;
var { mask: applyMask, toBuffer: toBuffer$1 } = bufferUtilExports;
var kByteLength = Symbol("kByteLength");
var maskBuffer = Buffer.alloc(4);
var Sender$1 = class Sender2 {
  constructor(socket, extensions, generateMask) {
    this._extensions = extensions || {};
    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }
    this._socket = socket;
    this._firstFragment = true;
    this._compress = false;
    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }
  static frame(data2, options) {
    let mask2;
    let merge = false;
    let offset = 2;
    let skipMasking = false;
    if (options.mask) {
      mask2 = options.maskBuffer || maskBuffer;
      if (options.generateMask) {
        options.generateMask(mask2);
      } else {
        randomFillSync(mask2, 0, 4);
      }
      skipMasking = (mask2[0] | mask2[1] | mask2[2] | mask2[3]) === 0;
      offset = 6;
    }
    let dataLength;
    if (typeof data2 === "string") {
      if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
        dataLength = options[kByteLength];
      } else {
        data2 = Buffer.from(data2);
        dataLength = data2.length;
      }
    } else {
      dataLength = data2.length;
      merge = options.mask && options.readOnly && !skipMasking;
    }
    let payloadLength = dataLength;
    if (dataLength >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      payloadLength = 126;
    }
    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
    target[0] = options.fin ? options.opcode | 128 : options.opcode;
    if (options.rsv1)
      target[0] |= 64;
    target[1] = payloadLength;
    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }
    if (!options.mask)
      return [target, data2];
    target[1] |= 128;
    target[offset - 4] = mask2[0];
    target[offset - 3] = mask2[1];
    target[offset - 2] = mask2[2];
    target[offset - 1] = mask2[3];
    if (skipMasking)
      return [target, data2];
    if (merge) {
      applyMask(data2, mask2, target, offset, dataLength);
      return [target];
    }
    applyMask(data2, mask2, data2, 0, dataLength);
    return [target, data2];
  }
  close(code, data2, mask2, cb) {
    let buf;
    if (code === undefined) {
      buf = EMPTY_BUFFER$1;
    } else if (typeof code !== "number" || !isValidStatusCode(code)) {
      throw new TypeError("First argument must be a valid error code number");
    } else if (data2 === undefined || !data2.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data2);
      if (length > 123) {
        throw new RangeError("The message must not be greater than 123 bytes");
      }
      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);
      if (typeof data2 === "string") {
        buf.write(data2, 2);
      } else {
        buf.set(data2, 2);
      }
    }
    const options = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask: mask2,
      maskBuffer: this._maskBuffer,
      opcode: 8,
      readOnly: false,
      rsv1: false
    };
    if (this._deflating) {
      this.enqueue([this.dispatch, buf, false, options, cb]);
    } else {
      this.sendFrame(Sender2.frame(buf, options), cb);
    }
  }
  ping(data2, mask2, cb) {
    let byteLength;
    let readOnly;
    if (typeof data2 === "string") {
      byteLength = Buffer.byteLength(data2);
      readOnly = false;
    } else {
      data2 = toBuffer$1(data2);
      byteLength = data2.length;
      readOnly = toBuffer$1.readOnly;
    }
    if (byteLength > 125) {
      throw new RangeError("The data size must not be greater than 125 bytes");
    }
    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask: mask2,
      maskBuffer: this._maskBuffer,
      opcode: 9,
      readOnly,
      rsv1: false
    };
    if (this._deflating) {
      this.enqueue([this.dispatch, data2, false, options, cb]);
    } else {
      this.sendFrame(Sender2.frame(data2, options), cb);
    }
  }
  pong(data2, mask2, cb) {
    let byteLength;
    let readOnly;
    if (typeof data2 === "string") {
      byteLength = Buffer.byteLength(data2);
      readOnly = false;
    } else {
      data2 = toBuffer$1(data2);
      byteLength = data2.length;
      readOnly = toBuffer$1.readOnly;
    }
    if (byteLength > 125) {
      throw new RangeError("The data size must not be greater than 125 bytes");
    }
    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask: mask2,
      maskBuffer: this._maskBuffer,
      opcode: 10,
      readOnly,
      rsv1: false
    };
    if (this._deflating) {
      this.enqueue([this.dispatch, data2, false, options, cb]);
    } else {
      this.sendFrame(Sender2.frame(data2, options), cb);
    }
  }
  send(data2, options, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate$1.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;
    let byteLength;
    let readOnly;
    if (typeof data2 === "string") {
      byteLength = Buffer.byteLength(data2);
      readOnly = false;
    } else {
      data2 = toBuffer$1(data2);
      byteLength = data2.length;
      readOnly = toBuffer$1.readOnly;
    }
    if (this._firstFragment) {
      this._firstFragment = false;
      if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }
    if (options.fin)
      this._firstFragment = true;
    if (perMessageDeflate) {
      const opts = {
        [kByteLength]: byteLength,
        fin: options.fin,
        generateMask: this._generateMask,
        mask: options.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data2, this._compress, opts, cb]);
      } else {
        this.dispatch(data2, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(Sender2.frame(data2, {
        [kByteLength]: byteLength,
        fin: options.fin,
        generateMask: this._generateMask,
        mask: options.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1: false
      }), cb);
    }
  }
  dispatch(data2, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender2.frame(data2, options), cb);
      return;
    }
    const perMessageDeflate = this._extensions[PerMessageDeflate$1.extensionName];
    this._bufferedBytes += options[kByteLength];
    this._deflating = true;
    perMessageDeflate.compress(data2, options.fin, (_2, buf) => {
      if (this._socket.destroyed) {
        const err = new Error("The socket was closed while data was being compressed");
        if (typeof cb === "function")
          cb(err);
        for (let i3 = 0;i3 < this._queue.length; i3++) {
          const params = this._queue[i3];
          const callback = params[params.length - 1];
          if (typeof callback === "function")
            callback(err);
        }
        return;
      }
      this._bufferedBytes -= options[kByteLength];
      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender2.frame(buf, options), cb);
      this.dequeue();
    });
  }
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();
      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }
  sendFrame(list3, cb) {
    if (list3.length === 2) {
      this._socket.cork();
      this._socket.write(list3[0]);
      this._socket.write(list3[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list3[0], cb);
    }
  }
};
var sender2 = Sender$1;
var { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants3;
var kCode = Symbol("kCode");
var kData = Symbol("kData");
var kError = Symbol("kError");
var kMessage = Symbol("kMessage");
var kReason = Symbol("kReason");
var kTarget = Symbol("kTarget");
var kType = Symbol("kType");
var kWasClean = Symbol("kWasClean");

class Event {
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }
  get target() {
    return this[kTarget];
  }
  get type() {
    return this[kType];
  }
}
Object.defineProperty(Event.prototype, "target", { enumerable: true });
Object.defineProperty(Event.prototype, "type", { enumerable: true });

class CloseEvent extends Event {
  constructor(type, options = {}) {
    super(type);
    this[kCode] = options.code === undefined ? 0 : options.code;
    this[kReason] = options.reason === undefined ? "" : options.reason;
    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
  }
  get code() {
    return this[kCode];
  }
  get reason() {
    return this[kReason];
  }
  get wasClean() {
    return this[kWasClean];
  }
}
Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

class ErrorEvent extends Event {
  constructor(type, options = {}) {
    super(type);
    this[kError] = options.error === undefined ? null : options.error;
    this[kMessage] = options.message === undefined ? "" : options.message;
  }
  get error() {
    return this[kError];
  }
  get message() {
    return this[kMessage];
  }
}
Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

class MessageEvent extends Event {
  constructor(type, options = {}) {
    super(type);
    this[kData] = options.data === undefined ? null : options.data;
  }
  get data() {
    return this[kData];
  }
}
Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
var EventTarget = {
  addEventListener(type, handler, options = {}) {
    for (const listener of this.listeners(type)) {
      if (!options[kForOnEventAttribute$1] && listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {
        return;
      }
    }
    let wrapper;
    if (type === "message") {
      wrapper = function onMessage(data2, isBinary2) {
        const event = new MessageEvent("message", {
          data: isBinary2 ? data2 : data2.toString()
        });
        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === "close") {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent("close", {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });
        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === "error") {
      wrapper = function onError(error) {
        const event = new ErrorEvent("error", {
          error,
          message: error.message
        });
        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === "open") {
      wrapper = function onOpen() {
        const event = new Event("open");
        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else {
      return;
    }
    wrapper[kForOnEventAttribute$1] = !!options[kForOnEventAttribute$1];
    wrapper[kListener$1] = handler;
    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },
  removeEventListener(type, handler) {
    for (const listener of this.listeners(type)) {
      if (listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {
        this.removeListener(type, listener);
        break;
      }
    }
  }
};
var eventTarget = {
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
};
var { tokenChars } = validationExports;
var extension = { format: format$1, parse: parse$1 };
var EventEmitter = require$$0$3;
var https = require$$1$1;
var http = require$$2;
var net = require$$3;
var tls = require$$4;
var { randomBytes, createHash } = require$$1;
var { URL: URL2 } = require$$7;
var PerMessageDeflate2 = permessageDeflate;
var Receiver3 = receiver2;
var Sender3 = sender2;
var {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket,
  NOOP
} = constants3;
var {
  EventTarget: { addEventListener, removeEventListener }
} = eventTarget;
var { format: format7, parse: parse4 } = extension;
var { toBuffer } = bufferUtilExports;
var closeTimeout = 30 * 1000;
var kAborted = Symbol("kAborted");
var protocolVersions = [8, 13];
var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

class WebSocket4 extends EventEmitter {
  constructor(address, protocols, options) {
    super();
    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._extensions = {};
    this._paused = false;
    this._protocol = "";
    this._readyState = WebSocket4.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;
    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;
      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === "object" && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }
      initAsClient(this, address, protocols, options);
    } else {
      this._autoPong = options.autoPong;
      this._isServer = true;
    }
  }
  get binaryType() {
    return this._binaryType;
  }
  set binaryType(type) {
    if (!BINARY_TYPES.includes(type))
      return;
    this._binaryType = type;
    if (this._receiver)
      this._receiver._binaryType = type;
  }
  get bufferedAmount() {
    if (!this._socket)
      return this._bufferedAmount;
    return this._socket._writableState.length + this._sender._bufferedBytes;
  }
  get extensions() {
    return Object.keys(this._extensions).join();
  }
  get isPaused() {
    return this._paused;
  }
  get onclose() {
    return null;
  }
  get onerror() {
    return null;
  }
  get onopen() {
    return null;
  }
  get onmessage() {
    return null;
  }
  get protocol() {
    return this._protocol;
  }
  get readyState() {
    return this._readyState;
  }
  get url() {
    return this._url;
  }
  setSocket(socket, head, options) {
    const receiver3 = new Receiver3({
      allowSynchronousEvents: options.allowSynchronousEvents,
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });
    this._sender = new Sender3(socket, this._extensions, options.generateMask);
    this._receiver = receiver3;
    this._socket = socket;
    receiver3[kWebSocket] = this;
    socket[kWebSocket] = this;
    receiver3.on("conclude", receiverOnConclude);
    receiver3.on("drain", receiverOnDrain);
    receiver3.on("error", receiverOnError);
    receiver3.on("message", receiverOnMessage);
    receiver3.on("ping", receiverOnPing);
    receiver3.on("pong", receiverOnPong);
    if (socket.setTimeout)
      socket.setTimeout(0);
    if (socket.setNoDelay)
      socket.setNoDelay();
    if (head.length > 0)
      socket.unshift(head);
    socket.on("close", socketOnClose);
    socket.on("data", socketOnData);
    socket.on("end", socketOnEnd);
    socket.on("error", socketOnError);
    this._readyState = WebSocket4.OPEN;
    this.emit("open");
  }
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket4.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
      return;
    }
    if (this._extensions[PerMessageDeflate2.extensionName]) {
      this._extensions[PerMessageDeflate2.extensionName].cleanup();
    }
    this._receiver.removeAllListeners();
    this._readyState = WebSocket4.CLOSED;
    this.emit("close", this._closeCode, this._closeMessage);
  }
  close(code, data2) {
    if (this.readyState === WebSocket4.CLOSED)
      return;
    if (this.readyState === WebSocket4.CONNECTING) {
      const msg = "WebSocket was closed before the connection was established";
      abortHandshake(this, this._req, msg);
      return;
    }
    if (this.readyState === WebSocket4.CLOSING) {
      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
        this._socket.end();
      }
      return;
    }
    this._readyState = WebSocket4.CLOSING;
    this._sender.close(code, data2, !this._isServer, (err) => {
      if (err)
        return;
      this._closeFrameSent = true;
      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
        this._socket.end();
      }
    });
    this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
  }
  pause() {
    if (this.readyState === WebSocket4.CONNECTING || this.readyState === WebSocket4.CLOSED) {
      return;
    }
    this._paused = true;
    this._socket.pause();
  }
  ping(data2, mask2, cb) {
    if (this.readyState === WebSocket4.CONNECTING) {
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    }
    if (typeof data2 === "function") {
      cb = data2;
      data2 = mask2 = undefined;
    } else if (typeof mask2 === "function") {
      cb = mask2;
      mask2 = undefined;
    }
    if (typeof data2 === "number")
      data2 = data2.toString();
    if (this.readyState !== WebSocket4.OPEN) {
      sendAfterClose(this, data2, cb);
      return;
    }
    if (mask2 === undefined)
      mask2 = !this._isServer;
    this._sender.ping(data2 || EMPTY_BUFFER, mask2, cb);
  }
  pong(data2, mask2, cb) {
    if (this.readyState === WebSocket4.CONNECTING) {
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    }
    if (typeof data2 === "function") {
      cb = data2;
      data2 = mask2 = undefined;
    } else if (typeof mask2 === "function") {
      cb = mask2;
      mask2 = undefined;
    }
    if (typeof data2 === "number")
      data2 = data2.toString();
    if (this.readyState !== WebSocket4.OPEN) {
      sendAfterClose(this, data2, cb);
      return;
    }
    if (mask2 === undefined)
      mask2 = !this._isServer;
    this._sender.pong(data2 || EMPTY_BUFFER, mask2, cb);
  }
  resume() {
    if (this.readyState === WebSocket4.CONNECTING || this.readyState === WebSocket4.CLOSED) {
      return;
    }
    this._paused = false;
    if (!this._receiver._writableState.needDrain)
      this._socket.resume();
  }
  send(data2, options, cb) {
    if (this.readyState === WebSocket4.CONNECTING) {
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    }
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (typeof data2 === "number")
      data2 = data2.toString();
    if (this.readyState !== WebSocket4.OPEN) {
      sendAfterClose(this, data2, cb);
      return;
    }
    const opts = {
      binary: typeof data2 !== "string",
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };
    if (!this._extensions[PerMessageDeflate2.extensionName]) {
      opts.compress = false;
    }
    this._sender.send(data2 || EMPTY_BUFFER, opts, cb);
  }
  terminate() {
    if (this.readyState === WebSocket4.CLOSED)
      return;
    if (this.readyState === WebSocket4.CONNECTING) {
      const msg = "WebSocket was closed before the connection was established";
      abortHandshake(this, this._req, msg);
      return;
    }
    if (this._socket) {
      this._readyState = WebSocket4.CLOSING;
      this._socket.destroy();
    }
  }
}
Object.defineProperty(WebSocket4, "CONNECTING", {
  enumerable: true,
  value: readyStates.indexOf("CONNECTING")
});
Object.defineProperty(WebSocket4.prototype, "CONNECTING", {
  enumerable: true,
  value: readyStates.indexOf("CONNECTING")
});
Object.defineProperty(WebSocket4, "OPEN", {
  enumerable: true,
  value: readyStates.indexOf("OPEN")
});
Object.defineProperty(WebSocket4.prototype, "OPEN", {
  enumerable: true,
  value: readyStates.indexOf("OPEN")
});
Object.defineProperty(WebSocket4, "CLOSING", {
  enumerable: true,
  value: readyStates.indexOf("CLOSING")
});
Object.defineProperty(WebSocket4.prototype, "CLOSING", {
  enumerable: true,
  value: readyStates.indexOf("CLOSING")
});
Object.defineProperty(WebSocket4, "CLOSED", {
  enumerable: true,
  value: readyStates.indexOf("CLOSED")
});
Object.defineProperty(WebSocket4.prototype, "CLOSED", {
  enumerable: true,
  value: readyStates.indexOf("CLOSED")
});
[
  "binaryType",
  "bufferedAmount",
  "extensions",
  "isPaused",
  "protocol",
  "readyState",
  "url"
].forEach((property) => {
  Object.defineProperty(WebSocket4.prototype, property, { enumerable: true });
});
["open", "error", "close", "message"].forEach((method) => {
  Object.defineProperty(WebSocket4.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute])
          return listener[kListener];
      }
      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) {
          this.removeListener(method, listener);
          break;
        }
      }
      if (typeof handler !== "function")
        return;
      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});
WebSocket4.prototype.addEventListener = addEventListener;
WebSocket4.prototype.removeEventListener = removeEventListener;
var websocket2 = WebSocket4;

// ../../node_modules/crossws/dist/adapters/node.mjs
import require$$02 from "events";
import require$$22 from "http";
import require$$12 from "crypto";

// ../../node_modules/crossws/dist/shared/crossws.77e89680.mjs
var createCrossWS = function(opts = {}) {
  const resolveHook = async (req, name302) => {
    const hooks = await opts.resolve?.(req);
    return hooks?.[name302];
  };
  return {
    async callHook(name302, ...args) {
      await opts.hooks?.[name302]?.apply(undefined, args);
      const hook2 = await resolveHook(args[0], name302);
      await hook2?.apply(undefined, args);
    },
    async upgrade(req) {
      const [res1, res2] = await Promise.all([
        opts.hooks?.upgrade?.(req),
        await resolveHook(req, "upgrade").then((h2) => h2?.(req))
      ]);
      const headers = new Headers(res1?.headers);
      if (res2?.headers) {
        for (const [key, value] of new Headers(res2?.headers)) {
          headers.append(key, value);
        }
      }
      return { headers };
    },
    $callHook(name302, ...args) {
      return opts.adapterHooks?.[name302]?.apply(undefined, args);
    }
  };
};
var toBufferLike = function(val) {
  if (val === undefined || val === null) {
    return "";
  }
  if (typeof val === "string") {
    return val;
  }
  if (isPlainObject3(val)) {
    return JSON.stringify(val);
  }
  return val;
};
var isPlainObject3 = function(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
};
var defineWebSocketAdapter = function(factory309) {
  return factory309;
};
var defineHooks = function(hooks) {
  return hooks;
};

class Message {
  constructor(rawData, isBinary2) {
    this.rawData = rawData;
    this.isBinary = isBinary2;
  }
  text() {
    if (typeof this.rawData === "string") {
      return this.rawData;
    }
    const buff = toBufferLike(this.rawData);
    if (typeof buff === "string") {
      return buff;
    }
    return new TextDecoder().decode(buff);
  }
  toString() {
    return this.text();
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.text();
  }
}
var __defProp12 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp12(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ReadyStateMap = {
  "-1": "unknown",
  0: "connecting",
  1: "open",
  2: "closing",
  3: "closed"
};
var _Peer = class _Peer2 {
  constructor(ctx) {
    this.ctx = ctx;
    __publicField(this, "_subscriptions", new Set);
    __publicField(this, "_id");
    this._id = ++_Peer2._idCounter + "";
  }
  get id() {
    return this._id.toString();
  }
  get addr() {
    return;
  }
  get url() {
    return "/";
  }
  get headers() {
    return {};
  }
  get readyState() {
    return -1;
  }
  publish(topic, message, options) {
  }
  subscribe(topic) {
    this._subscriptions.add(topic);
  }
  unsubscribe(topic) {
    this._subscriptions.delete(topic);
  }
  toString() {
    return `#${this.id}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    const _id = this.toString();
    const _addr = this.addr ? ` (${this.addr})` : "";
    const _state = this.readyState === 1 || this.readyState === -1 ? "" : ` [${ReadyStateMap[this.readyState]}]`;
    return `${_id}${_addr}${_state}`;
  }
};
__publicField(_Peer, "_idCounter", 0);
var Peer = _Peer;

// ../../node_modules/crossws/dist/index.mjs
class WSError extends Error {
  constructor(...args) {
    super(...args);
    this.name = "WSError";
  }
}

// ../../node_modules/crossws/dist/adapters/node.mjs
var parse5 = function(header) {
  const protocols = new Set;
  let start = -1;
  let end = -1;
  let i3 = 0;
  for (i3;i3 < header.length; i3++) {
    const code = header.charCodeAt(i3);
    if (end === -1 && tokenChars2[code] === 1) {
      if (start === -1)
        start = i3;
    } else if (i3 !== 0 && (code === 32 || code === 9)) {
      if (end === -1 && start !== -1)
        end = i3;
    } else if (code === 44) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i3}`);
      }
      if (end === -1)
        end = i3;
      const protocol5 = header.slice(start, end);
      if (protocols.has(protocol5)) {
        throw new SyntaxError(`The "${protocol5}" subprotocol is duplicated`);
      }
      protocols.add(protocol5);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i3}`);
    }
  }
  if (start === -1 || end !== -1) {
    throw new SyntaxError("Unexpected end of input");
  }
  const protocol4 = header.slice(start, i3);
  if (protocols.has(protocol4)) {
    throw new SyntaxError(`The "${protocol4}" subprotocol is duplicated`);
  }
  protocols.add(protocol4);
  return protocols;
};
var addListeners = function(server, map11) {
  for (const event of Object.keys(map11))
    server.on(event, map11[event]);
  return function removeListeners() {
    for (const event of Object.keys(map11)) {
      server.removeListener(event, map11[event]);
    }
  };
};
var emitClose = function(server) {
  server._state = CLOSED;
  server.emit("close");
};
var socketOnError2 = function() {
  this.destroy();
};
var abortHandshake2 = function(socket, code, message, headers) {
  message = message || http2.STATUS_CODES[code];
  headers = {
    Connection: "close",
    "Content-Type": "text/html",
    "Content-Length": Buffer.byteLength(message),
    ...headers
  };
  socket.once("finish", socket.destroy);
  socket.end(`HTTP/1.1 ${code} ${http2.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h2) => `${h2}: ${headers[h2]}`).join("\r\n") + "\r\n\r\n" + message);
};
var abortHandshakeOrEmitwsClientError = function(server, req, socket, code, message) {
  if (server.listenerCount("wsClientError")) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
    server.emit("wsClientError", err, socket, req);
  } else {
    abortHandshake2(socket, code, message);
  }
};
var { tokenChars: tokenChars2 } = validationExports;
var subprotocol$1 = { parse: parse5 };
var EventEmitter2 = require$$02;
var http2 = require$$22;
var { createHash: createHash2 } = require$$12;
var extension2 = extension;
var PerMessageDeflate3 = permessageDeflate;
var subprotocol = subprotocol$1;
var WebSocket5 = websocket2;
var { GUID: GUID2, kWebSocket: kWebSocket2 } = constants3;
var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
var RUNNING = 0;
var CLOSING = 1;
var CLOSED = 2;

class WebSocketServer2 extends EventEmitter2 {
  constructor(options, callback) {
    super();
    options = {
      allowSynchronousEvents: false,
      autoPong: true,
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null,
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket: WebSocket5,
      ...options
    };
    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
      throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + "must be specified");
    }
    if (options.port != null) {
      this._server = http2.createServer((req, res) => {
        const body = http2.STATUS_CODES[426];
        res.writeHead(426, {
          "Content-Length": body.length,
          "Content-Type": "text/plain"
        });
        res.end(body);
      });
      this._server.listen(options.port, options.host, options.backlog, callback);
    } else if (options.server) {
      this._server = options.server;
    }
    if (this._server) {
      const emitConnection = this.emit.bind(this, "connection");
      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, "listening"),
        error: this.emit.bind(this, "error"),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }
    if (options.perMessageDeflate === true)
      options.perMessageDeflate = {};
    if (options.clientTracking) {
      this.clients = new Set;
      this._shouldEmitClose = false;
    }
    this.options = options;
    this._state = RUNNING;
  }
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }
    if (!this._server)
      return null;
    return this._server.address();
  }
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once("close", () => {
          cb(new Error("The server is not running"));
        });
      }
      process.nextTick(emitClose, this);
      return;
    }
    if (cb)
      this.once("close", cb);
    if (this._state === CLOSING)
      return;
    this._state = CLOSING;
    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }
      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server = this._server;
      this._removeListeners();
      this._removeListeners = this._server = null;
      server.close(() => {
        emitClose(this);
      });
    }
  }
  shouldHandle(req) {
    if (this.options.path) {
      const index2 = req.url.indexOf("?");
      const pathname = index2 !== -1 ? req.url.slice(0, index2) : req.url;
      if (pathname !== this.options.path)
        return false;
    }
    return true;
  }
  handleUpgrade(req, socket, head, cb) {
    socket.on("error", socketOnError2);
    const key = req.headers["sec-websocket-key"];
    const version9 = +req.headers["sec-websocket-version"];
    if (req.method !== "GET") {
      const message = "Invalid HTTP method";
      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
      return;
    }
    if (req.headers.upgrade.toLowerCase() !== "websocket") {
      const message = "Invalid Upgrade header";
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }
    if (!key || !keyRegex.test(key)) {
      const message = "Missing or invalid Sec-WebSocket-Key header";
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }
    if (version9 !== 8 && version9 !== 13) {
      const message = "Missing or invalid Sec-WebSocket-Version header";
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }
    if (!this.shouldHandle(req)) {
      abortHandshake2(socket, 400);
      return;
    }
    const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
    let protocols = new Set;
    if (secWebSocketProtocol !== undefined) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        const message = "Invalid Sec-WebSocket-Protocol header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }
    const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
    const extensions = {};
    if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
      const perMessageDeflate = new PerMessageDeflate3(this.options.perMessageDeflate, true, this.options.maxPayload);
      try {
        const offers = extension2.parse(secWebSocketExtensions);
        if (offers[PerMessageDeflate3.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate3.extensionName]);
          extensions[PerMessageDeflate3.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }
    if (this.options.verifyClient) {
      const info = {
        origin: req.headers[`${version9 === 8 ? "sec-websocket-origin" : "origin"}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };
      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake2(socket, code || 401, message, headers);
          }
          this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
        });
        return;
      }
      if (!this.options.verifyClient(info))
        return abortHandshake2(socket, 401);
    }
    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  }
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
    if (!socket.readable || !socket.writable)
      return socket.destroy();
    if (socket[kWebSocket2]) {
      throw new Error("server.handleUpgrade() was called more than once with the same " + "socket, possibly due to a misconfiguration");
    }
    if (this._state > RUNNING)
      return abortHandshake2(socket, 503);
    const digest = createHash2("sha1").update(key + GUID2).digest("base64");
    const headers = [
      "HTTP/1.1 101 Switching Protocols",
      "Upgrade: websocket",
      "Connection: Upgrade",
      `Sec-WebSocket-Accept: ${digest}`
    ];
    const ws = new this.options.WebSocket(null, undefined, this.options);
    if (protocols.size) {
      const protocol4 = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
      if (protocol4) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol4}`);
        ws._protocol = protocol4;
      }
    }
    if (extensions[PerMessageDeflate3.extensionName]) {
      const params = extensions[PerMessageDeflate3.extensionName].params;
      const value = extension2.format({
        [PerMessageDeflate3.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }
    this.emit("headers", headers, req);
    socket.write(headers.concat("\r\n").join("\r\n"));
    socket.removeListener("error", socketOnError2);
    ws.setSocket(socket, head, {
      allowSynchronousEvents: this.options.allowSynchronousEvents,
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });
    if (this.clients) {
      this.clients.add(ws);
      ws.on("close", () => {
        this.clients.delete(ws);
        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }
    cb(ws, req);
  }
}
var websocketServer = WebSocketServer2;
var _WebSocketServer = getDefaultExportFromCjs(websocketServer);
var node = defineWebSocketAdapter((options = {}) => {
  const crossws = createCrossWS(options);
  const wss = options.wss || new _WebSocketServer({
    noServer: true,
    ...options.serverOptions
  });
  wss.on("connection", (ws, req) => {
    const peer = new NodePeer({ node: { ws, req, server: wss } });
    crossws.callHook("open", peer);
    ws.on("message", (data2, isBinary2) => {
      crossws.$callHook("node:message", peer, data2, isBinary2);
      if (Array.isArray(data2)) {
        data2 = Buffer.concat(data2);
      }
      crossws.callHook("message", peer, new Message(data2, isBinary2));
    });
    ws.on("error", (error) => {
      crossws.$callHook("node:error", peer, error);
      crossws.callHook("error", peer, new WSError(error));
    });
    ws.on("close", (code, reason) => {
      crossws.$callHook("node:close", peer, code, reason);
      crossws.callHook("close", peer, {
        code,
        reason: reason?.toString()
      });
    });
    ws.on("open", () => {
      crossws.$callHook("node:open", peer);
    });
    ws.on("ping", (data2) => {
      crossws.$callHook("node:ping", peer, data2);
    });
    ws.on("pong", (data2) => {
      crossws.$callHook("node:pong", peer, data2);
    });
    ws.on("unexpected-response", (req2, res) => {
      crossws.$callHook("node:unexpected-response", peer, req2, res);
    });
    ws.on("upgrade", (req2) => {
      crossws.$callHook("node:upgrade", peer, req2);
    });
  });
  wss.on("headers", function(outgoingHeaders, req) {
    const upgradeHeaders = req._upgradeHeaders;
    if (upgradeHeaders) {
      const _headers = new Headers(upgradeHeaders);
      for (const [key, value] of _headers) {
        outgoingHeaders.push(`${key}: ${value}`);
      }
    }
  });
  return {
    handleUpgrade: async (req, socket, head) => {
      const { headers } = await crossws.upgrade({
        url: req.url || "",
        headers: req.headers
      });
      req._upgradeHeaders = headers;
      wss.handleUpgrade(req, socket, head, (ws) => {
        wss.emit("connection", ws, req);
      });
    }
  };
});

class NodePeer extends Peer {
  constructor(ctx) {
    super(ctx);
    ctx.node.ws._peer = this;
  }
  get addr() {
    const socket = this.ctx.node.req.socket;
    if (!socket) {
      return;
    }
    const headers = this.ctx.node.req.headers;
    let addr = headers["x-forwarded-for"] || socket.remoteAddress || "??";
    if (addr.includes(":")) {
      addr = `[${addr}]`;
    }
    const port = headers["x-forwarded-port"] || socket.remotePort || "??";
    return `${addr}:${port}`;
  }
  get url() {
    return this.ctx.node.req.url || "/";
  }
  get headers() {
    return this.ctx.node.req.headers;
  }
  get readyState() {
    return this.ctx.node.ws.readyState;
  }
  send(message, options) {
    this.ctx.node.ws.send(toBufferLike(message), {
      compress: options?.compress,
      binary: options?.binary,
      ...options
    });
    return 0;
  }
  publish(topic, message) {
    message = toBufferLike(message);
    for (const client of this.ctx.node.server.clients) {
      const peer = client._peer;
      if (peer && peer !== this && peer._subscriptions.has(topic)) {
        peer.send(message);
      }
    }
  }
}

// src/app/wss.ts
import_mobx13.configure({ enforceActions: "never" });

class Wss {
  clientMap = new Map;
  bots = new BotManager(this);
  cards = new CardManager(this);
  plugin = new PluginManager(this);
  config = new ConfigManager(this);
  hooks = defineHooks({
    upgrade(req) {
    },
    close: (peer) => {
      console.log("WebSocket \u670D\u52A1\u5DF2\u5173\u95ED");
      this.clientMap.get(peer.id)?.onClose();
    },
    error: (peer, e4) => {
      console.error("WebSocket \u670D\u52A1\u51FA\u9519", e4);
      this.clientMap.get(peer.id)?.onError(e4);
    },
    open: (peer) => {
      console.log("\u5DF2\u63A5\u5165\u65B0\u7684\u5BA2\u6237\u7AEF");
      this.clientMap.set(peer.id, new WsClient(this, peer));
    },
    message: (peer, message) => {
      this.clientMap.get(peer.id)?.onMessage(message.rawData);
    }
  });
  constructor() {
    import_mobx13.makeAutoObservable(this, { server: false });
    this.mainClient();
  }
  async mainClient() {
    const mainClient = new WsClient(this);
    await this.handleClientRequest(mainClient, {
      cmd: "bot/loginV2",
      data: {
        platform: "qqguild",
        appid: "102128160",
        secret: "GWm2Jar8PgxEWo6OgyGZsBUn6Pi2Mg1M",
        token: "XFipyH3mHMVYv8I7HK4dYBwGnD7BF1Zy",
        sandbox: true,
        type: "private"
      }
    });
    await this.handleClientRequest(mainClient, {
      cmd: "channel/listen",
      data: {
        channelId: "654461697",
        guildId: "16465426603407454801"
      }
    });
    return mainClient;
  }
  async start(port) {
    const server = node({
      serverOptions: { port, noServer: false },
      hooks: this.hooks
    });
    return server;
  }
  async handleClientRequest(client, request) {
    return dispatch2(client, this, request);
  }
  removeClient(client) {
    this.clientMap.delete(client.id);
  }
  sendToClient(client, message) {
    client.send(message);
  }
  sendToChannel(channelUnionId, message) {
    this.clientMap.forEach((client) => {
      if (client.listenToChannelUnionId === channelUnionId) {
        client.send(message);
      }
    });
  }
}
export {
  Wss
};
